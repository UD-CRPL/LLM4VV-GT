System,User,Assistant
"### System : You will help create tests.", "Create a test for the feature acc_free.c", "#include "acc_testsuite.h" #ifndef T1 //T1:runtime data executable-data V:2.6-2.7 int test1(){     int err = 0;     int *a = (int *)acc_malloc(n * sizeof(int));     size_t initial_memory = acc_get_property(acc_get_device_num(acc_get_device_type())  acc_get_device_type()  acc_property_free_memory);      acc_free(a);     size_t final_memory = acc_get_property(acc_get_device_num(acc_get_device_type())  acc_get_device_type()  acc_property_free_memory);     if (final_memory < initial_memory + n * sizeof(int)){         err += 1;     }     return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature parallel_loop_tile.c", "#include "acc_testsuite.h" #ifndef T1 //T1:parallel loop tile reduction combined-constructs V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));     real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));     real_t temp = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = rand() / (real_t)(RAND_MAX / 10);     }     #pragma acc data copy(a[0:n]  b[0:n]  c[0:n]  d2[0:n*n])     {         #pragma acc parallel loop tile(*  *) reduction(+:temp)         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 temp = 0;                 for (int z = 0; z < n; ++z){                     temp += a[x] + b[y] + c[z];                 }                 d2[x * n + y] = temp;             }         }     }     for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             temp = 0.0;             for (int z = 0; z < n; ++z){                 temp += a[x] + b[y] + c[z];             }             if (fabs(temp - d2[x * n + y]) > PRECISION * n){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel loop tile combined-constructs V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));     real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));     real_t temp = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n]  b[0:n]  c[0:n]) copyout(d3[0:n*n*n])     {         #pragma acc parallel loop tile(2  4  8)         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 for (int z = 0; z < n; ++z){                     d3[(n * n * x) + (n * y) + z] = a[x] + b[x] + c[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             for (int z = 0; z < n; ++z){                 if (fabs(d3[(n * n * x) + (n * y) + z] - a[x] - b[x] - c[x]) > PRECISION * 2){                     err = 1;                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_structured_assign_postincrement.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *c = (int *)malloc(n * sizeof(int));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));     bool found = false;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = distribution[(int) (a[x]*b[x]/10)];                     distribution[(int) (a[x]*b[x]/10)]++;                 }             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]++;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < distribution_comparison[x]; ++y){             for (int z = 0; z < n; ++z){                 if (c[z] == y && (int) (a[z]*b[z]/10) == x){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature parallel.c", "#include "acc_testsuite.h" #ifndef T1 //T1:parallel V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t* a = (real_t *) malloc(1024 * sizeof(real_t));     real_t* b = (real_t *) malloc(1024 * sizeof(real_t));     real_t* c = (real_t *) malloc(1024 * sizeof(real_t));      for(int x = 0; x < 1024; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:1024]  b[0:1024]) copy(c[0:1024])     {         #pragma acc parallel         {             #pragma acc loop             for (int _0 = 0; _0 < 2; ++_0){                 #pragma acc loop                 for (int _1 = 0; _1 < 2; ++_1){                     #pragma acc loop                     for (int _2 = 0; _2 < 2; ++_2){                         #pragma acc loop                         for (int _3 = 0; _3 < 2; ++_3){                             #pragma acc loop                             for (int _4 = 0; _4 < 2; ++_4){                                 #pragma acc loop                                 for (int _5 = 0; _5 < 2; ++_5){                                     #pragma acc loop                                     for (int _6 = 0; _6 < 2; ++_6){                                         #pragma acc loop                                         for (int _7 = 0; _7 < 2; ++_7){                                             #pragma acc loop                                             for (int _8 = 0; _8 < 2; ++_8){                                                 #pragma acc loop                                                 for (int _9 = 0; _9 < 2; ++_9){                                                     c[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] =                                                     a[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] +                                                     b[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9];                                                 }                                             }                                         }                                     }                                 }                             }                         }                     }                 }             }         }     }      for (int x = 0; x < 1024; ++x){         if(fabs(c[x] - (a[x] +b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature exit_data_copyout_no_lower_bound.c", "#include "acc_testsuite.h" #ifndef T1 //T1:data executable-data syntactic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n]  b[0:n]) create(c[0:n])     #pragma acc parallel present(a[0:n]  b[0:n]  c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc exit data delete(a[0:n]  b[0:n]) copyout(c[:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_expr_bitand_x.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] &= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_x_lshift_expr.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic                             a[x] = a[x] << 1;                     }                 }             }         }     }     for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_update_lshift_equals.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic update                             a[x] <<= 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature parallel_create_zero.c", "#include "acc_testsuite.h" #ifndef T1 //#T1:parallel data data_region V:3.0-3.2 int Test1(){     int err=0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for( int x = 0; x < n; x++){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n]     {         #pragma acc parallel create(zero: b[0:n])         {             #pragma acc loop             {                 for(int x = 0; x < n; x++){                     b[x] += a[x];                 }             }         }     }     for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; }"
"### System : You will help create tests.", "Create a test for the feature serial_loop_reduction_max_loop.c", "#include "acc_testsuite.h" #ifndef T1 //T1:serial loop reduction combined-constructs V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * maximum = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);         c[x] = 0.0;     }     for (int x = 0; x < 10; ++x){         maximum[x] = 0;     }      #pragma acc data copyin(a[0:10*n]  b[0:10*n]) copy(c[0:10*n]  maximum[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(max:temp)             for (int y = 0; y < n; ++y){                 temp = fmax(a[x * n + y] * b[x * n + y]  temp);             }             maximum[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 c[x * n + y] = (a[x * n + y] * b[x * n + y]) / maximum[x];             }         }     }     for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = fmax(temp  a[x * n + y] * b[x * n + y]);         }         if (fabs(temp - maximum[x]) > PRECISION){             err += 1;         }         for (int y = 0; y < n; ++y){             if (c[x * n + y] > 1){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_structured_x_divided_expr_assign.c", "#include "acc_testsuite.h" bool is_possible(real_t* a  real_t* b  real_t* c  int length  real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_c = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(c[x] - (prev / (a[x] + b[x]))) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];                 passed_c[y] = c[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];                 passed_c[y - 1] = c[y];             }             if (is_possible(passed_a  passed_b  passed_c  length - 1  c[x])){                 free(passed_a);                 free(passed_b);                 free(passed_c);                 return true;             }         }     }     free(passed_a);     free(passed_b);     free(passed_c);     return false; }  #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));     real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));     real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x/10] = totals[x/10] / (a[x] + b[x]);                     c[x] = totals[x/10];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];             temp_c[temp_iterator] = c[ab_iterator];             temp_iterator++;         }         if (!(is_possible(temp_a  temp_b  temp_c  temp_iterator  1))){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature init_device_num.c", "#include "acc_testsuite.h" #ifndef T1 //T1:init runtime V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     int device_num = acc_get_device_num(acc_get_device_type());      #pragma acc init device_num(device_num)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature serial_loop_reduction_max_vector_loop.c", "#include "acc_testsuite.h" #ifndef T1 //T1:serial loop reduction combined-constructs V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * max = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 0;     real_t temp_max;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:10*n]  b[0:10*n]) copy(max[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(max:temp)             for (int y = 0; y < n; ++y){                 temp = fmax(a[x * n + y] * b[x * n + y]  temp);             }             max[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         temp_max = 0;         for (int y = 0; y < n; ++y){             if (temp_max < a[x * n + y] * b[x * n + y]){                 temp_max = a[x * n + y] * b[x * n + y];             }         }         if (fabs(temp_max - max[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature acc_get_device_type.c", "#include "acc_testsuite.h" #ifndef T1 //T1: V:1.0-3.2 int test1(){ 	int err = 0;  	int device_type = acc_get_device_type();  	if (acc_get_device_type() != device_type){ 		err += 1; 	}  	return err; } #endif  int main(){     	int failcode = 0;     	int failed; #ifndef T1     	failed = 0;     	for (int x = 0; x < NUM_TEST_CALLS; ++x){         	failed = failed + test1();     	}     	if (failed != 0){         	failcode = failcode + (1 << 0);     	} #endif     	return failcode; } "
"### System : You will help create tests.", "Create a test for the feature serial_loop_reduction_add_vector_loop.c", "#include "acc_testsuite.h" #ifndef T1 //T1:serial loop reduction combined-constructs V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 0.0;      for(int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     #pragma acc data copyin(a[0:10*n]  b[0:10*n]) copyout(c[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0.0;             #pragma acc loop vector reduction(+:temp)             for (int y = 0; y < n; ++y){                 temp += a[(x * n) + y] + b[(x * n) + y];             }             c[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             c[x] -= a[(x * n) + y] + b[(x * n) + y];         }         if (fabs(c[x]) > PRECISION * (2 * n - 1)){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_expr_divided_x.c", "#include "acc_testsuite.h" bool possible_result(real_t * remaining_combinations  int length  real_t current_value  real_t test_value){     if (length == 0){         if (fabs(current_value - test_value) > PRECISION){             return true;         }         else {             return false;         }     }     real_t * passed = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         for (int y = 0; y < x; ++y){             passed[y] = remaining_combinations[y];         }         for (int y = x + 1; y < length; ++y){             passed[y - 1] = remaining_combinations[y];         }         if (possible_result(passed  length - 1  remaining_combinations[x] / current_value  test_value)){             free(passed);             return true;         }     }     free(passed);     return false; }  #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed = (real_t *)malloc(10 * sizeof(real_t));     int indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];             }         }     }       for (int x = 0; x < (n/10 + 1); ++x){         indexer = x;         while (indexer < n){             passed[indexer/(n/10 + 1)] = (a[x] + b[x]);             indexer += (n/10 + 1);         }         if (!(possible_result(passed  10  1  totals[x]))){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_structured_bitor_equals_assign.c", "#include "acc_testsuite.h" bool is_possible(int* a  int* b  int length  int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == (prev | a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a  passed_b  length - 1  b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] |= a[x];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] |= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a  temp_b  temp_iterator  1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_structured_expr_bitxor_x_assign.c", "#include "acc_testsuite.h" bool is_possible(int* a  int* b  int length  int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == (prev ^ a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a  passed_b  length - 1  b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] = a[x] ^ totals[x/10];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] ^= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a  temp_b  temp_iterator  1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_update_divided_equals.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] /= (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_expr_plus_x.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(totals[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic                         totals[(int) ((a[x] + b[x])/2)] = a[x] * b[x] + totals[(int) ((a[x] + b[x])/2)];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];         }     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] -  totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_capture_expr_plus_x.c", "#include "acc_testsuite.h" bool is_possible(real_t* a  real_t* b  int length  real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] + prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a  passed_b  length - 1  b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((int)(n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((int)(n/10 + 1) * sizeof(real_t));     real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(totals[0:11]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = totals[x%((int)(n/10 + 1))] = (a[x] + b[x]) + totals[x%((int)(n/10 + 1))];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%((int)(n/10 + 1))] += (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0  absolute_indexer = x; absolute_indexer < n; passed_indexer++  absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab  passed_c  passed_indexer  0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature kernels_loop_reduction_min_loop.c", "#include "acc_testsuite.h" #ifndef T1 //T1:kernels loop reduction combined-constructs V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * minimum = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 0;      for (int x = 0; x < 10 * n; ++x){         a[x] = 1 + rand() / (real_t)(RAND_MAX/10);         b[x] = 1 + rand() / (real_t)(RAND_MAX/10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:10*n]  b[0:10*n]) copy(c[0:10*n]  minimum[0:10])     {         #pragma acc kernels loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1000;             #pragma acc loop reduction(min:temp)             for (int y = 0; y < n; ++y){                 temp = fmin(a[x * n + y] * b[x * n + y]  temp);             }             minimum[x] = temp;             #pragma acc loop             for (int y = 0; y < n; ++y){                 c[x * n + y] = (a[x * n + y] * b[x * n + y]) / minimum[x];             }         }     }      for (int x = 0; x < 10; ++x){         temp = 1000;         for (int y = 0; y < n; ++y){             temp = fmin(temp  a[x * n + y] * b[x * n + y]);         }         if (fabs(temp - minimum[x]) > PRECISION){             err += 1;         }         for (int y = 0; y < n; ++y){             if (fabs(c[x * n + y] - (a[x * n + y] * b[x * n + y] / minimum[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature kernels_loop_reduction_and_loop.c", "#include "acc_testsuite.h" #ifndef T1 //T1:kernels loop reduction combined-constructs V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(10 * n * sizeof(char));     char * a_copy = (char *)malloc(10 * n * sizeof(char));     char * has_false = (char *)malloc(10 * sizeof(char));     real_t false_margin = pow(exp(1)  log(.5)/n);      for (int x = 0; x < 10; ++x){         has_false[x] = 0;     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (rand() / (real_t)(RAND_MAX) < false_margin){                 a[x * n + y] = 1;                 a_copy[x * n + y] = 1;             }             else {                 a[x * n + y] = 0;                 a_copy[x * n + y] = 0;                 has_false[x] = 1;             }         }     }      char temp = 1;     #pragma acc data copy(a[0:10*n])     {         #pragma acc kernels loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop worker reduction(&&:temp)             for (int y = 0; y < n; ++y){                 temp = temp && a[x * n + y];             }             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 if(temp == 1){                     if  (a[x * n + y] == 1){                         a[x * n + y] = 0;                     }                     else {                         a[x * n + y] = 1;                     }                 }             }         }     }       for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){                 err = 1;             }             else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){                 err = 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_structured_assign_x_rshift_expr.c", "#include "acc_testsuite.h" bool is_possible(unsigned int a  unsigned int* b  int length  unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if ((a >> x) % 2 == 1){                 if (is_possible(passed_a  passed_b  length - 1 prev >> 1)){                     free(passed_b);                     return true;                 }             }             else{                 if (is_possible(passed_a  passed_b  length - 1  prev)){                     free(passed_b);                     return true;                 }             }         }     }     free(passed_b);     return false; }  #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1<<8;      for (int x = 0; x < n; ++x){         a[x] = 1<<8;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                         {                             c[x * 7 + y] = a[x];                             a[x] = a[x] >> 1;                         }                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<8){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x]  &(c[x * 7])  7  passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature test.c", "#include "acc_testsuite.h"  //test 1 #pragma acc routine nohost real_t unnamed_function(real_t * a  long long n){     real_t returned = 0;     #pragma acc loop worker reduction(+:returned)     for (int x = 0; x < n; ++x){ 	returned += a[x];     }     return returned; }  //test 2 #pragma acc routine(named_function) nohost real_t named_function(real_t * a  long long n){     real_t returned = 0;     #pragma acc loop worker reduction(+:returned)     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  //helper function test 3 #pragma acc routine nohost real_t unnamed_helper_unnamed_main(real_t *a  int x){     return(a[x]); }  //main test function test 3 #pragma acc routine nohost  real_t unnamed_main_unnamed_helper(real_t *a  long long n){     real_t returned = 0;     #pragma acc loop worker reduction(+:returned)     for (int x = 0; x < n; ++x){         returned += unnamed_helper_unnamed_main(a  x);     }     return returned; }  //helper function test 4 #pragma acc routine nohost real_t unnamed_helper_named_main(real_t *a  int  x){     return(a[x]); }  //main test function test 4 #pragma acc routine(named_main_unnamed_helper) nohost real_t named_main_unnamed_helper(real_t *a  long long n){     real_t returned = 0;     #pragma acc loop worker reduction(+:returned)     for (int x = 0; x < n; ++x){         returned += unnamed_helper_named_main(a  x);     }     return returned; }  //helper function test 5 #pragma acc routine(named_helper_unnamed_main) nohost real_t named_helper_unnamed_main(real_t *a  int x){    return(a[x]); }  //main test function test 5 #pragma acc routine nohost real_t unnamed_main_named_helper(real_t *a  long long n){     real_t returned = 0;     #pragma acc loop worker reduction(+:returned)     for (int x = 0; x < n; ++x){         returned += named_helper_unnamed_main(a  x);     }     return returned; }  // helper function test 6 #pragma acc routine(named_helper_named_main) nohost real_t named_helper_named_main(real_t *a  int x){     return(a[x]); }  //main test function test 6 #pragma acc routine(named_main_named_helper) nohost real_t named_main_named_helper(real_t *a  long long n){     real_t returned = 0;     #pragma acc loop worker reduction(+:returned)     for (int x = 0; x < n; ++x){         returned += named_helper_named_main(a  x);     }     return returned; }   #ifndef T1 //T1:routine construct-independent V:2.0-3.3 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t summation;      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])     {         #pragma acc parallel          for (int x = 0; x < n; ++x){                 b[x] = unnamed_function(a[x]  n);  	}     }      for (int x = 0; x < n; ++x){         summation = 0;         for (int y = 0; y < n; ++y){             summation += a[x][y];         }         if (fabs(summation - b[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < n; ++x){         free(a[x]);     }      free(b);      return err; } #endif  #ifndef T2 //T2:routine construct-independent V:2.0-3.3 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t summation;      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])     {         #pragma acc parallel 	for (int x = 0; x < n; ++x){ 	     b[x] = named_function(a[x]  n); 	}     }      for (int x = 0; x < n; ++x){         summation = 0;         for (int y = 0; y < n; ++y){             summation += a[x][y];         }         if (fabs(summation - b[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < n; ++x){         free(a[x]);     }      free(b);      return err; } #endif #ifndef T3 //T3:routine construct-independent V:2.0-3.3 int test3(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t summation;      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])     {         #pragma acc parallel         for (int x = 0; x < n; ++x){              b[x] = unnamed_main_unnamed_helper(a[x]  n);         }     }      for (int x = 0; x < n; ++x){         summation = 0;         for (int y = 0; y < n; ++y){             summation += a[x][y];         }         if (fabs(summation - b[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < n; ++x){         free(a[x]);     }      free(b);      return err; } #endif #ifndef T4 //T4:routine construct-independent V:2.0-3.3 int test4(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t summation;      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])     {         #pragma acc parallel         for (int x = 0; x < n; ++x){              b[x] = named_main_unnamed_helper(a[x]  n);         }     }      for (int x = 0; x < n; ++x){         summation = 0;         for (int y = 0; y < n; ++y){             summation += a[x][y];         }         if (fabs(summation - b[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < n; ++x){         free(a[x]);     }      free(b);      return err; } #endif #ifndef T5 //T5:routine construct-independent V:2.0-3.3 int test5(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t summation;      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])     {         #pragma acc parallel         for (int x = 0; x < n; ++x){              b[x] = unnamed_main_named_helper(a[x]  n);         }     }      for (int x = 0; x < n; ++x){         summation = 0;         for (int y = 0; y < n; ++y){             summation += a[x][y];         }         if (fabs(summation - b[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < n; ++x){         free(a[x]);     }      free(b);      return err; } #endif #ifndef T6 //T6:routine construct-independent V:2.0-3.3 int test6(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t summation;      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])     {         #pragma acc parallel         for (int x = 0; x < n; ++x){              b[x] = named_main_named_helper(a[x]  n);         }     }      for (int x = 0; x < n; ++x){         summation = 0;         for (int y = 0; y < n; ++y){             summation += a[x][y];         }         if (fabs(summation - b[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < n; ++x){         free(a[x]);     }      free(b);      return err; } #endif   int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }     if (failed != 0){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }     if (failed != 0){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }     if (failed != 0){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test4();     }     if (failed != 0){         failcode += (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test5();     }     if (failed != 0){         failcode += (1 << 4);     } #endif #ifndef T6     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test6();     }     if (failed != 0){         failcode += (1 << 6);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_update_multiply_equals.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] *= a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature shutdown_device_type_num_nvidia.c", "#include "acc_testsuite.h" #ifndef T1 //T1:shutdown runtime syntactic V:2.5-2.7 int test1(){     int err = 0;     int device_num;      device_num = acc_get_device_num(acc_get_device_type());     #pragma acc shutdown device_type(nvidia) device_num(device_num)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_structured_minus_equals_assign.c", "#include "acc_testsuite.h" bool is_possible(real_t* a  real_t* b  int length  real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (prev - a[x])) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a  passed_b  length - 1  b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));     real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0; 	totals_host[x] = 0;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(totals[0:10]  c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x%10] -= (a[x] + b[x]);                     c[x] = totals[x%10];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (passed_indexer = 0  absolute_indexer = x; absolute_indexer < n; passed_indexer++  absolute_indexer+= 10){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab  passed_c  passed_indexer  0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature acc_is_present.c", "#include "acc_testsuite.h" #ifndef T1 //T1:runtime data executable-data devonly V:2.0-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      #pragma acc enter data create(a[0:n])     if (acc_is_present(a  n * sizeof(real_t)) == 0){         err += 1;     }     #pragma acc exit data delete(a[0:n])      if (devtest[0] == 1){         if (acc_is_present(a  n * sizeof(real_t)) != 0){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_structured_assign_divided_equals.c", "#include "acc_testsuite.h" bool is_possible(real_t* a  real_t* b  real_t* c  int length  real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_c = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(c[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];                 passed_c[y] = c[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];                 passed_c[y - 1] = c[y];             }             if (is_possible(passed_a  passed_b  passed_c  length - 1  prev / (a[x] + b[x]))){                 free(passed_a);                 free(passed_b);                 free(passed_c);                 return true;             }         }     }     free(passed_a);     free(passed_b);     free(passed_c);     return false; }  #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));     real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));     real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x/10];                     totals[x/10] /= (a[x] + b[x]);                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];             temp_c[temp_iterator] = c[ab_iterator];             temp_iterator++;         }         if (!(is_possible(temp_a  temp_b  temp_c  temp_iterator  1))){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature serial_while_loop.c", "#include "acc_testsuite.h" #ifndef T1 //T1:serial reduction V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t avg = 0.0;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(a[0:10*n])     {         #pragma acc serial         {             #pragma acc loop             for (int y = 0; y < 10; ++y){                 avg = 0.0;                 while (avg - 1000 < PRECISION * n){                     avg = 0.0;                     #pragma acc loop reduction(+:avg)                     for (int x = 0; x < n; ++x){                         a[n * y + x] *= 1.5;                         avg += a[n * y + x] / n;                     }                 }             }         }     }      for (int y = 0; y < 10; ++y){         avg = 0.0;         for (int x = 0; x < n; ++x){             avg += a[y * n + x]/n;         }          if (avg < 1000 || avg > 1500){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_capture_expr_divided_x.c", "#include "acc_testsuite.h" bool is_possible(real_t* a  real_t* b  int length  real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x]/prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a  passed_b  length - 1  b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  bool possible_result(real_t * remaining_combinations  int length  real_t current_value  real_t test_value){     if (length == 0){         if (fabs(current_value - test_value) > PRECISION){             return true;         }         else {             return false;         }     }     real_t * passed = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         for (int y = 0; y < x; ++y){             passed[y] = remaining_combinations[y];         }         for (int y = x + 1; y < length; ++y){             passed[y - 1] = remaining_combinations[y];         }         if (possible_result(passed  length - 1  remaining_combinations[x] / current_value  test_value)){             free(passed);             return true;         }     }     free(passed);     return false; }  #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;     real_t * passed = (real_t *)malloc(10 * sizeof(real_t));     int indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];             }         }     }       for (int x = 0; x < (n/10 + 1); ++x){         indexer = x;         while (indexer < n){             passed[indexer/(n/10 + 1)] = (a[x] + b[x]);             indexer += (n/10 + 1);         }         if (!(possible_result(passed  10  1  totals[x]))){             err += 1;         }     }      for (int x = 0; x < (n/10 + 1); ++x){         for (passed_indexer = 0  absolute_indexer = x; absolute_indexer < n; passed_indexer++  absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab  passed_c  passed_indexer  1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature kernels_loop_reduction_min_general.c", "#include "acc_testsuite.h" #pragma acc routine (fmin) seq  #ifndef T1 //T1:kernels loop reduction combined-constructs V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t min = 1000.0;     int found = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:n]  b[0:n]) copy(min)     {         #pragma acc kernels loop reduction(min:min)         for (int x = 0; x < n; ++x){             min = fmin(a[x] * b[x]  min);         }     }      for (int x = 0; x < n; ++x){         if (fabs((a[x] * b[x]) - (min + PRECISION)) < 0){             err = 1;         }         if (fabs(min - (a[x] * b[x])) < PRECISION){             found = 1;         }     }     if (found == 0){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature shutdown_device_type_nvidia.c", "#include "acc_testsuite.h" #ifndef T1 //T1:shutdown runtime syntactic V:2.5-3.2 int test1(){     int err = 0;      #pragma acc shutdown device_type(nvidia)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_structured_x_minus_expr_assign.c", "#include "acc_testsuite.h" bool is_possible(real_t* a  real_t* b  int length  real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (prev - a[x])) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a  passed_b  length - 1  b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));     real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0; 	totals_host[x] = 0;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(totals[0:10]  c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x%10] = totals[x%10] - (a[x] + b[x]);                     c[x] = totals[x%10];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (passed_indexer = 0  absolute_indexer = x; absolute_indexer < n; passed_indexer++  absolute_indexer+= 10){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab  passed_c  passed_indexer  0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature serial_default_present.c", "#include "acc_testsuite.h" #ifndef T1 //T1:serial data data-region default V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = 0.0;     }     #pragma acc enter data copyin(a[0:n])     #pragma acc serial default(present)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             a[x] = 1.0;         }     }     #pragma acc exit data copyout(a[0:n])      for (int x = 0; x < n; ++x){         if (fabs(a[x] - 1.0) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature parallel_loop_reduction_min_loop.c", "#include "acc_testsuite.h" #ifndef T1 //T1:parallel loop reduction combined-constructs V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * minimum = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 0;      for (int x = 0; x < 10 * n; ++x){         a[x] = 1 + rand() / (real_t)(RAND_MAX/10);         b[x] = 1 + rand() / (real_t)(RAND_MAX/10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:10*n]  b[0:10*n]) copy(c[0:10*n]  minimum[0:10])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1000;             #pragma acc loop reduction(min:temp)             for (int y = 0; y < n; ++y){                 temp = fmin(a[x * n + y] * b[x * n + y]  temp);             }             minimum[x] = temp;             #pragma acc loop             for (int y = 0; y < n; ++y){                 c[x * n + y] = (a[x * n + y] * b[x * n + y]) / minimum[x];             }         }     }      for (int x = 0; x < 10; ++x){         temp = 1000;         for (int y = 0; y < n; ++y){             temp = fmin(temp  a[x * n + y] * b[x * n + y]);         }         if (fabs(temp - minimum[x]) > PRECISION){             err += 1;         }         for (int y = 0; y < n; ++y){             if (fabs(c[x * n + y] - (a[x * n + y] * b[x * n + y] / minimum[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel private reduction combined-constructs loop V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(25 * n * sizeof(real_t));     real_t minimums[25];     real_t host_minimums[25];     real_t reduced[5];      for (int x = 0; x < n; ++x){         a[x] = 1 + rand() / (real_t)(RAND_MAX / 10);         b[x] = 1 + rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:25*n]  b[0:25*n]) copy(minimums[0:25]  c[0:25*n])     {         #pragma acc parallel loop gang private(reduced)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 reduced[y] = 1000;             }             #pragma acc loop reduction(min:reduced)             for (int y = 0; y < 5 * n; ++y) {                 reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y]  reduced[y%5]);             }             for (int y = 0; y < 5; ++y) {                 minimums[x * 5 + y] = reduced[y];             }             #pragma acc loop             for (int y = 0; y < 5 * n; ++y) {                 c[x * 5 * n + y] = (a[x * 5 * n + y] * b[x * 5 * n + y]) / minimums[x * 5 + (y % 5)];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             reduced[y] = 1000;         }         for (int y = 0; y < 5 * n; ++y) {             reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y]  reduced[y%5]);         }         for (int y = 0; y < 5; ++y) {             host_minimums[x * 5 + y] = reduced[y];             if (fabs(host_minimums[x * 5 + y] - minimums[x * 5 + y]) > PRECISION) {                 err += 1;             }         }         for (int y = 0; y < 5 * n; ++y) {             if (fabs(c[x * 5 * n + y] - ((a[x * 5 * n + y] * b[x * 5 * n + y]) / minimums[x * 5 + (y % 5)])) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature serial_loop_reduction_or_loop.c", "#include "acc_testsuite.h" #ifndef T1 //T1:serial loop reduction combined-constructs V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(10 * n * sizeof(char));     char * a_copy = (char *)malloc(10 * n * sizeof(char));     char * results = (char *)malloc(10 * sizeof(char));     char temp = 0;     real_t false_margin = pow(exp(1)  log(.5)/n);      for (int x = 0; x < 10 * n; ++x){         if (rand() / (real_t)(RAND_MAX) > false_margin){             a[x] = 1;             a_copy[x] = 1;         }         else{             a[x] = 0;             a_copy[x] = 0;         }     }     #pragma acc data copy(a[0:10*n]) copyout(results[0:10])     {         #pragma acc serial  	{ 	#pragma loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(||:temp)             for (int y = 0; y < n; ++y){                 temp = temp || a[x * n + y];             }             results[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 if(results[x] == 1){                     if (a[x * n + y] == 1){                         a[x * n + y] = 0;                     }                     else{                         a[x * n + y] = 1;                     }                 }             }         } 	}     }     for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = temp || a_copy[x * n + y];         }         if (temp != results[x]) {             err += 1;         }         for (int y = 0; y < n; ++y){             if (temp == 1){                 if (a[x * n + y] == a_copy[x * n + y]){                     err += 1;                 }             }             else {                 if (a[x * n + y] != a_copy[x * n + y]){                     err += 1;                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_update_rshift_equals.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1<<7;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic update                             a[x] >>= 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<7){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_x_rshift_expr.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1<<7;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic                             a[x] = a[x] >> 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<7){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature parallel_loop_reduction_bitor_vector_loop.c", "#include "acc_testsuite.h" #ifndef T1 //T1:parallel loop reduction combined-constructs V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1)  log(.5)/n);     unsigned int temp = 1;     unsigned int b_host;      for (int x = 0; x < 10 * n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX > false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }     temp = 0;     #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc parallel loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(|:temp)             for (int y = 0; y < n; ++y){                 temp = temp | a[x * n + y];             }             b[x] = temp;         }     }      for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host | a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel private reduction combined-constructs loop V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));      unsigned int reduced[5];     real_t false_margin = pow(exp(1)  log(.5)/n);          for (int x = 0; x < 25 * n; ++x) {         a[x] = 0;         for (int y = 0; y < 16; ++y) {             if (rand() / (real_t)RAND_MAX > false_margin) {                 a[x] += 1<<y;             }         }     }      #pragma acc data copyin(a[0:25*n]) copy(b[0:25])     {         #pragma acc parallel loop private(reduced)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 reduced[y] = 0;             }             #pragma acc loop vector reduction(|:reduced)             for (int y = 0; y < 5 * n; ++y) {                 reduced[y%5] = reduced[y%5] | a[x * 5 * n + y];             }             for (int y = 0; y < 5; ++y) {                 b[x * 5 + y] = reduced[y];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             reduced[y] = 0;         }         for (int y = 0; y < 5 * n; ++y) {             reduced[y%5] = reduced[y%5] | a[x * 5 * n + y];         }         for (int y = 0; y < 5; ++y) {             if (b[x * 5 + y] != reduced[y]) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature parallel_loop_worker.c", "#include "acc_testsuite.h" #ifndef T1 //T1:parallel loop combined-constructs V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(c[0:n])     {         #pragma acc parallel loop worker         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature serial_loop.c", "#include "acc_testsuite.h" #ifndef T1 //T1:serial loop combined-constructs V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = 0;     }      #pragma acc data copy(a[0:n])     {         #pragma acc serial loop         for (int x = 0; x < n; ++x){             a[x] = 1.0;         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - 1.0) > PRECISION){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:serial loop V:2.6-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){       a[x] = 0.0;       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = rand() / (real_t)(RAND_MAX / 10);     }     #pragma acc data copy(a[0:n]  b[0:n]  c[0:n])     {         #pragma acc serial         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = b[x];             }             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] += c[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] + c[x])) > PRECISION * 2){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_update_x_plus_expr.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(totals[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic update                         totals[(int) ((a[x] + b[x])/2)] = totals[(int) ((a[x] + b[x])/2)] + a[x] * b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];         }     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature kernels_if.c", "#include "acc_testsuite.h" #ifndef T1 //T1:kernels if V:1.0-3.2 int test1(){     int err = 0;     srand(SEED);     int data_on_device = 0;     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc kernels if(data_on_device) present(a[0:n]  b[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             b[x] = a[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - a[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:kernels if V:2.0-3.2 int test2(){     int err = 0;     srand(SEED);     int data_on_device = 0;     int * devtest = (int *)malloc(sizeof(int));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc enter data copyin(a[0:n]) create(b[0:n])     data_on_device = 1;      #pragma acc kernels if(data_on_device) present(a[0:n]  b[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             b[x] = a[x];         }     }     #pragma acc exit data copyout(b[0:n]) delete(a[0:n])      for (int x = 0; x < n; ++x){         if (fabs(b[x] - a[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:kernels if devonly V:2.0-3.2 int test3(){     int err = 0;     srand(SEED);     int data_on_device = 0;     int * devtest = (int *)malloc(sizeof(int));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     devtest[0] = 1;      #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     { 	devtest[0] = 0;      }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0;         }          #pragma acc enter data copyin(a[0:n]) create(b[0:n])         for (int x = 0; x < n; ++x){             a[x] = -1;         }          #pragma acc kernels if(data_on_device) present(a[0:n]  b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }         for (int x = 0; x < n; ++x){             if (fabs(a[x] + 1) > PRECISION){                 err += 1;             }             if (fabs(b[x] + 1) > PRECISION){                 err += 1;             }         }         #pragma acc exit data copyout(a[0:n]  b[0:n])         data_on_device = 0;         for (int x = 0; x < n; ++x){             if (fabs(a[x] - b[x]) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T4 //T4:kernels if devonly V:2.0-3.2 int test4(){     int err = 0;     srand(SEED);     int data_on_device = 0;     int * devtest = (int *)malloc(sizeof(int));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {       devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0;         }          #pragma acc enter data copyin(a[0:n]  b[0:n])         #pragma acc kernels if(data_on_device) present(a[0:n]  b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }         for (int x = 0; x < n; ++x){             if (fabs(a[x] - b[x]) > PRECISION) {                 err += 1;             }         }         #pragma acc exit data copyout(a[0:n]  b[0:n])         for (int x = 0; x < n; ++x){             if (fabs(b[x]) > PRECISION && b[x] != a[x]){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature parallel_loop_reduction_multiply_loop.c", "#include "acc_testsuite.h" #ifndef T1 //T1:parallel loop reduction combined-constructs V:1.0-2.7 int test1(){     int err = 0;     int m_n = 128;     srand(SEED);     real_t * a = (real_t *)malloc(10 * m_n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * m_n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * m_n * sizeof(real_t));     real_t * totals = (real_t *)malloc(10 * sizeof(real_t));     real_t temp;      for (int x = 0; x < 10 * m_n; ++x){         a[x] = .05 + rand() / (real_t)(RAND_MAX);         b[x] = .05 + rand() / (real_t)(RAND_MAX);         c[x] = 0.0;     }       #pragma acc data copyin(a[0:10*m_n]  b[0:10*m_n]) copyout(c[0:10*m_n]  totals[0:10])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop worker reduction(*:temp)             for (int y = 0; y < m_n; ++y){                 temp *= a[x * m_n + y] + b[x * m_n + y];             }             totals[x] = temp;             #pragma acc loop worker             for (int y = 0; y < m_n; ++y){                 c[x * m_n + y] = (a[x * m_n + y] + b[x * m_n + y]) / totals[x];             }         }     }      for (int x = 0; x < 10; ++x){         temp = 1;         for (int y = 0; y < m_n; ++y){             temp *= a[x * m_n + y] + b[x * m_n + y];         }         if (fabs(temp - totals[x]) > (temp / 2 + totals[x] / 2) * PRECISION){             err += 1;         }         for (int y = 0; y < m_n; ++y){             if (fabs(c[x * m_n + y] - ((a[x * m_n + y] + b[x * m_n + y]) / totals[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel private reduction combined-constructs loop V:2.7-2.7 int test2(){     int err = 0;     int m_n = 128;     srand(SEED);     real_t * a = (real_t *)malloc(25 * m_n * sizeof(real_t));     real_t * b = (real_t *)malloc(25 * m_n * sizeof(real_t));     real_t * c = (real_t *)malloc(25 * m_n * sizeof(real_t));      real_t * totals = (real_t *)malloc(25 * sizeof(real_t));     real_t reduced[5];      for (int x = 0; x < n; ++x){         a[x] = .05 + rand() / (real_t)(RAND_MAX / 10);         b[x] = .05 + rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc data copyin(a[0:25*m_n]  b[0:25*m_n]) copyout(c[0:25*m_n]  totals[0:25])     {         #pragma acc parallel loop gang private(reduced)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 reduced[y] = 1.0;             }             #pragma acc loop worker reduction(*:reduced)             for (int y = 0; y < 5 * m_n; ++y) {                 reduced[y%5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];             }             for (int y = 0; y < 5; ++y) {                 totals[x * 5 + y] = reduced[y];             }             for (int y = 0; y < 5 * m_n; ++y) {                 c[x * 5 * m_n + y] = (a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[x * 5 + (y%5)];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             reduced[y] = 1;         }         for (int y = 0; y < 5 * m_n; ++y) {             reduced[y%5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];         }         for (int y = 0; y < 5; ++y) {             if (fabs(totals[x * 5 + y] - reduced[y]) > PRECISION) {                 err += 1;             }         }         for (int y = 0; y < 5 * m_n; ++y) {             if (fabs(c[x * 5 * m_n + y] - ((a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[x * 5 + (y % 5)])) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature parallel_create.c", "#include "acc_testsuite.h" #ifndef T1 //T1:parallel data data-region V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copy(c[0:n])     {         #pragma acc parallel create(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - c[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_postincrement.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(distribution[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic                         distribution[(int) (a[x]*b[y]/10)]++;                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             distribution_comparison[(int) (a[x]*b[y]/10)]++;         }     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_structured_assign_x_minus_expr.c", "#include "acc_testsuite.h" bool is_possible(real_t* a  real_t* b  int length  real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a  passed_b  length - 1  prev - a[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));     real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_host[x] = 0;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(totals[0:10]  c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x%10]; totals[x%10] = totals[x%10] - (a[x] + b[x]);                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (passed_indexer = 0  absolute_indexer = x; absolute_indexer < n; passed_indexer++  absolute_indexer+= 10){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab  passed_c  passed_indexer  0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature parallel_independent_atomic_capture.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.7-3.2 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(a[0:n]  b[0:n])     {         #pragma acc parallel         { 	    #pragma acc loop independent             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     b[x] = (a[x])++;             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] + 1)) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1    failed = 0;    for (int x = 0; x < NUM_TEST_CALLS; ++x){        failed = failed + test1();    }    if (failed != 0){        failcode = failcode + (1 << 0);    } #endif     return failcode; }  "
"### System : You will help create tests.", "Create a test for the feature acc_on_device.c", "#include "acc_testsuite.h" #ifndef T1 //T1:runtime construct-independent V:1.0-2.7 int test1(){     int err = 0;     int device_type = acc_get_device_type();      if (device_type != acc_device_none){         #pragma acc data copy(err)         {             #pragma acc parallel             {                 if (acc_on_device(device_type) == 0){                     err += 1;                 }             }         }     }     else{         #pragma acc parallel         {             if (acc_on_device(acc_device_host) == 0){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature kernels_copyout_zero.c", "#include "acc_testsuite.h" #ifndef T1 //T1:kernels data data-region V:3.0-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n])     {         #pragma acc kernels copyout(zero: b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] += a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:kernels data data-region devonly V:3.0-3.1 int test2(){     int err = 0;     srand(SEED);     int * devtest = (int *)malloc(sizeof(int));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc kernels present(devtest[0:1])     {       devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0;         }          #pragma acc data copyin(a[0:n])         {             #pragma acc kernels copyout(zero: b[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] += a[x];                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(a[x] - b[x]) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature parallel_loop_async.c", "#include "acc_testsuite.h" #ifndef T1 //T1:parallel loop async combined-constructs V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * d = (real_t *)malloc(10 * n * sizeof(real_t)); 	int * errors = (int *)malloc(10 * sizeof(int));  	for (int x = 0; x < 10; ++x){ 		errors[x] = 0; 	}      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = a[x] + b[x];     }      #pragma acc data copyin(a[0:10*n]  b[0:10*n]  c[0:10*n]  d[0:10*n]) copy(errors[0:10])     {         for (int x = 0; x < 10; ++x){             #pragma acc parallel loop async(x)             for (int y = 0; y < n; ++y){                 c[x * n + y] = a[x * n + y] + b[x * n + y];             }             #pragma acc parallel loop async(x) reduction(+:errors[x])             for (int y = 0; y < n; ++y){                 if(c[x * n + y] - d[x * n + y] > PRECISION || d[x * n + y] - c[x * n + y] > PRECISION){                     errors[x] += 1;                 }             }         } 		#pragma acc wait     }      for (int x = 0; x < 10; ++x){         err += errors[x];     }      return err; } #endif #ifndef T2 //T2:parallel loop async combined-constructs V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * d = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x] * 2;         c[x] = rand() / (real_t)(RAND_MAX / 10);         d[x] = c[x] * 2;     }      #pragma acc parallel loop copy(a[0:n]) async(0)     for(int x = 0; x < n; ++x) {         a[x] = a[x] * 2;     }      #pragma acc parallel loop copy(c[0:n]) async(0)     for(int x = 0; x < n; ++x) {         c[x] = c[x] * 2;     }      #pragma acc wait      for (int x = 0; x < n; ++x){         if(a[x] != b[x] || c[x] != d[x]) err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature acc_memcpy_to_device.c", "#include "acc_testsuite.h" #ifndef T1 //T1:runtime data executable-data construct-independent V:2.0-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *hostdata = (real_t *)malloc(3 * n * sizeof(real_t));     real_t *devdata;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 1;     }      devdata = acc_create(hostdata  3 * n * sizeof(real_t));      acc_memcpy_to_device(devdata  a  n * sizeof(real_t));     acc_memcpy_to_device(&(devdata[n])  b  n * sizeof(real_t));     acc_memcpy_to_device(&(devdata[2*n])  c  n * sizeof(real_t));      #pragma acc data deviceptr(devdata)     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[2*n + x] += devdata[x] + devdata[n + x];             }         }     }     #pragma acc exit data copyout(hostdata[0:3*n])     for (int x = 0; x < n; ++x){         if (fabs(hostdata[2 * n + x] - (1 + hostdata[n + x] + hostdata[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_expr_bitor_x.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] |= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature parallel_default_copy.c", "#include "acc_testsuite.h" #ifndef T1 //T1:parallel data data-region default-mapping V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t c[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n]  b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel data data-region default-mapping V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t c[n];     int * devtest = (int *)malloc(sizeof(real_t));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 1;         }          #pragma acc enter data copyin(c[0:n])         for (int x = 0; x < n; ++x){             c[x] = 0.0;         }         #pragma acc data copyin(a[0:n]  b[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] += a[x] + b[x];                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(c[x]) > PRECISION){                 err += 1;             }         }          #pragma acc exit data copyout(c[0:n])          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature parallel_async.c", "#include "acc_testsuite.h" #ifndef T1 //T1:parallel async wait V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * d = (real_t *)malloc(n * sizeof(real_t));     real_t * e = (real_t *)malloc(n * sizeof(real_t));     real_t * f = (real_t *)malloc(n * sizeof(real_t));     real_t * g = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;         g[x] = 0.0;     }      #pragma acc data copyin(a[0:n]  b[0:n]  d[0:n]  e[0:n]  c[0:n]  f[0:n]  g[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         #pragma acc parallel wait(1  2) async(3)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 g[x] = c[x] + f[x];             }         }         #pragma acc update host(c[0:n]) async(1)         #pragma acc update host(f[0:n]) async(2)         #pragma acc update host(g[0:n]) async(3)          #pragma acc wait(1)         for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x])) > PRECISION){                 err += 1;             }         }         #pragma acc wait(2)         for (int x = 0; x < n; ++x){             if (fabs(f[x] - (d[x] + e[x])) > PRECISION){                 err += 1;             }         }         #pragma acc wait(3)         for (int x = 0; x < n; ++x){             if (fabs(g[x] - (a[x] + b[x] + d[x] + e[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature acc_copyin.c", "#include "acc_testsuite.h" #ifndef T1 //T1:runtime data executable-data construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      acc_copyin(a  n * sizeof(real_t));     acc_copyin(b  n * sizeof(real_t));      #pragma acc data copy(c[0:n])     {         #pragma acc parallel present(a[0:n]  b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      acc_copyout(a  n * sizeof(real_t));     acc_copyout(b  n * sizeof(real_t));      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime data executable-data construct-independent V:2.0-2.7 int test2(){     int err = 0;     srand(time(NULL));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      acc_copyin(a  n * sizeof(real_t));     acc_copyin(b  n * sizeof(real_t));      #pragma acc data copy(c[0:n])     {         #pragma acc parallel present(a[0:n]  b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data copyout(a[0:n]  b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }     return err; } #endif  #ifndef T3 //T3:runtime data executable-data devonly construct-independent reference-counting V:2.5-2.7 int test3(){     int err = 0;     srand(time(NULL));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int * dev_test = (int *)malloc(n * sizeof(int));      dev_test[0] = 1;     #pragma acc enter data copyin(dev_test[0:1])     #pragma acc parallel present(dev_test[0:1])     {         dev_test[0] = 0;     }      if (dev_test[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             a_copy[x] = a[x];             b[x] = rand() / (real_t)(RAND_MAX / 10);             b_copy[x] = b[x];             c[x] = 0.0;         }          acc_copyin(a  n * sizeof(real_t));         acc_copyin(b  n * sizeof(real_t));          for (int x = 0; x < n; ++x){             a[x] = 0;             b[x] = 0;         }          #pragma acc data copyin(a[0:n]  b[0:n]) copyout(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] + b[x];                 }             }         }          acc_copyout(a  n * sizeof(real_t));         acc_copyout(b  n * sizeof(real_t));          for (int x = 0; x < n; ++x){             if (fabs(a[x] - a_copy[x]) > PRECISION){                 err += 1;             }             if (fabs(b[x] - b_copy[x]) > PRECISION){                 err += 1;             }             if (fabs(c[x] - (a[x] + b[x])) > PRECISION){                 err += 1;             }         }     }     return err; } #endif  #ifndef T4 //T4:runtime data executable-data construct-independent compatibility-features V:2.0-2.7 int test4(){     int err = 0;     srand(time(NULL));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      acc_pcopyin(a  n * sizeof(real_t));     acc_pcopyin(b  n * sizeof(real_t));      #pragma acc data copy(c[0:n])     {         #pragma acc parallel present(a[0:n]  b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data delete(a[0:n]  b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }     return err; } #endif  #ifndef T5 //T5:runtime data executable-data construct-independent compatibility-features V:2.0-2.7 int test5(){     int err = 0;     srand(time(NULL));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      acc_present_or_copyin(a  n * sizeof(real_t));     acc_present_or_copyin(b  n * sizeof(real_t));      #pragma acc data copyout(c[0:n]) present(a[0:n]  b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data delete(a[0:n]  b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }     return err; } #endif  #ifndef T6 //T6:runtime data executable-data construct-independent reference-counting V:2.5-2.7 int test6() {     int err = 0;     srand(time(NULL));     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x) {         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      acc_copyin(a  n * sizeof(real_t));     acc_copyin(a  n * sizeof(real_t));     acc_copyin(b  n * sizeof(real_t));     acc_copyin(b  n * sizeof(real_t));      #pragma acc data copyout(c[0:n])     {         #pragma acc parallel present(a[0:n]  b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data delete(a[0:n]  b[0:n])     #pragma acc exit data delete(a[0:n]  b[0:n])      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }     return err; } #endif  #ifndef T7 //T7:runtime data executable-data construct-independent reference-counting devonly V:2.5-2.7 int test7() {     int err = 0;     srand(time(NULL));     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *a_copy = (real_t *)malloc(n * sizeof(real_t));     real_t *b_copy = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     int * dev_test = (int *)malloc(n * sizeof(int));      dev_test[0] = 1;     #pragma acc enter data copyin(dev_test[0:1])     #pragma acc parallel present(dev_test[0:1])     {         dev_test[0] = 0;     }      if (dev_test[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             a_copy[x] = a[x];             b_copy[x] = b[x];             c[x] = 0;         }                  acc_copyin(a  n * sizeof(real_t));         acc_copyin(b  n * sizeof(real_t));          for (int x = 0; x < n; ++x){             a[x] = 0;             b[x] = 0;         }          acc_copyin(a  n * sizeof(real_t));         acc_copyin(b  n * sizeof(real_t));          #pragma acc data copyout(c[0:n])         {             #pragma acc parallel present(a[0:n]  b[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] + b[x];                 }             }         }          #pragma acc exit data delete(a[0:n]  b[0:n])         #pragma acc exit data delete(a[0:n]  b[0:n])          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){                 err += 1;             }         }     }     return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif #ifndef T6     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x) {         failed = failed + test6();     }     if (failed != 0) {         failcode = failcode + (1 << 5);     } #endif #ifndef T7     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x) {         failed = failed + test7();     }     if (failed != 0) {         failcode = failcode + (1 << 6);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature data_copy_no_lower_bound.c", "#include "acc_testsuite.h" #ifndef T1 //T1:data data-region construct-independent V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(c[:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature parallel_independent_atomic_update.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.7-3.2 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      #pragma acc data copy(a[0:n])     {         #pragma acc parallel         { 	    #pragma acc loop independent             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     (a[x])++;             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] + 1)) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1    failed = 0;    for (int x = 0; x < NUM_TEST_CALLS; ++x){        failed = failed + test1();    }    if (failed != 0){        failcode = failcode + (1 << 0);    } #endif     return failcode; }  "
"### System : You will help create tests.", "Create a test for the feature atomic_update_x_bitand_expr.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0; 	for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] & a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] &= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_structured_assign_expr_bitxor_x.c", "#include "acc_testsuite.h" bool is_possible(int* a  int* b  int length  int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a  passed_b  length - 1  prev ^ a[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         for (int y = 0; y < 8; ++y){             totals[x] =  1<<y;             totals_comparison[x] = 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         b[x] = totals[x/10];                         totals[x/10] = a[x] ^ totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] ^= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a  temp_b  temp_iterator  1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature set_default_async.c", "#include "acc_testsuite.h" #ifndef T1 //T1:async set construct-independent V:2.5-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *a_host = (real_t *)malloc(n * sizeof(real_t));     real_t *b_host = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         a_host[x] = a[x];         b_host[x] = b[x];     }      #pragma acc data copyin(a[0:n]  b[0:n]) copyout(c[0:n])     {         #pragma acc set default_async(1)         #pragma acc parallel async         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = a[x] * a[x];             }         }         #pragma acc set default_async(2)         #pragma acc parallel async         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = b[x] * b[x];             }         }         #pragma acc parallel async(1) wait(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc wait(1)     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4*PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature kernels_loop_seq.c", "#include "acc_testsuite.h" #ifndef T1 //T1:kernels loop combined-constructs V:1.0-2.7 int test1(){   int err = 0;   srand(SEED);   real_t * a = (real_t *)malloc(n * sizeof(real_t));   real_t * b = (real_t *)malloc(n * sizeof(real_t));   real_t temp = 0.0;    for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = 0.0;   }    #pragma acc data copyin(a[0:n]) copy(b[0:n])   {       #pragma acc kernels loop seq       for (int x = 1; x < n; ++x){           b[x] = b[x-1] + a[x];       }   }    for (int x = 1; x < n; ++x){       temp += a[x];       if (fabs(b[x] - temp) > PRECISION){           err = 1;       }   }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature kernels_loop_reduction_bitand_vector_loop.c", "#include "acc_testsuite.h" #ifndef T1 //T1:kernels loop reduction combined-constructs V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1)  log(.5)/n);     unsigned int temp = 1;     unsigned int c = 0;     unsigned int b_host;      for (int x = 0; x < 10 * n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX < false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc kernels loop private(c)         for (int x = 0; x < 10; ++x){             c = a[x * n];             #pragma acc loop vector reduction(&:c)             for (int y = 1; y < n; ++y){                 c = c & a[x * n + y];             }             b[x] = c;         }     }     for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host & a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature declare_function_scope_present.c", "#include "acc_testsuite.h" void present(real_t *a  real_t *b  real_t *c  real_t *d){     #pragma acc declare present(c[0:n])     #pragma acc parallel present(a[0:n]  b[0:n]  d[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = c[x] + a[x] + b[x];         }         #pragma acc loop         for (int x = 0; x < n; ++x){             d[x] = c[x] * a[x];         }     } }  #ifndef T1 //T1:declare present construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     real_t ** d = (real_t **)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));         b[x] = (real_t *)malloc(n * sizeof(real_t));         c[x] = (real_t *)malloc(n * sizeof(real_t));         d[x] = (real_t *)malloc(n * sizeof(real_t));         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 1;             d[x][y] = 0;         }     }      #pragma acc data copyin(a[0:n][0:n]  b[0:n][0:n]) copyout(d[0:n][0:n])     {         for (int x = 0; x < n; ++x){             #pragma acc data copy(c[x:1][0:n])             {                 present(a[x]  b[x]  c[x]  d[x]);             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){                 err += 1;             }             if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:declare present devonly construct-independent V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     real_t ** d = (real_t **)malloc(n * sizeof(real_t));     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 a[x][y] = rand() / (real_t)(RAND_MAX / 10);                 b[x][y] = rand() / (real_t)(RAND_MAX / 10);                 c[x][y] = 3;             }         }          #pragma acc data copyin(a[0:n][0:n]  b[0:n][0:n])         {             for (int x = 0; x < n; ++x){                 #pragma acc data copyin(c[x:1][0:n]) copyout(d[x:1][0:n])                 {                     present(a[x]  b[x]  c[x]  d[x]);                 }                 for (int y = 0; y < n; ++y){                     if (fabs(c[x][y] - 3) > PRECISION){                         err += 1;                     }                 }                 for (int y = 0; y < n; ++y){                     if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 2){                         err += 1;                     }                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_expr_bitxor_x.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .5){                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] ^= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature parallel_loop_reduction_bitxor_general.c", "#include "acc_testsuite.h" #ifndef T1 //T1:parallel reduction combined-constructs loop V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     unsigned int b = 0;     unsigned int host_b = 0;      for (int x = 0; x < n; ++x){         a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);     }      #pragma acc data copyin(a[0:n])     {         #pragma acc parallel loop reduction(^:b)         for (int x = 0; x < n; ++x){             b = b ^ a[x];         }     }      for (int x = 0; x < n; ++x){         host_b = host_b ^ a[x];     }     if (b != host_b){         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel reduction combined-constructs loop V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int b[10];     unsigned int host_b[10];      for (int x = 0; x < 10 * n; ++x){         a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);     }      for (int x = 0; x < 10; ++x) {         b[x] = 0;         host_b[x] = 0;     }      #pragma acc data copyin(a[0:10*n])     {         #pragma acc parallel loop reduction(^:b)         for (int x = 0; x < 10 * n; ++x) {             b[x % 10] = b[x % 10] ^ a[x];         }     }      for (int x = 0; x < 10 * n; ++x) {         host_b[x % 10] = host_b[x % 10] ^ a[x];     }      for (int x = 0; x < 10; ++x) {         if (host_b[x] != b[x]) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_update_expr_multiply_x.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_predecrement.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(distribution[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic                         --distribution[(int) (a[x]*b[y]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             distribution_comparison[(int) (a[x]*b[y]/10)]--;         }     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature serial_loop_gang.c", "#include "acc_testsuite.h" #ifndef T1 //T1:serial loop combined-constructs V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(c[0:n])     {         #pragma acc serial loop gang         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_update_minus_equals.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_host[x] = 0;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(totals[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%10] -= (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature parallel_independent_atomic_read.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.7-3.2 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(a[0:n]  b[0:n])     {         #pragma acc parallel         { 	    #pragma acc loop independent             for (int x = 0; x < n; ++x){                 #pragma acc atomic read                     b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1    failed = 0;    for (int x = 0; x < NUM_TEST_CALLS; ++x){        failed = failed + test1();    }    if (failed != 0){        failcode = failcode + (1 << 0);    } #endif     return failcode; }  "
"### System : You will help create tests.", "Create a test for the feature atomic_structured_postdecrement_assign.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *c = (int *)malloc(n * sizeof(int));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));     bool found = false;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     (distribution[(int) (a[x]*b[x]/10)])--;                     c[x] = distribution[(int) (a[x]*b[x]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]--;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y > -distribution_comparison[x]; --y){             for (int z = 0; z < n; ++z){                 if (y - 1 == c[z] && x == (int) (a[x] * b[x] / 10)){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_structured_assign_minus_equals.c", "#include "acc_testsuite.h" bool is_possible(real_t* a  real_t* b  int length  real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a  passed_b  length - 1  prev - a[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));     real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0; 	totals_host[x] =0;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(totals[0:10]  c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x%10];                     totals[x%10] -= (a[x] + b[x]);                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (passed_indexer = 0  absolute_indexer = x; absolute_indexer < n; passed_indexer++  absolute_indexer+= 10){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab  passed_c  passed_indexer  0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_structured_x_multiply_expr_assign.c", "#include "acc_testsuite.h" bool is_possible(real_t* a  real_t* b  int length  real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] * prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a  passed_b  length - 1  b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);                     c[x] = totals[x%(n/10 + 1)];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0  absolute_indexer = x; absolute_indexer < n; passed_indexer++  absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab  passed_c  passed_indexer  1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature serial_loop_gang_blocking.c", "#include "acc_testsuite.h" #ifndef T1 //T1:serial loop V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t multiplyer = 1;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copyout(c[0:n])     {       #pragma acc serial       {         #pragma acc loop gang         for (int x = 0; x < n; ++x){           c[x] = (a[x] + b[x]) * multiplyer;         }         multiplyer += 1;         #pragma acc loop gang         for (int x = 0; x < n; ++x){           c[x] += (a[x] + b[x]) * multiplyer;         }       }     }      for (int x = 0; x < n; ++x){       if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){         err + 1;         break;       }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature serial_present.c", "#include "acc_testsuite.h" #ifndef T1 //T1:serial present V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n]  b[0:n])     #pragma acc serial present(a[0:n]  b[0:n]) copy(c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc exit data delete(a[0:n]  b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature parallel_loop_reduction_add_general.c", "#include "acc_testsuite.h" #ifndef T1 //T1:parallel loop reduction combined-constructs V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t total;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      total = 10;     #pragma acc data copyin(a[0:n]  b[0:n]) copy(total)     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x){             total += a[x] + b[x];         }     }     for (int x = 0; x < n; ++x){         total -= a[x] + b[x];     }     if (fabs(total - 10) > PRECISION * (2 * n - 1)){ //199 = # of mathematical operations necessary         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel loop reduction combined-constructs V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * 10 * sizeof(real_t));     real_t * b = (real_t *)malloc(n * 10 * sizeof(real_t));     real_t c[10];     real_t c_host[10];      for (int x = 0; x < 10 * n; ++x) {         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      for (int x = 0; x < 10; ++x) {         c[x] = 1.0;         c_host[x] = 1.0;     }      #pragma acc data copyin(a[0:10*n]  b[0:10*n])     {         #pragma acc parallel loop reduction(+:c[0:10])         for (int x = 0; x < n; ++x) {             for (int y = 0; y < 10; ++y) {                 c[y] += a[x * 10 + y] + b[x * 10 + y];             }         }     }      for (int x = 0; x < n; ++x) {         for (int y = 0; y < 10; ++y) {             c_host[y] += a[x * 10 + y] + b[x * 10 + y];         }     }      for (int x = 0; x < 10; ++x) {         if (fabs(c_host[x] - c[x]) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature serial_async.c", "#include "acc_testsuite.h" #ifndef T1 //T1:serial async wait V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * d = (real_t *)malloc(n * sizeof(real_t));     real_t * e = (real_t *)malloc(n * sizeof(real_t));     real_t * f = (real_t *)malloc(n * sizeof(real_t));     real_t * g = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;         g[x] = 0.0;     }      #pragma acc data copyin(a[0:n]  b[0:n]  d[0:n]  e[0:n]  c[0:n]  f[0:n]  g[0:n])     {         #pragma acc serial async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc serial async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         #pragma acc serial wait(1  2) async(3)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 g[x] = c[x] + f[x];             }         }         #pragma acc update host(c[0:n]) async(1)         #pragma acc update host(f[0:n]) async(2)         #pragma acc update host(g[0:n]) async(3)          #pragma acc wait(1)         for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x])) > PRECISION){                 err += 1;             }         }         #pragma acc wait(2)         for (int x = 0; x < n; ++x){             if (fabs(f[x] - (d[x] + e[x])) > PRECISION){                 err += 1;             }         }         #pragma acc wait(3)         for (int x = 0; x < n; ++x){             if (fabs(g[x] - (a[x] + b[x] + d[x] + e[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_update_x_multiply_expr.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_structured_postincrement_assign.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *c = (int *)malloc(n * sizeof(int));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));     bool found = false;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]  b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     distribution[(int) (a[x]*b[x]/10)]++;                     c[x] = distribution[(int) (a[x]*b[x]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]++;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < distribution_comparison[x]; ++y){             for (int z = 0; z < n; ++z){                 if (c[z] == y + 1 && (int) (a[z]*b[z]/10) == x){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature data_create.c", "#include "acc_testsuite.h" #ifndef T1 //T1:data data-region construct-independent V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc data create(b[0:n])     {         #pragma acc data copyin(a[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = a[x];                 }             }         }         #pragma acc data copyout(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - a[x]) > PRECISION) {             err += 1;             break;         }     }      return err; } #endif  #ifndef T2 //T2:data data-region construct-independent compatibility-features V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc data present_or_create(b[0:n])     {         #pragma acc data copyin(a[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = a[x];                 }             }         }         #pragma acc data copyout(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - a[x]) > PRECISION) {             err += 2;             break;         }     }      return err; } #endif  #ifndef T3 //T3:data data-region construct-independent compatibility-features V:1.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc data pcreate(b[0:n])     {         #pragma acc data copyin(a[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = a[x];                 }             }         }         #pragma acc data copyout(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - a[x]) > PRECISION){             err += 4;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_expr_rshift_x.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     int orders[18] = {1  2  0  1  0  2  2  1  0  2  0  1  0  1  2  0  2  1};     int result;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 3; ++y){             a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));         }         b[x] = 0;     }      #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop independent                 for (int y = 0; y < 3; ++y){                     #pragma acc atomic                         b[x] = a[x * 3 + y] >> b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 6; ++y){             result = 0;             for (int z = 0; z < 3; ++z){                 result = a[x * 3 + orders[y * 3 + z]] >> result;             }             if (result == b[x]){                 break;             }         }         if (result != b[x]){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature serial_copyout_zero.c", "#include "acc_testsuite.h" #ifndef T1 //T1:serial data data-region V:3.0-3.1 int test1(){     int err = 0;     srand(SEED);      real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n])     {         #pragma acc serial copyout(zero: b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] += a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T2 //T2:serial data data-region reference-counting devonly V:3.0-3.1 int test2(){     int err = 0;     srand(SEED);      real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int* hasDevice = (int *) malloc(sizeof(int));     hasDevice[0] = 1;     #pragma acc enter data copyin(hasDevice[0:1])     #pragma acc serial present(hasDevice[0:1])     {       hasDevice[0] = 0;     }      if (hasDevice[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0;         }         #pragma acc data copyin(a[0:n]  b[0:n])         {             #pragma acc serial copyout(b[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] += a[x];                 }             }         }         for (int x = 0; x < n; ++x){             if (fabs(b[x]) > PRECISION){                 err += 1;                 break;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature atomic_update_bitor_equals.c", "#include "acc_testsuite.h" #ifndef T1 //T1:atomic construct-independent V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] |= a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] |= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature kernels_loop_reduction_multiply_vector_loop.c", "#include "acc_testsuite.h" #ifndef T1 //T1:kernels loop reduction combined-constructs V:1.0-2.7 int test1(){     int err = 0;     int multiplicitive_n = 128;     srand(SEED);     real_t * a = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * sizeof(real_t));     real_t temp;      for (int x = 0; x < 10 * multiplicitive_n; ++x){         a[x] = rand() / (real_t) RAND_MAX;         b[x] = rand() / (real_t) RAND_MAX;     }      #pragma acc data copyin(a[0:10*multiplicitive_n]  b[0:10*multiplicitive_n]) copyout(c[0:10])     {         #pragma acc kernels loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 1.0;             #pragma acc loop vector reduction(*:temp)             for (int y = 0; y < multiplicitive_n; ++y){                 temp *= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];             }             c[x] = temp;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < multiplicitive_n; ++y){             c[x] /= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];         }     }      for (int x = 0; x < 10; ++x){         if (fabs(c[x] - 1) > PRECISION * (4 * multiplicitive_n - 1)){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
"### System : You will help create tests.", "Create a test for the feature serial_loop_reduction_multiply_general.c", "#include "acc_testsuite.h" #ifndef T1 //T1:serial loop reduction combined-constructs V:2.6-2.7 int test1(){     int err = 0;     int multiplicitive_n = 128;     srand(SEED);     real_t * a = (real_t *)malloc(multiplicitive_n * sizeof(real_t));     real_t * b = (real_t *)malloc(multiplicitive_n * sizeof(real_t));      real_t multiplied_total = 1.0;      for (int x = 0; x < multiplicitive_n; ++x){         a[x] = rand() / (real_t) RAND_MAX;         b[x] = rand() / (real_t) RAND_MAX;     }      #pragma acc data copyin(a[0:multiplicitive_n]  b[0:multiplicitive_n]) copy(multiplied_total)     {         #pragma acc serial loop reduction (*:multiplied_total)         for (int x = 0; x < multiplicitive_n; ++x){             multiplied_total *= a[x] + b[x];         }     }      for (int x = 0; x < multiplicitive_n; ++x){         multiplied_total /= (a[x] + b[x]);     }     if (fabs(multiplied_total - 1) > PRECISION * (2 * multiplicitive_n - 1)){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "
