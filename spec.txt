Contents
1 Introduction
11 Scope                                         
12 Execution Model                                   
13 Memory Model                                    
14 Language Interoperability                               
15 Runtime Errors                                    
16 Conventions used in this document                          
17 Organization of this document                            
18 References                                       
19 Changes from Version 10 to 20                           
110 Corrections in the August 2013 document                      
111 Changes from Version 20 to 25                           
112 Changes from Version 25 to 26                           
113 Changes from Version 26 to 27                           
114 Changes from Version 27 to 30                           
115 Changes from Version 30 to 31                           
116 Changes from Version 31 to 32                           
117 Changes from Version 32 to 33                           
118 Topics Deferred For a Future Revision                        
2 Directives
21 Directive Format                                   
22 Conditional Compilation                               
23 Internal Control Variables                               
231 Modifying and Retrieving ICV Values                    
24 Device-Speciﬁc Clauses                               
25 Compute Constructs                                  
251 Parallel Construct                               
252 Serial Construct                                
253 Kernels Construct                               
254 Compute Construct Restrictions                       
255 Compute Construct Errors                          
256 if clause                                    
257 self clause                                   
258 async clause                                 
259 wait clause                                  
2510 num gangs clause                               
2511 num workers clause                             
2512 vector length clause                             
2513 private clause                                 
2514 ﬁrstprivate clause                               
2515 reduction clause                               
2516 default clause                                 

26 Data Environment                                   
261 Variables with Predetermined Data Attributes                
262 Variables with Implicitly Determined Data Attributes            
263 Data Regions and Data Lifetimes                      
264 Data Structures with Pointers                         
265 Data Construct                                
266 Enter Data and Exit Data Directives                     
267 Reference Counters                              
268 Attachment Counter                             
27 Data Clauses                                     
271 Data Speciﬁcation in Data Clauses                      
272 Data Clause Actions                             
273 Data Clause Errors                              
274 deviceptr clause                                
275 present clause                                 
276 copy clause                                  
277 copyin clause                                 
278 copyout clause                                
279 create clause                                 
2710 no create clause                                
2711 delete clause                                 
2712 attach clause                                 
2713 detach clause                                 
28 Host Data Construct                                 
281 use device clause                               
282 if clause                                    
283 if present clause                               
29 Loop Construct                                    
291 collapse clause                                
292 gang clause                                  
293 worker clause                                 
294 vector clause                                 
295 seq clause                                   
296 independent clause                              
297 auto clause                                  
298 tile clause                                   
299 device type clause                              
2910 private clause                                 
2911 reduction clause                               
210 Cache Directive                                    
211 Combined Constructs                                 
212 Atomic Construct                                   
213 Declare Directive                                   
2131 device resident clause                            
2132 create clause                                 
2133 link clause                                  
214 Executable Directives                                 
2141 Init Directive                                 

2142 Shutdown Directive                              
2143 Set Directive                                 
2144 Update Directive                               
2145 Wait Directive                                
2146 Enter Data Directive                             
2147 Exit Data Directive                              
215 Procedure Calls in Compute Regions                         
2151 Routine Directive                               
2152 Global Data Access                              
216 Asynchronous Behavior                                
2161 async clause                                 
2162 wait clause                                  
2163 Wait Directive                                
217 Fortran Speciﬁc Behavior                               
2171 Optional Arguments                             
2172 Do Concurrent Construct                           
3 Runtime Library
31 Runtime Library Deﬁnitions                             
32 Runtime Library Routines                              
321 acc getnum devices                             
322 acc setdevice type                              
323 acc getdevice type                              
324 acc setdevice num                              
325 acc getdevice num                              
326 acc getproperty                               
327 acc init                                    
328 acc shutdown                                 
329 acc async test                                 
3210 acc wait                                    
3211 acc wait async                                
3212 acc wait any                                 
3213 acc getdefault async                             
3214 acc setdefault async                             
3215 acc ondevice                                 
3216 acc malloc                                  
3217 acc free                                    
3218 acc copyin and acc create                          
3219 acc copyout and acc delete                          
3220 acc update device and acc update self                    
3221 acc map data                                 
3222 acc unmap data                                
3223 acc deviceptr                                 
3224 acc hostptr                                  
3225 acc ispresent                                 
3226 acc memcpy todevice                            
3227 acc memcpy from device                          
3228 acc memcpy device                             

3229 acc attach and acc detach                          
3230 acc memcpy d2d                               
4 Environment Variables
41 ACC DEVICE TYPE                                 
42 ACC DEVICE NUM                                 
43 ACC PROFLIB                                    
5 Proﬁling and Error Callback Interface
51 Events                                         
511 Runtime Initialization and Shutdown                    
512 Device Initialization and Shutdown                     
513 Enter Data and Exit Data                           
514 Data Allocation                                
515 Data Construct                                
516 Update Directive                               
517 Compute Construct                              
518 Enqueue Kernel Launch                           
519 Enqueue Data Update (Upload and Download)               
5110 Wait                                      
5111 Error Event                                  
52 Callbacks Signature                                  
521 First Argument: General Information                    
522 Second Argument: Event-Speciﬁc Information               
523 Third Argument: API-Speciﬁc Information                 
53 Loading the Library                                  
531 Library Registration                             
532 Statically-Linked Library Initialization                   
533 Runtime Dynamic Library Loading                     
534 Preloading with LD PRELOAD                       
535 Application-Controlled Initialization                     
54 Registering Event Callbacks                             
541 Event Registration and Unregistration                    
542 Disabling and Enabling Callbacks                      
55 Advanced Topics                                   
551 Dynamic Behavior                              
552 OpenACC Events During Event Processing                 
553 Multiple Host Threads                            
6 Glossary
A Recommendations for Implementers
A1 Target Devices                                    
A11 NVIDIA GPU Targets                            
A12 AMD GPU Targets                              
A13 Multicore Host CPU Target                         
A2 API Routines for Target Platforms                          
A21 NVIDIA CUDA Platform                          

A22 OpenCL Target Platform                           
A3 Recommended Options and Diagnostics                       
A31 C Pointer in Present clause                          
A32 Nonconforming Applications and Implementations             
A33 Automatic Data Attributes                          
A34 Routine Directive with a Name                        


1 Introduction
This document describes the compiler directives, library routines, and en vironment variables that
collectively deﬁne the OpenACCTMApplication Programming Interface (OpenACC API) for writ-
ing parallel programs in C, C++, and Fortran that run identiﬁed regions in p arallel on multicore
CPUs or attached accelerators The method described provides a model f or parallel programming
that is portable across operating systems and various types of multicore CPU s and accelerators The
directives extend the ISO/ANSI standard C, C++, and Fortran base lang uages in a way that allows
a programmer to migrate applications incrementally to parallel multicore and acceler ator targets
using standards-based C, C++, or Fortran
The directives and programming model deﬁned in this document allow progra mmers to create appli-
cations capable of using accelerators without the need to explicitly manage da ta or program transfers
between a host and accelerator or to initiate accelerator startup and shutdo wn Rather, these details
are implicit in the programming model and are managed by the OpenACC API-ena bled compilers
and runtime environments The programming model allows the programmer to augme nt informa-
tion available to the compilers, including speciﬁcation of data local to an acceler ator, guidance on
mapping of loops for parallel execution, and similar performance-related d etails
11 Scope
This OpenACC API document covers only user-directed parallel and ac celerator programming,
where the user speciﬁes the regions of a program to be targeted for par allel execution The remainder
of the program will be executed sequentially on the host This document doe s not describe features
or limitations of the host programming environment as a whole; it is limited to speciﬁca tion of loops
and regions of code to be executed in parallel on a multicore CPU or an acce lerator
This document does not describe automatic detection of parallel regions or automatic ofﬂoading
of regions of code to an accelerator by a compiler or other tool This docume nt does not describe
splitting loops or code regions across multiple accelerators attached to a single host While future
compilers may allow for automatic parallelization or automatic ofﬂoading, or paralle lizing across
multiple accelerators of the same type, or across multiple accelerators of diffe rent types, these pos-
sibilities are not addressed in this document
12 Execution Model
The execution model targeted by OpenACC API-enabled implementations is hos t-directed execu-
tion with an attached parallel accelerator, such as a GPU, or a multicore host with a host thread that
initiates parallel execution on the multiple cores, thus treating the multicore CPU itself as a device
Much of a user application executes on a host thread Compute intensive r egions are ofﬂoaded to an
accelerator or executed on the multiple host cores under control of a hos t thread A device, either
an attached accelerator or the multicore CPU, executes parallel regions , which typically contain
work-sharing loops, kernels regions, which typically contain one or more loops that may be exe-
cuted as kernels, or serial regions, which are blocks of sequential code Even in accelerator-targeted
regions, the host thread may orchestrate the execution by allocating memory o n the accelerator de-
vice, initiating data transfer, sending the code to the accelerator, passing a rguments to the compute
region, queuing the accelerator code, waiting for completion, transferrin g results back to the host,

and deallocating memory In most cases, the host can queue a sequence o f operations to be executed
on a device, one after the other
Most current accelerators and many multicore CPUs support two or three levels of parallelism
Most accelerators and multicore CPUs support coarse-grain parallelism, which is fully parallel exe-
cution across execution units There may be limited support for synchroniz ation across coarse-grain
parallel operations Many accelerators and some CPUs also support ﬁn e-grain parallelism, often
implemented as multiple threads of execution within a single execution unit, which are typically
rapidly switched on the execution unit to tolerate long latency memory operations  Finally, most
accelerators and CPUs also support SIMD or vector operations within ea ch execution unit The
execution model exposes these multiple levels of parallelism on a device and the programmer is
required to understand the difference between, for example, a fully par allel loop and a loop that
is vectorizable but requires synchronization between statements A fully pa rallel loop can be pro-
grammed for coarse-grain parallel execution Loops with dependences must either be split to allow
coarse-grain parallel execution, or be programmed to execute on a single execution unit using ﬁne-
grain parallelism, vector parallelism, or sequentially
OpenACC exposes these three levels of parallelism viagang ,worker , and vector parallelism Gang
parallelism is coarse-grain A number of gangs will be launched on the acc elerator The gangs are
organized in a one-, two-, or three-dimensional grid, where dimension on e corresponds to the inner
level of gang parallelism; the default is to only use dimension one Worker pa rallelism is ﬁne-grain
Each gang will have one or more workers Vector parallelism is for SIMD o r vector operations
within a worker
When executing a compute region on a device, one or more gangs are launc hed, each with one or
more workers, where each worker may have vector execution capability w ith one or more vector
lanes The gangs start executing in gang-redundant mode (GR mode), meaning one vector lane of
one worker in each gang executes the same code, redundantly Each ga ng dimension is associated
with a gang-redundant mode dimension, denoted GR1, GR2, and GR3 When the program reaches
a loop or loop nest marked for gang-level work-sharing at some dimensio n, the program starts to
execute in gang-partitioned mode for that dimension, denoted GP1, GP2, or GP3 mode, where the
iterations of the loop or loops are partitioned across the gangs in that dimension for truly parallel
execution, but still with only one worker per gang and one vector lane per worker active The
program may be simultaneously in different gang modes for different dimens ions For instance,
after entering a loop partitioned for gang-level work-sharing at dimensio n 3, the program will be in
GP3, GR2, GR1 mode
When only one worker is active, in any gang-level execution mode, the pr ogram is in worker-single
mode (WS mode) When only one vector lane is active, the program is in vector-single mode
(VS mode) If a gang reaches a loop or loop nest marked for worker-le vel work-sharing, the gang
transitions to worker-partitioned mode (WP mode), which activates all the workers of the gang The
iterations of the loop or loops are partitioned across the workers of this gan g If the same loop is
marked for both gang-partitioning in dimension dand worker-partitioning, then the iterations of the
loop are spread across all the workers of all the gangs of dimension d If a worker reaches a loop
or loop nest marked for vector-level work-sharing, the worker will tra nsition to vector-partitioned
mode (VP mode) Similar to WP mode, the transition to VP mode activates all the vector lanes of
the worker The iterations of the loop or loops will be partitioned across the v ector lanes using vector
or SIMD operations Again, a single loop may be marked for one, two, or all three of gang, worker,
and vector parallelism, and the iterations of that loop will be spread across th e gangs, workers, and
vector lanes as appropriate

The program starts executing with a single initial host thread, identiﬁed by a p rogram counter and
its stack The initial host thread may spawn additional host threads, using O penACC or another
mechanism, such as with the OpenMP API On a device, a single vector lane of a single worker of a
single gang is called a device thread When executing on an accelerator, a parallel execution context
is created on the accelerator and may contain many such threads
The user should not attempt to implement barrier synchronization, critical se ctions, or locks across
any of gang, worker, or vector parallelism The execution model allows fo r an implementation that
executes some gangs to completion before starting to execute other gangs T his means that trying
to implement synchronization between gangs is likely to fail In particular, a bar rier across gangs
cannot be implemented in a portable fashion, since all gangs may not ever be active at the same time
Similarly, the execution model allows for an implementation that executes some work ers within a
gang or vector lanes within a worker to completion before starting other work ers or vector lanes,
or for some workers or vector lanes to be suspended until other worker s or vector lanes complete
This means that trying to implement synchronization across workers or vecto r lanes is likely to fail
In particular, implementing a barrier or critical section across workers or v ector lanes using atomic
operations and a busy-wait loop may never succeed, since the schedule r may suspend the worker or
vector lane that owns the lock, and the worker or vector lane waiting on the lo ck can never complete
Some devices, such as a multicore CPU, may also create and launch additional compute regions,
allowing for nested parallelism In that case, the OpenACC directives may be executed by a host
thread or a device thread This speciﬁcation uses the term local thread orlocal memory to mean the
thread that executes the directive, or the memory associated with that thread , whether that thread
executes on the host or on the accelerator The speciﬁcation uses the ter mlocal device to mean the
device on which the local thread is executing
Most accelerators can operate asynchronously with respect to the hos t thread Such devices have one
or more activity queues The host thread will enqueue operations onto the device activity queues,
such as data transfers and procedure execution After enqueuing the operation, the host thread can
continue execution while the device operates independently and asynchro nously The host thread
may query the device activity queue(s) and wait for all the operations in a q ueue to complete
Operations on a single device activity queue will complete before starting the n ext operation on the
same queue; operations on different activity queues may be active simultan eously and may complete
in any order
13 Memory Model
The most signiﬁcant difference between a host-only program and a hos t+accelerator program is that
the memory on an accelerator may be discrete from host memory This is the cas e with most current
GPUs, for example In this case, the host thread may not be able to read or write device memory
directly because it is not mapped into the host thread’s virtual memory space  All data movement
between host memory and accelerator memory must be performed by the host thread through system
calls that explicitly move data between the separate memories, typically using direc t memory access
(DMA) transfers Similarly, the accelerator may not be able to read or write h ost memory; though
this is supported by some accelerators, it may incur signiﬁcant performanc e penalty
The concept of discrete host and accelerator memories is very apparen t in low-level accelerator
programming languages such as CUDA or OpenCL, in which data movement be tween the memories
can dominate user code In the OpenACC model, data movement between the memo ries can be
implicit and managed by the compiler, based on directives from the programmer  However, the

programmer must be aware of the potentially discrete memories for many reason s, including but
not limited to:
	Memory bandwidth between host memory and accelerator memory determines the level of
compute intensity required to effectively accelerate a given region of cod e
	The user should be aware that a discrete accelerator memory is usually sign iﬁcantly smaller
than the host memory, prohibiting ofﬂoading regions of code that operate o n very large
amounts of data
	Data in host memory may only be accessible on the host; data in accelerator memor y may
only be accessible on that accelerator Explicitly transferring pointer valu es between host and
accelerator memory is not advised Dereferencing pointers to host memory on an accelerator
or dereferencing pointers to accelerator memory on the host is likely to resu lt in a runtime
error or incorrect results on such targets
OpenACC exposes the discrete memories through the use of a device data en vironment Device data
has an explicit lifetime, from when it is allocated or created until it is deleted If a device shares
memory with the local thread, its device data environment will be shared with the lo cal thread In
that case, the implementation need not create new copies of the data for the de vice and no data
movement need be done If a device has a discrete memory and shares no me mory with the local
thread, the implementation will allocate space in device memory and copy data betwe en the local
memory and device memory, as appropriate The local thread may share some memory with a
device and also have some memory that is not shared with that device In that case, data in shared
memory may be accessed by both the local thread and the device Data not in s hared memory will
be copied to device memory as necessary
Some accelerators implement a weak memory model In particular, they do not su pport memory
coherence between operations executed by different threads; even on the same execution unit, mem-
ory coherence is only guaranteed when the memory operations are separ ated by an explicit memory
fence Otherwise, if one thread updates a memory location and another rea ds the same location, or
two threads store a value to the same location, the hardware may not guarante e the same result for
each execution While a compiler can detect some potential errors of this natu re, it is nonetheless
possible to write a compute region that produces inconsistent numerical res ults
Similarly, some accelerators implement a weak memory model for memory shared be tween the
host and the accelerator, or memory shared between multiple accelerators Programmers need to
be very careful that the program uses appropriate synchronization to ensure that an assignment or
modiﬁcation by a thread on any device to data in shared memory is complete and av ailable before
that data is used by another thread on the same or another device
Some current accelerators have a software-managed cache, some hav e hardware managed caches,
and most have hardware caches that can be used only in certain situations and are limited to read-
only data In low-level programming models such as CUDA or OpenCL langua ges, it is up to the
programmer to manage these caches In the OpenACC model, these caches a re managed by the
compiler with hints from the programmer in the form of directives
14 Language Interoperability
The speciﬁcation supports programs written using OpenACC in two or more of F ortran, C, and
C++ languages The parts of the program in any one base language will in teroperate with the parts
written in the other base languages as described here In particular:

	Data made present in one base language on a device will be seen as prese nt by any base
language
	A region that starts and ends in a procedure written in one base language ma y directly or
indirectly call procedures written in any base language The execution of those procedures
are part of the region
15 Runtime Errors
Common runtime errors are noted in this document When one of these runtime err ors is issued, one
or more error callback routines are called by the program Error condition s are noted throughout
Chapter 2 Directives and Chapter 3 Runtime Library along with the error cod e that gets set for the
error callback
A list of error codes appears in Section 522 Since device actions may occ ur asynchronously,
some errors may occur asynchronously as well In such cases, the err or callback routines may not
be called immediately when the error occurs, but at some point later when the e rror is detected
during program execution In situations when more than one error may occ ur or has occurred,
any one of the errors may be issued and different implementations may issue d ifferent errors An
acc_error_system error may be issued at any time if the current device becomes unavailable
due to underlying system issues
The default error callback routine may print an error message and halt p rogram execution The ap-
plication can register one or more additional error callback routines, to allow a failing application to
release resources or to cleanly shut down a large parallel runtime with many threads and processes
See Chapter 5 Proﬁling and Error Callback Interface The error callba ck mechanism is not intended
for error recovery There is no support for restarting or retrying a n OpenACC program, construct, or
API routine after an error condition has been detected and an error callb ack routine has been called
16 Conventions used in this document
Some terms are used in this speciﬁcation that conﬂict with their usage as deﬁne d in the base lan-
guages When there is potential confusion, the term will appear in the Gloss ary
Keywords and punctuation that are part of the actual speciﬁcation will ap pear in typewriter font:
#pragma acc
Italic font is used where a keyword or other name must be used:
#pragma acc directive-name
For C and C++, new-line means the newline character at the end of a line:
#pragma acc directive-name new-line
Optional syntax is enclosed in square brackets; an option that may be repe ated more than once is
followed by ellipses:
#pragma acc directive-name [clause [[,]clause ]   ] new-line
In this spec, a var(in italics) is one of the following:
	a variable name (a scalar, array, or composite variable name);
	a subarray speciﬁcation with subscript ranges;

	an array element;
	a member of a composite variable;
	a common block name between slashes
Not all options are allowed in all clauses; the allowable options are clariﬁed f or each use of the term
var Unnamed common blocks (blank commons) are not permitted and common blocks o f the same
name must be of the same size in all scoping units as required by the Fortran sta ndard
To simplify the speciﬁcation and convey appropriate constraint information, apqr-list is a comma-
separated list of pqritems For example, an int-expr-list is a comma-separated list of one or more
integer expressions, and a var-list is a comma-separated list of one or more vars The one exception
isclause-list , which is a list of one or more clauses optionally separated by commas
#pragma acc directive-name [clause-list ]new-line
For C/C++, unless otherwise speciﬁed, each expression inside of the Op enACC clauses and direc-
tive arguments must be a valid assignment-expression  This avoids ambiguity between the comma
operator and comma-separated list items
In this spec, a do loop (in italics) is the doconstruct as deﬁned by the Fortran standard The do-stmt
of thedoconstruct must conform to one of the following forms:
do [label] do-var = lb, ub [, incr]
do concurrent [label] concurrent-header [concurrent-locality]
Thedo-var is a variable name and the lb, ub, incr are scalar integer expressions A doconcurrent
is treated as if deﬁning a loop for each index in the concurrent-header 
An italicized true is used for a condition that evaluates to nonzero in C or C++, or true in
Fortran An italicized false is used for a condition that evaluates to zero in C or C++, or false
in Fortran
17 Organization of this document
The rest of this document is organized as follows:
Chapter 2 Directives, describes the C, C++, and Fortran directives us ed to delineate accelerator
regions and augment information available to the compiler for scheduling of loo ps and classiﬁcation
of data
Chapter 3 Runtime Library, deﬁnes user-callable functions and library ro utines to query the accel-
erator features and control behavior of accelerator-enabled progr ams at runtime
Chapter 4 Environment Variables, deﬁnes user-settable environment va riables used to control be-
havior of accelerator-enabled programs at runtime
Chapter 5 Proﬁling and Error Callback Interface, describes the OpenA CC interface for tools that
can be used for proﬁle and trace data collection
Chapter 6 Glossary, deﬁnes common terms used in this document
Appendix A Recommendations for Implementers, gives advice to implementers to s upport more
portability across implementations and interoperability with other accelerator API s

18 References
Each language version inherits the limitations that remain in previous versions o f the language in
this list
	American National Standard Programming Language C , ANSI X3159-1989 (ANSI C)
	ISO/IEC 9899:1999, Information Technology – Programming Languages – C , (C99)
	ISO/IEC 9899:2011, Information Technology – Programming Languages – C , (C11)
The use of the following C11 features may result in unspeciﬁed behavior
		Threads
		Thread-local storage
		Parallel memory model
		Atomic
	ISO/IEC 9899:2018, Information Technology – Programming Languages – C , (C18)
The use of the following C18 features may result in unspeciﬁed behavior
		Thread related features
	ISO/IEC 14882:1998, Information Technology – Programming Languages – C++ 
	ISO/IEC 14882:2011, Information Technology – Programming Languages – C++ , (C++11)
The use of the following C++11 features may result in unspeciﬁed behavio r
		Extern templates
		copy and rethrow exceptions
		memory model
		atomics
		move semantics
		std::thread
		thread-local storage
	ISO/IEC 14882:2014, Information Technology – Programming Languages – C++ , (C++14)
	ISO/IEC 14882:2017, Information Technology – Programming Languages – C++ , (C++17)
	ISO/IEC 1539-1:2004, Information Technology – Programming Languages – Fortran – Part
1: Base Language , (Fortran 2003)
	ISO/IEC 1539-1:2010, Information Technology – Programming Languages – Fortran – Part
1: Base Language , (Fortran 2008)
The use of the following Fortran 2008 features may result in unspeciﬁed b ehavior
		Coarrays
		Simply contiguous arrays rank remapping to rank >1 target

		Allocatable components of recursive type
		Polymorphic assignment
	ISO/IEC 1539-1:2018, Information Technology – Programming Languages – Fortran – Part
1: Base Language , (Fortran 2018)
The use of the following Fortran 2018 features may result in unspeciﬁed b ehavior
		Interoperability with C
∗C functions declared in ISO Fortran bindingh
∗Assumed rank
		All additional parallel/coarray features
	OpenMP Application Program Interface, version 50, November
	NVIDIA CUDATMC Programming Guide , version 1111, October
	The OpenCL Speciﬁcation , version 22, Khronos OpenCL Working Group, July
	INCITS INCLUSIVE TERMINOLOGY GUIDELINES , version 20210607, InterNational Com-
mittee for Information Technology Standards, June
19 Changes from Version 10 to 2
	_OPENACC value updated to
	default(none) clause onparallel andkernels directives
	the implicit data attribute for scalars in parallel constructs has changed
	the implicit data attribute for scalars in loops with loop directives with the independent
attribute has been clariﬁed
	acc_async_sync andacc_async_noval values for the async clause
	Clariﬁed the behavior of the reduction clause on a gang loop
	Clariﬁed allowable loop nesting ( gang may not appear inside worker , which may not ap-
pear within vector )
	wait clause onparallel ,kernels andupdate directives
	async clause on the wait directive
	enterdata andexitdata directives
	Fortran common block names may now appear in many data clauses
	link clause for the declare directive
	the behavior of the declare directive for global data
	the behavior of a data clause with a C or C++ pointer variable has been clariﬁ ed
	predeﬁned data attributes
	support for multidimensional dynamic C/C++ arrays

	tile andauto loop clauses
	updateself introduced as a preferred synonym for updatehost
	routine directive and support for separate compilation
	device_type clause and support for multiple device types
	nested parallelism using parallel or kernels region containing another par allel or kernels re-
gion
	atomic constructs
	new concepts: gang-redundant, gang-partitioned; worker-single, w orker-partitioned; vector-
single, vector-partitioned; thread
	new API routines:
		acc_wait ,acc_wait_all instead ofacc_async_wait andacc_async_wait_all
		acc_wait_async
		acc_copyin ,acc_present_or_copyin
		acc_create ,acc_present_or_create
		acc_copyout ,acc_delete
		acc_map_data ,acc_unmap_data
		acc_deviceptr ,acc_hostptr
		acc_is_present
		acc_memcpy_to_device ,acc_memcpy_from_device
		acc_update_device ,acc_update_self
	deﬁned behavior with multiple host threads, such as with OpenMP
	recommendations for speciﬁc implementations
	clariﬁed that no arguments are allowed on the vector clause in a parallel region
110 Corrections in the August 2013 document
	corrected the atomiccapture syntax for C/C++
	ﬁxed the name of the acc_wait andacc_wait_all procedures
	ﬁxed description of the acc_hostptr procedure
111 Changes from Version 20 to 2
	The_OPENACC value was updated to 201510 ; see Section 22 Conditional Compilation
	Thenum_gangs ,num_workers , andvector_length clauses are now allowed on the
kernels construct; see Section 253 Kernels Construct
	Reduction on C++ class members, array elements, and struct elements are ex plicitly disal-
lowed; see Section 2515 reduction clause

	Reference counting is now used to manage the correspondence and lifetime of device data;
see Section 267 Reference Counters
	The behavior of the exitdata directive has changed to decrement the dynamic reference
counter A new optional finalize clause was added to set the dynamic reference counter
to zero See Section 266 Enter Data and Exit Data Directives
	Thecopy ,copyin ,copyout , andcreate data clauses were changed to behave like
present_or_copy , etc Thepresent_or_copy ,pcopy ,present_or_copyin ,
pcopyin ,present_or_copyout ,pcopyout ,present_or_create , andpcreate
data clauses are no longer needed, though will be accepted for compatibility ; see Section 2
Data Clauses
	Reductions on orphaned gang loops are explicitly disallowed; see Section 29 Loop Construct
	The description of the loopauto clause has changed; see Section 297 auto clause
	Text was added to the private clause on a loop construct to clarify that a copy is made
for each gang or worker or vector lane, not each thread; see Section 2910 private clause
	The description of the reduction clause on a loop construct was corrected; see Sec-
tion 2911 reduction clause
	A restriction was added to the cache clause that all references to that variable must lie within
the region being cached; see Section 210 Cache Directive
	Text was added to the private andreduction clauses on a combined construct to clarify
that they act like private andreduction on theloop , notprivate andreduction
on theparallel orreduction on thekernels ; see Section 211 Combined Constructs
	Thedeclarecreate directive with a Fortran allocatable has new behavior; see Sec-
tion 2132 create clause
	Newinit ,shutdown ,set directives were added; see Section 2141 Init Directive, 214
Shutdown Directive, and 2143 Set Directive
	A newif_present clause was added to the update directive, which changes the behavior
when data is not present from a runtime error to a no-op; see Section 214 4 Update Directive
	Theroutinebind clause deﬁnition changed; see Section 2151 Routine Directive
	Anacc routine withoutgang /worker /vector /seq is now deﬁned as an error; see
Section 2151 Routine Directive
	A newdefault(present) clause was added for compute constructs; see Section 25
default clause
	The Fortran header ﬁle openacc_libh is no longer supported; the Fortran module openacc
should be used instead; see Section 31 Runtime Library Deﬁnitions
	New API routines were added to get and set the default async queue va lue; see Section 32
accgetdefault async and 3214 acc setdefault async
	Theacc_copyin ,acc_create ,acc_copyout , andacc_delete API routines were
changed to behave like acc_present_or_copyin , etc Theacc_present_or_ names

are no longer needed, though will be supported for compatibility See Sectio ns 3218 and fol-
lowing
	Asynchronous versions of the data API routines were added; see Sec tions 3218 and follow-
ing
	A new API routine added, acc_memcpy_device , to copy from one device address to
another device address; see Section 3226 acc memcpy todevice
	A new OpenACC interface for proﬁle and trace tools was added;
see Chapter 5 Proﬁling and Error Callback Interface
112 Changes from Version 25 to 2
	The_OPENACC value was updated to 201711 
	A newserial compute construct was added See Section 252 Serial Construct
	A new runtime API query routine was added acc_get_property may be called from
the host and returns properties about any device See Section 326
	The text has clariﬁed that if a variable is in a reduction which spans two or mor e nested loops,
eachloop directive on any of those loops must have a reduction clause that contains the
variable; see Section 2911 reduction clause
	An optional iforif_present clause is now allowed on the host_data construct See
Section 28 Host Data Construct
	A newno_create data clause is now allowed on compute and data constructs See Sec-
tion 2710 no create clause
	The behavior of Fortran optional arguments in data clauses and in routine c alls has been
speciﬁed; see Section 2171 Optional Arguments
	The descriptions of some of the Fortran versions of the runtime library routin es were simpli-
ﬁed; see Section 32 Runtime Library Routines
	To allow for manual deep copy of data structures with pointers, new attach anddetach be-
havior was added to the data clauses, new attach anddetach clauses were added, and
matchingacc_attach andacc_detach runtime API routines were added; see Sections
264, 2712-2713 and 3229
	The Intel Coprocessor Ofﬂoad Interface target and API routine sec tions were removed from
the Section A Recommendations for Implementers, since Intel no longer produ ces this prod-
uct
113 Changes from Version 26 to 2
	The_OPENACC value was updated to 201811 
	The speciﬁcation allows for hosts that share some memory with the device but n ot all memory
The wording in the text now discusses whether local thread data is in share d memory (memory
shared between the local thread and the device) or discrete memory (local thread memory that
is not shared with the device), instead of shared-memory devices and non -shared memory
devices See Sections 13 Memory Model and 26 Data Environment

	The text was clariﬁed to allow an implementation that treats a multicore CPU as a devic e,
either an additional device or the only device
	Thereadonly modiﬁer was added to the copyin data clause and cache directive See
Sections 277 and 210
	The term local device was deﬁned; see Section 12 Execution Model and the Glossary
	The term varis used more consistently throughout the speciﬁcation to mean a variable name,
array name, subarray speciﬁcation, array element, composite variable memb er, or Fortran
common block name between slashes Some uses of varallow only a subset of these options,
and those limitations are given in those cases
	Theself clause was added to the compute constructs; see Section 257 self clause
	The appearance of a reduction clause on a compute construct implies a copy clause for
each reduction variable; see Sections 2515 reduction clause and 211 Co mbined Constructs
	Thedefault(none) anddefault(present) clauses were added to the data con-
struct; see Section 265 Data Construct
	Data is deﬁned to be present based on the values of the structured and dynamic reference
counters; see Section 267 Reference Counters and the Glossary
	The interaction of the acc_map_data andacc_unmap_data runtime API calls on the
present counters is deﬁned; see Section 272, 3221, and 3222
	A restriction clarifying that a host_data construct must have at least one use_device
clause was added
	Arrays, subarrays and composite variables are now allowed in reduction clauses; see
Sections 2911 reduction clause and 2515 reduction clause
	Changed behavior of ICVs to support nested compute regions and host as a device semantics
See Section 23
114 Changes from Version 27 to 3
	Updated_OPENACC value to201911 
	Updated the normative references to the most recent standards for all b ase languages See
Section 18
	Changed the text to clarify uses and limitations of the device_type clause and added
examples; see Section 24
	Clariﬁed the conﬂict between the implicit copy clause for variables in a reduction clause
and the implicit firstprivate for scalar variables not in a data clause but used in a
parallel orserial construct; see Sections 251 and 252
	Required at least one data clause on a data construct, an enterdata directive, or an exit
data directive; see Sections 265 and 266
	Added text describing how a C++ lambda invoked in a compute region and the variables
captured by the lambda are handled; see Section 262

	Added azero modiﬁer to create andcopyout data clauses that zeros the device memory
after it is allocated; see Sections 278 and 279
	Added a new restriction on the loop directive allowing only one of the seq,independent ,
andauto clauses to appear; see Section 29
	Added a new restriction on the loop directive disallowing a gang ,worker , orvector
clause to appear if a seq clause appears; see Section 29
	Allowed variables to be modiﬁed in an atomic region in a loop where the iterations mus t
otherwise be data independent, such as loops with a loopindependent clause or aloop
directive in a parallel construct; see Sections 292, 293, 294, and 296
	Clariﬁed the behavior of the auto andindependent clauses on the loop directive; see
Sections 297 and 296
	Clariﬁed that an orphaned loop construct, or a loop construct in a parallel construct
with noauto orseq clauses is treated as if an independent clause appears; see Sec-
tion 296
	For a variable in a reduction clause, clariﬁed when the update to the original variable is
complete, and added examples; see Section 2911
	Clariﬁed that a variable in an orphaned reduction clause must be private; see Section 2911
	Required at least one clause on a declare directive; see Section 213
	Added anifclause toinit ,shutdown ,set, andwait directives; see Sections 2141,
2142, 2143, and 2163
	Required at least one clause on a set directive; see Section 2143
	Added a devnum modiﬁer to the wait directive and clause to specify a device to which the
wait operation applies; see Section 2163
	Allowed a routine directive to include a C++ lambda name or to appear before a C++
lambda deﬁnition, and deﬁned implicit routine directive behavior when a C++ lambda is
called in a compute region or an accelerator routine; see Section 215
	Added runtime API routine acc_memcpy_d2d for copying data directly between two de-
vice arrays on the same or different devices; see Section 3230
	Deﬁned the values for the acc_construct_t andacc_device_api enumerations for
cross-implementation compatibility; see Sections 522 and 523
	Changed the return type of acc_set_cuda_stream fromint (values were not speciﬁed)
tovoid ; see Section A21
	Edited and expanded Section 118 Topics Deferred For a Future Revision
115 Changes from Version 30 to 3
	Updated_OPENACC value to202011 
	Clariﬁed that Fortran blank common blocks are not permitted and that same-na med common
blocks must have the same size See Section 16

	Clariﬁed that a parallel construct’s block is considered to start in gang-redundant mode
even if there’s just a single gang See Section 251
	Added support for the Fortran BLOCK construct See Sections 251, 25 3, 261, 265, 28,
213, and 6
	Deﬁned the serial construct in terms of the parallel construct to improve readability
Instead of deﬁning it in terms of clauses num_gangs(1)num_workers(1)
vector_length(1) , deﬁned the serial construct as executing with a single gang of a
single worker with a vector length of one See Section 252
	Consolidated compute construct restrictions into a new section to improve read ability See
Section 254
	Clariﬁed that a default clause may appear at most once on a compute construct See
Section 2516
	Consolidated discussions of implicit data attributes on compute and combined con structs into
a separate section Clariﬁed the conditions under which each data attribute is implied See
Section 262
	Added a restriction that certain loop reduction variables must have explicit d ata clauses on
their parent compute constructs This change addresses portability acro ss existing OpenACC
implementations See Sections 262 and A33
	Restored the OpenACC 25 behavior of the present ,copy ,copyin ,copyout ,create ,
no_create ,delete data clauses at exit from a region, or on an exitdata directive, as
applicable, and create clause at exit from an implicit data region where a declare di-
rective appears, and acc_copyout ,acc_delete routines, such that no action is taken if
the appropriate reference counter is zero, instead of a runtime error be ing issued if data is not
present See Sections 275, 276, 277, 278, 279, 2710, 2711, 2132, and 3219
	Clariﬁed restrictions on loop forms that can be associated with loop constructs, including
the case of C++ range-based for loops See Section 29
	Speciﬁed where gang clauses are implied on loop constructs This change standardizes
behavior of existing OpenACC implementations See Section 292
	Corrected C/C++ syntax for atomic capture with a structured block See Section 212
	Added the behavior of the Fortran do concurrent construct See Section 2172
	Changed the Fortran run-time procedures: acc_device_property has been renamed to
acc_device_property_kind andacc_get_property uses a different integer kind
for the result See Section 32
	Added or changed argument names for the Runtime Library routines to be de scriptive and
consistent This mostly impacts Fortran programs, which can pass arguments b y name See
Section 32
	Replaced composite variable by aggregate variable in reduction ,default , andprivate
clauses and in implicitly determined data attributes; the new wording also includes F ortran
character and allocatable/pointer variables See glossary in Section 6

116 Changes from Version 31 to 3
	Updated_OPENACC value to202111 
	Modiﬁed speciﬁcation to comply with INCITS standard for inclusive terminolog y
	The text was changed to state that certain runtime errors, when detected, r esult in a call to the
current runtime error callback routines See Section 15
	An ambiguity issue with the C/C++ comma operator was resolved See Section 16
	The terms true andfalse were deﬁned and used throughout to shorten the descriptions See
Section 16
	Implicitly determined data attributes on compute constructs were clariﬁed See Se ction 262
	Clariﬁed that the default(none) clause applies to scalar variables See Section 262
	Theasync ,wait , anddevice_type clauses may be speciﬁed on data constructs See
Section 265
	The behavior of data clauses and data API routines with a null pointer in the c lause or as a
routine argument is deﬁned See Sections 275-2711, 281, and 3216-3 230
	Precision issues with the loop trip count calculation were clariﬁed See Sectio n 29
	Text in Section 216 was moved and reorganized to improve clarity and reduc e redundancy
	Some runtime routine descriptions were expanded and clariﬁed See Section 32
	Theacc_init_device andacc_shutdown_device routines were added to initialize
and shut down individual devices See Section 327 and Section 328
	Some runtime routine sections were reorganized and combined into a single sec tion to sim-
plify maintenance and reduce redundant text:
		The sections for four acc_async_test routines were combined into a single section
See Section 329
		The sections for four acc_wait routines were combined into a single section See
Section 3210
		The sections for four acc_wait_async routines were combined into a single section
See Section 3211
		The two sections for acc_copyin andacc_create were combined into a single
section See Section 3218
		The two sections for acc_copyout andacc_delete were combined into a single
section See Section 3219
		The two sections for acc_update_self andacc_update_device were com-
bined into a single section See Section 3220
		The two sections for acc_attach andacc_detach were combined into a single
section See Section 3229
	Added runtime API routine acc_wait_any  See section 3212

	The descriptions of the async andasync_queue ﬁelds ofacc_callback_info were
clariﬁed See Section 521
117 Changes from Version 32 to 3
	Updated_OPENACC value to202211 
	Allowed three dimensions of gang parallelism:
		Deﬁned multiple levels of gang-redundant andgang-partitioned execution modes See
Section 1
		Allowed multiple values in the num_gangs clauses on the parallel construct See
Section 2510
		Allowed adim argument to the gang clause on the loop construct See Section 292
		Allowed a dim argument to the gang clause on the routine directive See Sec-
tion 2151
		Changed the launch event information to include all three gang dimension size s See
Section 522
	Clariﬁed user-visible behavior of evaluation of expressions in clause ar guments See Sec-
tion 21
	Added the force modiﬁer to the collapse clause on loops to enable collapsing non-
tightly nested loops See Section 291
	Generalized implicit routine directives for all procedures instead of just C++ lambdas See
Section 2151
	Revised Section 2151 for clarity and conciseness, including:
		Speciﬁed predetermined routine directives that the implementation may apply
		Clariﬁed where routine directives must appear relative to deﬁnitions or uses of their
associated procedures in C and C++ This clariﬁcation includes the case o f forward
references in C++ class member lists
		Clariﬁed to which procedure a routine directive with a name applies in C and C++
		Clariﬁed how a nohost clause affects a procedure’s use within a compute region
	Added a Fortran interface for the following runtime routines (See Chapter 3) :
		acc_malloc
		acc_free
		acc_map_data
		acc_unmap_data
		acc_deviceptr
		acc_hostptr
		The twoacc_memcpy_to_device routines

		The twoacc_memcpy_from_device routines
		The twoacc_memcpy_device routines
		The twoacc_attach routines
		The fouracc_detach routines
	Added a new error condition for acc_map_data when thebytes argument is zero See
Section 3221
	Added recommendations for how a routine directive should affect multicore host CPU
compilation See Section A13
	Recommended additional diagnostics promoting portable and readable OpenA CC See Section A3
118 Topics Deferred For a Future Revision
The following topics are under discussion for a future revision Some of th ese are known to be
important, while others will depend on feedback from users Readers wh o have feedback or want
to participate may send email to feedback@openaccorg No promises are mad e or implied that all
these items will be available in a future revision
	Directives to deﬁne implicit deep copy behavior for pointer-based data structures
	Deﬁned behavior when data in data clauses on a directive are aliases of e ach other
	Clarifying when data becomes present ornot present on the device for enterdata orexit
data directives with an async clause
	Clarifying the behavior of Fortran pointer variables in data clauses
	Allowing Fortran pointer variables to appear in deviceptr clauses
	Support for attaching C/C++ pointers that point to an address past the en d of a memory region
	Fully deﬁned interaction with multiple host threads
	Optionally removing the synchronization or barrier at the end of vector and worker loops
	Allowing an ifclause after a device_type clause
	Ashared clause (or something similar) for the loop directive
	Better support for multiple devices from a single thread, whether of the same type or of
different types
	Anauto construct (by some name), to allow kernels -like auto-parallelization behavior
insideparallel constructs or accelerator routines
	Abegindeclare   enddeclare construct that behaves like putting any global vari-
ables declared inside the construct in a declare clause
	Deﬁning the behavior of additional parallelism constructs in the base langua ges when used
inside a compute construct or accelerator routine
	Optimization directives or clauses, such as an unroll directive or clause
	Extended reductions

	Fortran bindings for all the API routines
	Alinear clause for the loop directive
	Allowing two or more of gang ,worker ,vector , orseq clause on an acc routine
directive
	A single list of all devices of all types, including the host device
	A memory allocation API for speciﬁc types of memory, including device memory, h ost pinned
memory, and uniﬁed memory
	Allowing non-contiguous Fortran array sections as arguments to some Runtime API routines,
such asacc_update_device 
	Bindings to other languages

2 Directives
This chapter describes the syntax and behavior of the OpenACC directiv es In C and C++, Open-
ACC directives are speciﬁed using the #pragma mechanism provided by the language In Fortran,
OpenACC directives are speciﬁed using special comments that are identiﬁe d by a unique sentinel
Compilers will typically ignore OpenACC directives if support is disabled or n ot provided
21 Directive Format
In C and C++, OpenACC directives are speciﬁed with the #pragma mechanism The syntax of an
OpenACC directive is:
#pragma acc directive-name [clause-list ]new-line
Each directive starts with #pragma acc  The remainder of the directive follows the C and C++
conventions for pragmas Whitespace may be used before and after the #; whitespace may be
required to separate words in a directive Preprocessing tokens follow ing the#pragma acc are
subject to macro replacement Directives are case-sensitive
In Fortran, OpenACC directives are speciﬁed in free-form source ﬁ les as
!$acc directive-name [clause-list ]
The comment preﬁx ( !) may appear in any column, but may only be preceded by whitespace (spac es
and tabs) The sentinel ( !$acc ) must appear as a single word, with no intervening whitespace
Line length, whitespace, and continuation rules apply to the directive line In itial directive lines
must have whitespace after the sentinel Continued directive lines must have an ampersand ( &) as
the last nonblank character on the line, prior to any comment placed in the dire ctive Continuation
directive lines must begin with the sentinel (possibly preceded by whitespac e) and may have an
ampersand as the ﬁrst non-whitespace character after the sentinel Comme nts may appear on the
same line as a directive, starting with an exclamation point and extending to the en d of the line If
the ﬁrst nonblank character after the sentinel is an exclamation point, the line is ignored
In Fortran ﬁxed-form source ﬁles, OpenACC directives are speciﬁe d as one of
!$acc directive-name [clause-list ]
c$acc directive-name [clause-list ]
*$acc directive-name [clause-list ]
The sentinel ( !$acc ,c$acc , or*$acc ) must occupy columns 1-5 Fixed form line length,
whitespace, continuation, and column rules apply to the directive line Initial d irective lines must
have a space or zero in column 6, and continuation directive lines must have a character other than
a space or zero in column 6 Comments may appear on the same line as a directive , starting with an
exclamation point on or after column 7 and continuing to the end of the line
In Fortran, directives are case-insensitive Directives cannot be e mbedded within continued state-
ments, and statements must not be embedded within continued directives In this document, free
form is used for all Fortran OpenACC directive examples
Only one directive-name can appear per directive, except that a combined directive name is cons id-
ered a single directive-name 

The order in which clauses appear is not signiﬁcant unless otherwise sp eciﬁed A program must not
depend on the order of evaluation of expressions in clause arguments or on any side effects of the
evaluations (See examples below) Clauses may be repeated unless otherw ise speciﬁed
/triangledownsld /triangledownsld
Examples

	In the following example, the order and number of evaluations of ++i and calls to foo()
andbar() are unspeciﬁed
#pragma acc parallel \
num_gangs(foo(++i)) \
num_workers(bar(++i)) \
async(foo(++i))
{  }
See Section 251 for the parallel construct
	In the following example, if the implementation knows that array is not present in the
current device memory, it may omit calling size() 
#pragma acc update \
device(array[0:size()])
if_present
See Section 2144 for the update directive
/trianglesolid /trianglesolid

22 Conditional Compilation
The_OPENACC macro name is deﬁned to have a value yyyymm where yyyy is the year and mmis
the month designation of the version of the OpenACC directives supported b y the implementation
This macro must be deﬁned by a compiler only when OpenACC directives are enabled The version
described here is 202211
23 Internal Control Variables
An OpenACC implementation acts as if there are internal control variables (IC Vs) that control the
behavior of the program These ICVs are initialized by the implementation, and ma y be given
values through environment variables and through calls to OpenACC API r outines The program
can retrieve values through calls to OpenACC API routines
The ICVs are:
	acc-current-device-type-var - controls which type of device is used
	acc-current-device-num-var - controls which device of the selected type is used
	acc-default-async-var - controls which asynchronous queue is used when none appears in an
async clause

231 Modifying and Retrieving ICV Values
The following table shows environment variables or procedures to modify th e values of the internal
control variables, and procedures to retrieve the values:
ICV Ways to modify values Way to retrieve value
acc-current-device-type-var acc_set_device_type acc_get_device_type
set device_type
init device_type
ACC_DEVICE_TYPE
acc-current-device-num-var acc_set_device_num acc_get_device_num
set device_num
init device_num
ACC_DEVICE_NUM
acc-default-async-var acc_set_default_async acc_get_default_async
set default_async
The initial values are implementation-deﬁned After initial values are assigned , but before any
OpenACC construct or API routine is executed, the values of any enviro nment variables that were
set by the user are read and the associated ICVs are modiﬁed according ly There is one copy of
each ICV for each host thread that is not generated by a compute constr uct For threads that are
generated by a compute construct the initial value for each ICV is inherited f rom the local thread
The behavior for each ICV is as if there is a copy for each thread If an ICV is modiﬁed, then a
unique copy of that ICV must be created for the modifying thread
24 Device-Speciﬁc Clauses
OpenACC directives can specify different clauses or clause argumen ts for different devices using
thedevice_type clause Clauses that precede any device_type clause are default clauses 
Clauses that follow a device_type clause up to the end of the directive or up to the next
device_type clause are device-speciﬁc clauses for the device types speciﬁed in the device_type
argument For each directive, only certain clauses may be device-speciﬁ c clauses If a directive has
at least one device-speciﬁc clause, it is device-dependent , and otherwise it is device-independent 
The argument to the device_type clause is a comma-separated list of one or more device ar-
chitecture name identiﬁers, or an asterisk An asterisk indicates all device ty pes that are not named
in any other device_type clause on that directive A single directive may have one or several
device_type clauses The device_type clauses may appear in any order
Except where otherwise noted, the rest of this document describes dev ice-independent directives, on
which all clauses apply when compiling for any device type When compiling a d evice-dependent
directive for a particular device type, the directive is treated as if the only c lauses that appear are (a)
the clauses speciﬁc to that device type and (b) all default clauses for wh ich there are no like-named
clauses speciﬁc to that device type If, for any device type, the resulting directive is nonconforming,
then the original directive is nonconforming
The supported device types are implementation-deﬁned Depending on the imp lementation and the
compiling environment, an implementation may support only a single device type, or may support
multiple device types but only one at a time, or may support multiple device types in a single
compilation

A device architecture name may be generic, such as a vendor, or more spe ciﬁc, such as a partic-
ular generation of device; see Appendix A Recommendations for Implementer s for recommended
names When compiling for a particular device, the implementation will use the claus es associated
with thedevice_type clause that speciﬁes the most speciﬁc architecture name that applies for
this device; clauses associated with any other device_type clause are ignored In this context,
the asterisk is the least speciﬁc architecture name
Syntax
The syntax of the device_type clause is
device_type( *)
device_type( device-type-list )

Thedevice_type clause may be abbreviated to dtype 
/triangledownsld /triangledownsld
Examples

	On the following directive, worker appears as a device-speciﬁc clause for devices of type
foo, butgang appears as a default clause and so applies to all device types, including foo
#pragma acc loop gang device_type(foo) worker
	The ﬁrst directive below is identical to the previous directive except that loop is replaced
withroutine  Unlikeloop ,routine does not permit gang to appear with worker ,
but both apply for device type foo, so the directive is nonconforming The second directive
below is conforming because gang there applies to all device types except foo
// nonconforming: gang and worker not permitted together
#pragma acc routine gang device_type(foo) worker

// conforming: gang and worker for different device types
#pragma acc routine device_type(foo) worker \
device_type( *) gang
	On the directive below, the value of num_gangs is4for device type foo, but it is2for all
other device types, including bar That is,foo has a device-speciﬁc num_gangs clause,
so the default num_gangs clause does not apply to foo
!$acc parallel num_gangs(2) &
!$acc device_type(foo) num_gangs(4) &
!$acc device_type(bar) num_workers(8)
	The directive below is the same as the previous directive except that num_gangs(2) has
moved after device_type( *)and so now does not apply to foo orbar
!$acc parallel device_type( *) num_gangs(2) &
!$acc device_type(foo) num_gangs(4) &
!$acc device_type(bar) num_workers(8)
/trianglesolid /trianglesolid


25 Compute Constructs
Compute constructs indicate code that should be executed on the current d evice It is implementa-
tion deﬁned how users specify for which accelerators that code is compile d and whether it is also
compiled for the host
251 Parallel Construct
Summary
This fundamental construct starts parallel execution on the current dev ice
Syntax
In C and C++, the syntax of the OpenACC parallel construct is
#pragma acc parallel [clause-list ]new-line
structured block

and in Fortran, the syntax is
!$acc parallel [clause-list ]
structured block
!$acc end parallel
or
!$acc parallel [clause-list ]
block construct
[!$acc end parallel ]
where clause is one of the following:
async [(int-expr)]
wait [(int-expr-list )]
num_gangs( int-expr-list )
num_workers( int-expr)
vector_length( int-expr)
device_type( device-type-list )
if( condition)
self [(condition)]
reduction( operator:var-list)
copy( var-list)
copyin( [readonly: ]var-list)
copyout( [zero: ]var-list)
create( [zero: ]var-list)
no_create( var-list)
present( var-list)
deviceptr( var-list)
attach( var-list)
private( var-list)
firstprivate( var-list)
default( none | present )

Description
When the program encounters an accelerator parallel construct, one or more gangs of workers
are created to execute the accelerator parallel region The number of ga ngs, and the number of
workers in each gang and the number of vector lanes per worker remain c onstant for the duration of
that parallel region Each gang begins executing the code in the structure d block in gang-redundant
mode even if there is only a single gang This means that code within the parallel region, but outside
of a loop construct with gang-level worksharing, will be executed redu ndantly by all gangs
One worker in each gang begins executing the code in the structured block of the construct Note:
Unless there is a loop construct within the parallel region, all gangs will execute all the code within
the region redundantly
If theasync clause does not appear, there is an implicit barrier at the end of the accele rator parallel
region, and the execution of the local thread will not proceed until all gan gs have reached the end
of the parallel region
Thecopy ,copyin ,copyout ,create ,no_create ,present ,deviceptr , andattach
data clauses are described in Section 27 Data Clauses The private andfirstprivate
clauses are described in Sections 2513 and Sections 2514 The device_type clause is de-
scribed in Section 24 Device-Speciﬁc Clauses Implicitly determined data attribu tes are described
in Section 262 Restrictions are described in Section 254
252 Serial Construct
Summary
This construct deﬁnes a region of the program that is to be executed seq uentially on the current
device The behavior of the serial construct is the same as that of the parallel construct
except that it always executes with a single gang of a single worker with a v ector length of one
Note: Theserial construct may be used to execute sequential code on the current device ,
which removes the need for data movement when the required data is already present on the device
Syntax
In C and C++, the syntax of the OpenACC serial construct is
#pragma acc serial [clause-list ]new-line
structured block

and in Fortran, the syntax is
!$acc serial [clause-list ]
structured block
!$acc end serial
or
!$acc serial [clause-list ]
block construct
[!$acc end serial ]
where clause is as for the parallel construct except that the num_gangs ,num_workers , and
vector_length clauses are not permitted

253 Kernels Construct
Summary
This construct deﬁnes a region of the program that is to be compiled into a se quence of kernels for
execution on the current device
Syntax
In C and C++, the syntax of the OpenACC kernels construct is
#pragma acc kernels [clause-list ]new-line
structured block

and in Fortran, the syntax is
!$acc kernels [clause-list ]
structured block
!$acc end kernels
or
!$acc kernels [clause-list ]
block construct
[!$acc end kernels ]
where clause is one of the following:
async [(int-expr)]
wait [(int-expr-list )]
num_gangs( int-expr)
num_workers( int-expr)
vector_length( int-expr)
device_type( device-type-list )
if( condition)
self [(condition)]
copy( var-list)
copyin( [readonly: ]var-list)
copyout( [zero: ]var-list)
create( [zero: ]var-list)
no_create( var-list)
present( var-list)
deviceptr( var-list)
attach( var-list)
default( none | present )
Description
The compiler will split the code in the kernels region into a sequence of accele rator kernels Typi-
cally, each loop nest will be a distinct kernel When the program encounte rs akernels construct,
it will launch the sequence of kernels in order on the device The number a nd conﬁguration of gangs
of workers and vector length may be different for each kernel

If theasync clause does not appear, there is an implicit barrier at the end of the kerne ls region,
and the local thread execution will not proceed until the entire sequence o f kernels has completed
execution
Thecopy ,copyin ,copyout ,create ,no_create ,present ,deviceptr , andattach
data clauses are described in Section 27 Data Clauses The device_type clause is described
in Section 24 Device-Speciﬁc Clauses Implicitly determined data attributes are d escribed in Sec-
tion 262 Restrictions are described in Section 254
254 Compute Construct Restrictions
The following restrictions apply to all compute constructs:
	A program may not branch into or out of a compute construct
	Only theasync ,wait ,num_gangs ,num_workers , andvector_length clauses
may follow a device_type clause
	At most one ifclause may appear In Fortran, the condition must evaluate to a scalar logica l
value; in C or C++, the condition must evaluate to a scalar integer value
	At most one default clause may appear, and it must have a value of either none or
present 
	Areduction clause may not appear on a parallel construct with a num_gangs clause
that has more than one argument
255 Compute Construct Errors
	Anacc_error_wrong_device_type error is issued if the compute construct was not
compiled for the current device type This includes the case when the curr ent device is the
host multicore
	Anacc_error_device_type_unavailable error is issued if no device of the cur-
rent device type is available
	Anacc_error_device_unavailable error is issued if the current device is not avail-
able
	Anacc_error_device_init error is issued if the current device cannot be initialized
	Anacc_error_execution error is issued if the execution of the compute construct on
the current device type fails and the failure can be detected
	Explicit or implicitly determined data attributes can cause an error to be issued; s ee Sec-
tion 273
	Anasync orwait clause can cause an error to be issued; see Sections 2161 and 2162
See Section 522
256 if clause
Theifclause is optional

When the condition in theifclause evaluates to true, the region will execute on the current device
When the condition in theifclause evaluates to false , the local thread will execute the region
257 self clause
Theself clause is optional
Theself clause may have a single condition-argument  If the condition-argument is not present it
is assumed to evaluate to true When both an ifclause and a self clause appear and the condition
in theifclause evaluates to false , theself clause has no effect
When the condition evaluates to true, the region will execute on the local device When the condition
in theself clause evaluates to false , the region will execute on the current device
258 async clause
Theasync clause is optional; see Section 216 Asynchronous Behavior for more info rmation
259 wait clause
Thewait clause is optional; see Section 216 Asynchronous Behavior for more infor mation
2510 num gangs clause
Thenum_gangs clause is allowed on the parallel andkernels constructs On a parallel
construct, it may have one, two, or three arguments The values of the integ er expressions deﬁne
the number of parallel gangs along dimensions one, two, and three that will e xecute the parallel
region If it has fewer than three arguments, the missing values are treated as having the value 1
The total number of gangs must be at least 1 and is the product of the value s of the arguments On a
kernels construct, the num_gangs clause must have a single argument, the value of which will
deﬁne the number of parallel gangs that will execute each kernel create d for the kernels region
If thenum_gangs clause does not appear, an implementation-deﬁned default will be used wh ich
may depend on the code within the construct The implementation may use a lower va lue than
speciﬁed based on limitations imposed by the target architecture
2511 num workers clause
Thenum_workers clause is allowed on the parallel andkernels constructs The value
of the integer expression deﬁnes the number of workers within each gang that will be active after
a gang transitions from worker-single mode to worker-partitioned mode If the clause does not
appear, an implementation-deﬁned default will be used; the default value ma y be 1, and may be
different for each parallel construct or for each kernel created for a kernels construct The
implementation may use a different value than speciﬁed based on limitations imposed by the target
architecture
2512 vector length clause
Thevector_length clause is allowed on the parallel andkernels constructs The value
of the integer expression deﬁnes the number of vector lanes that will be ac tive after a worker transi-
tions from vector-single mode to vector-partitioned mode This clause determin es the vector length
to use for vector or SIMD operations If the clause does not appear, a n implementation-deﬁned

default will be used This vector length will be used for loop constructs an notated with the vector
clause, as well as loops automatically vectorized by the compiler The implementatio n may use a
different value than speciﬁed based on limitations imposed by the target arch itecture
2513 private clause
Theprivate clause is allowed on the parallel andserial constructs; it declares that a copy
of each item on the list will be created for each gang in all dimensions
Restrictions
	See Section 2171 Optional Arguments for discussion of Fortran optional a rguments in private
clauses
2514 ﬁrstprivate clause
Thefirstprivate clause is allowed on the parallel andserial constructs; it declares that
a copy of each item on the list will be created for each gang, and that the co py will be initialized with
the value of that item on the local thread when a parallel orserial construct is encountered
Restrictions
	See Section 2171 Optional Arguments for discussion of Fortran optional a rguments in
firstprivate clauses
2515 reduction clause
Thereduction clause is allowed on the parallel andserial constructs It speciﬁes a
reduction operator and one or more vars It implies copy clauses as described in Section 262 For
each reduction var, a private copy is created for each parallel gang and initialized for that o perator
At the end of the region, the values for each gang are combined using the r eduction operator, and
the result combined with the value of the original varand stored in the original var If the reduction
varis an array or subarray, the array reduction operation is logically equiv alent to applying that
reduction operation to each element of the array or subarray individually  If the reduction var
is a composite variable, the reduction operation is logically equivalent to apply ing that reduction
operation to each member of the composite variable individually The reduction result is available
after the region
The following table lists the operators that are valid and the initialization values; in each case, the
initialization value will be cast into the data type of the var Formax andmin reductions, the
initialization values are the least representable value and the largest repre sentable value for that data
type, respectively At a minimum, the supported data types include Fortran logical as well as
the numerical data types in C (eg, _Bool ,char ,int,float ,double ,float _Complex ,
double _Complex ), C++ (eg, bool ,char ,wchar_t ,int,float ,double ), and Fortran
(eg,integer ,real ,doubleprecision ,complex ) However, for each reduction operator,
the supported data types include only the types permitted as operands to the co rresponding operator
in the base language where (1) for max and min, the corresponding opera tor is less-than and (2) for
other operators, the operands and the result are the same type

C and C++ Fortran
operator initialization
valueoperator initialization
value
+ 0 +
* 1 *
max least max least
min largest min largest
& ˜0 iand all bits on
| 0 ior
ˆ 0 ieor
&& 1 and true
|| 0 or false
eqv true
neqv false
Restrictions
	Avarin areduction clause must be a scalar variable name, an aggregate variable name,
an array element, or a subarray (refer to Section 271)
	If the reduction varis an array element or a subarray, accessing the elements of the array
outside the speciﬁed index range results in unspeciﬁed behavior
	The reduction varmay not be a member of a composite variable
	If the reduction varis a composite variable, each member of the composite variable must be
a supported datatype for the reduction operation
	See Section 2171 Optional Arguments for discussion of Fortran optional a rguments in
reduction clauses
2516 default clause
Thedefault clause is optional At most one default clause may appear It adjusts what
data attributes are implicitly determined for variables used in the compute construc t as described in
Section 262
26 Data Environment
This section describes the data attributes for variables The data attributes f or a variable may be
predetermined ,implicitly determined , orexplicitly determined  Variables with predetermined data
attributes may not appear in a data clause that conﬂicts with that data attribute V ariables with
implicitly determined data attributes may appear in a data clause that overrides the imp licit attribute
Variables with explicitly determined data attributes are those which appear in a da ta clause on a
data construct, a compute construct, or a declare directive See Section A33 for recommended
diagnostics related to data attributes
OpenACC supports systems with accelerators that have discrete memory fro m the host, systems
with accelerators that share memory with the host, as well as systems where an accelerator shares
some memory with the host but also has some discrete memory that is not shared w ith the host
In the ﬁrst case, no data is in shared memory In the second case, all data is in shared memory
In the third case, some data may be in shared memory and some data may be in discr ete memory,

although a single array or aggregate data structure must be allocated comple tely in shared or discrete
memory When a nested OpenACC construct is executed on the device, the d efault target device for
that construct is the same device on which the encountering accelerator thr ead is executing In that
case, the target device shares memory with the encountering thread
261 Variables with Predetermined Data Attributes
The loop variable in a C for statement or Fortran dostatement that is associated with a loop
directive is predetermined to be private to each thread that will execute eac h iteration of the loop
Loop variables in Fortran dostatements within a compute construct are predetermined to be private
to the thread that executes the loop
Variables declared in a C block or Fortran block construct that is execute d in vector-partitioned
mode are private to the thread associated with each vector lane Variables d eclared in a C block
or Fortran block construct that is executed in worker-partitioned vector-single mode are private to
the worker and shared across the threads associated with the vector lane s of that worker Variables
declared in a C block or Fortran block construct that is executed in worker-single mode are private
to the gang and shared across the threads associated with the workers an d vector lanes of that gang
A procedure called from a compute construct will be annotated as seq,vector ,worker , or
gang , as described Section 215 Procedure Calls in Compute Regions Variables declared in seq
routine are private to the thread that made the call Variables declared in vector routine are private
to the worker that made the call and shared across the threads associated with the vector lanes of
that worker Variables declared in worker organg routine are private to the gang that made the
call and shared across the threads associated with the workers and vec tor lanes of that gang
262 Variables with Implicitly Determined Data Attributes
When implicitly determining data attributes on a compute construct, the following claus es are visi-
ble and variable accesses are exposed to the compute construct:
	Visibledefault clause : The nearest default clause appearing on the compute construct
or a lexically containing data construct
	Visible data clause : Any data clause on the compute construct, a lexically containing data
construct, or a visible declare directive
	Exposed variable access : Any access to the data or address of a variable at a point within the
compute construct where the variable is not private to a scope lexically enc losed within the
compute construct
Note: In the argument of C’s sizeof operator, the appearance of a variable is not an exposed
access because neither its data nor its address is accessed In the argu ment of areduction
clause on an enclosed loop construct, the appearance of a variable that is not otherwise
privatized is an exposed access to the original variable
On a compute or combined construct, if a variable appears in a reduction clause but no other
data clause, it is treated as if it also appears in a copy clause Otherwise, for any variable, the
compiler will implicitly determine its data attribute on a compute construct if all of the follo wing
conditions are met:
	There is no default(none) clause visible at the compute construct

	An access to the variable is exposed to the compute construct
	The variable does not appear in a data clause visible at the compute constru ct
An aggregate variable will be treated as if it appears either:
	In apresent clause if there is a default(present) clause visible at the compute con-
struct
	In acopy clause otherwise
A scalar variable will be treated as if it appears either:
	In acopy clause if the compute construct is a kernels construct
	In afirstprivate clause otherwise
Note: Anydefault(none) clause visible at the compute construct applies to both aggregate
and scalar variables However, any default(present) clause visible at the compute construct
applies only to aggregate variables
Restrictions
	If there is a default(none) clause visible at a compute construct, for any variable access
exposed to the compute construct, the compiler requires the variable to appea r either in an
explicit data clause visible at the compute construct or in a firstprivate ,private , or
reduction clause on the compute construct
	If a scalar variable appears in a reduction clause on a loop construct that has a parent
parallel orserial construct, and if the reduction’s access to the original variable is
exposed to the parent compute construct, the variable must appear either in an explicit data
clause visible at the compute construct or in a firstprivate ,private , orreduction
clause on the compute construct Note: Implementations are encouraged to issue a compile-
time diagnostic when this restriction is violated to assist users in writing portable Op enACC
applications
If a C++ lambda is called in a compute region and does not appear in a data clause, then it is
treated as if it appears in a copyin clause on the current construct A variable captured by a
lambda is processed according to its data types: a pointer type variable is treated as if it appears
in ano_create clause; a reference type variable is treated as if it appears in a present clause;
for a struct or a class type variable, any pointer member is treated as if it app ears in ano_create
clause on the current construct If the variable is deﬁned as global or ﬁ le or function static, it must
appear in a declare directive
263 Data Regions and Data Lifetimes
Data in shared memory is accessible from the current device as well as to the local thread Such
data is available to the accelerator for the lifetime of the variable Data not in sha red memory must
be copied to and from device memory using data constructs, clauses, and A PI routines A data
lifetime is the duration from when the data is ﬁrst made available to the accelerator until it becomes
unavailable For data in shared memory, the data lifetime begins when the data is a llocated and
ends when it is deallocated; for statically allocated data, the data lifetime begins w hen the program
begins and does not end For data not in shared memory, the data lifetime beg ins when it is made
present and ends when it is no longer present

There are four types of data regions When the program encounters a data construct, it creates a
data region
When the program encounters a compute construct with explicit data clause s or with implicit data
allocation added by the compiler, it creates a data region that has a duration o f the compute construct
When the program enters a procedure, it creates an implicit data region tha t has a duration of the
procedure That is, the implicit data region is created when the procedure is called, and exited when
the program returns from that procedure invocation There is also an imp licit data region associated
with the execution of the program itself The implicit program data region has a duration of the
execution of the program
In addition to data regions, a program may create and delete data on the acce lerator using enter
data andexit data directives or using runtime API routines When the program executes
anenter data directive, or executes a call to a runtime API acc_copyin oracc_create
routine, each varon the directive or the variable on the runtime API argument list will be made live
on accelerator
264 Data Structures with Pointers
This section describes the behavior of data structures that contain pointer s A pointer may be a
C or C++ pointer (eg, float*), a Fortran pointer or array pointer (eg, real, pointer,
dimension(:) ), or a Fortran allocatable (eg, real,allocatable,dimension(:) )
When a data object is copied to device memory, the values are copied exactly If the data is a data
structure that includes a pointer, or is just a pointer, the pointer value copie d to device memory
will be the host pointer value If the pointer target object is also allocated in o r copied to device
memory, the pointer itself needs to be updated with the device address of the tar get object before
dereferencing the pointer in device memory
Anattach action updates the pointer in device memory to point to the device copy of the data
that the host pointer targets; see Section 272 For Fortran array pointer s and allocatable arrays,
this includes copying any associated descriptor (dope vector) to the devic e copy of the pointer
When the device pointer target is deallocated, the pointer in device memory sho uld be restored
to the host value, so it can be safely copied back to host memory A detach action updates the
pointer in device memory to have the same value as the corresponding pointer in lo cal memory;
see Section 272 The attach anddetach actions are performed by the copy ,copyin ,copyout ,
create ,attach , anddetach data clauses (Sections 274-2713), and the acc_attach and
acc_detach runtime API routines (Section 3229) The attach anddetach actions use attachment
counters to determine when the pointer in device memory needs to be updated; s ee Section 268
265 Data Construct
Summary
Thedata construct deﬁnes vars to be allocated in the current device memory for the duration of
the region, whether data should be copied from local memory to the current device memory upon
region entry, and copied from device memory to local memory upon region ex it
Syntax
In C and C++, the syntax of the OpenACC data construct is

#pragma acc data [clause-list ]new-line
structured block
and in Fortran, the syntax is
!$acc data [clause-list ]
structured block
!$acc end data
or
!$acc data [clause-list ]
block construct
[!$acc end data ]
where clause is one of the following:
if( condition)
async [(int-expr)]
wait [(wait-argument )]
device_type( device-type-list )
copy( var-list)
copyin( [readonly: ]var-list)
copyout([zero:] var-list)
create([zero:] var-list)
no_create( var-list)
present( var-list)
deviceptr( var-list)
attach( var-list)
default( none | present )
Description
Data will be allocated in the memory of the current device and copied from loca l memory to device
memory, or copied back, as required The data clauses are described in Section 27 Data Clauses
Structured reference counters are incremented for data when entering a data region, and decre-
mented when leaving the region, as described in Section 267 Reference Co unters The device_type
clause is described in Section 24 Device-Speciﬁc Clauses
Restrictions
	At least one copy ,copyin ,copyout ,create ,no_create ,present ,deviceptr ,
attach , ordefault clause must appear on a data construct
	Only theasync andwait clauses may follow a device_type clause
if clause
Theifclause is optional; when there is no ifclause, the compiler will generate code to allocate
space in the current device memory and move data from and to the local memory a s required When
anifclause appears, the program will conditionally allocate memory in and move data to and/or
from device memory When the condition in theifclause evaluates to false , no device memory
will be allocated, and no data will be moved When the condition evaluates to true, the data will be
allocated and moved as speciﬁed At most one ifclause may appear

async clause
Theasync clause is optional; see Section 216 Asynchronous Behavior for more info rmation
Note: Theasync clause only affects operations directly associated with this particular data con-
struct, such as data transfers Execution of the associated structured b lock or block construct remains
synchronous to the local thread Nested OpenACC constructs, directiv es, and calls to runtime li-
brary routines do not inherit the async clause from this construct, and the programmer must take
care to not accidentally introduce race conditions related to asynchronou s data transfers
wait clause
Thewait clause is optional; see Section 216 Asynchronous Behavior for more infor mation
default clause
Thedefault clause is optional At most one default clause may appear It adjusts what data
attributes are implicitly determined for variables used in lexically contained compute constructs as
described in Section 262
Errors
	See Section 273 for errors due to data clauses
	See Sections 2161 and 2162 for errors due to async orwait clauses
266 Enter Data and Exit Data Directives
Summary
Anenterdata directive may be used to deﬁne vars to be allocated in the current device memory
for the remaining duration of the program, or until an exitdata directive that deallocates the data
They also tell whether data should be copied from local memory to device memor y at theenter
data directive, and copied from device memory to local memory at the exitdata directive The
dynamic range of the program between the enterdata directive and the matching exitdata
directive is the data lifetime for that data
Syntax
In C and C++, the syntax of the OpenACC enterdata directive is
#pragma acc enter data clause-list new-line
and in Fortran, the syntax is
!$acc enter data clause-list
where clause is one of the following:
if( condition)
async [(int-expr)]
wait [(wait-argument )]
copyin( var-list)
create( [zero: ]var-list)
attach( var-list)
In C and C++, the syntax of the OpenACC exitdata directive is

#pragma acc exit data clause-list new-line
and in Fortran, the syntax is
!$acc exit data clause-list
where clause is one of the following:
if( condition)
async [(int-expr)]
wait [(wait-argument )]
copyout( var-list)
delete( var-list)
detach( var-list)
finalize
Description
At anenterdata directive, data may be allocated in the current device memory and copied fro m
local memory to device memory This action enters a data lifetime for those vars, and will make
the data available for present clauses on constructs within the data lifetime Dynamic reference
counters are incremented for this data, as described in Section 267 Refer ence Counters Pointers
in device memory may be attached to point to the corresponding device copy of the host pointer
target
At anexitdata directive, data may be copied from device memory to local memory and deal-
located from device memory If no finalize clause appears, dynamic reference counters are
decremented for this data If a finalize clause appears, the dynamic reference counters are set
to zero for this data Pointers in device memory may be detached so as to have the same value as
the original host pointer
The data clauses are described in Section 27 Data Clauses Reference c ounting behavior is de-
scribed in Section 267 Reference Counters
Restrictions
	At least one copyin ,create , orattach clause must appear on an enterdata direc-
tive
	At least one copyout ,delete , ordetach clause must appear on an exitdata direc-
tive
if clause
Theifclause is optional; when there is no ifclause, the compiler will generate code to allocate or
deallocate space in the current device memory and move data from and to loca l memory When an
ifclause appears, the program will conditionally allocate or deallocate device memory and move
data to and/or from device memory When the condition in theifclause evaluates to false , no
device memory will be allocated or deallocated, and no data will be moved When thecondition
evaluates to true, the data will be allocated or deallocated and moved as speciﬁed
async clause
Theasync clause is optional; see Section 216 Asynchronous Behavior for more info rmation

wait clause
Thewait clause is optional; see Section 216 Asynchronous Behavior for more infor mation
ﬁnalize clause
Thefinalize clause is allowed on the exitdata directive and is optional When no finalize
clause appears, the exit data directive will decrement the dynamic reference counters for vars
appearing in copyout anddelete clauses, and will decrement the attachment counters for point-
ers appearing in detach clauses If a finalize clause appears, the exitdata directive will
set the dynamic reference counters to zero for vars appearing in copyout anddelete clauses,
and will set the attachment counters to zero for pointers appearing in detach clauses
Errors
	See Section 273 for errors due to data clauses
	See Sections 2161 and 2162 for errors due to async orwait clauses
267 Reference Counters
When device memory is allocated for data not in shared memory due to data claus es or OpenACC
API routine calls, the OpenACC implementation keeps track of that section of de vice memory and
its relationship to the corresponding data in host memory
Each section of device memory is associated with two reference counters per device, a structured
reference counter and a dynamic reference counter The structured and dynamic reference counters
are used to determine when to allocate or deallocate data in device memory The s tructured reference
counter for a section of memory keeps track of how many nested data region s have been entered for
that data The initial value of the structured reference counter for static d ata in device memory (in a
globaldeclare directive) is one; for all other data, the initial value is zero The dynamic re ference
counter for a section of memory keeps track of how many dynamic data lifetimes a re currently active
in device memory for that section The initial value of the dynamic reference c ounter is zero Data
is considered present if the sum of the structured and dynamic reference counters is greater tha n
zero
A structured reference counter is incremented when entering each data o r compute region that con-
tain an explicit data clause or implicitly-determined data attributes for that section o f memory, and
is decremented when exiting that region A dynamic reference counter is inc remented for each
enterdatacopyin orcreate clause, or each acc_copyin oracc_create API routine
call for that section of memory The dynamic reference counter is decreme nted for each exit
datacopyout ordelete clause when no finalize clause appears, or each acc_copyout
oracc_delete API routine call for that section of memory The dynamic reference counte r will
be set to zero with an exit data copyout ordelete clause when a finalize clause ap-
pears, or each acc_copyout_finalize oracc_delete_finalize API routine call for
the section of memory The reference counters are modiﬁed synchronou sly with the local thread,
even if the data directives include an async clause When both structured and dynamic reference
counters reach zero, the data lifetime in device memory for that data ends
268 Attachment Counter
Since multiple pointers can target the same address, each pointer in device memo ry is associated
with an attachment counter per device The attachment counter for a pointer is initialized to zero

when the pointer is allocated in device memory The attachment counter for a pointer is set to one
whenever the pointer is attached to new target address, and incremented whenever an attach action
for that pointer is performed for the same target address The attachment counter is decremented
whenever a detach action occurs for the pointer, and the pointer is detached when the attachment
counter reaches zero This is described in more detail in Section 272 Data Clause Ac tions
A pointer in device memory can be assigned a device address in two ways Th e pointer can be
attached to a device address due to data clauses or API routines, as desc ribed in Section 27
Data Clause Actions, or the pointer can be assigned in a compute region exec uted on that device
Unspeciﬁed behavior may result if both ways are used for the same pointer 
Pointer members of structs, classes, or derived types in device or host me mory can be overwritten
due to update directives or API routines It is the user’s responsibility to e nsure that the pointers
have the appropriate values before or after the data movement in either dire ction The behavior of
the program is undeﬁned if any of the pointer members are attached when an update of a composite
variable is performed
27 Data Clauses
Data clauses may appear on the parallel construct,serial construct,kernels construct,
data construct, the enter data andexit data directives, and declare directives In the
descriptions, the region is a compute region with a clause appearing on a parallel ,serial , or
kernels construct, a data region with a clause on a data construct, or an implicit data region
with a clause on a declare directive If the declare directive appears in a global context,
the corresponding implicit data region has a duration of the program The list argument to each
data clause is a comma-separated collection of vars On adeclare directive, the list argument
of acopyin ,create ,device_resident , orlink clause may include a Fortran common
block name enclosed within slashes On any directive, for any clause except deviceptr and
present , the list argument may include a Fortran common block name enclosed within slashes
if that common block name also appears in a declare directivelink clause In all cases, the
compiler will allocate and manage a copy of the varin the memory of the current device, creating a
visible device copy of that var, for data not in shared memory
OpenACC supports accelerators with discrete memories from the local threa d However, if the
accelerator can access the local memory directly, the implementation may avoid the memory allo-
cation and data movement and simply share the data in local memory Therefore , a program that
uses and assigns data on the host and uses and assigns the same data on th e accelerator within a
data region without update directives to manage the coherence of the two co pies may get different
answers on different accelerators or implementations
Restrictions
	Data clauses may not follow a device_type clause
	See Section 2171 Optional Arguments for discussion of Fortran optional a rguments in data
clauses
271 Data Speciﬁcation in Data Clauses
In C and C++, a subarray is an array name followed by an extended arra y range speciﬁcation in
brackets, with start and length, such as
AA[2:n]

If the lower bound is missing, zero is used If the length is missing and the arra y has known size, the
size of the array is used; otherwise the length is required The subarray AA[2:n] means elements
AA[2] ,AA[3] ,    ,AA[2+n-1] 
In C and C++, a two dimensional array may be declared in at least four way s:
	Statically-sized array: float AA[100][200];
	Pointer to statically sized rows: typedef float row[200]; row *BB;
	Statically-sized array of pointers: float*CC[200];
	Pointer to pointers: float**DD;
Each dimension may be statically sized, or a pointer to dynamically allocated memory Each of
these may be included in a data clause using subarray notation to specify a re ctangular array:
	AA[2:n][0:200]
	BB[2:n][0:m]
	CC[2:n][0:m]
	DD[2:n][0:m]
Multidimensional rectangular subarrays in C and C++ may be speciﬁed for a ny array with any com-
bination of statically-sized or dynamically-allocated dimensions For statically siz ed dimensions, all
dimensions except the ﬁrst must specify the whole extent to preserve the c ontiguous data restriction,
discussed below For dynamically allocated dimensions, the implementation will alloc ate pointers
in device memory corresponding to the pointers in local memory and will ﬁll in thos e pointers as
appropriate
In Fortran, a subarray is an array name followed by a comma-separated lis t of range speciﬁcations
in parentheses, with lower and upper bound subscripts, such as
arr(1:high,low:100)
If either the lower or upper bounds are missing, the declared or allocated b ounds of the array, if
known, are used All dimensions except the last must specify the whole ex tent, to preserve the
contiguous data restriction, discussed below
Restrictions
	In Fortran, the upper bound for the last dimension of an assumed-size du mmy array must be
speciﬁed
	In C and C++, the length for dynamically allocated dimensions of an array must be explicitly
speciﬁed
	In C and C++, modifying pointers in pointer arrays during the data lifetime, eithe r on the host
or on the device, may result in undeﬁned behavior
	If a subarray appears in a data clause, the implementation may choose to alloca te memory for
only that subarray on the accelerator
	In Fortran, array pointers may appear, but pointer association is not pr eserved in device mem-
ory

	Any array or subarray in a data clause, including Fortran array pointer s, must be a contiguous
section of memory, except for dynamic multidimensional C arrays
	In C and C++, if a variable or array of composite type appears, all the data members of the
struct or class are allocated and copied, as appropriate If a composite me mber is a pointer
type, the data addressed by that pointer are not implicitly copied
	In Fortran, if a variable or array of composite type appears, all the member s of that derived
type are allocated and copied, as appropriate If any member has the allocatable or
pointer attribute, the data accessed through that member are not copied
	If an expression is used in a subscript or subarray expression in a cla use on adata construct,
the same value is used when copying data at the end of the data region, even if the values of
variables in the expression change during the data region
272 Data Clause Actions
Most of the data clauses perform one or more the following actions The ac tions test or modify one
or both of the structured and dynamic reference counters, depending o n the directive on which the
data clause appears
Present Increment Action
Apresent increment action is one of the actions that may be performed for a present (Sec-
tion 275), copy (Section 276), copyin (Section 277), copyout (Section 278), create
(Section 279), or no_create (Section 2710) clause, or for a call to an acc_copyin or
acc_create (Section 3218) API routine See those sections for details
Apresent increment action for a varoccurs only when varis already present in device memory
Apresent increment action for a varincrements the structured or dynamic reference counter for var
Present Decrement Action
Apresent decrement action is one of the actions that may be performed for a present (Section
275),copy (Section 276), copyin (Section 277), copyout (Section 278), create (Sec-
tion 279), no_create (Section 2710), or delete (Section 2711) clause, or for a call to an
acc_copyout oracc_delete (Section 3219) API routine See those sections for details
Apresent decrement action for a varoccurs only when varis already present in device memory
Apresent decrement action for a vardecrements the structured or dynamic reference counter for
var, if its value is greater than zero If the device memory associated with varwas mapped to
the device using acc_map_data , the dynamic reference count may not be decremented to zero,
except by a call to acc_unmap_data  If the reference counter is already zero, its value is left
unchanged
Create Action
Acreate action is one of the actions that may be performed for a copyout (Section 278) or
create (Section 279) clause, or for a call to an acc_create API routine (Section 3218) See
those sections for details

Acreate action for a varoccurs only when varis not already present in device memory
Acreate action for a var:
	allocates device memory for var; and
	sets the structured or dynamic reference counter to one
Copyin Action
Acopyin action is one of the actions that may be performed for a copy (Section 276) or copyin
(Section 277) clause, or for a call to an acc_copyin API routine (Section 3218) See those
sections for details
Acopyin action for a varoccurs only when varis not already present in device memory
Acopyin action for a var:
	allocates device memory for var;
	initiates a copy of the data for varfrom the local thread memory to the corresponding device
memory; and
	sets the structured or dynamic reference counter to one
The data copy may complete asynchronously, depending on other clauses on the directive
Copyout Action
Acopyout action is one of the actions that may be performed for a copy (Section 276) or
copyout (Section 278) clause, or for a call to an acc_copyout API routine (Section 3219)
See those sections for details
Acopyout action for a varoccurs only when varis present in device memory
Acopyout action for a var:
	performs an immediate detach action for any pointer in var;
	initiates a copy of the data for varfrom device memory to the corresponding local thread
memory; and
	deallocates device memory for var
The data copy may complete asynchronously, depending on other clauses on the directive, in which
case the memory is deallocated when the data copy is complete
Delete Action
Adelete action is one of the actions that may be performed for a present (Section 275),
copyin (Section 277), create (Section 279), no_create (Section 2710), or delete (Sec-
tion 2711) clause, or for a call to an acc_delete API routine (Section 3219) See those sections
for details
Adelete action for a varoccurs only when varis present in device memory
Adelete action for var:

	performs an immediate detach action for any pointer in var; and
	deallocates device memory for var
Attach Action
Anattach action is one of the actions that may be performed for a present (Section 275),
copy (Section 276), copyin (Section 277), copyout (Section 278), create (Section 279),
no_create (Section 2710), or attach (Section 2711) clause, or for a call to an acc_attach
API routine (Section 3229) See those sections for details
Anattach action for a varoccurs only when varis a pointer reference
If the pointer varis in shared memory or is not present in the current device memory, or if the
address to which varpoints is not present in the current device memory, no action is taken If the
attachment counter forvaris nonzero and the pointer in device memory already points to the device
copy of the data in var, the attachment counter for the pointer varis incremented Otherwise, the
pointer in device memory is attached to the device copy of the data by initiating an update for the
pointer in device memory to point to the device copy of the data and setting the attachment counter
for the pointer varto one If the pointer is a null pointer, the pointer in device memory is updated to
have the same value The update may complete asynchronously, depending on other clauses on the
directive The implementation schedules pointer updates after any data copie s due to copyin actions
that are performed for the same directive
Detach Action
Adetach action is one of the actions that may be performed for a present (Section 275),
copy (Section 276), copyin (Section 277), copyout (Section 278), create (Section 279),
no_create (Section 2710), delete (Section 2711), or detach (Section 2711) clause, or
for a call to an acc_detach API routine (Section 3229) See those sections for details
Adetach action for a varoccurs only when varis a pointer reference
If the pointer varis in shared memory or is not present in the current device memory, or if the
attachment counter forvarfor the pointer is zero, no action is taken Otherwise, the attachment
counter for the pointer varis decremented If the attachment counter is decreased to zero, the
pointer is detached by initiating an update for the pointer varin device memory to have the same
value as the corresponding pointer in local memory The update may complete a synchronously,
depending on other clauses on the directive The implementation schedules p ointer updates before
any data copies due to copyout actions that are performed for the same directive
Immediate Detach Action
Animmediate detach action is one of the actions that may be performed for a detach (Section
2711) clause, or for a call to an acc_detach_finalize API routine (Section 3229) See
those sections for details
Animmediate detach action for a varoccurs only when varis a pointer reference and is present in
device memory
If the attachment counter for the pointer is zero, the immediate detach action has no effect Other-
wise, the attachment counter for the pointer set to zero and the pointer is detached by initiating an
update for the pointer in device memory to have the same value as the correspon ding pointer in local

memory The update may complete asynchronously, depending on other clau ses on the directive
The implementation schedules pointer updates before any data copies due to copyout actions that
are performed for the same directive
273 Data Clause Errors
An error is issued for a varthat appears in a copy ,copyin ,copyout ,create , anddelete
clause as follows:
	Anacc_error_partly_present error is issued if part of varis present in the current
device memory but all of varis not
	Anacc_error_invalid_data_section error is issued if varis a Fortran subarray
with a stride that is not one
	Anacc_error_out_of_memory error is issued if the accelerator device does not have
enough memory for var
An error is issued for a varthat appears in a present clause as follows:
	Anacc_error_not_present error is issued if varis not present in the current device
memory at entry to a data or compute construct
	Anacc_error_partly_present error is issued if part of varis present in the current
device memory but all of varis not
See Section 522
274 deviceptr clause
Thedeviceptr clause may appear on structured data and compute constructs and declare
directives
Thedeviceptr clause is used to declare that the pointers in var-list are device pointers, so the
data need not be allocated or moved between the host and device for this po inter
In C and C++, the vars invar-list must be pointer variables
In Fortran, the vars invar-list must be dummy arguments (arrays or scalars), and may not have the
Fortranpointer ,allocatable , orvalue attributes
For data in shared memory, host pointers are the same as device pointers, s o this clause has no
effect
275 present clause
Thepresent clause may appear on structured data and compute constructs and declare di-
rectives The present clause speciﬁes that vars invar-list are in shared memory or are already
present in the current device memory due to data regions or data lifetimes that contain the construct
on which the present clause appears
For each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,
thepresent clause behaves as follows:
	At entry to the region:

		Anattach action is performed if varis a pointer reference, and a present increment
action with the structured reference counter is performed if varis not a null pointer
	At exit from the region:
		If the structured reference counter for varis zero, no action is taken
		Otherwise, a detach action is performed if varis a pointer reference, and a present decrement
action with the structured reference counter is performed if varis not a null pointer If
both structured and dynamic reference counters are zero, a delete action is performed
The errors in Section 273 Data Clause Errors may be issued for this clause 
276 copy clause
Thecopy clause may appear on structured data and compute constructs and on declare direc-
tives
For each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,
thecopy clause behaves as follows:
	At entry to the region:
		Ifvaris present and is not a null pointer, a present increment action with the structured
reference counter is performed
		Ifvaris not present, a copyin action with the structured reference counter is performed
		Ifvaris a pointer reference, an attach action is performed
	At exit from the region:
		If the structured reference counter for varis zero, no action is taken
		Otherwise, a detach action is performed if varis a pointer reference, and a present decrement
action with the structured reference counter is performed if varis not a null pointer If
both structured and dynamic reference counters are zero, a copyout action is performed
The errors in Section 273 Data Clause Errors may be issued for this clause 
For compatibility with OpenACC 20, present_or_copy andpcopy are alternate names for
copy 
277 copyin clause
Thecopyin clause may appear on structured data and compute constructs, on declare direc-
tives, and on enterdata directives
For each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,
thecopyin clause behaves as follows:
	At entry to a region, the structured reference counter is used On an enterdata directive,
the dynamic reference counter is used
		Ifvaris present and is not a null pointer, a present increment action with the appropriate
reference counter is performed

		Ifvaris not present, a copyin action with the appropriate reference counter is performed
		Ifvaris a pointer reference, an attach action is performed
	At exit from the region:
		If the structured reference counter for varis zero, no action is taken
		Otherwise, a detach action is performed if varis a pointer reference, and a present decrement
action with the structured reference counter is performed if varis not a null pointer If
both structured and dynamic reference counters are zero, a delete action is performed
If the optional readonly modiﬁer appears, then the implementation may assume that the data
referenced by var-list is never written to within the applicable region
The errors in Section 273 Data Clause Errors may be issued for this clause 
For compatibility with OpenACC 20, present_or_copyin andpcopyin are alternate names
forcopyin 
Anenterdata directive with a copyin clause is functionally equivalent to a call to the acc_copyin
API routine, as described in Section 3218
278 copyout clause
Thecopyout clause may appear on structured data and compute constructs, on declare di-
rectives, and on exit data directives The clause may optionally have a zero modiﬁer if the
copyout clause appears on a structured data or compute construct
For each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,
thecopyout clause behaves as follows:
	At entry to a region:
		Ifvaris present and is not a null pointer, a present increment action with the structured
reference counter is performed
		Ifvaris not present, a create action with the structured reference counter is performed
If azero modiﬁer appears, the memory is zeroed after the create action
		Ifvaris a pointer reference, an attach action is performed
	At exit from a region, the structured reference counter is used On an exitdata directive,
the dynamic reference counter is used
		If the appropriate reference counter for varis zero, no action is taken
		Otherwise, a detach action is performed if varis a pointer reference, and the reference
counter is updated if var is not a null pointer:
∗On anexit data directive with a finalize clause, the dynamic reference
counter is set to zero
∗Otherwise, a present decrement action with the appropriate reference counter is
performed

If both structured and dynamic reference counters are zero, a copyout action is per-
formed
The errors in Section 273 Data Clause Errors may be issued for this clause 
For compatibility with OpenACC 20, present_or_copyout andpcopyout are alternate
names forcopyout 
Anexitdata directive with a copyout clause and with or without a finalize clause is func-
tionally equivalent to a call to the acc_copyout_finalize oracc_copyout API routine,
respectively, as described in Section 3219
279 create clause
Thecreate clause may appear on structured data and compute constructs, on declare direc-
tives, and on enterdata directives The clause may optionally have a zero modiﬁer
For each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,
thecreate clause behaves as follows:
	At entry to a region, the structured reference counter is used On an enterdata directive,
the dynamic reference counter is used
		Ifvaris present and is not a null pointer, a present increment action with the appropriate
reference counter is performed
		Ifvaris not present and is not a null pointer, a create action with the appropriate refer-
ence counter is performed If a zero modiﬁer appears, the memory is zeroed after the
create action
		Ifvaris a pointer reference, an attach action is performed
	At exit from the region:
		If the structured reference counter for varis zero, no action is taken
		Otherwise, a detach action is performed if varis a pointer reference, and a present decrement
action with the structured reference counter is performed if varis not a null pointer If
both structured and dynamic reference counters are zero, a delete action is performed
The errors in Section 273 Data Clause Errors may be issued for this clause 
For compatibility with OpenACC 20, present_or_create andpcreate are alternate names
forcreate 
Anenterdata directive with a create clause is functionally equivalent to a call to the acc_create
API routine, as described in Section 3218, except the directive may perf orm an attach action for a
pointer reference
2710 no create clause
Theno_create clause may appear on structured data and compute constructs
For each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,
theno_create clause behaves as follows:

	At entry to the region:
		Ifvaris present and is not a null pointer, a present increment action with the structured
reference counter is performed If varis present and is a pointer reference, an attach
action is performed
		Ifvaris not present, no action is performed, and any device code in this constru ct will
use the local memory address for var
	At exit from the region:
		If the structured reference counter for varis zero, no action is taken
		Otherwise, a detach action is performed if varis a pointer reference, and a present decrement
action with the structured reference counter is performed if varis not a null pointer If
both structured and dynamic reference counters are zero, a delete action is performed
2711 delete clause
Thedelete clause may appear on exitdata directives
For each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,
thedelete clause behaves as follows:
	If the dynamic reference counter for varis zero, no action is taken
	Otherwise, a detach action is performed if varis a pointer reference, and the dynamic refer-
ence counter is updated if varis not a null pointer:
		On anexitdata directive with a finalize clause, the dynamic reference counter
is set to zero
		Otherwise, a present decrement action with the dynamic reference counter is performed
Ifvaris a pointer reference, a detach action is performed If both structured and dynamic
reference counters are zero, a delete action is performed
Anexitdata directive with a delete clause and with or without a finalize clause is func-
tionally equivalent to a call to the acc_delete_finalize oracc_delete API routine, re-
spectively, as described in Section 3219
The errors in Section 273 Data Clause Errors may be issued for this clause 
2712 attach clause
Theattach clause may appear on structured data and compute constructs and on enterdata
directives Each varargument to an attach clause must be a C or C++ pointer or a Fortran variable
or array with the pointer orallocatable attribute
For each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,
theattach clause behaves as follows:
	At entry to a region or at an enterdata directive, an attach action is performed
	At exit from the region, a detach action is performed

2713 detach clause
Thedetach clause may appear on exitdata directives Each varargument to a detach clause
must be a C or C++ pointer or a Fortran variable or array with the pointer orallocatable
attribute
For each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,
thedetach clause behaves as follows:
	If there is a finalize clause on the exitdata directive, an immediate detach action is
performed
	Otherwise, a detach action is performed
28 Host Data Construct
Summary
Thehost_data construct makes the address of data in device memory available on the host
Syntax
In C and C++, the syntax of the OpenACC host_data construct is
#pragma acc host_data clause-list new-line
structured block
and in Fortran, the syntax is
!$acc host_data clause-list
structured block
!$acc end host_data
or
!$acc host_data clause-list
block construct
[!$acc end host_data ]
where clause is one of the following:
use_device( var-list)
if( condition)
if_present
Description
This construct is used to make the address of data in device memory available in host code
Restrictions
	Avarin ause_device clause must be the name of a variable or array
	At least one use_device clause must appear
	At most one ifclause may appear In Fortran, the condition must evaluate to a scalar logica l
value; in C or C++, the condition must evaluate to a scalar integer value
	See Section 2171 Optional Arguments for discussion of Fortran optional a rguments in
use_device clauses

281 use device clause
Theuse_device clause tells the compiler to use the current device address of any varinvar-list
in code within the construct In particular, this may be used to pass the device a ddress of varto
optimized procedures written in a lower-level API If varis a null pointer, the same value is used
for the device address Otherwise, when there is no if_present clause, and either there is no
ifclause or the condition in the ifclause evaluates to true, the varinvar-list must be present in
the accelerator memory due to data regions or data lifetimes that contain this cons truct For data in
shared memory, the device address is the same as the host address
282 if clause
Theifclause is optional When an ifclause appears and the condition evaluates to false , the
compiler will not replace the addresses of any varin code within the construct When there is no if
clause, or when an ifclause appears and the condition evaluates to true, the compiler will replace
the addresses as described in the previous subsection
283 if present clause
When anif_present clause appears on the directive, the compiler will only replace the address
of any varwhich appears in var-list that is present in the current device memory
29 Loop Construct
Summary
The OpenACC loop construct applies to a loop which must immediately follow this directive The
loop construct can describe what type of parallelism to use to execute the loop a nd declare private
vars and reduction operations
Syntax
In C and C++, the syntax of the loop construct is
#pragma acc loop [clause-list ]new-line
for loop
In Fortran, the syntax of the loop construct is
!$acc loop [clause-list ]
do loop
where clause is one of the following:
collapse( [force: ]n)
gang [(gang-arg-list )]
worker [([num: ]int-expr)]
vector [([length: ]int-expr)]
seq
independent
auto
tile( size-expr-list )
device_type( device-type-list )

private( var-list)
reduction( operator:var-list)
where gang-arg is one of:
[num: ]int-expr
dim: int-expr
static: size-expr
andgang-arg-list may have at most one num, onedim, and onestatic argument, and where
size-expr is one of:
*
int-expr

Some clauses are only valid in the context of a kernels construct; see the descriptions below
Anorphanedloop construct is a loop construct that is not lexically enclosed within a compute
construct The parent compute construct of a loop construct is the nearest compute construct that
lexically contains the loop construct
Aloop construct is data-independent if it has anindependent clause that is determined explic-
itly, implicitly, or from an auto clause Aloop construct is sequential if it has aseq clause that
is determined explicitly or from an auto clause
When do-loop is adoconcurrent , the OpenACC loop construct applies to the loop for each
index in the concurrent-header  Theloop construct can describe what type of parallelism to use
to execute all the loops, and declares all indices appearing in the concurrent-header to be implicitly
private If the loop construct that is associated with doconcurrent is combined with a compute
construct then concurrent-locality is processed as follows: variables appearing in a local are treated
as appearing in a private clause; variables appearing in a local initare treated as appearing in a
firstprivate clause; variables appearing in a shared are treated as appearing in a copy clause;
and a default(none) locality spec implies a default(none) clause on the compute construct If
theloop construct is not combined with a compute construct, the behavior is implementation -
deﬁned
Restrictions
	Only thecollapse ,gang ,worker ,vector ,seq,independent ,auto , andtile
clauses may follow a device_type clause
	Theint-expr argument to the worker andvector clauses must be invariant in the kernels
region
	A loop associated with a loop construct that does not have a seq clause must be written to
meet all of the following conditions:
		The loop variable must be of integer, C/C++ pointer, or C++ random-acces s iterator
type
		The loop variable must monotonically increase or decrease in the direction of its termi-
nation condition
		The loop trip count must be computable in constant time when entering the loop con-
struct

For a C++ range-based for loop, the loop variable identiﬁed by the above conditions is the
internal iterator, such as a pointer, that the compiler generates to iterate the r ange It is not the
variable declared by the for loop
	Only one of the seq,independent , andauto clauses may appear
	Agang ,worker , orvector clause may not appear if a seq clause appears
	Atile andcollapse clause may not appear on loop that is associated with doconcurrent 
291 collapse clause
Thecollapse clause is used to specify how many nested loops are associated with the loop
construct The argument to the collapse clause must be a constant positive integer expression
If nocollapse clause appears, only the immediately following loop is associated with the loop
construct
If more than one loop is associated with the loop construct, the iterations of all the associated loops
are all scheduled according to the rest of the clauses The trip count fo r all loops associated with
thecollapse clause must be computable and invariant in all the loops The particular intege r
type used to compute the trip count for the collapsed loops is implementation deﬁne d However, the
integer type used for the trip count has at least the precision of each loop variable of the associated
loops
It is implementation-deﬁned whether a gang ,worker orvector clause on the construct is ap-
plied to each loop, or to the linearized iteration space
The associated loops are the nnested loops that immediately follow the loop construct If the
force modiﬁer does not appear, then the associated loops must be tightly nested I f theforce
modiﬁer appears, then any intervening code may be executed multiple times as ne eded to perform
the collapse
Restrictions
	Each associated loop, except the innermost, must contain exactly one loop o r loop nest
	Intervening code must not contain other OpenACC directives or calls to AP I routines
/triangledownsld /triangledownsld
Examples

	In the code below, a compiler may choose to move the call to tan inside the inner loop in
order to collapse the two loops, resulting in redundant execution of the inter vening code
#pragma acc parallel loop collapse(force:2)
{
for ( int i = 0; i < 360; i++ )
{
// This operation may be executed additional times in order
// to perform the forced collapse
tanI = tan(a[i]);
for ( int j = 0; j < N; j++ )
{

// Do Something
}
}
}
/trianglesolid /trianglesolid
292 gang clause
When the parent compute construct is a parallel construct, or on an orphaned loop construct,
thegang clause behaves as follows It speciﬁes that the iterations of the associate d loop or loops
are to be executed in parallel by distributing the iterations among the gangs alon g the associated
dimension created by the compute construct The associated dimension is the va lue of thedim
argument, if it appears, or is dimension one The dim argument must be a constant positive integer
with value 1, 2, or 3 If the associated dimension is d, aloop construct with the gang clause
transitions a compute region from gang-redundant mode to gang-partitione d mode on dimension d
(GRdto GP d) The number of gangs in dimension dis controlled by the parallel construct; the
num argument is not allowed The loop iterations must be data independent, exce pt for vars which
appear in a reduction clause or which are modiﬁed in an atomic region
When the parent compute construct is a kernels construct, the gang clause behaves as follows
It speciﬁes that the iterations of the associated loop or loops are to be exec uted in parallel across the
gangs The dim argument is not allowed An argument with no keyword or with the num keyword
is allowed only when the num_gangs does not appear on the kernels construct If an argument
with no keyword or an argument after the num keyword appears, it speciﬁes how many gangs to use
to execute the iterations of this loop The region of a loop with the gang clause may not contain
another loop with a gang clause unless within a nested compute region
The scheduling of loop iterations to gangs is not speciﬁed unless the static modiﬁer appears as
an argument If the static modiﬁer appears with an integer expression, that expression is used
as a chunk size If the static modiﬁer appears with an asterisk, the implementation will select a
chunk size The iterations are divided into chunks of the selected chunk size, and the chunks are
assigned to gangs starting with gang zero and continuing in round-robin fa shion Two gang loops
in the same parallel region with the same number of iterations, and with static clauses with the
same argument, will assign the iterations to gangs in the same manner Two gang loops in the
same kernels region with the same number of iterations, the same number of gang s to use, and with
static clauses with the same argument, will assign the iterations to gangs in the same manne r
Agang(dim:1) clause is implied on a data-independent loop construct without an explicit
gang clause if the following conditions hold while ignoring gang ,worker , andvector clauses
on any sequential loop constructs:
	Thisloop construct’s parent compute construct, if any, is not a kernels construct
	An explicit gang(dim:1) clause would be permitted on this loop construct
	For every lexically enclosing data-independent loop construct, either an explicit gang(dim:1)
clause would not be permitted on the enclosing loop construct, or the enclosing loop con-
struct lexically encloses a compute construct that lexically encloses this loop construct
Note: As a performance optimization, the implementation might select different levels of paral-
lelism for a loop construct than speciﬁed by explicitly or implicitly determined clauses as long

as it can prove program semantics are preserved In particular, the imple mentation must consider
semantic differences between gang-redundant and gang-partitioned mo de For example, in a series
of tightly nested, data-independent loop constructs, implementations often move gang-partitioning
from oneloop construct to another without affecting semantics
Note: If theauto ordevice_type clause appears on a loop construct, it is the programmer’s
responsibility to ensure that program semantics are the same regardless of whether the auto clause
is treated as independent orseq and regardless of the device type for which the program is
compiled In particular, the programmer must consider the effect on both ex plicitly and implicitly
determined gang clauses and thus on gang-redundant and gang-partitioned mode Examp les in
Section 2911 demonstrate this issue for the auto clause
Restrictions
	At most one gang clause may appear on a loop directive
	The region of a loop with a gang(dim:d) clause may not contain a loop construct with a
gang(dim:e) clause where e >= d unless it appears within a nested compute region
293 worker clause
When the parent compute construct is a parallel construct, or on an orphaned loop construct,
theworker clause speciﬁes that the iterations of the associated loop or loops are to be e xecuted
in parallel by distributing the iterations among the multiple workers within a single gan g Aloop
construct with a worker clause causes a gang to transition from worker-single mode to worker-
partitioned mode In contrast to the gang clause, the worker clause ﬁrst activates additional
worker-level parallelism and then distributes the loop iterations across thos e workers No argu-
ment is allowed The loop iterations must be data independent, except for vars which appear in
areduction clause or which are modiﬁed in an atomic region The region of a loop with the
worker clause may not contain a loop with the gang orworker clause unless within a nested
compute region
When the parent compute construct is a kernels construct, the worker clause speciﬁes that the
iterations of the associated loop or loops are to be executed in parallel acro ss the workers within
a single gang An argument is allowed only when the num_workers does not appear on the
kernels construct The optional argument speciﬁes how many workers per gang to use to execute
the iterations of this loop The region of a loop with the worker clause may not contain a loop
with agang orworker clause unless within a nested compute region
All workers will complete execution of their assigned iterations before any w orker proceeds beyond
the end of the loop
294 vector clause
When the parent compute construct is a parallel construct, or on an orphaned loop construct,
thevector clause speciﬁes that the iterations of the associated loop or loops are to be e xecuted
in vector or SIMD mode A loop construct with a vector clause causes a worker to transition
from vector-single mode to vector-partitioned mode Similar to the worker clause, the vector
clause ﬁrst activates additional vector-level parallelism and then distribu tes the loop iterations across
those vector lanes The operations will execute using vectors of the length speciﬁed or chosen for
the parallel region The loop iterations must be data independent, except f orvars which appear in
areduction clause or which are modiﬁed in an atomic region The region of a loop with the

vector clause may not contain a loop with the gang ,worker , orvector clause unless within
a nested compute region
When the parent compute construct is a kernels construct, the vector clause speciﬁes that the
iterations of the associated loop or loops are to be executed with vector or SI MD processing An
argument is allowed only when the vector_length does not appear on the kernels construct
If an argument appears, the iterations will be processed in vector strips o f that length; if no argument
appears, the implementation will choose an appropriate vector length The re gion of a loop with the
vector clause may not contain a loop with a gang ,worker , orvector clause unless within a
nested compute region
All vector lanes will complete execution of their assigned iterations before an y vector lane proceeds
beyond the end of the loop
295 seq clause
Theseq clause speciﬁes that the associated loop or loops are to be executed sequ entially by the
accelerator This clause will override any automatic parallelization or vector ization
296 independent clause
Theindependent clause tells the implementation that the loop iterations must be data indepen-
dent, except for vars which appear in a reduction clause or which are modiﬁed in an atomic
region This allows the implementation to generate code to execute the iterations in p arallel with no
synchronization
Aloop construct with no auto orseq clause is treated as if it has the independent clause
when it is an orphaned loop construct or its parent compute construct is a parallel construct
Note
	It is likely a programming error to use the independent clause on a loop if any iteration
writes to a variable or array element that any other iteration also writes or rea ds, except for
vars which appear in a reduction clause or which are modiﬁed in an atomic region
	The implementation may be restricted in the levels of parallelism it can apply by the pr esence
ofloop constructs with gang ,worker , orvector clauses for outer or inner loops
297 auto clause
Theauto clause speciﬁes that the implementation must analyze the loop and determine wheth er the
loop iterations are data-independent If it determines that the loop iterations a re data-independent,
the implementation must treat the auto clause as if it is an independent clause If not, or if it
is unable to make a determination, it must treat the auto clause as if it is a seq clause, and it must
ignore anygang ,worker , orvector clauses on the loop construct
When the parent compute construct is a kernels construct, a loop construct with no independent
orseq clause is treated as if it has the auto clause
298 tile clause
Thetile clause speciﬁes that the implementation should split each loop in the loop nest into two
loops, with an outer set of tileloops and an inner set of element loops The argument to the tile

clause is a list of one or more tile sizes, where each tile size is a constant positi ve integer expression
or an asterisk If there are ntile sizes in the list, the loop construct must be immediately followed
byntightly-nested loops The ﬁrst argument in the size-expr-list corresponds to the innermost loop
of the nassociated loops, and the last element corresponds to the outermost asso ciated loop If the
tile size is an asterisk, the implementation will choose an appropriate value Each loop in the nest
will be split or strip-mined into two loops, an outer tileloop and an inner element loop The trip
count of the element loop will be limited to the corresponding tile size from the size-expr-list  The
tileloops will be reordered to be outside all the element loops, and the element loops will all be
inside the tileloops
If thevector clause appears on the loop construct, the vector clause is applied to the element
loops If the gang clause appears on the loop construct, the gang clause is applied to the tile
loops If the worker clause appears on the loop construct, the worker clause is applied to the
element loops if no vector clause appears, and to the tileloops otherwise
299 device type clause
Thedevice_type clause is described in Section 24 Device-Speciﬁc Clauses
2910 private clause
Theprivate clause on a loop construct speciﬁes that a copy of each item in var-list will be
created If the body of the loop is executed in vector-partitioned mode, a copy of the item is created
for each thread associated with each vector lane If the body of the loop is executed in worker-
partitioned vector-single mode, a copy of the item is created for each worker and shared across th e
set of threads associated with all the vector lanes of that worker Otherw ise, a copy of the item is
created for each gang in all dimensions and shared across the set of thr eads associated with all the
vector lanes of all the workers of that gang
Restrictions
	See Section 2171 Optional Arguments for discussion of Fortran optional a rguments in private
clauses
/triangledownsld /triangledownsld
Examples

	In the example below, tmp is private to each worker of every gang but shared across all the
vector lanes of a worker
!$acc parallel
!$acc loop gang
do k = 1, n
!$acc loop worker private(tmp)
do j = 1, n
!a single vector lane in each gang and worker assigns to tmp
tmp = b(j,k) + c(j,k)
!$acc loop vector
do i = 1, n
!all vector lanes use the result of the above update to tmp
a(i,j,k) = a(i,j,k) + tmp/div

enddo
enddo
enddo
!$acc end parallel
	In the example below, tmp is private to each gang in every dimension
!$acc parallel num_gangs(3,50,150)
!$acc loop gang(dim:3)
do k = 1, n
!$acc loop gang(dim:2) private(tmp)
do j = 1, n
!all gangs along dimension 1 execute in gang redundant mode a nd
!assign to tmp which is private to each gang in all dimensions
tmp = b(j,k) + c(j,k)
!$acc loop gang(dim:1)
do i = 1, n
a(i,j,k) = a(i,j,k) + tmp/div
enddo
enddo
enddo
!$acc end parallel
/trianglesolid /trianglesolid
2911 reduction clause
Thereduction clause speciﬁes a reduction operator and one or more vars For each reduction
var, a private copy is created in the same manner as for a private clause on the loop construct,
and initialized for that operator; see the table in Section 2515 reduction claus e After the loop, the
values for each thread are combined using the speciﬁed reduction opera tor, and the result combined
with the value of the original varand stored in the original var If the original varis not private,
this update occurs by the end of the compute region, and any access to the o riginal varis undeﬁned
within the compute region Otherwise, the update occurs at the end of the loop  If the reduction
varis an array or subarray, the reduction operation is logically equivalent to applying that reduction
operation to each array element of the array or subarray individually I f the reduction varis a com-
posite variable, the reduction operation is logically equivalent to applying tha t reduction operation
to each member of the composite variable individually
If a variable is involved in a reduction that spans multiple nested loops where tw o or more of those
loops have associated loop directives, a reduction clause containing that variable must appear
on each of those loop directives
Restrictions
	Avarin areduction clause must be a scalar variable name, an aggregate variable name,
an array element, or a subarray (refer to Section 271)
	Reduction clauses on nested constructs for the same reduction varmust have the same reduc-
tion operator
	Every varin areduction clause appearing on an orphaned loop construct must be private
	The restrictions for a reduction clause on a compute construct listed in in Section 25
reduction clause also apply to a reduction clause on a loop construct

	See Section 2171 Optional Arguments for discussion of Fortran optional a rguments in
reduction clauses
	See Section 262 Variables with Implicitly Determined Data Attributes for a restriction re-
quiring certain loop reduction variables to have explicit data clauses on their parent compute
constructs
	Areduction clause may not appear on a loop directive that has a gang clause with a
dim: argument whose value is greater than 1
	Areduction clause may not appear on a loop directive that has a gang clause and
is within a compute construct that has a num_gangs clause with more than one explicit
argument
/triangledownsld /triangledownsld
Examples

	xis not private at the loop directive below, so its reduction normally updates xat the end
of the parallel region, where gangs synchronize When possible, the imp lementation might
choose to partially update xat the loop exit instead, or fully if num_gangs(1) were added
to theparallel directive However, portable applications cannot rely on such early up -
dates, so accesses to xare undeﬁned within the parallel region outside the loop
int x = 0;
#pragma acc parallel copy(x)
{
// gang-shared x undefined
#pragma acc loop gang worker vector reduction(+:x)
for (int i = 0; i < I; ++i)
x += 1; // vector-private x modified
// gang-shared x undefined
}// gang-shared x updated for gang/worker/vector reduction
// x = I
	xis private at each of the innermost two loop directives below, so each of their reductions
updatesxat the loop’s exit However, xis not private at the outer loop directive, so its
reduction updates xby the end of the parallel region instead
int x = 0;
#pragma acc parallel copy(x)
{
// gang-shared x undefined
#pragma acc loop gang reduction(+:x)
for (int i = 0; i < I; ++i) {
#pragma acc loop worker reduction(+:x)
for (int j = 0; j < J; ++j) {
#pragma acc loop vector reduction(+:x)
for (int k = 0; k < K; ++k) {
x += 1; // vector-private x modified
}// worker-private x updated for vector reduction
}// gang-private x updated for worker reduction
}

// gang-shared x undefined
}// gang-shared x updated for gang reduction
// x = I *J*K
	At eachloop directive below, xis private and yis not private due to the data clauses on
theparallel directive Thus, each reduction updates xat the loop exit, but each reduction
updatesyby the end of the parallel region instead
int x = 0, y = 0;
#pragma acc parallel firstprivate(x) copy(y)
{
// gang-private x = 0; gang-shared y undefined
#pragma acc loop seq reduction(+:x,y)
for (int i = 0; i < I; ++i) {
x += 1; y += 2; // loop-private x and y modified
}// gang-private x updated for trivial seq reduction
// gang-private x = I; gang-shared y undefined
#pragma acc loop worker reduction(+:x,y)
for (int i = 0; i < I; ++i) {
x += 1; y += 2; // worker-private x and y modified
}// gang-private x updated for worker reduction
// gang-private x = 2 *I; gang-shared y undefined
#pragma acc loop vector reduction(+:x,y)
for (int i = 0; i < I; ++i) {
x += 1; y += 2; // vector-private x and y modified
}// gang-private x updated for vector reduction
// gang-private x = 3 *I; gang-shared y undefined
}// gang-shared y updated for gang/seq/worker/vector reduc tions
// x = 0; y = 3 *I*
	The examples below are equivalent That is, the reduction clause on the combined con-
struct applies to the loop construct but implies a copy clause on the parallel construct Thus,
xis not private at the loop directive, so the reduction updates xby the end of the parallel
region
int x = 0;
#pragma acc parallel loop worker reduction(+:x)
for (int i = 0; i < I; ++i) {
x += 1; // worker-private x modified
}// gang-shared x updated for gang/worker reduction
// x = I

int x = 0;
#pragma acc parallel copy(x)
{
// gang-shared x undefined
#pragma acc loop worker reduction(+:x)
for (int i = 0; i < I; ++i) {
x += 1; // worker-private x modified
}
// gang-shared x undefined
}// gang-shared x updated for gang/worker reduction
// x = I

	If the implementation treats the auto clause below as independent , the loop executes in
gang-partitioned mode and thus examines every element of arr once to compute arr’s max-
imum However, if the implementation treats auto asseq, the gangs redundantly compute
arr’s maximum, but the combined result is still arr’s maximum Either way, because xis
not private at the loop directive, the reduction updates xby the end of the parallel region
int x = 0;
const int *arr =/*array of I values */;
#pragma acc parallel copy(x)
{
// gang-shared x undefined
#pragma acc loop auto gang reduction(max:x)
for (int i = 0; i < I; ++i) {
// complex loop body
x = x < arr[i] ? arr[i] : x; // gang- or loop-private
// x modified
}
// gang-shared x undefined
}// gang-shared x updated for gang or gang/seq reduction
// x = arr maximum
	The following example is the same as the previous one except that the reductio n operator is
now+ While gang-partitioned mode sums the elements of arr once, gang-redundant mode
sums them once per gang, producing a result many times arr’s sum This example shows
that, for some reduction operators, combining auto ,gang , andreduction is typically
non-portable
int x = 0;
const int *arr =/*array of I values */;
#pragma acc parallel copy(x)
{
// gang-shared x undefined
#pragma acc loop auto gang reduction(+:x)
for (int i = 0; i < I; ++i) {
// complex loop body
x += arr[i]; // gang or loop-private x modified
}
// gang-shared x undefined
}// gang-shared x updated for gang or gang/seq reduction
// x = arr sum possibly times number of gangs
	At the following loop directive,xandzare private, so the loop reductions are not across
gangs even though the loop is gang-partitioned Nevertheless, the reduction clause on the
loop directive is important as the loop is also vector-partitioned These reduction s are only
partial reductions relative to the full set of values computed by the loop, so th ereduction
clause is needed on the parallel directive to reduce across gangs
int x = 0, y = 0;
#pragma acc parallel copy(x) reduction(+:x,y)
{
int z = 0;
#pragma acc loop gang vector reduction(+:x,z)
for (int i = 0; i < I; ++i) {
x += 1; z += 2; // vector-private x and z modified

}// gang-private x and z updated for vector reduction
y += z; // gang-private y modified
}// gang-shared x and y updated for gang reduction
// x = I; y = I *
/trianglesolid /trianglesolid

210 Cache Directive
Summary
Thecache directive may appear at the top of (inside of) a loop It speciﬁes array e lements or
subarrays that should be fetched into the highest level of the cache for the body of the loop
Syntax
In C and C++, the syntax of the cache directive is
#pragma acc cache( [readonly: ]var-list)new-line
In Fortran, the syntax of the cache directive is
!$acc cache( [readonly: ]var-list)
Avarin acache directive must be a single array element or a simple subarray In C and C++ ,
a simple subarray is an array name followed by an extended array range s peciﬁcation in brackets,
with start and length, such as
arr[ lower:length]
where the lower bound is a constant, loop invariant, or the for loop variable plus or minus a
constant or loop invariant, and the length is a constant
In Fortran, a simple subarray is an array name followed by a comma-separa ted list of range speciﬁ-
cations in parentheses, with lower and upper bound subscripts, such as
arr( lower:upper,lower2:upper2)
The lower bounds must be constant, loop invariant, or the doloop variable plus or minus a constant
or loop invariant; moreover the difference between the corresponding u pper and lower bounds must
be a constant
If the optional readonly modiﬁer appears, then the implementation may assume that the data
referenced by any varin that directive is never written to within the applicable region
Restrictions
	If an array element or subarray is listed in a cache directive, all references to that array
during execution of that loop iteration must not refer to elements of the array outside the
index range speciﬁed in the cache directive
	See Section 2171 Optional Arguments for discussion of Fortran optional a rguments in cache
directives
211 Combined Constructs

Summary
The combined OpenACC parallelloop ,serialloop , andkernelsloop constructs are
shortcuts for specifying a loop construct nested immediately inside a parallel ,serial , or
kernels construct The meaning is identical to explicitly specifying a parallel ,serial , or
kernels construct containing a loop construct Any clause that is allowed on a parallel or
loop construct is allowed on the parallelloop construct; any clause allowed on a serial or
loop construct is allowed on a serialloop construct; and any clause allowed on a kernels
orloop construct is allowed on a kernelsloop construct
Syntax
In C and C++, the syntax of the parallelloop construct is
#pragma acc parallel loop [clause-list ]new-line
for loop
In Fortran, the syntax of the parallelloop construct is
!$acc parallel loop [clause-list ]
do loop
[!$acc end parallel loop ]
The associated structured block is the loop which must immediately follow the direc tive Any of
theparallel orloop clauses valid in a parallel region may appear
In C and C++, the syntax of the serialloop construct is
#pragma acc serial loop [clause-list ]new-line
for loop
In Fortran, the syntax of the serialloop construct is
!$acc serial loop [clause-list ]
do loop
[!$acc end serial loop ]
The associated structured block is the loop which must immediately follow the direc tive Any of
theserial orloop clauses valid in a serial region may appear
In C and C++, the syntax of the kernelsloop construct is
#pragma acc kernels loop [clause-list ]new-line
for loop
In Fortran, the syntax of the kernelsloop construct is
!$acc kernels loop [clause-list ]
do loop
[!$acc end kernels loop ]
The associated structured block is the loop which must immediately follow the direc tive Any of
thekernels orloop clauses valid in a kernels region may appear
Aprivate orreduction clause on a combined construct is treated as if it appeared on the
loop construct In addition, a reduction clause on a combined construct implies a copy clause
as described in Section 262

Restrictions
	The restrictions for the parallel ,serial ,kernels , andloop constructs apply
212 Atomic Construct
Summary
Anatomic construct ensures that a speciﬁc storage location is accessed and/or u pdated atomically,
preventing simultaneous reading and writing by gangs, workers, and vec tor threads that could result
in indeterminate values
Syntax
In C and C++, the syntax of the atomic constructs is:
#pragma acc atomic [atomic-clause ]new-line
expression-stmt
or:
#pragma acc atomic capture new-line
structured block
Where atomic-clause is one ofread ,write ,update , orcapture  The expression-stmt is an
expression statement with one of the following forms:
If the atomic-clause isread :
v = x;
If the atomic-clause iswrite :
x = expr;
If the atomic-clause isupdate or no clause appears:
x++;
x--;
++x;
--x;
xbinop=expr;
x = x binop expr ;
x = expr binop x;
If the atomic-clause iscapture :
v = x++;
v = x--;
v = ++x;
v = --x;
v = x binop=expr;
v = x = x binop expr ;
v = x = expr binop x;
Thestructured-block is a structured block with one of the following forms:

{v = x; x binop=expr;}
{xbinop=expr; v = x; }
{v = x; x = x binop expr ;}
{v = x; x = expr binop x;}
{x = x binop expr ; v = x; }
{x = expr binop x; v = x; }
{v = x; x = expr;}
{v = x; x++; }
{v = x; ++x; }
{++x; v = x; }
{x++; v = x; }
{v = x; x--; }
{v = x; --x; }
{--x; v = x; }
{x--; v = x; }
In the preceding expressions:
	xandv(as applicable) are both l-value expressions with scalar type
	During the execution of an atomic region, multiple syntactic occurrences of xmust designate
the same storage location
	Neither ofvandexpr (as applicable) may access the storage location designated by x
	Neither ofxandexpr (as applicable) may access the storage location designated by v
	expr is an expression with scalar type
	binop is one of+,*,-,/,&,ˆ,|,<<, or>>
	binop ,binop=,++, and--are not overloaded operators
	The expression xbinop expr must be mathematically equivalent to xbinop(expr) This
requirement is satisﬁed if the operators in expr have precedence greater than binop , or by
using parentheses around expr or subexpressions of expr
	The expression expr binop xmust be mathematically equivalent to (expr)binopx This
requirement is satisﬁed if the operators in expr have precedence equal to or greater than binop ,
or by using parentheses around expr or subexpressions of expr
	For forms that allow multiple occurrences of x, the number of times that xis evaluated is
unspeciﬁed
In Fortran the syntax of the atomic constructs is:
!$acc atomic read
capture-statement
[!$acc end atomic ]
or
!$acc atomic write
write-statement
[!$acc end atomic ]

or
!$acc atomic [update ]
update-statement
[!$acc end atomic ]
or
!$acc atomic capture
update-statement
capture-statement
!$acc end atomic
or
!$acc atomic capture
capture-statement
update-statement
!$acc end atomic
or
!$acc atomic capture
capture-statement
write-statement
!$acc end atomic
where write-statement has the following form (if atomic-clause iswrite orcapture ):
x = expr
where capture-statement has the following form (if atomic-clause iscapture orread ):
v = x
and where update-statement has one of the following forms (if atomic-clause isupdate ,capture ,
or no clause appears):
x = x operator expr
x = expr operator x
x = intrinsic procedure name( x, expr-list)
x = intrinsic procedure name(expr-list, x )
In the preceding statements:
	xandv(as applicable) are both scalar variables of intrinsic type
	xmust not be an allocatable variable
	During the execution of an atomic region, multiple syntactic occurrences of xmust designate
the same storage location
	None ofv,expr, and expr-list (as applicable) may access the same storage location as x
	None ofx,expr, and expr-list (as applicable) may access the same storage location as v
	expr is a scalar expression

	expr-list is a comma-separated, non-empty list of scalar expressions If intrinsic procedure name
refers toiand ,ior, orieor , exactly one expression must appear in expr-list 
	intrinsic procedure name is one ofmax,min,iand ,ior, orieor operator is one of+,
*,-,/,and ,or ,eqv , orneqv 
	The expression xoperator expr must be mathematically equivalent to xoperator(expr)
This requirement is satisﬁed if the operators in expr have precedence greater than operator ,
or by using parentheses around expr or subexpressions of expr
	The expression expr operator xmust be mathematically equivalent to (expr)operatorx
This requirement is satisﬁed if the operators in expr have precedence equal to or greater than
operator , or by using parentheses around expr or subexpressions of expr
	intrinsic procedure name must refer to the intrinsic procedure name and not to other program
entities
	operator must refer to the intrinsic operator and not to a user-deﬁned operator A ll assign-
ments must be intrinsic assignments
	For forms that allow multiple occurrences of x, the number of times that xis evaluated is
unspeciﬁed
Anatomic construct with the read clause forces an atomic read of the location designated by x
Anatomic construct with the write clause forces an atomic write of the location designated by
x
Anatomic construct with the update clause forces an atomic update of the location designated
byxusing the designated operator or intrinsic Note that when no clause appea rs, the semantics
are equivalent to atomic update  Only the read and write of the location designated by xare
performed mutually atomically The evaluation of expr orexpr-list need not be atomic with respect
to the read or write of the location designated by x
Anatomic construct with the capture clause forces an atomic update of the location designated
byxusing the designated operator or intrinsic while also capturing the original or ﬁnal value of
the location designated by xwith respect to the atomic update The original or ﬁnal value of the
location designated by xis written into the location designated by vdepending on the form of the
atomic construct structured block or statements following the usual language sema ntics Only
the read and write of the location designated by xare performed mutually atomically Neither the
evaluation of expr orexpr-list , nor the write to the location designated by v,need to be atomic with
respect to the read or write of the location designated by x
For all forms of the atomic construct, any combination of two or more of these atomic constructs
enforces mutually exclusive access to the locations designated by x To avoid race conditions, all
accesses of the locations designated by xthat could potentially occur in parallel must be protected
with anatomic construct
Atomic regions do not guarantee exclusive access with respect to any ac cesses outside of atomic re-
gions to the same storage location xeven if those accesses occur during the execution of a reduction
clause
If the storage location designated by xis not size-aligned (that is, if the byte alignment of xis not a
multiple of the size of x), then the behavior of the atomic region is implementation-deﬁned

Restrictions
	All atomic accesses to the storage locations designated by xthroughout the program are
required to have the same type and type parameters
	Storage locations designated by xmust be less than or equal in size to the largest available
native atomic operator width
213 Declare Directive
Summary
Adeclare directive is used in the declaration section of a Fortran subroutine, functio n, block
construct, or module, or following a variable declaration in C or C++ It can specify that a varis to
be allocated in device memory for the duration of the implicit data region of a func tion, subroutine
or program, and specify whether the data values are to be transferred f rom local memory to device
memory upon entry to the implicit data region, and from device memory to local memor y upon exit
from the implicit data region These directives create a visible device copy o f the var
Syntax
In C and C++, the syntax of the declare directive is:
#pragma acc declare clause-list new-line
In Fortran the syntax of the declare directive is:
!$acc declare clause-list
where clause is one of the following:
copy( var-list)
copyin( [readonly: ]var-list)
copyout( var-list)
create( var-list)
present( var-list)
deviceptr( var-list)
device_resident( var-list)
link( var-list)
The associated region is the implicit region associated with the function, subro utine, or program in
which the directive appears If the directive appears in the declaration s ection of a Fortran module
subprogram, for a Fortran common block , or in a C or C++ global or namespace scope, the associated
region is the implicit region for the whole program The copy ,copyin ,copyout ,present ,
anddeviceptr data clauses are described in Section 27 Data Clauses
Restrictions
	Adeclare directive must be in the same scope as the declaration of any varthat appears
in the clauses of the directive or any scope within a C or C++ function or For tran function,
subroutine, or program
	At least one clause must appear on a declare directive
	Avarin adeclare declare must be a variable or array name, or a Fortran common block
name between slashes

	Avarmay appear at most once in all the clauses of declare directives for a function,
subroutine, program, or module
	In Fortran, assumed-size dummy arrays may not appear in a declare directive
	In Fortran, pointer arrays may appear, but pointer association is not pr eserved in device mem-
ory
	In a Fortran module declaration section, only create ,copyin ,device_resident , and
link clauses are allowed
	In C or C++ global or namespace scope, only create ,copyin ,deviceptr ,
device_resident andlink clauses are allowed
	C and C++ extern variables may only appear in create ,copyin ,deviceptr ,
device_resident andlink clauses on a declare directive
	In C or C++, the link clause must appear at global or namespace scope or the arguments
must be extern variables In Fortran, the link clause must appear in a module declaration
section, or the arguments must be common block names enclosed in slashes
	In C or C++, a longjmp call in the region must return to a setjmp call within the region
	In C++, an exception thrown in the region must be handled within the region
	See Section 2171 Optional Arguments for discussion of Fortran optional d ummy arguments
in data clauses, including device_resident clauses
2131 device resident clause
Summary
Thedevice_resident clause speciﬁes that the memory for the named variables should be
allocated in the current device memory and not in local memory The host may n ot be able to access
variables in a device_resident clause The accelerator data lifetime of global variables or
common blocks that appear in a device_resident clause is the entire execution of the program
In Fortran, if the variable has the Fortran allocatable attribute, the memory for the variable will
be allocated in and deallocated from the current device memory when the hos t thread executes
anallocate ordeallocate statement for that variable, if the current device is a non-shared
memory device If the variable has the Fortran pointer attribute, it may be allocated or deallocated
by the host in the current device memory, or may appear on the left hand sid e of a pointer assignment
statement, if the right hand side variable itself appears in a device_resident clause
In Fortran, the argument to a device_resident clause may be a common block name enclosed
in slashes; in this case, all declarations of the common block must have a matchin g
device_resident clause In this case, the common block will be statically allocated in de-
vice memory, and not in local memory The common block will be available to accelerator routines;
see Section 215 Procedure Calls in Compute Regions
In a Fortran module declaration section, a varin adevice_resident clause will be available to
accelerator subprograms
In C or C++ global scope, a varin adevice_resident clause will be available to accelerator
routines A C or C++ extern variable may appear in a device_resident clause only if the

actual declaration and all extern declarations are also followed by device_resident clauses
2132 create clause
For data in shared memory, no action is taken
For data not in shared memory, the create clause on a declare directive behaves as follows,
for each varinvar-list :
	At entry to an implicit data region where the declare directive appears:
		Ifvaris present, a present increment action with the structured reference counter is
performed If varis a pointer reference, an attach action is performed
		Otherwise, a create action with the structured reference counter is performed If varis
a pointer reference, an attach action is performed
	At exit from an implicit data region where the declare directive appears:
		If the structured reference counter for varis zero, no action is taken
		Otherwise, a present decrement action with the structured reference counter is per-
formed If varis a pointer reference, a detach action is performed If both structured
and dynamic reference counters are zero, a delete action is performed
If thedeclare directive appears in a global context, then the data in var-list is statically allocated
in device memory and the structured reference counter is set to one
In Fortran, if a variable varinvar-list has the Fortran allocatable orpointer attribute, then:
	Anallocate statement for varwill allocate memory in both local memory as well as in the
current device memory, for a non-shared memory device, and the dynamic reference counter
will be set to one
	Adeallocate statement for varwill deallocate memory from both local memory as well
as the current device memory, for a non-shared memory device, and the d ynamic reference
counter will be set to zero If the structured reference counter is not z ero, a runtime error is
issued
In Fortran, if a variable varinvar-list has the Fortran pointer attribute, then it may appear on the
left hand side of a pointer assignment statement, if the right hand side variab le itself appears in a
create clause
Errors
	In Fortran, an acc_error_present error is issued at a deallocate statement if the struc-
tured reference counter is not zero
See Section 522
2133 link clause
Thelink clause is used for large global host static data that is referenced within an accelerator
routine and that should have a dynamic data lifetime on the device The link clause speciﬁes that
only a global link for the named variables should be statically created in accele rator memory The
host data structure remains statically allocated and globally available The dev ice data memory will

be allocated only when the global variable appears on a data clause for a data construct, compute
construct, or enter data directive The arguments to the link clause must be global data A
declarelink clause must be visible everywhere the global variables or common block var iables
are explicitly or implicitly used in a data clause, compute construct, or accelerato r routine The
global variable or common block variables may be used in accelerator routines The accelerator
data lifetime of variables or common blocks that appear in a link clause is the data region that
allocates the variable or common block with a data clause, or from the execution of theenter
data directive that allocates the data until an exitdata directive deallocates it or until the end
of the program
214 Executable Directives
2141 Init Directive
Summary
Theinit directive initializes the runtime for the given device or devices of the given d evice type
This can be used to isolate any initialization cost from the computational cost, wh en collecting
performance statistics If no device type appears all devices will be initialize d Aninit directive
may be used in place of a call to the acc_init oracc_init_device runtime API routine, as
described in Section 327
Syntax
In C and C++, the syntax of the init directive is:
#pragma acc init [clause-list ]new-line
In Fortran the syntax of the init directive is:
!$acc init [clause-list ]
where clause is one of the following:
device_type( device-type-list )
device_num( int-expr)
if( condition)

device type clause
Thedevice_type clause speciﬁes the type of device that is to be initialized in the runtime If the
device_type clause appears, then the acc-current-device-type-var for the current thread is set to
the argument value If no device_num clause appears then all devices of this type are initialized
device num clause
Thedevice_num clause speciﬁes the device id to be initialized If the device_num clause
appears, then the acc-current-device-num-var for the current thread is set to the argument value If
nodevice_type clause appears, then the speciﬁed device id will be initialized for all available
device types

if clause
Theifclause is optional; when there is no ifclause, the implementation will generate code to
perform the initialization unconditionally When an ifclause appears, the implementation will
generate code to conditionally perform the initialization only when the condition evaluates to true
Restrictions
	This directive may only appear in code executed on the host
	If the directive is called more than once without an intervening acc_shutdown call or
shutdown directive, with a different value for the device type argument, the behavio r is
implementation-deﬁned
	If some accelerator regions are compiled to only use one device type, using this directive with
a different device type may produce undeﬁned behavior
Errors
	Anacc_error_device_type_unavailable error is issued if a device_type clause
appears and no device of that device type is available, or if no device_type clause appears
and no device of the current device type is available
	Anacc_error_device_unavailable error is issued if a device_num clause ap-
pears and the int-expr is not a valid device number or that device is not available, or if no
device_num clause appears and the current device is not available
	Anacc_error_device_init error is issued if the device cannot be initialized
See Section 522
2142 Shutdown Directive
Summary
Theshutdown directive shuts down the connection to the given device or devices of the g iven
device type, and frees any associated runtime resources This ends all data lifetimes in device
memory, which effectively sets structured and dynamic reference counte rs to zero A shutdown
directive may be used in place of a call to the acc_shutdown oracc_shutdown_device
runtime API routine, as described in Section 328
Syntax
In C and C++, the syntax of the shutdown directive is:
#pragma acc shutdown [clause-list ]new-line
In Fortran the syntax of the shutdown directive is:
!$acc shutdown [clause-list ]
where clause is one of the following:
device_type( device-type-list )
device_num( int-expr)
if( condition)


device type clause
Thedevice_type clause speciﬁes the type of device that is to be disconnected from the runtime 
If nodevice_num clause appears then all devices of this type are disconnected
device num clause
Thedevice_num clause speciﬁes the device id to be disconnected
If no clauses appear then all available devices will be disconnected
if clause
Theifclause is optional; when there is no ifclause, the implementation will generate code
to perform the shutdown unconditionally When an ifclause appears, the implementation will
generate code to conditionally perform the shutdown only when the condition evaluates to true
Restrictions
	This directive may only appear in code executed on the host
Errors
	Anacc_error_device_type_unavailable error is issued if a device_type clause
appears and no device of that device type is available,
	Anacc_error_device_unavailable error is issued if a device_num clause ap-
pears and the int-expr is not a valid device number or that device is not available
	Anacc_error_device_shutdown error is issued if there is an error shutting down the
device
See Section 522
2143 Set Directive
Summary
Theset directive provides a means to modify internal control variables using direc tives Each form
of theset directive is functionally equivalent to a matching runtime API routine
Syntax
In C and C++, the syntax of the set directive is:
#pragma acc set [clause-list ]new-line
In Fortran the syntax of the set directive is:
!$acc set [clause-list ]
where clause is one of the following
default_async( int-expr)
device_num( int-expr)
device_type( device-type-list )
if( condition)

default async clause
Thedefault_async clause speciﬁes the asynchronous queue that should be used if no que ue ap-
pears and changes the value of acc-default-async-var for the current thread to the argument value
If the value is acc_async_default , the value of acc-default-async-var will revert to the ini-
tial value, which is implementation-deﬁned A set default_async directive is functionally
equivalent to a call to the acc_set_default_async runtime API routine, as described in Sec-
tion 3214
device num clause
Thedevice_num clause speciﬁes the device number to set as the default device for accele rator
regions and changes the value of acc-current-device-num-var for the current thread to the argument
value If the value of device_num argument is negative, the runtime will revert to the default be-
havior, which is implementation-deﬁned A setdevice_num directive is functionally equivalent
to theacc_set_device_num runtime API routine, as described in Section 324
device type clause
Thedevice_type clause speciﬁes the device type to set as the default device type for acce lerator
regions and sets the value of acc-current-device-type-var for the current thread to the argument
value If the value of the device_type argument is zero or the clause does not appear, the
selected device number will be used for all attached accelerator types A set device_type
directive is functionally equivalent to a call to the acc_set_device_type runtime API routine,
as described in Section 322
if clause
Theifclause is optional; when there is no ifclause, the implementation will generate code to
perform the set operation unconditionally When an ifclause appears, the implementation will
generate code to conditionally perform the set operation only when the condition evaluates to true
Restrictions
	This directive may only appear in code executed on the host
	Passingdefault_async the value of acc_async_noval has no effect
	Passingdefault_async the value of acc_async_sync will cause all asynchronous
directives in the default asynchronous queue to become synchronous 
	Passingdefault_async the value of acc_async_default will restore the default
asynchronous queue to the initial value, which is implementation-deﬁned
	At least one default_async ,device_num , ordevice_type clause must appear
	Two instances of the same clause may not appear on the same directive
Errors
	Anacc_error_device_type_unavailable error is issued if a device_type clause
appears, and no device of that device type is available
	Anacc_error_device_unavailable error is issued if a device_num clause ap-
pears, and the int-expr is not a valid device number

	Anacc_error_invalid_async error is issued if a default_async clause appears,
and the int-expr is not a valid async-argument 
See Section 522
2144 Update Directive
Summary
Theupdate directive is used during the lifetime of accelerator data to update vars in local memory
with values from the corresponding data in device memory, or to update vars in device memory with
values from the corresponding data in local memory
Syntax
In C and C++, the syntax of the update directive is:
#pragma acc update clause-list new-line
In Fortran the syntax of the update data directive is:
!$acc update clause-list
where clause is one of the following:
async [(int-expr)]
wait [(wait-argument )]
device_type( device-type-list )
if( condition)
if_present
self( var-list)
host( var-list)
device( var-list)
Multiple subarrays of the same array may appear in a var-list of the same or different clauses on
the same directive The effect of an update clause is to copy data from device memory to local
memory for updateself , and from local memory to device memory for updatedevice  The
updates are done in the order in which they appear on the directive
Restrictions
	At least one self ,host , ordevice clause must appear on an update directive
self clause
Theself clause speciﬁes that the vars invar-list are to be copied from the current device memory
to local memory for data not in shared memory For data in shared memory, no a ction is taken An
update directive with the self clause is equivalent to a call to the acc_update_self routine,
described in Section 3220
host clause
Thehost clause is a synonym for the self clause

device clause
Thedevice clause speciﬁes that the vars invar-list are to be copied from local memory to the cur-
rent device memory, for data not in shared memory For data in shared memory , no action is taken
Anupdate directive with the device clause is equivalent to a call to the acc_update_device
routine, described in Section 3220
if clause
Theifclause is optional; when there is no ifclause, the implementation will generate code to
perform the updates unconditionally When an ifclause appears, the implementation will generate
code to conditionally perform the updates only when the condition evaluates to true
async clause
Theasync clause is optional; see Section 216 Asynchronous Behavior for more info rmation
wait clause
Thewait clause is optional; see Section 216 Asynchronous Behavior for more infor mation
ifpresent clause
When anif_present clause appears on the directive, no action is taken for a varwhich appears
invar-list that is not present in the current device memory
Restrictions
	Theupdate directive is executable It must not appear in place of the statement followin g
anif,while ,do,switch , orlabel in C or C++, or in place of the statement following a logical
ifin Fortran
	If noif_present clause appears on the directive, each varinvar-list must be present in
the current device memory
	Only theasync andwait clauses may follow a device_type clause
	At most one ifclause may appear In Fortran, the condition must evaluate to a scalar logica l
value; in C or C++, the condition must evaluate to a scalar integer value
	Noncontiguous subarrays may appear It is implementation-speciﬁc whethe r noncontiguous
regions are updated by using one transfer for each contiguous subre gion, or whether the non-
contiguous data is packed, transferred once, and unpacked, or whe ther one or more larger
subarrays (no larger than the smallest contiguous region that contains the speciﬁed subarray)
are updated
	In C and C++, a member of a struct or class may appear, including a subarr ay of a member
Members of a subarray of struct or class type may not appear
	In C and C++, if a subarray notation is used for a struct member, subarra y notation may not
be used for any parent of that struct member
	In Fortran, members of variables of derived type may appear, including a subarray of a mem-
ber Members of subarrays of derived type may not appear

	In Fortran, if array or subarray notation is used for a derived type memb er, array or subarray
notation may not be used for a parent of that derived type member
	See Section 2171 Optional Arguments for discussion of Fortran optional a rguments in self ,
host , anddevice clauses
Errors
	Anacc_error_not_present error is issued if no if_present clause appears and
anyvarin adevice orself clause is not present on the current device
	Anacc_error_partly_present error is issued if part of varis present in the current
device memory but all of varis not
	Anasync orwait clause can cause an error to be issued; see Sections 2161 and 2162
See Section 522
2145 Wait Directive
See Section 216 Asynchronous Behavior for more information
2146 Enter Data Directive
See Section 266 Enter Data and Exit Data Directives for more information
2147 Exit Data Directive
See Section 266 Enter Data and Exit Data Directives for more information
215 Procedure Calls in Compute Regions
This section describes how routines are compiled for an accelerator and h ow procedure calls are
compiled in compute regions See Section 2171 Optional Arguments for discus sion of Fortran
optional arguments in procedure calls inside compute regions
2151 Routine Directive
Summary
Theroutine directive is used to tell the compiler to compile the deﬁnition for a procedure, su ch
as a function or C++ lambda, for an accelerator as well as for the host Th eroutine directive is
also used to tell the compiler the attributes of the procedure when called on the a ccelerator
Syntax
In C and C++, the syntax of the routine directive is:
#pragma acc routine clause-list new-line
#pragma acc routine( name)clause-list new-line
In C and C++, the routine directive without a name may appear immediately before a function
deﬁnition, a function prototype, or a C++ lambda and applies to the function or C++ lambda The
routine directive with a name may appear anywhere that a function prototype is allowe d and
applies to the function or the C++ lambda in scope with that name See Section A34 for recom-
mended diagnostics for a routine directive with a name

In Fortran the syntax of the routine directive is:
!$acc routine clause-list
!$acc routine( name)clause-list
In Fortran, the routine directive without a name may appear within the speciﬁcation part of a
subroutine or function deﬁnition, or within an interface body for a subrou tine or function in an
interface block, and applies to the containing subroutine or function The routine directive with
a name may appear in the speciﬁcation part of a subroutine, function or modu le, and applies to the
named subroutine or function
Theclause is one of the following:
gang [(dim: int-expr)]
worker
vector
seq
bind( name)
bind( string)
device_type( device-type-list )
nohost
Agang ,worker ,vector , orseq clause speciﬁes the level of parallelism in the routine
A procedure compiled with the routine directive for an accelerator is called an accelerator rou-
tine
If no explicit routine directive applies to a procedure that is called or whose address is acces sed
in a compute region, and the procedure’s deﬁnition appears in the progra m unit being compiled, then
the implementation applies an implicit routine directive with a seq clause to that procedure A
C++ lambda’s implicit routine directive also has a nohost clause if the lambda is deﬁned in an
accelerator routine that has a nohost clause
When the implementation applies an implicit routine directive, it must recursively handle proce-
dure references in that accelerator routine
The implementation may apply predetermined routine directives with a seq clause to any pro-
cedures that it provides for an accelerator, such as those of base lan guage standard libraries
gang clause
The associated dimension is the value of the dim clause, if it appears, or is dimension one The dim
argument must be a constant positive integer with value 1, 2, or 3 The gang clause with dimension
dspeciﬁes that the procedure contains, may contain, or may call another pr ocedure that contains a
loop with a gang clause associated with dimension dor less
worker clause
Theworker clause speciﬁes that the procedure contains, may contain, or may call ano ther pro-
cedure that contains a loop with a worker clause, but does not contain nor does it call another
procedure that contains a loop with the gang clause A loop in this procedure with an auto clause
may be selected by the compiler to execute in worker orvector mode A call to this procedure
must appear in code that is executed in worker-single mode, though it may be in gang-redundant

organg-partitioned mode For instance, a procedure with a routineworker directive may be
called from within a loop that has the gang clause, but not from within a loop that has the worker
clause
vector clause
Thevector clause speciﬁes that the procedure contains, may contain, or may call ano ther pro-
cedure that contains a loop with the vector clause, but does not contain nor does it call another
procedure that contains a loop with either a gang orworker clause A loop in this procedure with
anauto clause may be selected by the compiler to execute in vector mode, but not worker
mode A call to this procedure must appear in code that is executed in vector-single mode, though
it may be in gang-redundant organg-partitioned mode, and in worker-single orworker-partitioned
mode For instance, a procedure with a routine vector directive may be called from within
a loop that has the gang clause or the worker clause, but not from within a loop that has the
vector clause
seq clause
Theseq clause speciﬁes that the procedure does not contain nor does it call an other procedure that
contains a loop with a gang ,worker , orvector clause A loop in this procedure with an auto
clause will be executed in seq mode A call to this procedure may appear in any mode
bind clause
Thebind clause speciﬁes the name to use when calling the procedure on a device othe r than the
host If the name is speciﬁed as an identiﬁer, it is called as if that name were sp eciﬁed in the
language being compiled If the name is speciﬁed as a string, the string is used for the procedure
name unmodiﬁed A bind clause on a procedure deﬁnition behaves as if it had appeared on a
declaration by changing the name used to call the procedure on a device oth er than the host; however,
the procedure is not compiled for the device with either the original name or the name in the bind
clause
If there is both a Fortran bind and an acc bind clause for a procedure deﬁnition then a call on the
host will call the Fortran bound name and a call on another device will call th e name in the bind
clause
device type clause
Thedevice_type clause is described in Section 24 Device-Speciﬁc Clauses
nohost clause
Thenohost clause tells the compiler not to compile a version of this procedure for the host
Restrictions
	Only thegang ,worker ,vector ,seq andbind clauses may follow a device_type
clause
	Exactly one of the gang ,worker ,vector , orseq clauses must appear
	In C and C++, function static variables are not supported in functions to wh ich aroutine
directive applies

	In Fortran, variables with the save attribute, either explicitly or implicitly, are not supported
in subprograms to which a routine directive applies
	A call to a procedure with a nohost clause must not appear in a compute construct that is
compiled for the host See examples below
	If a call to a procedure with a nohost clause appears in another procedure but outside any
compute construct, that other procedure must also have a nohost clause
	A call to a procedure with a gang(dim: d)clause must appear in code that is executed
ingang-redundant mode in all dimensions dand lower For instance, a procedure with a
gang(dim:2) clause may not be called from within a loop that has a gang(dim:1)
or agang(dim:2) clause The user needs to ensure that a call to a procedure with a
gang(dim: d)clause, when present in a region executing in GRe orGPe mode with e>d
and called by a gang along dimension e, is executed by all of its corresponding gangs along
dimension d
	Abind clause may not bind to a routine name that has a visible bind clause
	If a procedure has a bind clause on both the declaration and the deﬁnition then they both
must bind to the same name
	In C and C++, a deﬁnition or use of a procedure must appear within the sco pe of at least
one explicit and applying routine directive if any appears in the same compilation unit
An explicit routine directive’s scope is from the directive to the end of the compilation
unit If the routine directive appears in the member list of a C++ class, then its scope also
extends in the same manner as any class member’s scope (eg, it includes the bo dies of all
other member functions)
/triangledownsld /triangledownsld
Examples

	A function, such as fbelow, requires a nohost clause if it contains accelerator-speciﬁc code
that cannot be compiled for the host By default, some implementations compile all c ompute
constructs for the host in addition to accelerators In that case, a call to fmust not appear in
any compute construct or compilation will fail However, fcan appear in the bind clause of
another function, such as gbelow, that does not have a nohost clause, and a call to gcan
appear in a compute construct Thus, gis called when the compute construct is compiled for
the host, and fis called when the compute construct is compiled for accelerators
#pragma acc routine seq nohost
void f() { /*accelerator implementation */}

#pragma acc routine seq bind(f)
void g() { /*host implementation */}

void h() {
#pragma acc parallel
g();
}

	In C, the restriction that a function’s deﬁnitions and uses must appear within any applying
routine directive’s scope has a simple interpretation: the routine directive must appear
ﬁrst This interpretation seems intuitive for the common case in C where prototyp es, deﬁni-
tions, androutine directives for a function, such as fbelow, appear at global scope
void f();
void scopeA() {
#pragma acc parallel
f();// nonconforming
}
// The routine directive’s scope is not f’s full scope
// Instead, it starts at the routine directive
#pragma acc routine(f) gang
void scopeB() {
#pragma acc parallel
f();// conforming
}
void f() {} // conforming
	C++ classes permit forward references from member function bodies to o ther members de-
clared later For example, immediately within classA below,g’s scope does not start until
afterf’s deﬁnition Nevertheless, within f’s body,gis in scope throughout The same is true
forg’sroutine directive Thus, f’s call togis conforming
class A {
void f() {
#pragma acc parallel
g();// conforming
}
#pragma acc routine gang
void g();
};
	In some places, C++ classes do not permit forward references For e xample, in the return type
of a member function, a member typedef that is declared later is not in scope L ikewise,g’s
deﬁnition below is not fully within the scope of g’sroutine directive even though its body
is, so its deﬁnition is nonconforming
class A {
#pragma acc routine(f) gang
void f() {} // conforming
void g() {} // nonconforming
#pragma acc routine(g) gang
};
	The C++ scope resolution operator and using directive do not affect the scope of routine
directives For example, the routine directive below is speciﬁed for the name f, which
resolves to A::f  Every reference to both A::f andC::f afterward is in the routine
directive’s scope, but the routine directive always applies to A::f and neverC::f even
when referenced as just f
namespace A {
void f();
namespace B {

#pragma acc routine(f) gang // applies to A::f
}
}
void g() {
#pragma acc parallel
A::f(); // conforming
}
void h() {
using A::f;
#pragma acc parallel
f();// conforming
}
namespace C {
void f();
using namespace A::B;
void i() {
#pragma acc parallel
f();// nonconforming
}
}
/trianglesolid /trianglesolid
2152 Global Data Access
C or C++ global, ﬁle static, or extern variables or array, and Fortran module orcommon block vari-
ables or arrays, that are used in accelerator routines must appear in a d eclare directive in a create ,
copyin ,device_resident orlink clause If the data appears in a device_resident
clause, the routine directive for the procedure must include the nohost clause If the data ap-
pears in alink clause, that data must have an active accelerator data lifetime by virtue of ap pearing
in a data clause for a data construct, compute construct, or enterdata directive
216 Asynchronous Behavior
This section describes the async clause, thewait clause, thewait directive, and the behavior of
programs that use asynchronous data movement, compute regions, and as ynchronous API routines
In this section and throughout the speciﬁcation, the term async-argument means a nonnegative
scalar integer expression ( intfor C or C++, integer for Fortran), or one of the special values
acc_async_noval oracc_async_sync , as deﬁned in the C header ﬁle and the Fortran
openacc module The special values are negative values, so as not to conﬂict with a user-speciﬁed
nonnegative async-argument  An async-argument is used inasync clauses,wait clauses,wait
directives, and as an argument to various runtime routines
Theasync-value of an async-argument is
	acc_async_sync ifasync-argument has a value equal to the special value acc_async_sync ,
	the value of acc-default-async-var ifasync-argument has a value equal to the special value
acc_async_noval ,
	the value of the async-argument , if it is nonnegative,
	implementation-deﬁned, otherwise

Theasync-value is used to select the activity queue to which the clause or directive or API ro utine
refers The properties of the current device and the implementation will dete rmine how many actual
activity queues are supported, and how the async-value is mapped onto the actual activity queues
Two asynchronous operations on the same device with the same async-value will be enqueued
onto the same activity queue, and therefore will be executed on the device in the order they are
encountered by the local thread Two asynchronous operations with dif ferent async-values may be
enqueued onto different activity queues, and therefore may be execu ted on the device in either order
or concurrently relative to each other If there are two or more host thre ads executing and sharing the
same device, asynchronous operations on any thread with the same async-value will be enqueued
onto the same activity queue If the threads are not synchronized with res pect to each other, the
operations may be enqueued in either order and therefore may execute on the device in either order
Asynchronous operations enqueued to difference devices may execu te in any order or may execute
concurrently, regardless of the async-value used for each
If a compute construct, data directive, or runtime API call has an async-value ofacc_async_sync ,
the associated operations are executed on the activity queue associated w ith the async-value
acc_async_sync , and the local thread will wait until the associated operations have completed
before executing the code following the construct or directive If a data construct has an async-
value ofacc_async_sync , the associated operations are executed on the activity queue associ-
ated with the async-value acc_async_sync , and the local thread will wait until the associated
operations that occur upon entry of the construct have completed befor e executing the code of the
construct’s structured block or block construct, and after that, will wait u ntil the associated opera-
tions that occur upon exit of the construct have completed before execu ting the code following the
construct
If a compute construct, data directive, or runtime API call has an async-value other than
acc_async_sync , the associated operations are executed on the activity queue associated with
thatasync-value and the associated operations may be processed asynchronously while th e local
thread continues executing the code following the construct or directive If adata construct has an
async-value other thanacc_async_sync , the associated operations are executed on the activity
queue associated with that async-value , and the associated operations that occur upon entry of the
construct may be processed asynchronously while the local thread con tinues executing the code
of the construct’s structured block or block construct, and after that, the associated operations that
occur upon exit of the construct may be processed asynchronously w hile the local thread continues
executing the code following the construct
In this section and throughout the speciﬁcation, the term wait-argument , means:
[ devnum : int-expr: ] [ queues : ] async-argument-list
If adevnum modiﬁer appears in the wait-argument then the associated device is the device with
that device number of the current device type If no devnum modiﬁer appears then the associated
device is the current device
Each async-argument is associated with an async-value  The async-values select the associated
activity queue or queues on the associated device If there is no async-argument-list , the associated
activity queues are all activity queues for the associated device
Thequeues modiﬁer within a wait-argument is optional to improve clarity of the expression list

2161 async clause
Theasync clause may appear on a parallel ,serial ,kernels , ordata construct, or an
enterdata ,exitdata ,update , orwait directive In all cases, the async clause is optional
Theasync clause may have a single async-argument , as deﬁned above If the async clause does
not appear, the behavior is as if the async-argument isacc_async_sync  If theasync clause
appears with no argument, the behavior is as if the async-argument isacc_async_noval  The
async-value for a construct or directive is deﬁned in Section 216
Errors
	Anacc_error_invalid_async error is issued if an async clause with an argument
appears on any directive and the argument is not a valid async-argument 
See Section 522
2162 wait clause
Thewait clause may appear on a parallel ,serial , orkernels , ordata construct, or
anenter data ,exit data , orupdate directive In all cases, the wait clause is optional
When there is no wait clause, the associated operations may be enqueued or launched or exec uted
immediately on the device
If there is an argument to the wait clause, it must be a wait-argument , the associated device and
activity queues are as speciﬁed in the wait-argument ; see Section 216 If there is no argument to
thewait clause, the associated device is the current device and associated activ ity queues are all
activity queues The associated operations may not be launched or exec uted until all operations
already enqueued up to this point by this thread on the associated asynchr onous device activity
queues have completed Note: One legal implementation is for the local thread to wait until the
operations already enqueued on the associated asynchronous device activity queues have completed;
another legal implementation is for the local thread to enqueue the associated o perations in such a
way that they will not start until the operations already enqueued on the as sociated asynchronous
device activity queues have completed
Errors
	Anacc_error_device_unavailable error is issued if a wait clause appears on any
directive with a devnum modiﬁer and the associated int-expr is not a valid device number
	Anacc_error_invalid_async error is issued if a wait clause appears on any direc-
tive with aqueues modiﬁer or no modiﬁer and any value in the associated list is not a valid
async-argument 
See Section 522
2163 Wait Directive
Summary
Thewait directive causes the local thread or operations enqueued onto a device activity queue on
the current device to wait for completion of asynchronous operations
Syntax
In C and C++, the syntax of the wait directive is:

#pragma acc wait [(wait-argument )] [clause-list ]new-line
In Fortran the syntax of the wait directive is:
!$acc wait [(wait-argument )] [clause-list ]
where clause is:
async [(async-argument )]
if( condition)
If it appears, the wait-argument is as deﬁned in Section 216, and the associated device and activity
queues are as speciﬁed in the wait-argument  If there is no wait-argument clause, the associated
device is the current device and associated activity queues are all activ ity queues
If there is no async clause, the local thread will wait until all operations enqueued by this threa d
onto each of the associated device activity queues for the associated dev ice have completed There
is no guarantee that all the asynchronous operations initiated by other thre ads onto those queues will
have completed without additional synchronization with those threads
If there is an async clause, no new operation may be launched or executed on the activity queu e
associated with the async-argument on the current device until all operations enqueued up to this
point by this thread on the activity queues associated with the wait-argument have completed Note:
One legal implementation is for the local thread to wait for all the associated acti vity queues; another
legal implementation is for the thread to enqueue a synchronization operation in such a way that
no new operation will start until the operations enqueued on the associated activity queues have
completed
Theifclause is optional; when there is no ifclause, the implementation will generate code to
perform the wait operation unconditionally When an ifclause appears, the implementation will
generate code to conditionally perform the wait operation only when the condition evaluates to true
Await directive is functionally equivalent to a call to one of the acc_wait ,acc_wait_async ,
acc_wait_all , oracc_wait_all_async runtime API routines, as described in Sections 32
and 3211
Errors
	Anacc_error_device_unavailable error is issued if a devnum modiﬁer appears
and the int-expr is not a valid device number
	Anacc_error_invalid_async error is issued if a queues modiﬁer or no modiﬁer
appears and any value in the associated list is not a valid async-argument 
See Section 522
217 Fortran Speciﬁc Behavior
2171 Optional Arguments
This section refers to the Fortran intrinsic function PRESENT  A call to the Fortran intrinsic function
PRESENT(arg) returnstrue , ifarg is an optional dummy argument and an actual argument
forarg was present in the argument list of the call site This should not be confus ed with the
OpenACCpresent data clause

The appearance of a Fortran optional argument arg as avarin any of the following clauses has no
effect at runtime if PRESENT(arg) isfalse :
	in data clauses on compute and data constructs;
	in data clauses on enterdata andexitdata directives;
	in data and device_resident clauses ondeclare directives;
	inuse_device clauses onhost_data directives;
	inself ,host , anddevice clauses onupdate directives
The appearance of a Fortran optional argument arg in the following situations may result in unde-
ﬁned behavior if PRESENT(arg) isfalse when the associated construct is executed:
	as avarinprivate ,firstprivate , andreduction clauses;
	as avarincache directives;
	as part of an expression in any clause or directive
A call to the Fortran intrinsic function PRESENT behaves the same way in a compute construct or
an accelerator routine as on the host The function call PRESENT(arg) must return the same value
in a compute construct as PRESENT(arg) would outside of the compute construct If a Fortran
optional argument arg appears as an actual argument in a procedure call in a compute construc t
or an accelerator routine, and the associated dummy argument subarg also has the optional
attribute, then PRESENT(subarg) returns the same value as PRESENT(subarg) would when
executed on the host
2172 Do Concurrent Construct
This section refers to the Fortran doconcurrent construct that is a form of doconstruct When
doconcurrent appears without a loop construct in a kernels construct it is treated as if it is
annotated with loop auto  If it appears in a parallel construct or an accelerator routine then
it is treated as if it is annotated with loop independent 


3 Runtime Library
This chapter describes the OpenACC runtime library routines that are availa ble for use by program-
mers Use of these routines may limit portability to systems that do not support the OpenACC API
Conditional compilation using the _OPENACC preprocessor variable may preserve portability
This chapter has two sections:
	Runtime library deﬁnitions
	Runtime library routines
There are four categories of runtime routines:
	Device management routines, to get the number of devices, set the curren t device, and so on
	Asynchronous queue management, to synchronize until all activities on an async queue are
complete, for instance
	Device test routine, to test whether this statement is executing on the device or not
	Data and memory management, to manage memory allocation or copy data between memo -
ries
31 Runtime Library Deﬁnitions
In C and C++, prototypes for the runtime library routines described in this ch apter are provided in
a header ﬁle named openacch  All the library routines are extern functions with “C” linkage
This ﬁle deﬁnes:
	The prototypes of all routines in the chapter
	Any datatypes used in those prototypes, including an enumeration type to des cribe the sup-
ported device types
	The values of acc_async_noval ,acc_async_sync , andacc_async_default 
In Fortran, interface declarations are provided in a Fortran module named openacc  Theopenacc
module deﬁnes:
	The integer parameter openacc_version with a value yyyymm where yyyy andmmare the
year and month designations of the version of the Accelerator programming mo del supported
This value matches the value of the preprocessor variable _OPENACC 
	Interfaces for all routines in the chapter
	Integer parameters to deﬁne integer kinds for arguments to and return valu es for those rou-
tines
	Integer parameters to describe the supported device types
	Integer parameters to deﬁne the values of acc_async_noval ,acc_async_sync , and
acc_async_default 

Many of the routines accept or return a value corresponding to the type o f device In C and C++, the
datatype used for device type values is acc_device_t ; in Fortran, the corresponding datatype
isinteger(kind=acc_device_kind)  The possible values for device type are implemen-
tation speciﬁc, and are deﬁned in the C or C++ include ﬁle openacch and the Fortran module
openacc  Five values are always supported: acc_device_none ,acc_device_default ,
acc_device_host ,acc_device_not_host , andacc_device_current  For other val-
ues, look at the appropriate ﬁles included with the implementation, or read the do cumentation for
the implementation The value acc_device_default will never be returned by any function;
its use as an argument will tell the runtime library to use the default device type f or that implemen-
tation
32 Runtime Library Routines
In this section, for the C and C++ prototypes, pointers are typed h_void*ord_void*to desig-
nate a host memory address or device memory address, when these calls ar e executed on the host,
as if the following deﬁnitions were included:
#define h_void void
#define d_void void
Many Fortran API bindings deﬁned in this section rely on types deﬁned in Fo rtran’siso_c_binding
module It is implied that the iso_c_binding module is used in these bindings, even if not ex-
plicitly stated in the format section for that routine
Restrictions
Except foracc_on_device , these routines are only available on the host
321 acc getnum devices
Summary
Theacc_get_num_devices routine returns the number of available devices of the given type
Format
C or C++:
int acc_get_num_devices(acc_device_t dev_type);
Fortran:
integer function acc_get_num_devices(dev_type)
integer(acc_device_kind) :: dev_type
Description
Theacc_get_num_devices routine returns the number of available devices of device type
dev_type  If device type dev_type is not supported or no device of dev_type is available,
this routine returns zero
322 acc setdevice type
Summary
Theacc_set_device_type routine tells the runtime which type of device to use when exe-
cuting a compute region and sets the value of acc-current-device-type-var  This is useful when the
implementation allows the program to be compiled to use more than one type of device 

Format
C or C++:
void acc_set_device_type(acc_device_t dev_type);
Fortran:
subroutine acc_set_device_type(dev_type)
integer(acc_device_kind) :: dev_type
Description
A call toacc_set_device_type is functionally equivalent to a setdevice_type(dev_type)
directive, as described in Section 2143 This routine tells the runtime which typ e of device to use
among those available and sets the value of acc-current-device-type-var for the current thread to
dev_type 
Restrictions
	If some compute regions are compiled to only use one device type, the result o f calling this
routine with a different device type may produce undeﬁned behavior
Errors
	Anacc_error_device_type_unavailable error is issued if device type dev_type
is not supported or no device of dev_type is available
See Section 522
323 acc getdevice type
Summary
Theacc_get_device_type routine returns the value of acc-current-device-type-var , which is
the device type of the current device This is useful when the implementation a llows the program to
be compiled to use more than one type of device
Format
C or C++:
acc_device_t acc_get_device_type(void);
Fortran:
function acc_get_device_type()
integer(acc_device_kind) :: acc_get_device_type
Description
Theacc_get_device_type routine returns the value of acc-current-device-type-var for the
current thread to tell the program what type of device will be used to run th e next compute region, if
one has been selected The device type may have been selected by the pro gram with a runtime API
call or a directive, by an environment variable, or by the default behav ior of the implementation; see
the table in Section 231
Restrictions
	If the device type has not yet been selected, the value acc_device_none may be returned

324 acc setdevice num
Summary
Theacc_set_device_num routine tells the runtime which device to use and sets the value of
acc-current-device-num-var 
Format
C or C++:
void acc_set_device_num(int dev_num, acc_device_t dev_t ype);
Fortran:
subroutine acc_set_device_num(dev_num, dev_type)
integer :: dev_num
integer(acc_device_kind) :: dev_type
Description
A call toacc_set_device_num is functionally equivalent to a setdevice_type(dev_type)
device_num(dev_num) directive, as described in Section 2143 This routine tells the runtime
which device to use among those available of the given type for compute or da ta regions in the cur-
rent thread and sets the value of acc-current-device-num-var todev_num  If the value of dev_num
is negative, the runtime will revert to its default behavior, which is implementation -deﬁned If the
value of the dev_type is zero, the selected device number will be used for all device types Calling
acc_set_device_num implies a call to acc_set_device_type(dev_type) 
Errors
	Anacc_error_device_type_unavailable error is issued if device type dev_type
is not supported or no device of dev_type is available
	Anacc_error_device_unavailable error is issued if the value of dev_num is not
a valid device number
See Section 522
325 acc getdevice num
Summary
Theacc_get_device_num routine returns the value of acc-current-device-num-var for the cur-
rent thread
Format
C or C++:
int acc_get_device_num(acc_device_t dev_type);
Fortran:
integer function acc_get_device_num(dev_type)
integer(acc_device_kind) :: dev_type
Description
Theacc_get_device_num routine returns the value of acc-current-device-num-var for the cur-
rent thread If there are no devices of device type dev_type or if device type dev_type is not
supported, this routine returns -1

326 acc getproperty
Summary
Theacc_get_property andacc_get_property_string routines return the value of a
device-property for the speciﬁed device
Format
C or C++:
size_t acc_get_property(int dev_num,
acc_device_t dev_type,
acc_device_property_t property);
const
char*acc_get_property_string(int dev_num,
acc_device_t dev_type,
acc_device_property_t property);
Fortran:
function acc_get_property(dev_num, dev_type, property)
subroutine acc_get_property_string(dev_num, dev_type, &
property, string)
integer, value :: dev_num
integer(acc_device_kind), value :: dev_type
integer(acc_device_property_kind), value :: property
integer(c_size_t) :: acc_get_property
character *(*) :: string
Description
Theacc_get_property andacc_get_property_string routines return the value of the
property dev_num anddev_type specify the device being queried If dev_type has the
valueacc_device_current , thendev_num is ignored and the value of the property for the
current device is returned property is an enumeration constant, deﬁned in openacch , for
C or C++, or an integer parameter, deﬁned in the openacc module, for Fortran Integer-valued
properties are returned by acc_get_property , and string-valued properties are returned by
acc_get_property_string  In Fortran, acc_get_property_string returns the result
into thestring argument
The supported values of property are given in the following table
property return type return value
acc_property_memory integer size of device memory in bytes
acc_property_free_memory integer free device memory in bytes
acc_property_shared_memory_support
integer nonzero if the speciﬁed device sup-
ports sharing memory with the local
thread
acc_property_name string device name
acc_property_vendor string device vendor
acc_property_driver string device driver version
An implementation may support additional properties for some devices

Restrictions
	acc_get_property will return 0 and acc_get_property_string will return a null
pointer (in C or C++) or a blank string (in Fortran) in the following cases:
		If device type dev_type is not supported or no device of dev_type is available
		If the value of dev_num is not a valid device number for device type dev_type 
		If the value of property is not one of the known values for that query routine, or that
property has no value for the speciﬁed device
327 acc init
Summary
Theacc_init andacc_init_device routines initialize the runtime for the speciﬁed device
type and device number This can be used to isolate any initialization cost from the computational
cost, such as when collecting performance statistics
Format
C or C++:
void acc_init(acc_device_t dev_type);
void acc_init_device(int dev_num, acc_device_t dev_type );
Fortran:
subroutine acc_init(dev_type)
subroutine acc_init_device(dev_num, dev_type)
integer :: dev_num
integer(acc_device_kind) :: dev_type
Description
A call toacc_init oracc_init_device is functionally equivalent to an init directive with
matchingdev_type anddev_num arguments, as described in Section 2141 dev_type must
be one of the deﬁned accelerator types dev_num must be a valid device number of the device type
dev_type  These routines also implicitly call acc_set_device_type(dev_type)  In the
case ofacc_init_device ,acc_set_device_num(dev_num) is also called
If a program initializes one or more devices without an intervening shutdown directive or
acc_shutdown call to shut down those same devices, no action is taken
Errors
	Anacc_error_device_type_unavailable error is issued if device type dev_type
is not supported or no device of dev_type is available
	Anacc_error_device_unavailable error is issued if dev_num is not a valid device
number
See Section 522
328 acc shutdown

Summary
Theacc_shutdown andacc_shutdown_device routines shut down the connection to spec-
iﬁed devices and free up any related resources in the runtime This ends a ll data lifetimes in device
memory for the device or devices that are shut down, which effectively s ets structured and dynamic
reference counters to zero
Format
C or C++:
void acc_shutdown(acc_device_t dev_type);
void acc_shutdown_device(int dev_num, acc_device_t dev_ type);
Fortran:
subroutine acc_shutdown(dev_type)
subroutine acc_shutdown_device(dev_num, dev_type)
integer :: dev_num
integer(acc_device_kind) :: dev_type
Description
A call toacc_shutdown oracc_shutdown_device is functionally equivalent to a shutdown
directive, with matching dev_type anddev_num arguments, as described in Section 2142
dev_type must be one of the deﬁned accelerator types dev_num must be a valid device number
of the device type dev_type acc_shutdown routine disconnects the program from all devices
of device type dev_type  Theacc_shutdown_device routine disconnects the program from
dev_num of typedev_type  Any data that is present in the memory of a device that is shut down
is immediately deallocated
Restrictions
	This routine may not be called while a compute region is executing on a device of type
dev_type 
	If the program attempts to execute a compute region on a device or to access a ny data in the
memory of a device that was shut down, the behavior is undeﬁned
	If the program attempts to shut down the acc_device_host device type, the behavior is
undeﬁned
Errors
	Anacc_error_device_type_unavailable error is issued if device type dev_type
is not supported or no device of dev_type is available
	Anacc_error_device_unavailable error is issued if dev_num is not a valid device
number
	Anacc_error_device_shutdown error is issued if there is an error shutting down the
device
See Section 522
329 acc async test
Summary
Theacc_async_test routines test for completion of all associated asynchronous operations f or
a single speciﬁed async queue or for all async queues on the current device or on a speciﬁed device

Format
C or C++:
int acc_async_test(int wait_arg);
int acc_async_test_device(int wait_arg, int dev_num);
int acc_async_test_all(void);
int acc_async_test_all_device(int dev_num);
Fortran:
logical function acc_async_test(wait_arg)
logical function acc_async_test_device(wait_arg, dev_n um)
logical function acc_async_test_all()
logical function acc_async_test_all_device(dev_num)
integer(acc_handle_kind) :: wait_arg
integer :: dev_num
Description
wait_arg must be an async-argument as deﬁned in Section 216 Asynchronous Behavior dev_num
must be a valid device number of the current device type
The behavior of the acc_async_test routines is:
	If there is no dev_num argument, it is treated as if dev_num is the current device number
	If any asynchronous operations initiated by this host thread on device dev_num either on
async queue wait_arg (if there is a wait_arg argument), or on any async queue (if there
is nowait_arg argument) have not completed, a call to the routine returns false 
	If all such asynchronous operations have completed, or there are no s uch asynchronous op-
erations, a call to the routine returns true A return value of true is no guarantee that asyn-
chronous operations initiated by other host threads have completed
Errors
	Anacc_error_invalid_async error is issued if wait_arg is not a valid async-
argument value
	Anacc_error_device_unavailable error is issued if dev_num is not a valid device
number
See Section 522
3210 acc wait
Summary
Theacc_wait routines wait for completion of all associated asynchronous operations o n a single
speciﬁed async queue or on all async queues on the current device o r on a speciﬁed device
Format
C or C++:
void acc_wait(int wait_arg);
void acc_wait_device(int wait_arg, int dev_num);
void acc_wait_all(void);
void acc_wait_all_device(int dev_num);

Fortran:
subroutine acc_wait(wait_arg)
subroutine acc_wait_device(wait_arg, dev_num)
subroutine acc_wait_all()
subroutine acc_wait_all_device(dev_num)
integer(acc_handle_kind) :: wait_arg
integer :: dev_num
Description
A call to an acc_wait routine is functionally equivalent to a wait directive as follows, see Sec-
tion 2163:
	acc_wait to await(wait_arg) directive
	acc_wait_device to await(devnum:dev_num,queues:wait_arg) directive
	acc_wait_all to await directive with no wait-argument 
	acc_wait_all_device to await(devnum:dev_num) directive
wait_arg must be an async-argument as deﬁned in Section 216 Asynchronous Behavior dev_num
must be a valid device number of the current device type
The behavior of the acc_wait routines is:
	If there is no dev_num argument, it is treated as if dev_num is the current device number
	The routine will not return until all asynchronous operations initiated by this host thread on
devicedev_num either on async queue wait_arg (if there is a wait_arg argument) or
on all async queues (if there is no wait_arg argument) have completed
	If two or more threads share the same accelerator, there is no guarantee th at matching asyn-
chronous operations initiated by other threads have completed
For compatibility with OpenACC version 10, acc_wait may also be spelled acc_async_wait ,
andacc_wait_all may also be spelled acc_async_wait_all 
Errors
	Anacc_error_invalid_async error is issued if wait_arg is not a valid async-
argument value
	Anacc_error_device_unavailable error is issued if dev_num is not a valid device
number
See Section 522
3211 acc wait async
Summary
Theacc_wait_async routines enqueue a wait operation on one async queue of the current
device or a speciﬁed device for the operations previously enqueued on a single speciﬁed async
queue or on all other async queues

Format
C or C++:
void acc_wait_async(int wait_arg, int async_arg);
void acc_wait_device_async(int wait_arg, int async_arg,
int dev_num);
void acc_wait_all_async(int async_arg);
void acc_wait_all_device_async(int async_arg, int dev_n um);
Fortran:
subroutine acc_wait_async(wait_arg, async_arg)
subroutine acc_wait_device_async(wait_arg, async_arg, dev_num)
subroutine acc_wait_all_async(async_arg)
subroutine acc_wait_all_device_async(async_arg, dev_n um)
integer(acc_handle_kind) :: wait_arg, async_arg
integer :: dev_num
Description
A call to an acc_wait_async routine is functionally equivalent to a waitasync(async_arg)
directive as follows, see Section 2163:
	A call toacc_wait_async is functionally equivalent to a wait(wait_arg)
async(async_arg) directive
	A call toacc_wait_device_async is functionally equivalent to a wait(devnum:
dev_num,queues:wait_arg)async(async_arg) directive
	A call toacc_wait_all_async is functionally equivalent to a waitasync(async_arg)
directive with no wait-argument 
	A call toacc_wait_all_device_async is functionally equivalent to a
wait(devnum:dev_num)async(async_arg) directive
async_arg andwait_arg must must be async-arguments , as deﬁned in
Section 216 Asynchronous Behavior dev_num must be a valid device number of the current
device type
The behavior of the acc_wait_async routines is:
	If there is no dev_num argument, it is treated as if dev_num is the current device number
	The routine will enqueue a wait operation on the async queue associated w ithasync_arg
for the current device which will wait for operations initiated on the async q ueuewait_arg
of devicedev_num (if there is a wait_arg argument), or for each async queue of device
dev_num (if there is no wait_arg argument)
See Section 216 Asynchronous Behavior for more information
Errors
	Anacc_error_invalid_async error is issued if either async_arg orwait_arg is
not a valid async-argument value
	Anacc_error_device_unavailable error is issued if dev_num is not a valid device
number
See Section 522

3212 acc wait any
Summary
Theacc_wait_any andacc_wait_any_device routines wait for any of the speciﬁed asyn-
chronous queues to complete all pending operations on the current devic e or the speciﬁed device
number, respectively Both routines return the queue’s index in the prov ided array of asynchronous
queues
Format
C or C++:
int acc_wait_any(int count, int wait_arg[]);
int acc_wait_any_device(int count, int wait_arg[], int de v_num);
Fortran:
integer function acc_wait_any(count, wait_arg)
integer function acc_wait_any_device(count, wait_arg, d ev_num)
integer :: count, dev_num
integer(acc_handle_kind) :: wait_arg(count)
Description
wait_arg is an array of async-arguments as deﬁned in Section 216 and count is a nonneg-
ative integer indicating the array length If there is no dev_num argument, it is treated as if
dev_num is the current device number Otherwise, dev_num must be a valid device number
of the current device type A call to any of these routines returns an inde xiassociated with
await_arg[i] that is not acc_async_sync and meets the conditions that would evalu-
ateacc_async_test_device(wait_arg[i], dev_num) totrue If all the elements in
wait_arg are equal to acc_async_sync orcount is equal to 0, these routines return -1
Otherwise, the return value is an integer in the range of 0≤i<count in C or C++ and
1≤i≤count in Fortran
Errors
	Anacc_error_invalid_argument error is issued if count is a negative number
	Anacc_error_invalid_async error is issued if any element encountered in wait_arg
is not a valid async-argument value
	Anacc_error_device_unavailable error is issued if dev_num is not a valid device
number
See Section 522
3213 acc getdefault async
Summary
Theacc_get_default_async routine returns the value of acc-default-async-var for the cur-
rent thread
Format
C or C++:
int acc_get_default_async(void);

Fortran:
function acc_get_default_async()
integer(acc_handle_kind) :: acc_get_default_async
Description
Theacc_get_default_async routine returns the value of acc-default-async-var for the cur-
rent thread, which is the asynchronous queue used when an async clause appears without an
async-argument or with the value acc_async_noval 
3214 acc setdefault async
Summary
Theacc_set_default_async routine tells the runtime which asynchronous queue to use
when anasync clause appears with no queue argument
Format
C or C++:
void acc_set_default_async(int async_arg);
Fortran:
subroutine acc_set_default_async(async_arg)
integer(acc_handle_kind) :: async_arg
Description
A call toacc_set_default_async is functionally equivalent to a setdefault_async(async_arg)
directive, as described in Section 2143 This acc_set_default_async routine tells the
runtime to place any directives with an async clause that does not have an async-argument or
with the special acc_async_noval value into the asynchronous activity queue associated with
async_arg instead of the default asynchronous activity queue for that device by s etting the value
ofacc-default-async-var for the current thread The special argument acc_async_default will
reset the default asynchronous activity queue to the initial value, which is implementation-deﬁned
Errors
	Anacc_error_invalid_async error is issued if async_arg is not a valid async-
argument value
See Section 522
3215 acc ondevice
Summary
Theacc_on_device routine tells the program whether it is executing on a particular device
Format
C or C++:
int acc_on_device(acc_device_t dev_type);
Fortran:
logical function acc_on_device(dev_type)
integer(acc_device_kind) :: dev_type

Description
Theacc_on_device routine may be used to execute different paths depending on whether the
code is running on the host or on some accelerator If the acc_on_device routine has a compile-
time constant argument, the call evaluates at compile time to a constant dev_type must be one
of the deﬁned accelerator types
The behavior of the acc_on_device routine is:
	Ifdev_type isacc_device_host , then outside of a compute region or accelerator rou-
tine, or in a compute region or accelerator routine that is executed on the hos t CPU, a call to
this routine will evaluate to true; otherwise, it will evaluate to false 
	Ifdev_type isacc_device_not_host , the result is the negation of the result with
argumentacc_device_host 
	Ifdev_type is an accelerator device type, then in a compute region or routine that is ex-
ecuted on a device of that type, a call to this routine will evaluate to true; otherwise, it will
evaluate to false 
	The result with argument acc_device_default is undeﬁned
3216 acc malloc
Summary
Theacc_malloc routine allocates space in the current device memory
Format
C or C++:
d_void*acc_malloc(size_t bytes);
Fortran:
type(c_ptr) function acc_malloc(bytes)
integer(c_size_t), value :: bytes
Description
Theacc_malloc routine may be used to allocate space in the current device memory Pointers
assigned from this routine may be used in deviceptr clauses to tell the compiler that the pointer
target is resident on the device In case of an allocation error or if bytes has the value zero,
acc_malloc returns a null pointer
3217 acc free
Summary
Theacc_free routine frees memory on the current device
Format
C or C++:
void acc_free(d_void *data_dev);
Fortran:
subroutine acc_free(data_dev)
type(c_ptr), value :: data_dev

Description
Theacc_free routine will free previously allocated space in the current device memory; data_dev
should be a pointer value that was returned by a call to acc_malloc  Ifdata_dev is a null
pointer, no operation is performed
3218 acc copyin and acc create
Summary
Theacc_copyin andacc_create routines test to see if the argument is in shared memory
or already present in the current device memory; if not, they allocate spac e in the current device
memory to correspond to the speciﬁed local memory, and the acc_copyin routines copy the data
to that device memory
Format
C or C++:
d_void*acc_copyin(h_void *data_arg, size_t bytes);
d_void*acc_create(h_void *data_arg, size_t bytes);

void acc_copyin_async(h_void *data_arg, size_t bytes,
int async_arg);
void acc_create_async(h_void *data_arg, size_t bytes,
int async_arg);

Fortran:
subroutine acc_copyin(data_arg [, bytes ])
subroutine acc_create(data_arg [, bytes ])

subroutine acc_copyin_async(data_arg [, bytes ], async_arg)
subroutine acc_create_async(data_arg [, bytes ], async_arg)

type(*), dimension() :: data_arg
integer :: bytes
integer(acc_handle_kind) :: async_arg
Description
A call to an acc_copyin oracc_create routine is similar to an enterdata directive with
acopyin orcreate clause, respectively, as described in Sections 277 and 279, except th at
noattach action is performed for a pointer reference In C/C++, data_arg is a pointer to the
data, andbytes speciﬁes the data size in bytes; the associated data section starts at the address
indata_arg and continues for bytes bytes The synchronous routines return a pointer to the
allocated device memory, as with acc_malloc  In Fortran, two forms are supported In the ﬁrst,
data_arg is a variable or a contiguous array section; the associated data section starts at the
address of, and continues to the end of the variable or array section In the second, data_arg
is a variable or array element and bytes is the length in bytes; the associated data section starts
at the address of the variable or array element and continues for bytes bytes For the _async
versions of these routines, async_arg must be an async-argument as deﬁned in Section 2
Asynchronous Behavior
The behavior of these routines for the associated data section is:

	If the data section is in shared memory, no action is taken The C/C++ synchronous acc_copyin
andacc_create routines return the incoming pointer
	If the data section is present in the current device memory, the routines perform a present increment
action with the dynamic reference counter The C/C++ synchronous acc_copyin and
acc_create routines return a pointer to the existing device memory
	Otherwise:
		Theacc_copyin routines perform a copyin action with the dynamic reference counter
		Theacc_create routines perform a create action with the dynamic reference counter
The C/C++ synchronous acc_copyin andacc_create routines return a pointer to the
newly allocated device memory
This data may be accessed using the present data clause Pointers assigned from the C/C++
synchronous acc_copyin andacc_create routines may be used in deviceptr clauses to
tell the compiler that the pointer target is resident on the device
The synchronous versions will not return until the memory has been alloca ted and any data transfers
are complete
The_async versions of these routines will perform any data transfers asynchron ously on the async
queue associated with async_arg  The routine may return before the data has been transferred;
see Section 216 Asynchronous Behavior for more details The data will be treated as present in
the current device memory even if the data has not been allocated or transf erred before the routine
returns
For compatibility with OpenACC 20, acc_present_or_copyin andacc_pcopyin are al-
ternate names for acc_copyin , andacc_present_or_create andacc_pcreate are al-
ternate names for acc_create 
Errors
	Anacc_invalid_null_pointer error is issued if data_arg is a null pointer and
bytes is nonzero
	Anacc_error_partly_present error is issued if part of the data section is already
present in the current device memory but all of the data section is not
	Anacc_error_invalid_data_section error is issued if data_arg is an array sec-
tion that is not contiguous (in Fortran)
	Anacc_error_out_of_memory error is issued if the accelerator device does not have
enough memory for the data
	Anacc_error_invalid_async error is issued if async_arg is not a valid async-
argument value
See Section 522
3219 acc copyout and acc delete

Summary
Theacc_copyout andacc_delete routines test to see if the argument is in shared memory;
if not, the argument must be present in the current device memory The acc_copyout routines
copy data from device memory to the corresponding local memory, and both acc_copyout and
acc_delete routines deallocate that space from the device memory
Format
C or C++:
void acc_copyout(h_void *data_arg, size_t bytes);
void acc_delete (h_void *data_arg, size_t bytes);

void acc_copyout_finalize(h_void *data_arg, size_t bytes);
void acc_delete_finalize (h_void *data_arg, size_t bytes);

void acc_copyout_async(h_void *data_arg, size_t bytes,
int async_arg);
void acc_delete_async (h_void *data_arg, size_t bytes,
int async_arg);

void acc_copyout_finalize_async(h_void *data_arg, size_t bytes,
int async_arg);
void acc_delete_finalize_async (h_void *data_arg, size_t bytes,
int async_arg);

Fortran:
subroutine acc_copyout(data_arg [, bytes ])
subroutine acc_delete (data_arg [, bytes ])

subroutine acc_copyout_finalize(data_arg [, bytes ])
subroutine acc_delete_finalize (data_arg [, bytes ])

subroutine acc_copyout_async(data_arg [, bytes ], async_arg)
subroutine acc_delete_async (data_arg [, bytes ], async_arg)

subroutine acc_copyout_finalize_async(data_arg [, bytes ], &
async_arg)
subroutine acc_delete_finalize_async (data_arg [, bytes ], &
async_arg)

type(*), dimension() :: data_arg
integer :: bytes
integer(acc_handle_kind) :: async_arg
Description
A call to an acc_copyout oracc_delete routine is similar to an exit data directive
with acopyout ordelete clause, respectively, and a call to an acc_copyout_finalize
oracc_delete_finalize routine is similar to an exit data finalize directive with a
copyout ordelete clause, respectively, as described in Section 278 and 2711, except th at no

detach action is performed for a pointer reference The arguments and the asso ciated data section
are as foracc_copyin 
The behavior of these routines for the associated data section is:
	If the data section is in shared memory, no action is taken
	If the dynamic reference counter for the data section is zero, no action is taken
	Otherwise, the dynamic reference counter is updated:
		Theacc_copyout andacc_delete ) routines perform a present decrement action
with the dynamic reference counter
		Theacc_copyout_finalize oracc_delete_finalize routines set the dy-
namic reference counter to zero
If both reference counters are then zero:
		Theacc_copyout routines perform a copyout action
		Theacc_delete routines perform a delete action
The synchronous versions will not return until the data has been complete ly transferred and the
memory has been deallocated
The_async versions of these routines will perform any associated data transfers a synchronously
on the async queue associated with async_arg  The routine may return before the data has been
transferred or deallocated; see Section 216 Asynchronous Behavior for more details Even if the
data has not been transferred or deallocated before the routine return s, the data will be treated as not
present in the current device memory if both reference counters are ze ro
Errors
	Anacc_invalid_null_pointer error is issued if data_arg is a null pointer and
bytes is nonzero
	Anacc_error_not_present error is issued if the data section is not in shared memory
and is not present in the current device memory
	Anacc_error_invalid_data_section error is issued if data_arg is an array sec-
tion that is not contiguous (in Fortran)
	Anacc_error_partly_present error is issued if part of the data section is already
present in the current device memory but all of the data section is not
	Anacc_error_invalid_async error is issued if async_arg is not a valid async-
argument value
See Section 522
3220 acc update device and acc update self
Summary
Theacc_update_device andacc_update_self routines test to see if the argument is in
shared memory; if not, the argument must be present in the current device memory, and the routines

update the data in device memory from the corresponding local memory ( acc_update_device )
or update the data in local memory from the corresponding device memory ( acc_update_self )
Format
C or C++:
void acc_update_device(h_void *data_arg, size_t bytes);
void acc_update_self (h_void *data_arg, size_t bytes);

void acc_update_device_async(h_void *data_arg, size_t bytes,
int async_arg);
void acc_update_self_async (h_void *data_arg, size_t bytes,
int async_arg);

Fortran:
subroutine acc_update_device(data_arg [, bytes ])
subroutine acc_update_self (data_arg [, bytes ])

subroutine acc_update_device_async(data_arg [, bytes ], async_arg)
subroutine acc_update_self_async (data_arg [, bytes ], async_arg)

type(*), dimension() :: data_arg
integer :: bytes
integer(acc_handle_kind) :: async_arg
Description
A call to an acc_update_device routine is functionally equivalent to an update device
directive A call to an acc_update_self routine is functionally equivalent to an updateself
directive See Section 2144 The arguments and the data section are as foracc_copyin 
The behavior of these routines for the associated data section is:
	If the data section is in shared memory or bytes is zero, no action is taken
	Otherwise:
		A call to an acc_update_device routine copies the data in the local memory to the
corresponding device memory
		A call to an acc_update_self routine copies the data in the corresponding device
memory to the local memory
The_async versions of these routines will perform the data transfers asynchrono usly on the async
queue associated with async_arg  The routine may return before the data has been transferred;
see Section 216 Asynchronous Behavior for more details The synchro nous versions will not return
until the data has been completely transferred
Errors
	Anacc_invalid_null_pointer error is issued if data_arg is a null pointer and
bytes is nonzero
	Anacc_error_not_present error is issued if the data section is not in shared memory
and is not present in the current device memory

	Anacc_error_invalid_data_section error is issued if data_arg is an array sec-
tion that is not contiguous (in Fortran)
	Anacc_error_partly_present error is issued if part of the data section is already
present in the current device memory but all of the data section is not
	Anacc_error_invalid_async error is issued if async_arg is not a valid async-
argument value
See Section 522
3221 acc map data
Summary
Theacc_map_data routine maps previously allocated space in the current device memory to the
speciﬁed host data
Format
C or C++:
void acc_map_data(h_void *data_arg, d_void *data_dev,
size_t bytes);
Fortran:
subroutine acc_map_data(data_arg, data_dev, bytes)
type(*),dimension( *) :: data_arg
type(c_ptr), value :: data_dev
integer(c_size_t), value :: bytes
Description
A call to the acc_map_data routine is similar to a call to acc_create , except that instead of
allocating new device memory to start a data lifetime, the device address to use fo r the data lifetime
is speciﬁed as an argument data_arg is a host address, data_dev is the corresponding device
address, and bytes is the length in bytes data_dev may be the result of a call to acc_malloc ,
or may come from some other device-speciﬁc API routine The associated data section is as for
acc_copyin 
The behavior of the acc_map_data routine is:
	If the data section is in shared memory, the behavior is undeﬁned
	If any of the data referred to by data_dev is already mapped to any host memory address,
the behavior is undeﬁned
	Otherwise, after this call, when data_arg appears in a data clause, the data_dev address
will be used The dynamic reference count for the data referred to by data_arg is set to
one, but no data movement will occur
Memory mapped by acc_map_data may not have the associated dynamic reference count decre-
mented to zero, except by a call to acc_unmap_data  See Section 267 Reference Counters
Errors
	Anacc_invalid_null_pointer error is issued if either data_arg ordata_dev is
a null pointer

	Anacc_invalid_argument error is issued if bytes is zero
	Anacc_error_present error is issued if any part of the data section is already present
in the current device memory
See Section 522
3222 acc unmap data
Summary
Theacc_unmap_data routine unmaps device data from the speciﬁed host data
Format
C or C++:
void acc_unmap_data(h_void *data_arg);
Fortran:
subroutine acc_unmap_data(data_arg)
type(*),dimension( *) :: data_arg
Description
A call to the acc_unmap_data routine is similar to a call to acc_delete , except the device
memory is not deallocated data_arg is a host address
The behavior of the acc_unmap_data routine is:
	Ifdata_arg was not previously mapped to some device address via a call to acc_map_data ,
the behavior is undeﬁned
	Otherwise, the data lifetime for data_arg is ended The dynamic reference count for
data_arg is set to zero, but no data movement will occur and the corresponding dev ice
memory is not deallocated See Section 267 Reference Counters
Errors
	Anacc_invalid_null_pointer error is issued if data_arg is a null pointer
	Anacc_error_present error is issued if the structured reference count for the any part
of the data is not zero
See Section 522
3223 acc deviceptr
Summary
Theacc_deviceptr routine returns the device pointer associated with a speciﬁc host address 
Format
C or C++:
d_void*acc_deviceptr(h_void *data_arg);
Fortran:
type(c_ptr) function acc_deviceptr(data_arg)
type(*),dimension( *) :: data_arg

Description
Theacc_deviceptr routine returns the device pointer associated with a host address data_arg
is the address of a host variable or array that may have an active lifetime on the current device
The behavior of the acc_deviceptr routine for the data referred to by data_arg is:
	If the data is in shared memory or data_arg is a null pointer, acc_deviceptr returns
the incoming address
	If the data is not present in the current device memory, acc_deviceptr returns a null
pointer
	Otherwise, acc_deviceptr returns the address in the current device memory that corre-
sponds to the address data_arg 
3224 acc hostptr
Summary
Theacc_hostptr routine returns the host pointer associated with a speciﬁc device address 
Format
C or C++:
h_void*acc_hostptr(d_void *data_dev);
Fortran:
type(c_ptr) function acc_hostptr(data_dev)
type(c_ptr), value :: data_dev
Description
Theacc_hostptr routine returns the host pointer associated with a device address data_dev
is the address of a device variable or array, such as that returned fro macc_deviceptr ,acc_create
oracc_copyin 
The behavior of the acc_hostptr routine for the data referred to by data_dev is:
	If the data is in shared memory or data_dev is a null pointer, acc_hostptr returns the
incoming address
	If the data corresponds to a host address which is present in the curre nt device memory,
acc_hostptr returns the host address
	Otherwise, acc_hostptr returns a null pointer
3225 acc ispresent
Summary
Theacc_is_present routine tests whether a variable or array region is accessible from the
current device
Format
C or C++:
int acc_is_present(h_void *data_arg, size_t bytes);

Fortran:
logical function acc_is_present(data_arg)
logical function acc_is_present(data_arg, bytes)
type(*), dimension() :: data_arg
integer :: bytes
Description
Theacc_is_present routine tests whether the speciﬁed host data is accessible from the curren t
device In C/C++, data_arg is a pointer to the data, and bytes speciﬁes the data size in bytes In
Fortran, two forms are supported In the ﬁrst, data_arg is a variable or contiguous array section
In the second, data_arg is a variable or array element and bytes is the length in bytes A
bytes value of zero is treated as a value of one if data_arg is not a null pointer
The behavior of the acc_is_present routines for the data referred to by data_arg is:
	If the data is in shared memory, a call to acc_is_present will evaluate to true
	If the data is present in the current device memory, a call to acc_is_present will evaluate
totrue
	Otherwise, a call to acc_is_present will evaluate to false 
Errors
	Anacc_error_invalid_argument error is issued if bytes is negative (in Fortran)
	Anacc_error_invalid_data_section error is issued if data_arg is an array sec-
tion that is not contiguous (in Fortran)
See Section 522
3226 acc memcpy todevice
Summary
Theacc_memcpy_to_device routine copies data from local memory to device memory
Format
C or C++:
void acc_memcpy_to_device(d_void *data_dev_dest,
h_void*data_host_src, size_t bytes);
void acc_memcpy_to_device_async(d_void *data_dev_dest,
h_void*data_host_src, size_t bytes,
int async_arg);
Fortran:
subroutine acc_memcpy_to_device(data_dev_dest,
data_host_src, bytes)
subroutine acc_memcpy_to_device_async(data_dev_dest,
data_host_src, bytes, async_arg)
type(c_ptr), value :: data_dev_dest
type(*),dimension( *) :: data_host_src
integer(c_size_t), value :: bytes
integer(acc_handle_kind), value :: async_arg

Description
Theacc_memcpy_to_device routine copies bytes bytes of data from the local address in
data_host_src to the device address in data_dev_dest data_dev_dest must be an
address accessible from the current device, such as an address re turned from acc_malloc or
acc_deviceptr , or an address in shared memory
The behavior of the acc_memcpy_to_device routines is:
	Ifbytes is zero, no action is taken
	Ifdata_dev_dest anddata_host_src both refer to shared memory and have the same
value, no action is taken
	Ifdata_dev_dest anddata_host_src both refer to shared memory and the memory
regions overlap, the behavior is undeﬁned
	If the data referred to by data_dev_dest is not accessible by the current device, the be-
havior is undeﬁned
	If the data referred to by data_host_src is not accessible by the local thread, the behavior
is undeﬁned
	Otherwise, bytes bytes of data at data_host_src in local memory are copied to
data_dev_dest in the current device memory
The_async version of this routine will perform the data transfers asynchronously o n the async
queue associated with async_arg  The routine may return before the data has been transferred;
see Section 216 Asynchronous Behavior for more details The synchro nous versions will not return
until the data has been completely transferred
Errors
	Anacc_error_invalid_null_pointer error is issued if data_dev_dest or
data_host_src is a null pointer and bytes is nonzero
	Anacc_error_invalid_async error is issued if async_arg is not a valid async-
argument value
See Section 522
3227 acc memcpy from device
Summary
Theacc_memcpy_from_device routine copies data from device memory to local memory
Format
C or C++:
void acc_memcpy_from_device(h_void *data_host_dest,
d_void*data_dev_src, size_t bytes);
void acc_memcpy_from_device_async(h_void *data_host_dest,
d_void*data_dev_src, size_t bytes,
int async_arg);
Fortran:
subroutine acc_memcpy_from_device(data_host_dest,

data_dev_src, bytes)
subroutine acc_memcpy_from_device_async(data_host_de st,
data_dev_src, bytes, async_arg)
type(*),dimension( *) :: data_host_dest
type(c_ptr), value :: data_dev_src
integer(c_size_t), value :: bytes
integer(acc_handle_kind), value :: async_arg
Description
Theacc_memcpy_from_device routine copies bytes bytes of data from the device address
indata_dev_src to the local address in data_host_dest data_dev_src must be an
address accessible from the current device, such as an address re turned from acc_malloc or
acc_deviceptr , or an address in shared memory
The behavior of the acc_memcpy_from_device routines is:
	Ifbytes is zero, no action is taken
	Ifdata_host_dest anddata_dev_src both refer to shared memory and have the same
value, no action is taken
	Ifdata_host_dest anddata_dev_src both refer to shared memory and the memory
regions overlap, the behavior is undeﬁned
	If the data referred to by data_dev_src is not accessible by the current device, the behav-
ior is undeﬁned
	If the data referred to by data_host_dest is not accessible by the local thread, the behav-
ior is undeﬁned
	Otherwise, bytes bytes of data at data_dev_src in the current device memory are copied
todata_host_dest in local memory
The_async version of this routine will perform the data transfers asynchronously o n the async
queue associated with async_arg  The routine may return before the data has been transferred;
see Section 216 Asynchronous Behavior for more details The synchro nous versions will not return
until the data has been completely transferred
Errors
	Anacc_error_invalid_null_pointer error is issued if data_host_dest or
data_dev_src is a null pointer and bytes is nonzero
	Anacc_error_invalid_async error is issued if async_arg is not a valid async-
argument value
See Section 522
3228 acc memcpy device
Summary
Theacc_memcpy_device routine copies data from one memory location to another memory
location on the current device

Format
C or C++:
void acc_memcpy_device(d_void *data_dev_dest,
d_void*data_dev_src, size_t bytes);
void acc_memcpy_device_async(d_void *data_dev_dest,
d_void*data_dev_src, size_t bytes,
int async_arg);
Fortran:
subroutine acc_memcpy_device(data_dev_dest,
data_dev_src, bytes);
subroutine acc_memcpy_device_async(data_dev_dest,
data_dev_src, bytes,
async_arg);
type(c_ptr), value :: data_dev_dest
type(c_ptr), value :: data_dev_src
integer(c_size_t), value :: bytes
integer(acc_handle_kind), value :: async_arg
Description
Theacc_memcpy_device routine copies bytes bytes of data from the device address in
data_dev_src to the device address in data_dev_dest  Both addresses must be addresses in
the current device memory, such as would be returned from acc_malloc oracc_deviceptr 
The behavior of the acc_memcpy_device routines is:
	Ifbytes is zero, no action is taken
	Ifdata_dev_dest anddata_dev_src have the same value, no action is taken
	If the memory regions referred to by data_dev_dest anddata_dev_src overlap, the
behavior is undeﬁned
	If the data referred to by data_dev_src ordata_dev_dest is not accessible by the
current device, the behavior is undeﬁned
	Otherwise, bytes bytes of data at data_dev_src in the current device memory are copied
todata_dev_dest in the current device memory
The_async version of this routine will perform the data transfers asynchronously o n the async
queue associated with async_arg  The routine may return before the data has been transferred;
see Section 216 Asynchronous Behavior for more details The synchro nous versions will not return
until the data has been completely transferred
Errors
	Anacc_error_invalid_null_pointer error is issued if data_dev_dest or
data_dev_src is a null pointer and bytes is nonzero
	Anacc_error_invalid_async error is issued if async_arg is not a valid async-
argument value
See Section 522

3229 acc attach and acc detach
Summary
Theacc_attach routines update a pointer in device memory to point to the corresponding devic e
copy of the host pointer target The acc_detach routines restore a pointer in device memory to
point to the host pointer target
Format
C or C++:
void acc_attach(h_void **ptr_addr);
void acc_attach_async(h_void **ptr_addr, int async_arg);

void acc_detach(h_void **ptr_addr);
void acc_detach_async(h_void **ptr_addr, int async_arg);
void acc_detach_finalize(h_void **ptr_addr);
void acc_detach_finalize_async(h_void **ptr_addr,
int async_arg);
Fortran:
subroutine acc_attach(ptr_addr)
subroutine acc_attach_async(ptr_addr, async_arg)
type(*),dimension() :: ptr_addr
integer(acc_handle_kind),value :: async_arg

subroutine acc_detach(ptr_addr)
subroutine acc_detach_async(ptr_addr, async_arg)
subroutine acc_detach_finalize(ptr_addr)
subroutine acc_detach_finalize_async(ptr_addr,
async_arg)
type(*),dimension() :: ptr_addr
integer(acc_handle_kind),value :: async_arg
Description
A call to an acc_attach routine is functionally equivalent to an enter data attach direc-
tive, as described in Section 2712 A call to an acc_detach routine is functionally equivalent to
anexitdatadetach directive, and a call to an acc_detach_finalize routine is function-
ally equivalent to an exit data finalize detach directive, as described in Section 2713
ptr_addr must be the address of a host pointer async_arg must be an async-argument as
deﬁned in Section 216
The behavior of these routines is:
	Ifptr_addr refers to shared memory, no action is taken
	If the pointer referred to by ptr_addr is not present in the current device memory, no action
is taken
	Otherwise:
		Theacc_attach routines perform an attach action on the pointer referred to by
ptr_addr ; see Section 272

		Theacc_detach routines perform a detach action on the pointer referred to by ptr_addr ;
See Section 272
		Theacc_detach_finalize routines perform an immediate detach action on the
pointer referred to by ptr_addr ; see Section 272
These routines may issue a data transfer from local memory to device memory The_async ver-
sions of these routines will perform the data transfers asynchronously on the async queue associated
withasync_arg  These routines may return before the data has been transferred; see Section 2
for more details The synchronous versions will not return until the data h as been completely trans-
ferred
Errors
	Anacc_error_invalid_null_pointer error is issued if ptr_addr is a null pointer
	Anacc_error_invalid_async error is issued if async_arg is not a valid async-
argument value
See Section 522
3230 acc memcpy d2d
Summary
Theacc_memcpy_d2d routines copy the contents of an array on one device to an array on the
same or a different device without updating the value on the host
Format
C or C++:
void acc_memcpy_d2d(h_void *data_arg_dest,
h_void*data_arg_src, size_t bytes,
int dev_num_dest, int dev_num_src);
void acc_memcpy_d2d_async(h_void *data_arg_dest,
h_void*data_arg_src, size_t bytes,
int dev_num_dest, int dev_num_src,
int async_arg_src);

Fortran:
subroutine acc_memcpy_d2d(data_arg_dest, data_arg_src ,&
bytes, dev_num_dest, dev_num_src)
subroutine acc_memcpy_d2d_async(data_arg_dest, data_a rg_src,&
bytes, dev_num_dest, dev_num_src,&
async_arg_src)
type(*), dimension() :: data_arg_dest
type(*), dimension() :: data_arg_src
integer :: bytes
integer :: dev_num_dest
integer :: dev_num_src
integer :: async_arg_src


Description
Theacc_memcpy_d2d routines are passed the address of destination and source host data as well
as integer device numbers for the destination and source devices, which mu st both be of the current
device type
The behavior of the acc_memcpy_d2d routines is:
	Ifbytes is zero, no action is taken
	If both pointers have the same value and either the two device numbers are the same or the
addresses are in shared memory, then no action is taken
	Otherwise, bytes bytes of data at the device address corresponding to data_arg_src on
devicedev_num_src are copied to the device address corresponding to data_arg_dest
on devicedev_num_dest 
Foracc_memcpy_d2d_async the value of async_arg_src is the number of an async queue
on the source device This routine will perform the data transfers async hronously on the async queue
associated with async_arg_src for devicedev_num_src ; see Section 216 Asynchronous Behavior
for more details
Errors
	Anacc_error_device_unavailable error is issued if dev_num_dest ordev_num_src
is not a valid device number
	Anacc_error_invalid_null_pointer error is issued if either data_arg_dest
ordata_arg_src is a null pointer and bytes is nonzero
	Anacc_error_not_present error is issued if the data at either address is not in shared
memory and is not present in the respective device memory
	Anacc_error_partly_present error is issued if part of the data is already present in
the current device memory but all of the data is not
	Anacc_error_invalid_async error is issued if async_arg is not a valid async-
argument value
See Section 522

4 Environment Variables
This chapter describes the environment variables that modify the behavior of accelerator regions
The names of the environment variables must be upper case The values a ssigned environment
variables are case-insensitive and may have leading and trailing whitespac e If the values of the
environment variables change after the program has started, even if the program itself modiﬁes the
values, the behavior is implementation-deﬁned
41 ACC DEVICE TYPE
TheACC_DEVICE_TYPE environment variable controls the default device type to use when ex-
ecuting parallel, serial, and kernels regions, if the program has been co mpiled to use more than
one different type of device The allowed values of this environment var iable are implementation-
deﬁned See the release notes for currently-supported values of this e nvironment variable
Example:
setenv ACC_DEVICE_TYPE NVIDIA
export ACC_DEVICE_TYPE=NVIDIA
42 ACC DEVICE NUM
TheACC_DEVICE_NUM environment variable controls the default device number to use when
executing accelerator regions The value of this environment variable mus t be a nonnegative integer
between zero and the number of devices of the desired type attached to the h ost If the value is
greater than or equal to the number of devices attached, the behavior is imple mentation-deﬁned
Example:
setenv ACC_DEVICE_NUM
export ACC_DEVICE_NUM=
43 ACC PROFLIB
TheACC_PROFLIB environment variable speciﬁes the proﬁling library More details about the
evaluation at runtime is given in section 533 Runtime Dynamic Library Loading
Example:
setenv ACC_PROFLIB /path/to/proflib/libaccprofso
export ACC_PROFLIB=/path/to/proflib/libaccprofso


5 Proﬁling and Error Callback Interface
This chapter describes the OpenACC interface for runtime callback routine s These routines may be
provided by the programmer or by a tool or library developer Calls to these routines are triggered
during the application execution at speciﬁc OpenACC events There are tw o classes of events,
proﬁling events and error events Proﬁling events can be used by tools f or proﬁle or trace data
collection Currently, this interface does not support tools that employ asy nchronous sampling
Error events can be used to release resources or cleanly shut down a large parallel application when
the OpenACC runtime detects an error condition from which it cannot recov er This is speciﬁcally
for error handling, not for error recovery There is no support p rovided for restarting or retrying
an OpenACC program, construct, or API routine after an error condition has been detected and an
error callback routine has been called
In this chapter, the term runtime refers to the OpenACC runtime library The term library refers to
the routines invoked at speciﬁed events by the OpenACC runtime
There are three steps for interfacing a library to the runtime  The ﬁrst step is to write the library
callback routines Section 51 Events describes the supported runtime even ts and the order in which
callbacks to the callback routines will occur Section 52 Callbacks Signature describes the signature
of the callback routines for all events
The second step is to load the library at runtime The library may be statically linked to the appli-
cation or dynamically loaded by the application, a library, or a tool This is desc ribed in Section 5
Loading the Library
The third step is to register the desired callbacks with the events This may be do ne explicitly by the
application, if the library is statically linked with the application, implicitly by including a c all to a
registration routine in a init section, or by including an initialization routine in the library if it is
dynamically loaded by the runtime  This is described in Section 54 Registering Event Callbacks
51 Events
This section describes the events that are recognized by the runtime Most proﬁling events have a
start and end callback routine, that is, a routine that is called just before th e runtime code to handle
the event starts and another routine that is called just after the event is han dled The event names
and routine prototypes are available in the header ﬁle acc_callbackh , which is delivered with
the OpenACC implementation For backward compatibility with previous versions o f OpenACC,
the implementation also delivers the same information in acc_profh  Event names are preﬁxed
withacc_ev_ 
The ordering of events must reﬂect the order in which the OpenACC runtime actually executes them,
ie if a runtime moves the enqueuing of data transfers or kernel launches o utside the originating
clauses/constructs, it needs to issue the corresponding launch callback s when they really occur A
callback for a start event must always precede the matching end callback  No callbacks will be
issued after a runtime shutdown event
The events that the runtime supports can be registered with a callback and ar e deﬁned in the enu-
meration type acc_event_t 

typedef enum acc_event_t {
acc_ev_none = 0,
acc_ev_device_init_start = 1,
acc_ev_device_init_end = 2,
acc_ev_device_shutdown_start = 3,
acc_ev_device_shutdown_end = 4,
acc_ev_runtime_shutdown = 5,
acc_ev_create = 6,
acc_ev_delete = 7,
acc_ev_alloc = 8,
acc_ev_free = 9,
acc_ev_enter_data_start = 10,
acc_ev_enter_data_end = 11,
acc_ev_exit_data_start = 12,
acc_ev_exit_data_end = 13,
acc_ev_update_start = 14,
acc_ev_update_end = 15,
acc_ev_compute_construct_start = 16,
acc_ev_compute_construct_end = 17,
acc_ev_enqueue_launch_start = 18,
acc_ev_enqueue_launch_end = 19,
acc_ev_enqueue_upload_start = 20,
acc_ev_enqueue_upload_end = 21,
acc_ev_enqueue_download_start = 22,
acc_ev_enqueue_download_end = 23,
acc_ev_wait_start = 24,
acc_ev_wait_end = 25,
acc_ev_error = 100,
acc_ev_last =
}acc_event_t;
The value of acc_ev_last will change if new events are added to the enumeration, so a library
should not depend on that value
511 Runtime Initialization and Shutdown
No callbacks can be registered for the runtime initialization Instead the initializatio n of the tool is
handled as described in Section 53 Loading the Library
Theruntime shutdown proﬁling event name is
acc_ev_runtime_shutdown
This event is triggered before the OpenACC runtime shuts down, either bec ause all devices have
been shutdown by calls to the acc_shutdown API routine, or at the end of the program
512 Device Initialization and Shutdown
Thedevice initialization proﬁling event names are

acc_ev_device_init_start
acc_ev_device_init_end
These events are triggered when a device is being initialized by the OpenACC runtime This may be
when the program starts, or may be later during execution when the progra m reaches an acc_init
call or an OpenACC construct The acc_ev_device_init_start is triggered before device
initialization starts and acc_ev_device_init_end after initialization is complete
Thedevice shutdown proﬁling event names are
acc_ev_device_shutdown_start
acc_ev_device_shutdown_end
These events are triggered when a device is shut down, most likely by a ca ll to the OpenACC
acc_shutdown API routine The acc_ev_device_shutdown_start is triggered before
the device shutdown process starts and acc_ev_device_shutdown_end after the device shut-
down is complete
513 Enter Data and Exit Data
Theenter data proﬁling event names are
acc_ev_enter_data_start
acc_ev_enter_data_end
These events are triggered at enterdata directives, entry to data constructs, and entry to implicit
data regions such as those generated by compute constructs The acc_ev_enter_data_start
event is triggered before any data allocation ,data update , orwait events that are associated with
that directive or region entry, and the acc_ev_enter_data_end is triggered after those events
Theexit data proﬁling event names are
acc_ev_exit_data_start
acc_ev_exit_data_end
These events are triggered at exit data directives, exit from data constructs, and exit from
implicit data regions The acc_ev_exit_data_start event is triggered before any data
deallocation ,data update , or wait events associated with that directive or region exit, and the
acc_ev_exit_data_end event is triggered after those events
When the construct that triggers an enter data orexit data event was generated implicitly by the
compiler the implicit ﬁeld in the event structure will be set to 1 When the construct that
triggers these events was speciﬁed explicitly by the application code the implicit ﬁeld in the
event structure will be set to 0
514 Data Allocation
Thedata allocation proﬁling event names are
acc_ev_create
acc_ev_delete
acc_ev_alloc
acc_ev_free

Anacc_ev_alloc event is triggered when the OpenACC runtime allocates memory from the de-
vice memory pool, and an acc_ev_free event is triggered when the runtime frees that memory
Anacc_ev_create event is triggered when the OpenACC runtime associates device memory
with local memory, such as for a data clause ( create ,copyin ,copy ,copyout ) at entry to
a data construct, compute construct, at an enter data directive, or in a call to a data API rou-
tine (acc_copyin ,acc_create ,    ) An acc_ev_create event may be preceded by an
acc_ev_alloc event, if newly allocated memory is used for this device data, or it may not, if
the runtime manages its own memory pool An acc_ev_delete event is triggered when the
OpenACC runtime disassociates device memory from local memory, such as fo r a data clause at
exit from a data construct, compute construct, at an exitdata directive, or in a call to a data API
routine (acc_copyout ,acc_delete ,    ) Anacc_ev_delete event may be followed by
anacc_ev_free event, if the disassociated device memory is freed, or it may not, if the runtime
manages its own memory pool
When the action that generates a data allocation event was generated explicitly by the application
code theimplicit ﬁeld in the event structure will be set to 0 When the data allocation event
is triggered because of a variable or array with implicitly-determined data attribu tes or otherwise
implicitly by the compiler the implicit ﬁeld in the event structure will be set to 1
515 Data Construct
The proﬁling events for entering and leaving data constructs are mapped to enter data andexit data
events as described in Section 513 Enter Data and Exit Data
516 Update Directive
Theupdate directive proﬁling event names are
acc_ev_update_start
acc_ev_update_end
Theacc_ev_update_start event will be triggered at an update directive, before any data
update orwait events that are associated with the update directive are carried out, and th e corre-
spondingacc_ev_update_end event will be triggered after any of the associated events
517 Compute Construct
Thecompute construct proﬁling event names are
acc_ev_compute_construct_start
acc_ev_compute_construct_end
Theacc_ev_compute_construct_start event is triggered at entry to a compute construct,
before any launch events that are associated with entry to the compute construct The
acc_ev_compute_construct_end event is triggered at the exit of the compute construct,
after any launch events associated with exit from the compute construct If there are data cla uses
on the compute construct, those data clauses may be treated as part of the co mpute construct, or as
part of a data construct containing the compute construct The callbacks f or data clauses must use
the same line numbers as for the compute construct events

518 Enqueue Kernel Launch
Thelaunch proﬁling event names are
acc_ev_enqueue_launch_start
acc_ev_enqueue_launch_end
Theacc_ev_enqueue_launch_start event is triggered just before an accelerator compu-
tation is enqueued for execution on a device, and acc_ev_enqueue_launch_end is trig-
gered just after the computation is enqueued Note that these events are sy nchronous with the
local thread enqueueing the computation to a device, not with the device exec uting the compu-
tation The acc_ev_enqueue_launch_start event callback routine is invoked just before
the computation is enqueued, not just before the computation starts execution  More importantly,
theacc_ev_enqueue_launch_end event callback routine is invoked after the computation is
enqueued, not after the computation ﬁnished executing
Note: Measuring the time between the start and end launch callbacks is often unlikely to be useful,
since it will only measure the time to manage the launch queue, not the time to execute the code on
the device
519 Enqueue Data Update (Upload and Download)
Thedata update proﬁling event names are
acc_ev_enqueue_upload_start
acc_ev_enqueue_upload_end
acc_ev_enqueue_download_start
acc_ev_enqueue_download_end
The_start events are triggered just before each upload (data copy from local memo ry to device
memory) operation is or download (data copy from device memory to local memor y) operation is
enqueued for execution on a device The corresponding _end events are triggered just after each
upload or download operation is enqueued
Note: Measuring the time between the start and end update callbacks is often unlikely to be useful,
since it will only measure the time to manage the enqueue operation, not the time to pe rform the
actual upload or download
When the action that generates a data update event was generated explicitly by the application
code theimplicit ﬁeld in the event structure will be set to 0 When the data allocation event
is triggered because of a variable or array with implicitly-determined data attribu tes or otherwise
implicitly by the compiler the implicit ﬁeld in the event structure will be set to 1
5110 Wait
Thewait proﬁling event names are
acc_ev_wait_start
acc_ev_wait_end

Anacc_ev_wait_start event will be triggered for each relevant queue before the local threa d
waits for that queue to be empty A acc_ev_wait_end event will be triggered for each relevant

queue after the local thread has determined that the queue is empty
Wait events occur when the local thread and a device synchronize, eithe r due to await directive
or by a wait clause on a synchronous data construct, compute construct, or enter data ,exit
data , orupdate directive For wait events triggered by an explicit synchronous wait directive
orwait clause, the implicit ﬁeld in the event structure will be 0 For all other wait events, the
implicit ﬁeld in the event structure will be 1
The OpenACC runtime need not trigger wait events for queues that have not been used in the
program, and need not trigger wait events for queues that have not been used by this thread since
the last wait operation For instance, an accwait directive with no arguments is deﬁned to wait on
all queues If the program only uses the default (synchronous) que ue and the queue associated with
async(1) andasync(2) then anacc wait directive may trigger wait events only for those
three queues If the implementation knows that no activities have been enque ued on theasync(2)
queue since the last wait operation, then the accwait directive may trigger wait events only for
the default queue and the async(1) queue
5111 Error Event
The only error event is
acc_ev_error
Anacc_ev_error event is triggered when the OpenACC program detects a runtime error con -
dition The default runtime error callback routine may print an error messag e and halt program
execution An application can register additional error event callback ro utines, to allow a failing
application to release resources or to cleanly shut down a large parallel r untime with many threads
and processes, for instance
The application can register multiple alternate error callbacks As described in Section
541 Multiple Callbacks, the callbacks will be invoked in the order in which they a re registered
If all the error callbacks return, the default error callback will be invok ed The error callback
routine must not execute any OpenACC compute or data constructs The on ly OpenACC API
routines that can be safely invoked from an error callback routine are acc_get_property ,
acc_get_property_string , andacc_shutdown 
52 Callbacks Signature
This section describes the signature of event callbacks All event callba cks have the same signature
The routine prototypes are available in the header ﬁle acc_callbackh , which is delivered with
the OpenACC implementation
All callback routines have three arguments The ﬁrst argument is a pointer to a struct containing
general information; the same struct type is used for all callback events T he second argument is
a pointer to a struct containing information speciﬁc to that callback event; ther e is one struct type
containing information for data events, another struct type containing infor mation for kernel launch
events, and a third struct type for other events, containing essentially no in formation The third
argument is a pointer to a struct containing information about the application pr ogramming interface
(API) being used for the speciﬁc device For NVIDIA CUDA devices, th is contains CUDA-speciﬁc
information; for OpenCL devices, this contains OpenCL-speciﬁc informatio n Other interfaces can
be supported as they are added by implementations The prototype for a callb ack routine is:

typedef void ( *acc_callback)
(acc_callback_info *, acc_event_info *, acc_api_info *);
typedef acc_callback acc_prof_callback;
In the descriptions, the datatype ssize_t means a signed 32-bit integer for a 32-bit binary and
a 64-bit integer for a 64-bit binary, the datatype size_t means an unsigned 32-bit integer for a
32-bit binary and a 64-bit integer for a 64-bit binary, and the datatype int means a 32-bit integer
for both 32-bit and 64-bit binaries
521 First Argument: General Information
The ﬁrst argument is a pointer to the acc_callback_info struct type:
typedef struct acc_prof_info {
acc_event_t event_type;
int valid_bytes;
int version;
acc_device_t device_type;
int device_number;
int thread_id;
ssize_t async;
ssize_t async_queue;
const char *src_file;
const char *func_name;
int line_no, end_line_no;
int func_line_no, func_end_line_no;
}acc_callback_info;
typedef struct acc_prof_info acc_prof_info;
The nameacc_prof_info is preserved for backward compatibility with previous versions of
OpenACC The ﬁelds are described below
	acc_event_t event_type - The event type that triggered this callback The datatype
is the enumeration type acc_event_t , described in the previous section This allows the
same callback routine to be used for different events
	intvalid_bytes - The number of valid bytes in this struct This allows a library to inter-
face with newer runtimes that may add new ﬁelds to the struct at the end while re taining com-
patibility with older runtimes A runtime must ﬁll in the event_type andvalid_bytes
ﬁelds, and must ﬁll in values for all ﬁelds with offset less than valid_bytes  The value of
valid_bytes for a struct is recursively deﬁned as:
valid_bytes(struct) = offset(lastfield) + valid_bytes(l astfield)
valid_bytes(type[n]) = (n-1) *sizeof(type) + valid_bytes(type)
valid_bytes(basictype) = sizeof(basictype)
	intversion - A version number; the value of _OPENACC 
	acc_device_tdevice_type - The device type corresponding to this event The datatype
isacc_device_t , an enumeration type of all the supported device types, deﬁned in openacch 
	intdevice_number - The device number Each device is numbered, typically starting at

device zero For applications that use more than one device type, the devic e numbers may be
unique across all devices or may be unique only across all devices of the same device type
	intthread_id - The host thread ID making the callback Host threads are given unique
thread ID numbers typically starting at zero This is not necessarily the same as the OpenMP
thread number
	ssize_tasync - The async-value used for operations associated with this event; see Sec-
tion 216 Asynchronous Behavior
	ssize_t async_queue - The actual activity queue onto which the async ﬁeld gets
mapped; see Section 216 Asynchronous Behavior
	const char *src_file - A pointer to null-terminated string containing the name of or
path to the source ﬁle, if known, or a null pointer if not If the library wants to save the source
ﬁle name, it should allocate memory and copy the string
	constchar *func_name - A pointer to a null-terminated string containing the name of
the function in which the event occurred, if known, or a null pointer if not If the library wants
to save the function name, it should allocate memory and copy the string
	int line_no - The line number of the directive or program construct or the starting line
number of the OpenACC construct corresponding to the event A negativ e or zero value
means the line number is not known
	intend_line_no - For an OpenACC construct, this contains the line number of the end
of the construct A negative or zero value means the line number is not know n
	intfunc_line_no - The line number of the ﬁrst line of the function named in func_name 
A negative or zero value means the line number is not known
	intfunc_end_line_no - The last line number of the function named in func_name 
A negative or zero value means the line number is not known
522 Second Argument: Event-Speciﬁc Information
The second argument is a pointer to the acc_event_info union type
typedef union acc_event_info {
acc_event_t event_type;
acc_data_event_info data_event;
acc_launch_event_info launch_event;
acc_other_event_info other_event;
}acc_event_info;
Theevent_type ﬁeld selects which union member to use The ﬁrst ﬁve members of each union
member are identical The second through ﬁfth members of each union member ( valid_bytes ,
parent_construct ,implicit , andtool_info ) have the same semantics for all event
types:
	intvalid_bytes - The number of valid bytes in the respective struct (This ﬁeld is similar
used as discussed in Section 521 First Argument: General Information)

	acc_construct_t parent_construct - This ﬁeld describes the type of construct
that caused the event to be emitted The possible values for this ﬁeld are deﬁ ned by the
acc_construct_t enum, described at the end of this section
	int implicit - This ﬁeld is set to 1 for any implicit event, such as an implicit wait at
a synchronous data construct or synchronous enter data, exit data o r update directive This
ﬁeld is set to zero when the event is triggered by an explicit directive or ca ll to a runtime API
routine
	void*tool_info - This ﬁeld is used to pass tool-speciﬁc information from a _start
event to the matching _end event For a _start event callback, this ﬁeld will be initialized
to a null pointer The value of this ﬁeld for a _end event will be the value returned by the
library in this ﬁeld from the matching _start event callback, if there was one, or a null
pointer otherwise For events that are neither _start or_end events, this ﬁeld will be a
null pointer
Data Events
For a data event, as noted in the event descriptions, the second argument will be a pointer to the
acc_data_event_info struct
typedef struct acc_data_event_info {
acc_event_t event_type;
int valid_bytes;
acc_construct_t parent_construct;
int implicit;
void*tool_info;
const char *var_name;
size_t bytes;
const void *host_ptr;
const void *device_ptr;
}acc_data_event_info;
The ﬁelds speciﬁc for a data event are:
	acc_event_tevent_type - The event type that triggered this callback The events that
use theacc_data_event_info struct are:
acc_ev_enqueue_upload_start
acc_ev_enqueue_upload_end
acc_ev_enqueue_download_start
acc_ev_enqueue_download_end
acc_ev_create
acc_ev_delete
acc_ev_alloc
acc_ev_free
	constchar *var_name - A pointer to null-terminated string containing the name of the
variable for which this event is triggered, if known, or a null pointer if not If the library wants
to save the variable name, it should allocate memory and copy the string
	size_tbytes - The number of bytes for the data event

	const void *host_ptr - If available and appropriate for this event, this is a pointer to
the host data
	constvoid *device_ptr - If available and appropriate for this event, this is a pointer
to the corresponding device data
Launch Events
For a launch event, as noted in the event descriptions, the second argume nt will be a pointer to the
acc_launch_event_info struct
typedef struct acc_launch_event_info {
acc_event_t event_type;
int valid_bytes;
acc_construct_t parent_construct;
int implicit;
void*tool_info;
const char *kernel_name;
size_t num_gangs, num_workers, vector_length;
size_t*num_gangs_per_dim;
}acc_launch_event_info;
The ﬁelds speciﬁc for a launch event are:
	acc_event_tevent_type - The event type that triggered this callback The events that
use theacc_launch_event_info struct are:
acc_ev_enqueue_launch_start
acc_ev_enqueue_launch_end
	constchar *kernel_name - A pointer to null-terminated string containing the name of
the kernel being launched, if known, or a null pointer if not If the library wants to save the
kernel name, it should allocate memory and copy the string
	size_tnum_gangs,num_workers,vector_length - The number of gangs, work-
ers, and vector lanes created for this kernel launch
	size_t*num_gangs_per_dim - An array of size_t whose ﬁrst element indicates the
number of dimensions of gang parallelism and each subsequent element gi ves the number of
gangs along each dimension starting with dimension 1 The product of the valu es of elements
1 throughnum_gangs_per_dim[0] isnum_gangs 
Error Events
For an error event, as noted in the event descriptions, the second argu ment will be a pointer to the
acc_error_event_info struct
typedef struct acc_error_event_info {
acc_event_t event_type;
int valid_bytes;
acc_construct_t parent_construct;
int implicit;
void*tool_info;

acc_error_t error_code;
const char *error_message;
size_t runtime_info;
}acc_error_event_info;
The enumeration type for the error code is
typedef enum acc_error_t {
acc_error_none = 0,
acc_error_other = 1,
acc_error_system = 2,
acc_error_execution = 3,
acc_error_device_init = 4,
acc_error_device_shutdown = 5,
acc_error_device_unavailable = 6,
acc_error_device_type_unavailable = 7,
acc_error_wrong_device_type = 8,
acc_error_out_of_memory = 9,
acc_error_not_present = 10,
acc_error_partly_present = 11,
acc_error_present = 12,
acc_error_invalid_argument = 13,
acc_error_invalid_async = 14,
acc_error_invalid_null_pointer = 15,
acc_error_invalid_data_section = 16,
acc_error_implementation_defined =
}acc_error_t;
The ﬁelds speciﬁc for an error event are:
	acc_event_tevent_type - The event type that triggered this callback The only event
that uses the acc_error_event_info struct is:
acc_ev_error
	intimplicit - This will be set to 1
	acc_error_terror_code - The error codes used are:
		acc_error_other is used for error conditions other than those described below
		acc_error_system is used when there is a system error condition
		acc_error_execution is used when there is an error condition issued from code
executing on the device
		acc_error_device_init is used for any error initializing a device
		acc_error_device_shutdown is used for any error shutting down a device
		acc_error_device_unavailable is used when there is an error where the se-
lected device is unavailable
		acc_error_device_type_unavailable is used when there is an error where
no device of the selected device type is available or is supported

		acc_error_wrong_device_type is used when there is an error related to the
device type, such as a mismatch between the device type for which a compute co nstruct
was compiled and the device available at runtime
		acc_error_out_of_memory is used when the program tries to allocate more mem-
ory on the device than is available
		acc_error_not_present is used for an error related to data not being present at
runtime
		acc_error_partly_present is used for an error related to part of the data being
present but not being completely present at runtime
		acc_error_present is used for an error related to data being unexpectedly present
at runtime
		acc_error_invalid_argument is used when an API routine is called with a
invalid argument value, other than those described above
		acc_error_invalid_async is used when an API routine is called with an invalid
async-argument , or when a directive is used with an invalid async-argument 
		acc_error_invalid_null_pointer is used when an API routine is called with
a null pointer argument where it is invalid, or when a directive is used with a n ull pointer
in a context where it is invalid
		acc_error_invalid_data_section is used when an invalid array section ap-
pears in a directive data clause, or an invalid array section appears as a runtime API call
argument
		acc_error_implementation_defined : any value greater or equal to this value
may be used for an implementation-deﬁned error code
	constchar *error_message - A pointer to null-terminated string containing an error
message from the OpenACC runtime describing the error, or a null pointer
	size_t runtime_info - A value, such as an error code, from the underlying device
runtime or driver, if one is available and appropriate
Other Events
For any event that does not use the acc_data_event_info ,acc_launch_event_info , or
acc_error_event_info struct, the second argument to the callback routine will be a pointer
toacc_other_event_info struct
typedef struct acc_other_event_info {
acc_event_t event_type;
int valid_bytes;
acc_construct_t parent_construct;
int implicit;
void*tool_info;
}acc_other_event_info;

Parent Construct Enumeration
All event structures contain a parent_construct member that describes the type of construct
that caused the event to be emitted The purpose of this ﬁeld is to provide a mea ns to identify
the type of construct emitting the event in the cases where an event may be emitte d by multi-
ple contruct types, such as is the case with data and wait events The poss ible values for the
parent_construct ﬁeld are deﬁned in the enumeration type acc_construct_t  In the
case of combined directives, the outermost construct of the combined con struct should be speciﬁed
as theparent_construct  If the event was emitted as the result of the application making a
call to the runtime api, the value will be acc_construct_runtime_api 
typedef enum acc_construct_t {
acc_construct_parallel = 0,
acc_construct_serial =
acc_construct_kernels = 1,
acc_construct_loop = 2,
acc_construct_data = 3,
acc_construct_enter_data = 4,
acc_construct_exit_data = 5,
acc_construct_host_data = 6,
acc_construct_atomic = 7,
acc_construct_declare = 8,
acc_construct_init = 9,
acc_construct_shutdown = 10,
acc_construct_set = 11,
acc_construct_update = 12,
acc_construct_routine = 13,
acc_construct_wait = 14,
acc_construct_runtime_api = 15,
}acc_construct_t;
523 Third Argument: API-Speciﬁc Information
The third argument is a pointer to the acc_api_info struct type, shown here
typedef struct acc_api_info {
acc_device_api device_api;
int valid_bytes;
acc_device_t device_type;
int vendor;
const void *device_handle;
const void *context_handle;
const void *async_handle;
}acc_api_info;
The ﬁelds are described below:
	acc_device_api device_api - The API in use for this device The data type is the
enumeration acc_device_api , which is described later in this section
	intvalid_bytes - The number of valid bytes in this struct See the discussion above in

Section 521 First Argument: General Information
	acc_device_tdevice_type - The device type; the datatype is acc_device_t , de-
ﬁned inopenacch 
	intvendor - An identiﬁer to identify the OpenACC vendor; contact your vendor to dete r-
mine the value used by that vendor’s runtime
	constvoid *device_handle - If applicable, this will be a pointer to the API-speciﬁc
device information
	constvoid *context_handle - If applicable, this will be a pointer to the API-speciﬁc
context information
	const void *async_handle - If applicable, this will be a pointer to the API-speciﬁc
async queue information
According to the value of device_api a library can cast the pointers of the ﬁelds device_handle ,
context_handle andasync_handle to the respective device API type The following device
APIs are deﬁned in the interface below Any implementation-deﬁned device A PI type must have a
value greater than acc_device_api_implementation_defined 
typedef enum acc_device_api {
acc_device_api_none = 0, /* no device API */
acc_device_api_cuda = 1, /* CUDA driver API */
acc_device_api_opencl = 2, /* OpenCL API */
acc_device_api_other = 4, /* other device API */
acc_device_api_implementation_defined = 1000 /* other device API */
}acc_device_api;
53 Loading the Library
This section describes how a tools library is loaded when the program is run  Four methods are
described
	A tools library may be linked with the program, as any other library is linked, eithe r as a
static library or a dynamic library, and the runtime will call a predeﬁned library initialization
routine that will register the event callbacks
	The OpenACC runtime implementation may support a dynamic tools library, such as a shared
object for Linux or OS/X, or a DLL for Windows, which is then dynamically loa ded at runtime
under control of the environment variable ACC_PROFLIB 
	Some implementations where the OpenACC runtime is itself implemented as a dynamic li-
brary may support adding a tools library using the LD_PRELOAD feature in Linux
	A tools library may be linked with the program, as in the ﬁrst option, and the applic ation itself
may directly register event callback routines, or may invoke a library initializatio n routine that
will register the event callbacks
Callbacks are registered with the runtime by calling acc_callback_register for each event
as described in Section 54 Registering Event Callbacks The prototype fo racc_callback_register
is:

extern void acc_callback_register
(acc_event_t event_type, acc_callback cb,
acc_register_t info);
The ﬁrst argument to acc_callback_register is the event for which a callback is being
registered (compare Section 51 Events) The second argument is a pointe r to the callback routine:
typedef void ( *acc_callback)
(acc_callback_info *,acc_event_info *,acc_api_info *);
The third argument is an enum type:
typedef enum acc_register_t {
acc_reg = 0,
acc_toggle = 1,
acc_toggle_per_thread =
}acc_register_t;
This is usually acc_reg , but see Section 542 Disabling and Enabling Callbacks for cases where
different values are used
An example of registering callbacks for launch, upload, and download ev ents is:
acc_callback_register(acc_ev_enqueue_launch_start,
prof_launch, acc_reg);
acc_callback_register(acc_ev_enqueue_upload_start,
prof_data, acc_reg);
acc_callback_register(acc_ev_enqueue_download_start ,
prof_data, acc_reg);
As shown in this example, the same routine ( prof_data ) can be registered for multiple events
The routine can use the event_type ﬁeld in the acc_callback_info structure to determine
for what event it was invoked
The names acc_prof_register andacc_prof_unregister are preserved for backward
compatibility with previous versions of OpenACC
531 Library Registration
The OpenACC runtime will invoke acc_register_library , passing the addresses of the reg-
istration routines acc_callback_register andacc_callback_unregister , in case
that routine comes from a dynamic library In the third argument it passes the address of the lookup
routineacc_prof_lookup to obtain the addresses of inquiry functions No inquiry functions
are deﬁned in this proﬁling interface, but we preserve this argument for future support of sampling-
based tools
Typically, the OpenACC runtime will include a weak deﬁnition of acc_register_library ,
which does nothing and which will be called when there is no tools library In th is case, the library
can save the addresses of these routines and/or make registration calls to r egister any appropriate
callbacks The prototype for acc_register_library is:
extern void acc_register_library
(acc_prof_reg reg, acc_prof_reg unreg,

acc_prof_lookup_func lookup);
The ﬁrst two arguments of this routine are of type:
typedef void ( *acc_prof_reg)
(acc_event_t event_type, acc_callback cb,
acc_register_t info);
The third argument passes the address to the lookup function acc_prof_lookup to obtain the
address of interface functions It is of type:
typedef void ( *acc_query_fn)();
typedef acc_query_fn ( *acc_prof_lookup_func)
(const char *acc_query_fn_name);
The argument of the lookup function is a string with the name of the inquiry func tion There are no
inquiry functions deﬁned for this interface
532 Statically-Linked Library Initialization
A tools library can be compiled and linked directly into the application If the librar y provides an
external routine acc_register_library as speciﬁed in Section 531Library Registration, the
runtime will invoke that routine to initialize the library
The sequence of events is:
1 The runtime invokes the acc_register_library routine from the library
2 Theacc_register_library routine calls acc_callback_register for each event
to be monitored
3acc_callback_register records the callback routines
4 The program runs, and your callback routines are invoked at the ap propriate events
In this mode, only one tool library is supported
533 Runtime Dynamic Library Loading
A common case is to build the tools library as a dynamic library (shared object fo r Linux or OS/X,
DLL for Windows) In that case, you can have the OpenACC runtime load th e library during initial-
ization This allows you to enable runtime proﬁling without rebuilding or even re linking your ap-
plication The dynamic library must implement a registration routine acc_register_library
as speciﬁed in Section 531 Library Registration
The user may set the environment variable ACC_PROFLIB to the path to the library will tell the
OpenACC runtime to load your dynamic library at initialization time:
Bash:
export ACC_PROFLIB=/home/user/lib/myprofso
/myapp
or
ACC_PROFLIB=/home/user/lib/myprofso /myapp

C-shell:
setenv ACC_PROFLIB /home/user/lib/myprofso
/myapp
When the OpenACC runtime initializes, it will read the ACC_PROFLIB environment variable (with
getenv ) The runtime will open the dynamic library (using dlopen orLoadLibraryA ); if
the library cannot be opened, the runtime may cause the program to halt exe cution and return an
error status, or may continue execution with or without an error message I f the library is suc-
cessfully opened, the runtime will get the address of the acc_register_library routine (us-
ingdlsym orGetProcAddress ) If this routine is resolved in the library, it will be invoked
passing in the addresses of the registration routine acc_callback_register , the deregistra-
tion routine acc_callback_unregister , and the lookup routine acc_prof_lookup  The
registration routine in your library, acc_register_library , should register the callbacks by
calling the register argument, and should save the addresses of the arguments ( register ,
unregister , andlookup ) for later use, if needed
The sequence of events is:
1 Initialization of the OpenACC runtime
2 OpenACC runtime reads ACC_PROFLIB 
3 OpenACC runtime loads the library
4 OpenACC runtime calls the acc_register_library routine in that library
5 Youracc_register_library routine calls acc_callback_register for each event
to be monitored
6acc_callback_register records the callback routines
7 The program runs, and your callback routines are invoked at the ap propriate events
If supported, paths to multiple dynamic libraries may be speciﬁed in the ACC_PROFLIB environ-
ment variable, separated by semicolons ( ;) The OpenACC runtime will open these libraries and in-
voke theacc_register_library routine for each, in the order they appear in ACC_PROFLIB 
534 Preloading with LD PRELOAD
The implementation may also support dynamic loading of a tools library using the LD_PRELOAD
feature available in some systems In such an implementation, you need only spe cify your tools
library path in the LD_PRELOAD environment variable before executing your program The Open-
ACC runtime will invoke the acc_register_library routine in your tools library at initial-
ization time This requires that the OpenACC runtime include a dynamic library with a default
(empty) implementation of acc_register_library that will be invoked in the normal case
where there is no LD_PRELOAD setting If an implementation only supports static linking, or if the
application is linked without dynamic library support, this feature will not be av ailable
Bash:
export LD_PRELOAD=/home/user/lib/myprofso
/myapp
or
LD_PRELOAD=/home/user/lib/myprofso /myapp

C-shell:
setenv LD_PRELOAD /home/user/lib/myprofso
/myapp
The sequence of events is:
1 The operating system loader loads the library speciﬁed in LD_PRELOAD 
2 The call to acc_register_library in the OpenACC runtime is resolved to the routine
in the loaded tools library
3 OpenACC runtime calls the acc_register_library routine in that library
4 Youracc_register_library routine calls acc_callback_register for each event
to be monitored
5acc_callback_register records the callback routines
6 The program runs, and your callback routines are invoked at the ap propriate events
In this mode, only a single tools library is supported, since only one acc_register_library
initialization routine will get resolved by the dynamic loader
535 Application-Controlled Initialization
An alternative to default initialization is to have the application itself call the library initialization
routine, which then calls acc_callback_register for each appropriate event The library
may be statically linked to the application or your application may dynamically load the lib rary
The sequence of events is:
1 Your application calls the library initialization routine
2 The library initialization routine calls acc_callback_register for each event to be
monitored
3acc_callback_register records the callback routines
4 The program runs, and your callback routines are invoked at the ap propriate events
In this mode, multiple tools libraries can be supported, with each library initialization routine in-
voked by the application
54 Registering Event Callbacks
This section describes how to register and unregister callbacks, temporar ily disabling and enabling
callbacks, the behavior of dynamic registration and unregistration, and re quirements on an Open-
ACC implementation to correctly support the interface
541 Event Registration and Unregistration
The library must call the registration routine acc_callback_register to register each call-
back with the runtime A simple example:
extern void prof_data(acc_callback_info *profinfo,
acc_event_info *eventinfo, acc_api_info *apiinfo);

extern void prof_launch(acc_callback_info *profinfo,
acc_event_info *eventinfo, acc_api_info *apiinfo);
  
void acc_register_library(acc_prof_reg reg,
acc_prof_reg unreg, acc_prof_lookup_func lookup) {
reg(acc_ev_enqueue_upload_start, prof_data, acc_reg);
reg(acc_ev_enqueue_download_start, prof_data, acc_reg );
reg(acc_ev_enqueue_launch_start, prof_launch, acc_reg );
}
In this example the prof_data routine will be invoked for each data upload and download event,
and theprof_launch routine will be invoked for each launch event The prof_data routine
might start out with:
void prof_data(acc_callback_info *profinfo,
acc_event_info *eventinfo, acc_api_info *apiinfo) {
acc_data_event_info *datainfo;
datainfo = (acc_data_event_info *)eventinfo;
switch( datainfo->event_type ) {
case acc_ev_enqueue_upload_start :
  
}
}
Multiple Callbacks
Multiple callback routines can be registered on the same event:
acc_callback_register(acc_ev_enqueue_upload_start,
prof_data, acc_reg);
acc_callback_register(acc_ev_enqueue_upload_start,
prof_up, acc_reg);
For most events, the callbacks will be invoked in the order in which they are r egistered However,
endevents, named acc_ev__end , invoke callbacks in the reverse order Essentially, each
event has an ordered list of callback routines A new callback routine is a ppended to the tail of the
list for that event For most events, that list is traversed from the head to th e tail, but for endevents,
the list is traversed from the tail to the head
If a callback is registered, then later unregistered, then later still registere d again, the second regis-
tration is considered to be a new callback, and the callback routine will then be appended to the tail
of the callback list for that event
Unregistering
A matching call to acc_callback_unregister will remove that routine from the list of call-
back routines for that event
acc_callback_register(acc_ev_enqueue_upload_start,
prof_data, acc_reg);
// prof_data is on the callback list for acc_ev_enqueue_upload_start
  

acc_callback_unregister(acc_ev_enqueue_upload_start ,
prof_data, acc_reg);
// prof_data is removed from the callback list
// foracc_ev_enqueue_upload_start
Each entry on the callback list must also have a refcount This keeps track of how many times
this routine was added to this event’s callback list If a routine is registered ntimes, it must be
unregistered ntimes before it is removed from the list Note that if a routine is registered multiple
times for the same event, its refcount will be incremented with each registration, but it will only be
invoked once for each event instance
542 Disabling and Enabling Callbacks
A callback routine may be temporarily disabled on the callback list for an event, then later re-
enabled The behavior is slightly different than unregistering and later re -registering that event
When a routine is disabled and later re-enabled, the routine’s position on the callback list for that
event is preserved When a routine is unregistered and later re-registe red, the routine’s position on
the callback list for that event will move to the tail of the list Also, unregistering a callback must be
done ntimes if the callback routine was registered ntimes In contrast, disabling, and enabling an
event sets a toggle Disabling a callback will immediately reset the toggle and disa ble calls to that
routine for that event, even if it was enabled multiple times Enabling a callback w ill immediately
set the toggle and enable calls to that routine for that event, even if it was dis abled multiple times
Registering a new callback initially sets the toggle
A call toacc_callback_unregister with a value of acc_toggle as the third argument
will disable callbacks to the given routine A call to acc_callback_register with a value of
acc_toggle as the third argument will enable those callbacks
acc_callback_unregister(acc_ev_enqueue_upload_start ,
prof_data, acc_toggle);
// prof_data is disabled
  
acc_callback_register(acc_ev_enqueue_upload_start,
prof_data, acc_toggle);
// prof_data is re-enabled
A call to either acc_callback_unregister oracc_callback_register to disable or
enable a callback when that callback is not currently registered for that e vent will be ignored with
no error
All callbacks for an event may be disabled (and re-enabled) by passing NULL to the second argument
andacc_toggle to the third argument of acc_callback_unregister (and
acc_callback_register ) This sets a toggle for that event, which is distinct from the toggle
for each callback for that event While the event is disabled, no callbacks for that event will be
invoked Callbacks for that event can be registered, unregistered, e nabled, and disabled while that
event is disabled, but no callbacks will be invoked for that event until the event itself is enabled
Initially, all events are enabled
acc_callback_unregister(acc_ev_enqueue_upload_start ,
prof_data, acc_toggle);
// prof_data is disabled

  
acc_callback_unregister(acc_ev_enqueue_upload_start ,
NULL, acc_toggle);
// acc_ev_enqueue_upload_start callbacks are disabled
  
acc_callback_register(acc_ev_enqueue_upload_start,
prof_data, acc_toggle);
// prof_data is re-enabled, but
// acc_ev_enqueue_upload_start callbacks still disabled
  
acc_callback_register(acc_ev_enqueue_upload_start,
prof_up, acc_reg);
// prof_up is registered and initially enabled, but
// acc_ev_enqueue_upload_start callbacks still disabled
  
acc_callback_register(acc_ev_enqueue_upload_start,
NULL, acc_toggle);
// acc_ev_enqueue_upload_start callbacks are enabled

Finally, all callbacks can be disabled (and enabled) by passing the argume nt list(acc_ev_none,
NULL,acc_toggle) toacc_callback_unregister (andacc_callback_register )
This sets a global toggle disabling all callbacks, which is distinct from the toggle enabling callbacks
for each event and the toggle enabling each callback routine
The behavior of passing acc_ev_none as the ﬁrst argument and a non- NULL value as the second
argument to acc_callback_unregister oracc_callback_register is not deﬁned,
and may be ignored by the runtime without error
All callbacks can be disabled (or enabled) for just the current thread b y passing the argument list
(acc_ev_none,NULL,acc_toggle_per_thread) toacc_callback_unregister
(andacc_callback_register ) This is the only thread-speciﬁc interface to
acc_callback_register andacc_callback_unregister , all other calls to register,
unregister, enable, or disable callbacks affect all threads in the applica tion
55 Advanced Topics
This section describes advanced topics such as dynamic registration and c hanges of the execution
state for callback routines as well as the runtime and tool behavior for multiple h ost threads
551 Dynamic Behavior
Callback routines may be registered or unregistered, enabled or disabled at any point in the execution
of the program Calls may appear in the library itself, during the processing o f an event The
OpenACC runtime must allow for this case, where the callback list for an even t is modiﬁed while
that event is being processed
Dynamic Registration and Unregistration
Calls toacc_register andacc_unregister may occur at any point in the application A
callback routine can be registered or unregistered from a callback routin e, either the same routine

or another routine, for a different event or the same event for which th e callback was invoked If a
callback routine is registered for an event while that event is being proce ssed, then the new callback
routine will be added to the tail of the list of callback routines for this event So me events (the
_end ) events process the callback routines in reverse order, from the tail to th e head For those
events, adding a new callback routine will not cause the new routine to be inv oked for this instance
of the event The other events process the callback routines in registration order, from the head
to the tail Adding a new callback routine for such an event will cause the run time to invoke that
newly registered callback routine for this instance of the event Both the run time and the library
must implement and expect this behavior
If an existing callback routine is unregistered for an event while that even t is being processed, that
callback routine is removed from the list of callbacks for this event For any event, if that callback
routine had not yet been invoked for this instance of the event, it will not b e invoked
Registering and unregistering a callback routine is a global operation and a ffects all threads, in a
multithreaded application See Section 541 Multiple Callbacks
Dynamic Enabling and Disabling
Calls toacc_register andacc_unregister to enable and disable a speciﬁc callback for
an event, enable or disable all callbacks for an event, or enable or disab le all callbacks may occur
at any point in the application A callback routine can be enabled or disabled from a callback
routine, either the same routine or another routine, for a different event or the same event for which
the callback was invoked If a callback routine is enabled for an event wh ile that event is being
processed, then the new callback routine will be immediately enabled If it app ears on the list of
callback routines closer to the head (for _end events) or closer to the tail (for other events), that
newly-enabled callback routine will be invoked for this instance of this even t, unless it is disabled
or unregistered before that callback is reached
If a callback routine is disabled for an event while that event is being proc essed, that callback routine
is immediately disabled For any event, if that callback routine had not yet bee n invoked for this in-
stance of the event, it will not be invoked, unless it is enabled before that callback routine is reached
in the list of callbacks for this event If all callbacks for an event are disa bled while that event is
being processed, or all callbacks are disabled for all events while an ev ent is being processed, then
when this callback routine returns, no more callbacks will be invoked for this instance of the event
Registering and unregistering a callback routine is a global operation and a ffects all threads, in a
multithreaded application See Section 541 Multiple Callbacks
552 OpenACC Events During Event Processing
OpenACC events may occur during event processing This may be becau se of OpenACC API rou-
tine calls or OpenACC constructs being reached during event processin g, or because of multiple host
threads executing asynchronously Both the OpenACC runtime and the tool library must implement
the proper behavior
553 Multiple Host Threads
Many programs that use OpenACC also use multiple host threads, such as p rograms using the
OpenMP API The appearance of multiple host threads affects both the Op enACC runtime and the
tools library

Runtime Support for Multiple Threads
The OpenACC runtime must be thread-safe, and the OpenACC runtime implementa tion of this
tools interface must also be thread-safe All threads use the same set of c allbacks for all events, so
registering a callback from one thread will cause all threads to execute tha t callback This means that
managing the callback lists for each event must be protected from multiple simultan eous updates
This includes adding a callback to the tail of the callback list for an event, remo ving a callback from
the list for an event, and incrementing or decrementing the refcount for a callback routine for an
event
In addition, one thread may register, unregister, enable, or disable a callb ack for an event while
another thread is processing the callback list for that event asynchron ously The exact behavior may
be dependent on the implementation, but some behaviors are expected and o thers are disallowed
In the following examples, there are three callbacks, A, B, and C, register ed for event E in that
order, where callbacks A and B are enabled and callback C is temporarily d isabled Thread T1 is
dynamically modifying the callbacks for event E while thread T2 is processing an instance of event
E
	Suppose thread T1 unregisters or disables callback A for event E Thr ead T2 may or may not
invoke callback A for this event instance, but it must invoke callback B; if it invokes callback
A, that must precede the invocation of callback B
	Suppose thread T1 unregisters or disables callback B for event E Thr ead T2 may or may not
invoke callback B for this event instance, but it must invoke callback A; if it invokes callback
B, that must follow the invocation of callback A
	Suppose thread T1 unregisters or disables callback A and then unregiste rs or disables callback
B for event E Thread T2 may or may not invoke callback A and may or may no t invoke
callback B for this event instance, but if it invokes both callbacks, it must inv oke callback A
before it invokes callback B
	Suppose thread T1 unregisters or disables callback B and then unregiste rs or disables callback
A for event E Thread T2 may or may not invoke callback A and may or may no t invoke
callback B for this event instance, but if it invokes callback B, it must have invoked callback
A for this event instance
	Suppose thread T1 is registering a new callback D for event E Thread T 2 may or may not
invoke callback D for this event instance, but it must invoke both callbacks A and B If it
invokes callback D, that must follow the invocations of A and B
	Suppose thread T1 is enabling callback C for event E Thread T2 may or ma y not invoke
callback C for this event instance, but it must invoke both callbacks A and B  If it invokes
callback C, that must follow the invocations of A and B
Theacc_callback_info struct has a thread_id ﬁeld, which the runtime must set to a
unique value for each host thread, though it need not be the same as the O penMP threadnum value
Library Support for Multiple Threads
The tool library must also be thread-safe The callback routine will be invo ked in the context of the
thread that reaches the event The library may receive a callback from a thread T2 while it’s still
processing a callback, from the same event type or from a different ev ent type, from another thread

T1 Theacc_callback_info struct has a thread_id ﬁeld, which the runtime must set to a
unique value for each host thread
If the tool library uses dynamic callback registration and unregistration, or callback disabling and
enabling, recall that unregistering or disabling an event callback from o ne thread will unregister or
disable that callback for all threads, and registering or enabling an even t callback from any thread
will register or enable it for all threads If two or more threads register the same callback for the
same event, the behavior is the same as if one thread registered that callback multiple times; see
Section 541 Multiple Callbacks The acc_unregister routine must be called as many times
asacc_register for that callback/event pair in order to totally unregister it If two threads
register two different callback routines for the same event, unless the ord er of the registration calls
is guaranteed by some sychronization method, the order in which the runtime se es the registration
may differ for multiple runs, meaning the order in which the callbacks occur will differ as well

6 Glossary
Clear and consistent terminology is important in describing any programming mod el We deﬁne
here the terms you must understand in order to make effective use of this do cument and the asso-
ciated programming model In particular, some terms used in this speciﬁcation con ﬂict with their
usage in the base language speciﬁcations When there is potential confus ion, the term will appear
here
Accelerator – a device attached to a CPU and to which the CPU can ofﬂoad data and compute
kernels to perform compute-intensive calculations
Accelerator routine – a procedure compiled for the accelerator with the routine directive
Accelerator thread – a thread of execution that executes on the accelerator; a single vector la ne of
a single worker of a single gang
Aggregate datatype – any non-scalar datatype such as array and composite datatypes In Fo rtran,
aggregate datatypes include arrays, derived types, character types  In C, aggregate datatypes include
arrays, targets of pointers, structs, and unions In C++, aggregate d atatypes include arrays, targets
of pointers, classes, structs, and unions
Aggregate variables – a variable of any non-scalar datatype, including array or composite var iables
In Fortran, this includes any variable with allocatable or pointer attribute and c haracter variables
Async-argument – an async-argument is a nonnegative scalar integer expression ( intfor C or C++,
integer for Fortran), or one of the special values acc_async_noval oracc_async_sync 
Barrier – a type of synchronization where all parallel execution units or threads mu st reach the
barrier before any execution unit or thread is allowed to proceed beyon d the barrier; modeled after
the starting barrier on a horse race track
Block construct – ablock-construct , as speciﬁed by the Fortran language
Composite datatype – a derived type in Fortran, or a struct orunion type in C, or a class ,
struct , orunion type in C++ (This is different from the use of the term composite data type in
the C and C++ languages)
Composite variable – a variable of composite datatype In Fortran, a composite variable must not
have allocatable or pointer attributes
Compute construct – aparallel construct ,serial construct , orkernels construct 
Compute intensity – for a given loop, region, or program unit, the ratio of the number of arith metic
operations performed on computed data divided by the number of memory tran sfers required to
move that data between two levels of a memory hierarchy
Compute region – aparallel region ,serial region , orkernels region 
Construct – a directive and the associated statement, loop, or structured block, if any 
CUDA – the CUDA environment from NVIDIA, a C-like programming environment us ed to ex-
plicitly control and program an NVIDIA GPU

Current device – the device represented by the acc-current-device-type-var andacc-current-device-
num-var ICVs
Current device type – the device type represented by the acc-current-device-type-var ICV
Data lifetime – the lifetime of a data object in device memory, which may begin at the entry to
a data region, or at an enter data directive, or at a data API call such as acc_copyin or
acc_create , and which may end at the exit from a data region, or at an exitdata directive,
or at a data API call such as acc_delete ,acc_copyout , oracc_shutdown , or at the end of
the program execution
Data region – aregion deﬁned by a data construct, or an implicit data region for a function or
subroutine containing OpenACC directives Data constructs typically alloca te device memory and
copy data from host to device memory upon entry, and copy data from dev ice to local memory and
deallocate device memory upon exit Data regions may contain other data region s and compute
regions
Default asynchronous queue – the asynchronous activity queue represented in the acc-default-
async-var ICV
Device – a general reference to an accelerator or a multicore CPU
Device memory – memory attached to a device, logically and physically separate from the host
memory
Device thread – a thread of execution that executes on any device
Directive – in C or C++, a #pragma , or in Fortran, a specially formatted comment statement, that
is interpreted by a compiler to augment information about or specify the behav ior of the program
Discrete memory – memory accessible from the local thread that is not accessible from the cu rrent
device, or memory accessible from the current device that is not access ible from the local thread
DMA – Direct Memory Access, a method to move data between physically separate me mories;
this is typically performed by a DMA engine, separate from the host CPU, tha t can access the host
physical memory as well as an IO device or other physical memory
Exposed variable access – with respect to a compute construct, any access to the data or address
of a variable at a point within the compute construct where the variable is not private to a scope
lexically enclosed within the compute construct See Section 262
false – a condition that evaluates to zero in C or C++, or false in Fortran
GPU – a Graphics Processing Unit; one type of accelerator
GPGPU – General Purpose computation on Graphics Processing Units
Host – the main CPU that in this context may have one or more attached accelerators The host
CPU controls the program regions and data loaded into and executed on on e or more devices
Host thread – a thread of execution that executes on the host
Implicit data region – the data region that is implicitly deﬁned for a Fortran subprogram or C
function A call to a subprogram or function enters the implicit data region, a nd a return from the
subprogram or function exits the implicit data region

Kernel – a nested loop executed in parallel by the accelerator Typically the loops a re divided into
a parallel domain, and the body of the loop becomes the body of the kernel
Kernels region – aregion deﬁned by a kernels construct A kernels region is a structured block
which is compiled for the accelerator The code in the kernels region will be d ivided by the compiler
into a sequence of kernels; typically each loop nest will become a single ker nel A kernels region
may require space in device memory to be allocated and data to be copied from lo cal memory to
device memory upon region entry, and data to be copied from device memory to local memory and
space in device memory to be deallocated upon exit
Level of parallelism – a possible level of parallelism, which in OpenACC is gang, worker, vector ,
or sequential One or more of gang, worker, and vector parallelism may ap pear on a loop con-
struct Sequential execution corresponds to no parallelism The gang ,worker ,vector , and
seq clauses specify the level of parallelism for a loop
Local device – the device where the local thread executes
Local memory – the memory associated with the local thread 
Local thread – the host thread or the accelerator thread that executes an OpenACC dir ective or
construct
Loop trip count – the number of times a particular loop executes
MIMD – a method of parallel execution (Multiple Instruction, Multiple Data) where diff erent exe-
cution units or threads execute different instruction streams asynchrono usly with each other
null pointer – a C or C++ pointer variable with the value zero, NULL , or (in C++) nullptr , or a
Fortranpointer variable that is not associated, or a Fortran allocatable variable that is not
allocated
OpenCL – short for Open Compute Language, a developing, portable standard C -like programming
environment that enables low-level general-purpose programming on GP Us and other accelerators
Orphaned loop construct - aloop construct that is not lexically contained in any compute con-
struct, that is, that has no parent compute construct
Parallel region – aregion deﬁned by a parallel construct A parallel region is a structured block
which is compiled for the accelerator A parallel region typically contains one or more work-sharing
loops A parallel region may require space in device memory to be allocated an d data to be copied
from local memory to device memory upon region entry, and data to be copied f rom device memory
to local memory and space in device memory to be deallocated upon exit
Parent compute construct – for aloop construct, the parallel ,serial , orkernels con-
struct that lexically contains the loop construct and is the innermost compute construct that con-
tains thatloop construct, if any
Partly present data – a section of data for which some of the data is present in a single device
memory section, but part of the data is either not present or is present in a different device memory
section For instance, if a subarray of an array is present, the array is partly present
Present data – data for which the sum of the structured and dynamic reference counter s is greater
than zero in a single device memory section; see Section 267 A null pointer is d eﬁned as always
present with a length of zero bytes

Private data – with respect to an iterative loop, data which is used only during a particular loop
iteration With respect to a more general region of code, data which is used within the region but is
not initialized prior to the region and is re-initialized prior to any use after the re gion
Procedure – in C or C++, a function or C++ lambda; in Fortran, a subroutine or function 
Region – all the code encountered during an instance of execution of a construc t A region includes
any code in called routines, and may be thought of as the dynamic extent of a construct This may
be a parallel region ,serial region ,kernels region ,data region , orimplicit data region 
Scalar – a variable of scalar datatype In Fortran, scalars must not have alloca table or pointer
attributes
Scalar datatype – an intrinsic or built-in datatype that is not an array or aggregate datatype In For-
tran, scalar datatypes are integer, real, double precision, complex, or lo gical In C, scalar datatypes
are char (signed or unsigned), int (signed or unsigned, with optional s hort, long or long long at-
tribute), enum, ﬂoat, double, long double, Complex (with optional ﬂoat or long attribute), or any
pointer datatype In C++, scalar datatypes are char (signed or unsigne d), wchar t, int (signed or
unsigned, with optional short, long or long long attribute), enum, bool, ﬂoat, double, long double,
or any pointer datatype Not all implementations or targets will support all of th ese datatypes
Serial region – aregion deﬁned by a serial construct A serial region is a structured block which
is compiled for the accelerator A serial region contains code that is execu ted by a single gang of a
single worker with a vector length of one A serial region may require spac e in device memory to be
allocated and data to be copied from local memory to device memory upon region entry, and data
to be copied from device memory to local memory and space in device memory to be deallocated
upon exit
Shared memory – memory that is accessible from both the local thread and the current devic e
SIMD – a method of parallel execution (single-instruction, multiple-data) where the s ame instruc-
tion is applied to multiple data elements simultaneously
SIMD operation – avector operation implemented with SIMD instructions
Structured block – in C or C++, an executable statement, possibly compound, with a single entry
at the top and a single exit at the bottom In Fortran, a block of executable sta tements with a single
entry at the top and a single exit at the bottom
Thread – a host CPU thread or an accelerator thread On a host CPU, a thread is deﬁned by a
program counter and stack location; several host threads may comprise a process and share host
memory On an accelerator, a thread is any one vector lane of one worker of one gang
true – a condition that evaluates to nonzero in C or C++, or true in Fortran
var– the name of a variable (scalar, array, or composite variable), or a suba rray speciﬁcation, or an
array element, or a composite variable member, or the name of a Fortran common b lock between
slashes
Vector operation – a single operation or sequence of operations applied uniformly to each ele ment
of an array
Visible data clause – with respect to a compute construct, any data clause on the compute constru ct,
a lexically containing data construct, or a visible declare directive See Section 262

Visibledefault clause – with respect to a compute construct, the nearest default clause ap-
pearing on the compute construct or a lexically containing data construct See Section 262
Visible device copy – a copy of a variable, array, or subarray allocated in device memory that is
visible to the program unit being compiled


A Recommendations for Implementers
This section gives recommendations for standard names and extensions to u se for implementations
for speciﬁc targets and target platforms, to promote portability across such implementations, and
recommended options that programmers ﬁnd useful While this appendix is not part of the Open-
ACC speciﬁcation, implementations that provide the functionality speciﬁed here in are strongly rec-
ommended to use the names in this section The ﬁrst subsection describes dev ices, such as NVIDIA
GPUs The second subsection describes additional API routines for tar get platforms, such as CUDA
and OpenCL The third subsection lists several recommended options for imp lementations
A1 Target Devices
A11 NVIDIA GPU Targets
This section gives recommendations for implementations that target NVIDIA GP U devices
Accelerator Device Type
These implementations should use the name acc_device_nvidia for theacc_device_t
type or return values from OpenACC Runtime API routines
ACC DEVICE TYPE
An implementation should use the case-insensitive name nvidia for the environment variable
ACC_DEVICE_TYPE 
device type clause argument
An implementation should use the case-insensitive name nvidia as the argument to the device_type
clause
A12 AMD GPU Targets
This section gives recommendations for implementations that target AMD GPUs
Accelerator Device Type
These implementations should use the name acc_device_radeon for theacc_device_t
type or return values from OpenACC Runtime API routines
ACC DEVICE TYPE
These implementations should use the case-insensitive name radeon for the environment variable
ACC_DEVICE_TYPE 
device type clause argument
An implementation should use the case-insensitive name radeon as the argument to the device_type
clause

A13 Multicore Host CPU Target
This section gives recommendations for implementations that target the multicore h ost CPU
Accelerator Device Type
These implementations should use the name acc_device_host for theacc_device_t type
or return values from OpenACC Runtime API routines
ACC DEVICE TYPE
These implementations should use the case-insensitive name host for the environment variable
ACC_DEVICE_TYPE 
device type clause argument
An implementation should use the case-insensitive name host as the argument to the device_type
clause
routine directive
Given aroutine directive for a procedure, an implementation should:
	Suppress the procedure’s compilation for the multicore host CPU if a nohost clause appears
	Ignore any bind clause when compiling the procedure for the multicore host CPU
	Disallow a bind clause to appear after a device_type(host) clause
A2 API Routines for Target Platforms
These runtime routines allow access to the interface between the OpenACC ru ntime API and the
underlying target platform An implementation may not implement all these routines, but if it
provides this functionality, it should use these function names
A21 NVIDIA CUDA Platform
This section gives runtime API routines for implementations that target the NVID IA CUDA Run-
time or Driver API
accgetcurrent cuda device
Summary
Theacc_get_current_cuda_device routine returns the NVIDIA CUDA device handle for
the current device
Format
C or C++:
void*acc_get_current_cuda_device ();

accgetcurrent cuda context
Summary
Theacc_get_current_cuda_context routine returns the NVIDIA CUDA context handle
in use for the current device
Format
C or C++:
void*acc_get_current_cuda_context ();
accgetcuda stream
Summary
Theacc_get_cuda_stream routine returns the NVIDIA CUDA stream handle in use for the
current device for the asynchronous activity queue associated with the async argument This
argument must be an async-argument as deﬁned in Section 216 Asynchronous Behavior
Format
C or C++:
void*acc_get_cuda_stream ( int async );
accsetcuda stream
Summary
Theacc_set_cuda_stream routine sets the NVIDIA CUDA stream handle the current device
for the asynchronous activity queue associated with the async argument This argument must be
anasync-argument as deﬁned in Section 216 Asynchronous Behavior
Format
C or C++:
void acc_set_cuda_stream ( int async, void *stream );
A22 OpenCL Target Platform
This section gives runtime API routines for implementations that target the Open CL API on any
device
accgetcurrent opencl device
Summary
Theacc_get_current_opencl_device routine returns the OpenCL device handle for the
current device
Format
C or C++:
void*acc_get_current_opencl_device ();
accgetcurrent opencl context
Summary
Theacc_get_current_opencl_context routine returns the OpenCL context handle in use
for the current device

Format
C or C++:
void*acc_get_current_opencl_context ();
accgetopencl queue
Summary
Theacc_get_opencl_queue routine returns the OpenCL command queue handle in use for
the current device for the asynchronous activity queue associated with theasync argument This
argument must be an async-argument as deﬁned in Section 216 Asynchronous Behavior
Format
C or C++:
cl_command_queue acc_get_opencl_queue ( int async );
accsetopencl queue
Summary
Theacc_set_opencl_queue routine returns the OpenCL command queue handle in use for
the current device for the asynchronous activity queue associated with theasync argument This
argument must be an async-argument as deﬁned in Section 216 Asynchronous Behavior
Format
C or C++:
void acc_set_opencl_queue ( int async, cl_command_queue c mdqueue
);
A3 Recommended Options and Diagnostics
This section recommends options and diagnostics for implementations Possible w ays to implement
the options include command-line options to a compiler or settings in an IDE
A31 C Pointer in Present clause
This revision of OpenACC clariﬁes the construct:
void test(int n ) {
float*p;
  
#pragma acc data present(p)
{
// code here   
}
This example tests whether the pointer pitself is present in the current device memory Implemen-
tations before this revision commonly implemented this by testing whether the pointer ta rgetp[0]
was present in the current device memory, and this appears in many progr ams assuming such Until
such programs are modiﬁed to comply with this revision, an option to implement present(p) as
present(p[0]) for C pointers may be helpful to users

A32 Nonconforming Applications and Implementations
Where feasible, implementations should diagnose OpenACC applications that d o not conform with
this speciﬁcation’s syntactic or semantic restrictions Many but not all of the se restrictions appear
in lists entitled “Restrictions”
While compile-time diagnostics are preferable (eg, invalid clauses on a directi ve), some cases of
nonconformity are more feasible to diagnose at run time (eg, see Section 15)  Where implemen-
tations are not able to diagnose nonconformity reliably (eg, an independent clause on a loop
with data-dependent loop iterations), they might offer no diagnostics, or th ey might diagnose only
subcases
In order to support OpenACC extensions, some implementations intentionally ac cept nonconform-
ing OpenACC applications without issuing diagnostics by default, and some imple mentations accept
conforming OpenACC applications but interpret their semantics differently th an as detailed in this
speciﬁcation To promote program portability across implementations, implementatio ns should pro-
vide an option to disable or report uses of these extensions Some such ex tensions and diagnostics
are described in detail in the remainder of this section
A33 Automatic Data Attributes
Some implementations provide autoscoping or other analysis to automatically determin e a variable’s
data attributes, including the addition of reduction, private, and ﬁrstpriva te clauses To promote
program portability across implementations, it would be helpful to provide an o ption to disable
the automatic determination of data attributes or report which variables’ data attr ibutes are not as
deﬁned in Section 26
A34 Routine Directive with a Name
In C and C++, if a routine directive with a name appears immediately before a procedure dec-
laration or deﬁnition with that name, it does not necessarily apply to that proc edure according to
Section 2151 and C and C++ name resolution Implementations should issue diag nostics in the
following two cases:
1 When no procedure with that name is already in scope, the directive is no nconforming, so
implementations should issue a compile-time error diagnostic regardless of the fo llowing
procedure For example:
#pragma acc routine(f) seq // compile-time error
void f();
2 When a procedure with that name is in scope and it is not the same procedu re as the immedi-
ately following procedure declaration or deﬁnition, the resolution of the name can be confus-
ing Implementations should then issue a compile-time warning diagnostic even thou gh the
application is conforming For example:
void g(); // routine directive applies
namespace NS {
#pragma acc routine(g) seq // compile-time warning
void g(); // routine directive does not apply
}

The diagnostic in this case should suggest the programmer either (1) reloca te theroutine
directive so that it more clearly applies to the procedure that is in scope or ( 2) remove the
name from the routine directive so that it applies to the following procedure

Index
_OPENACC , 28,
acc-current-device-num-var,
acc-current-device-type-var,
acc-default-async-var, 28,
acc_async_noval ,
acc_async_sync ,
acc_device_host ,
ACC_DEVICE_NUM , 29,
acc_device_nvidia ,
acc_device_radeon ,
ACC_DEVICE_TYPE , 29, 121, 153,
ACC_PROFLIB ,
accelerator routine,
action
attach, 45,
copyin,
copyout,
create,
delete,
detach, 45,
immediate,
present decrement,
present increment,
AMD GPU target,
async clause, 42, 43, 81,
async queue,
async-argument , 88,
asynchronous execution, 11,
atomic construct,
attach action, 45,
attach clause,
attachment counter,
auto clause,
portability,
autoscoping,
barrier synchronization, 11, 32, 34,
bind clause,
block construct,
cache directive,
capture clause,
collapse clause,
common block, 45, 73, 74,
compiler options, 156 5709compute construct,
compute region,
construct,
atomic ,
compute,
data , 40,
host_data ,
kernels , 33,
kernelsloop ,
parallel , 31,
parallelloop ,
serial , 32,
serialloop ,
copy clause, 39,
copyin action,
copyin clause,
copyout action,
copyout clause,
create action,
create clause, 53,
CUDA, 11, 12, 147, 153,
data attribute
explicitly determined,
implicitly determined,
predetermined, 37,
data clause,
visible, 38,
data construct, 40,
data lifetime,
data region, 40,
implicit,
data-independent loop construct,
declare directive,
default clause, 37,
visible, 38,
default(none) clause,
default(present),
delete action,
delete clause,
detach action, 45,
immediate,
detach clause,
device clause,
device_resident clause,
device_type clause, 29, 45, 153,

deviceptr clause, 45,
diagnostics,
direct memory access, 11,
DMA, 11,
enterdata directive, 42,
environment variable
_OPENACC ,
ACC_DEVICE_NUM , 29,
ACC_DEVICE_TYPE , 29, 121, 153,
ACC_PROFLIB ,
exitdata directive, 42,
explicitly determined data attribute,
exposed variable access, 38,
extensions,
firstprivate clause, 36,
gang,
gang clause, 59,
implicit,
gang parallelism,
gang-arg ,
gang-partitioned mode,
optimizations,
gang-redundant mode, 10,
GR mode,
host ,
host clause,
host_data construct,
ICV ,
ifclause, 41, 43, 77–79, 81,
immediate detach action,
implicit data region,
implicitgang clause,
implicitly determined data attribute,
independent clause,
init directive,
internal control variable,
kernels construct, 33,
kernelsloop construct,
level of parallelism, 10,
link clause, 45,
local device,
local memory,
local thread, 11 5797loop construct,
data-independent,
orphaned,
sequential,
no_create clause,
nohost clause,
nonconformity,
num_gangs clause,
num_workers clause,
nvidia ,
NVIDIA GPU target,
OpenCL, 11, 12, 149, 153,
optimizations
gang-partitioned mode,
orphanedloop construct,
parallel construct, 31,
parallelloop construct,
parallelism
level, 10,
parent compute construct,
pointer inpresent clause,
portability
auto clause,
predetermined data attribute, 37,
present clause, 39, 45,
pointer,
present decrement action,
present increment action,
private clause, 36,
radeon ,
read clause,
reduction clause, 36,
reference counter,
region
compute,
data, 40,
implicit data,
routine directive, 82,
self clause,
sentinel,
seq clause, 61,
sequentialloop construct,
serial construct, 32,
serialloop construct,

shutdown directive,
size-expr ,
structured-block,
thread,
tile clause,
update clause,
update directive,
use_device clause,
vector clause, 60,
vector lane,
vector parallelism,
vector-partitioned mode,
vector-single mode,
vector_length clause,
visible data clause, 38,
visibledefault clause, 38,
visible device copy,
VP mode,
VS mode,
wait clause, 42, 44, 81,
wait directive,
worker,
worker clause, 60,
worker parallelism,
worker-partitioned mode,
worker-single mode,
WP mode,
WS mode,

