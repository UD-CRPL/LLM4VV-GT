{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of parallel construct. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 251 Parallel Construct\nSummary\nThis fundamental construct starts parallel execution on the current dev ice\nSyntax\nIn C and C++, the syntax of the OpenACC parallel construct is\n#pragma acc parallel [clause-list ]new-line\nstructured block\n\nand in Fortran, the syntax is\n!$acc parallel [clause-list ]\nstructured block\n!$acc end parallel\nor\n!$acc parallel [clause-list ]\nblock construct\n[!$acc end parallel ]\nwhere clause is one of the following:\nasync [(int-expr)]\nwait [(int-expr-list )]\nnum_gangs( int-expr-list )\nnum_workers( int-expr)\nvector_length( int-expr)\ndevice_type( device-type-list )\nif( condition)\nself [(condition)]\nreduction( operator:var-list)\ncopy( var-list)\ncopyin( [readonly: ]var-list)\ncopyout( [zero: ]var-list)\ncreate( [zero: ]var-list)\nno_create( var-list)\npresent( var-list)\ndeviceptr( var-list)\nattach( var-list)\nprivate( var-list)\nfirstprivate( var-list)\ndefault( none | present )\n\nDescription\nWhen the program encounters an accelerator parallel construct, one or more gangs of workers\nare created to execute the accelerator parallel region The number of ga ngs, and the number of\nworkers in each gang and the number of vector lanes per worker remain c onstant for the duration of\nthat parallel region Each gang begins executing the code in the structure d block in gang-redundant\nmode even if there is only a single gang This means that code within the parallel region, but outside\nof a loop construct with gang-level worksharing, will be executed redu ndantly by all gangs\nOne worker in each gang begins executing the code in the structured block of the construct Note:\nUnless there is a loop construct within the parallel region, all gangs will execute all the code within\nthe region redundantly\nIf theasync clause does not appear, there is an implicit barrier at the end of the accele rator parallel\nregion, and the execution of the local thread will not proceed until all gan gs have reached the end\nof the parallel region\nThecopy ,copyin ,copyout ,create ,no_create ,present ,deviceptr , andattach\ndata clauses are described in Section 27 Data Clauses The private andfirstprivate\nclauses are described in Sections 2513 and Sections 2514 The device_type clause is de-\nscribed in Section 24 Device-Speci\ufb01c Clauses Implicitly determined data attribu tes are described\nin Section 262 Restrictions are described in Section 254\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of parallel construct. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 251 Parallel Construct\nSummary\nThis fundamental construct starts parallel execution on the current dev ice\nSyntax\nIn C and C++, the syntax of the OpenACC parallel construct is\n#pragma acc parallel [clause-list ]new-line\nstructured block\n\nand in Fortran, the syntax is\n!$acc parallel [clause-list ]\nstructured block\n!$acc end parallel\nor\n!$acc parallel [clause-list ]\nblock construct\n[!$acc end parallel ]\nwhere clause is one of the following:\nasync [(int-expr)]\nwait [(int-expr-list )]\nnum_gangs( int-expr-list )\nnum_workers( int-expr)\nvector_length( int-expr)\ndevice_type( device-type-list )\nif( condition)\nself [(condition)]\nreduction( operator:var-list)\ncopy( var-list)\ncopyin( [readonly: ]var-list)\ncopyout( [zero: ]var-list)\ncreate( [zero: ]var-list)\nno_create( var-list)\npresent( var-list)\ndeviceptr( var-list)\nattach( var-list)\nprivate( var-list)\nfirstprivate( var-list)\ndefault( none | present )\n\nDescription\nWhen the program encounters an accelerator parallel construct, one or more gangs of workers\nare created to execute the accelerator parallel region The number of ga ngs, and the number of\nworkers in each gang and the number of vector lanes per worker remain c onstant for the duration of\nthat parallel region Each gang begins executing the code in the structure d block in gang-redundant\nmode even if there is only a single gang This means that code within the parallel region, but outside\nof a loop construct with gang-level worksharing, will be executed redu ndantly by all gangs\nOne worker in each gang begins executing the code in the structured block of the construct Note:\nUnless there is a loop construct within the parallel region, all gangs will execute all the code within\nthe region redundantly\nIf theasync clause does not appear, there is an implicit barrier at the end of the accele rator parallel\nregion, and the execution of the local thread will not proceed until all gan gs have reached the end\nof the parallel region\nThecopy ,copyin ,copyout ,create ,no_create ,present ,deviceptr , andattach\ndata clauses are described in Section 27 Data Clauses The private andfirstprivate\nclauses are described in Sections 2513 and Sections 2514 The device_type clause is de-\nscribed in Section 24 Device-Speci\ufb01c Clauses Implicitly determined data attribu tes are described\nin Section 262 Restrictions are described in Section 254\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of parallel construct. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 251 Parallel Construct\nSummary\nThis fundamental construct starts parallel execution on the current dev ice\nSyntax\nIn C and C++, the syntax of the OpenACC parallel construct is\n#pragma acc parallel [clause-list ]new-line\nstructured block\n\nand in Fortran, the syntax is\n!$acc parallel [clause-list ]\nstructured block\n!$acc end parallel\nor\n!$acc parallel [clause-list ]\nblock construct\n[!$acc end parallel ]\nwhere clause is one of the following:\nasync [(int-expr)]\nwait [(int-expr-list )]\nnum_gangs( int-expr-list )\nnum_workers( int-expr)\nvector_length( int-expr)\ndevice_type( device-type-list )\nif( condition)\nself [(condition)]\nreduction( operator:var-list)\ncopy( var-list)\ncopyin( [readonly: ]var-list)\ncopyout( [zero: ]var-list)\ncreate( [zero: ]var-list)\nno_create( var-list)\npresent( var-list)\ndeviceptr( var-list)\nattach( var-list)\nprivate( var-list)\nfirstprivate( var-list)\ndefault( none | present )\n\nDescription\nWhen the program encounters an accelerator parallel construct, one or more gangs of workers\nare created to execute the accelerator parallel region The number of ga ngs, and the number of\nworkers in each gang and the number of vector lanes per worker remain c onstant for the duration of\nthat parallel region Each gang begins executing the code in the structure d block in gang-redundant\nmode even if there is only a single gang This means that code within the parallel region, but outside\nof a loop construct with gang-level worksharing, will be executed redu ndantly by all gangs\nOne worker in each gang begins executing the code in the structured block of the construct Note:\nUnless there is a loop construct within the parallel region, all gangs will execute all the code within\nthe region redundantly\nIf theasync clause does not appear, there is an implicit barrier at the end of the accele rator parallel\nregion, and the execution of the local thread will not proceed until all gan gs have reached the end\nof the parallel region\nThecopy ,copyin ,copyout ,create ,no_create ,present ,deviceptr , andattach\ndata clauses are described in Section 27 Data Clauses The private andfirstprivate\nclauses are described in Sections 2513 and Sections 2514 The device_type clause is de-\nscribed in Section 24 Device-Speci\ufb01c Clauses Implicitly determined data attribu tes are described\nin Section 262 Restrictions are described in Section 254\n\nTemplate:\n\n#ifndef T1\n!T1:parallel construct,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of serial construct. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 252 Serial Construct\nSummary\nThis construct de\ufb01nes a region of the program that is to be executed seq uentially on the current\ndevice The behavior of the serial construct is the same as that of the parallel construct\nexcept that it always executes with a single gang of a single worker with a v ector length of one\nNote: Theserial construct may be used to execute sequential code on the current device ,\nwhich removes the need for data movement when the required data is already present on the device\nSyntax\nIn C and C++, the syntax of the OpenACC serial construct is\n#pragma acc serial [clause-list ]new-line\nstructured block\n\nand in Fortran, the syntax is\n!$acc serial [clause-list ]\nstructured block\n!$acc end serial\nor\n!$acc serial [clause-list ]\nblock construct\n[!$acc end serial ]\nwhere clause is as for the parallel construct except that the num_gangs ,num_workers , and\nvector_length clauses are not permitted\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of serial construct. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 252 Serial Construct\nSummary\nThis construct de\ufb01nes a region of the program that is to be executed seq uentially on the current\ndevice The behavior of the serial construct is the same as that of the parallel construct\nexcept that it always executes with a single gang of a single worker with a v ector length of one\nNote: Theserial construct may be used to execute sequential code on the current device ,\nwhich removes the need for data movement when the required data is already present on the device\nSyntax\nIn C and C++, the syntax of the OpenACC serial construct is\n#pragma acc serial [clause-list ]new-line\nstructured block\n\nand in Fortran, the syntax is\n!$acc serial [clause-list ]\nstructured block\n!$acc end serial\nor\n!$acc serial [clause-list ]\nblock construct\n[!$acc end serial ]\nwhere clause is as for the parallel construct except that the num_gangs ,num_workers , and\nvector_length clauses are not permitted\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of serial construct. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 252 Serial Construct\nSummary\nThis construct de\ufb01nes a region of the program that is to be executed seq uentially on the current\ndevice The behavior of the serial construct is the same as that of the parallel construct\nexcept that it always executes with a single gang of a single worker with a v ector length of one\nNote: Theserial construct may be used to execute sequential code on the current device ,\nwhich removes the need for data movement when the required data is already present on the device\nSyntax\nIn C and C++, the syntax of the OpenACC serial construct is\n#pragma acc serial [clause-list ]new-line\nstructured block\n\nand in Fortran, the syntax is\n!$acc serial [clause-list ]\nstructured block\n!$acc end serial\nor\n!$acc serial [clause-list ]\nblock construct\n[!$acc end serial ]\nwhere clause is as for the parallel construct except that the num_gangs ,num_workers , and\nvector_length clauses are not permitted\n\nTemplate:\n\n#ifndef T1\n!T1:serial construct,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of kernels construct. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 253 Kernels Construct\nSummary\nThis construct de\ufb01nes a region of the program that is to be compiled into a se quence of kernels for\nexecution on the current device\nSyntax\nIn C and C++, the syntax of the OpenACC kernels construct is\n#pragma acc kernels [clause-list ]new-line\nstructured block\n\nand in Fortran, the syntax is\n!$acc kernels [clause-list ]\nstructured block\n!$acc end kernels\nor\n!$acc kernels [clause-list ]\nblock construct\n[!$acc end kernels ]\nwhere clause is one of the following:\nasync [(int-expr)]\nwait [(int-expr-list )]\nnum_gangs( int-expr)\nnum_workers( int-expr)\nvector_length( int-expr)\ndevice_type( device-type-list )\nif( condition)\nself [(condition)]\ncopy( var-list)\ncopyin( [readonly: ]var-list)\ncopyout( [zero: ]var-list)\ncreate( [zero: ]var-list)\nno_create( var-list)\npresent( var-list)\ndeviceptr( var-list)\nattach( var-list)\ndefault( none | present )\nDescription\nThe compiler will split the code in the kernels region into a sequence of accele rator kernels Typi-\ncally, each loop nest will be a distinct kernel When the program encounte rs akernels construct,\nit will launch the sequence of kernels in order on the device The number a nd con\ufb01guration of gangs\nof workers and vector length may be different for each kernel\n\nIf theasync clause does not appear, there is an implicit barrier at the end of the kerne ls region,\nand the local thread execution will not proceed until the entire sequence o f kernels has completed\nexecution\nThecopy ,copyin ,copyout ,create ,no_create ,present ,deviceptr , andattach\ndata clauses are described in Section 27 Data Clauses The device_type clause is described\nin Section 24 Device-Speci\ufb01c Clauses Implicitly determined data attributes are d escribed in Sec-\ntion 262 Restrictions are described in Section 254\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of kernels construct. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 253 Kernels Construct\nSummary\nThis construct de\ufb01nes a region of the program that is to be compiled into a se quence of kernels for\nexecution on the current device\nSyntax\nIn C and C++, the syntax of the OpenACC kernels construct is\n#pragma acc kernels [clause-list ]new-line\nstructured block\n\nand in Fortran, the syntax is\n!$acc kernels [clause-list ]\nstructured block\n!$acc end kernels\nor\n!$acc kernels [clause-list ]\nblock construct\n[!$acc end kernels ]\nwhere clause is one of the following:\nasync [(int-expr)]\nwait [(int-expr-list )]\nnum_gangs( int-expr)\nnum_workers( int-expr)\nvector_length( int-expr)\ndevice_type( device-type-list )\nif( condition)\nself [(condition)]\ncopy( var-list)\ncopyin( [readonly: ]var-list)\ncopyout( [zero: ]var-list)\ncreate( [zero: ]var-list)\nno_create( var-list)\npresent( var-list)\ndeviceptr( var-list)\nattach( var-list)\ndefault( none | present )\nDescription\nThe compiler will split the code in the kernels region into a sequence of accele rator kernels Typi-\ncally, each loop nest will be a distinct kernel When the program encounte rs akernels construct,\nit will launch the sequence of kernels in order on the device The number a nd con\ufb01guration of gangs\nof workers and vector length may be different for each kernel\n\nIf theasync clause does not appear, there is an implicit barrier at the end of the kerne ls region,\nand the local thread execution will not proceed until the entire sequence o f kernels has completed\nexecution\nThecopy ,copyin ,copyout ,create ,no_create ,present ,deviceptr , andattach\ndata clauses are described in Section 27 Data Clauses The device_type clause is described\nin Section 24 Device-Speci\ufb01c Clauses Implicitly determined data attributes are d escribed in Sec-\ntion 262 Restrictions are described in Section 254\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of kernels construct. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 253 Kernels Construct\nSummary\nThis construct de\ufb01nes a region of the program that is to be compiled into a se quence of kernels for\nexecution on the current device\nSyntax\nIn C and C++, the syntax of the OpenACC kernels construct is\n#pragma acc kernels [clause-list ]new-line\nstructured block\n\nand in Fortran, the syntax is\n!$acc kernels [clause-list ]\nstructured block\n!$acc end kernels\nor\n!$acc kernels [clause-list ]\nblock construct\n[!$acc end kernels ]\nwhere clause is one of the following:\nasync [(int-expr)]\nwait [(int-expr-list )]\nnum_gangs( int-expr)\nnum_workers( int-expr)\nvector_length( int-expr)\ndevice_type( device-type-list )\nif( condition)\nself [(condition)]\ncopy( var-list)\ncopyin( [readonly: ]var-list)\ncopyout( [zero: ]var-list)\ncreate( [zero: ]var-list)\nno_create( var-list)\npresent( var-list)\ndeviceptr( var-list)\nattach( var-list)\ndefault( none | present )\nDescription\nThe compiler will split the code in the kernels region into a sequence of accele rator kernels Typi-\ncally, each loop nest will be a distinct kernel When the program encounte rs akernels construct,\nit will launch the sequence of kernels in order on the device The number a nd con\ufb01guration of gangs\nof workers and vector length may be different for each kernel\n\nIf theasync clause does not appear, there is an implicit barrier at the end of the kerne ls region,\nand the local thread execution will not proceed until the entire sequence o f kernels has completed\nexecution\nThecopy ,copyin ,copyout ,create ,no_create ,present ,deviceptr , andattach\ndata clauses are described in Section 27 Data Clauses The device_type clause is described\nin Section 24 Device-Speci\ufb01c Clauses Implicitly determined data attributes are d escribed in Sec-\ntion 262 Restrictions are described in Section 254\n\nTemplate:\n\n#ifndef T1\n!T1:kernels construct,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of parallel construct if clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct if clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct if clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 256 if clause\nTheifclause is optional\n\nWhen the condition in theifclause evaluates to true, the region will execute on the current device\nWhen the condition in theifclause evaluates to false , the local thread will execute the region\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct if clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of parallel construct if clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct if clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct if clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 256 if clause\nTheifclause is optional\n\nWhen the condition in theifclause evaluates to true, the region will execute on the current device\nWhen the condition in theifclause evaluates to false , the local thread will execute the region\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct if clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of parallel construct if clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct if clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct if clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 256 if clause\nTheifclause is optional\n\nWhen the condition in theifclause evaluates to true, the region will execute on the current device\nWhen the condition in theifclause evaluates to false , the local thread will execute the region\n\nTemplate:\n\n#ifndef T1\n!T1:parallel construct if clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of serial construct if clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct if clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct if clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 256 if clause\nTheifclause is optional\n\nWhen the condition in theifclause evaluates to true, the region will execute on the current device\nWhen the condition in theifclause evaluates to false , the local thread will execute the region\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct if clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of serial construct if clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct if clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct if clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 256 if clause\nTheifclause is optional\n\nWhen the condition in theifclause evaluates to true, the region will execute on the current device\nWhen the condition in theifclause evaluates to false , the local thread will execute the region\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct if clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of serial construct if clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct if clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct if clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 256 if clause\nTheifclause is optional\n\nWhen the condition in theifclause evaluates to true, the region will execute on the current device\nWhen the condition in theifclause evaluates to false , the local thread will execute the region\n\nTemplate:\n\n#ifndef T1\n!T1:serial construct if clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of kernels construct if clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct if clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct if clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 256 if clause\nTheifclause is optional\n\nWhen the condition in theifclause evaluates to true, the region will execute on the current device\nWhen the condition in theifclause evaluates to false , the local thread will execute the region\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct if clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of kernels construct if clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct if clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct if clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 256 if clause\nTheifclause is optional\n\nWhen the condition in theifclause evaluates to true, the region will execute on the current device\nWhen the condition in theifclause evaluates to false , the local thread will execute the region\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct if clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of kernels construct if clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct if clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct if clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 256 if clause\nTheifclause is optional\n\nWhen the condition in theifclause evaluates to true, the region will execute on the current device\nWhen the condition in theifclause evaluates to false , the local thread will execute the region\n\nTemplate:\n\n#ifndef T1\n!T1:kernels construct if clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of parallel construct self clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct self clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct self clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 257 self clause\nTheself clause is optional\nTheself clause may have a single condition-argument  If the condition-argument is not present it\nis assumed to evaluate to true When both an ifclause and a self clause appear and the condition\nin theifclause evaluates to false , theself clause has no effect\nWhen the condition evaluates to true, the region will execute on the local device When the condition\nin theself clause evaluates to false , the region will execute on the current device\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct self clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of parallel construct self clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct self clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct self clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 257 self clause\nTheself clause is optional\nTheself clause may have a single condition-argument  If the condition-argument is not present it\nis assumed to evaluate to true When both an ifclause and a self clause appear and the condition\nin theifclause evaluates to false , theself clause has no effect\nWhen the condition evaluates to true, the region will execute on the local device When the condition\nin theself clause evaluates to false , the region will execute on the current device\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct self clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of parallel construct self clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct self clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct self clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 257 self clause\nTheself clause is optional\nTheself clause may have a single condition-argument  If the condition-argument is not present it\nis assumed to evaluate to true When both an ifclause and a self clause appear and the condition\nin theifclause evaluates to false , theself clause has no effect\nWhen the condition evaluates to true, the region will execute on the local device When the condition\nin theself clause evaluates to false , the region will execute on the current device\n\nTemplate:\n\n#ifndef T1\n!T1:parallel construct self clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of serial construct self clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct self clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct self clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 257 self clause\nTheself clause is optional\nTheself clause may have a single condition-argument  If the condition-argument is not present it\nis assumed to evaluate to true When both an ifclause and a self clause appear and the condition\nin theifclause evaluates to false , theself clause has no effect\nWhen the condition evaluates to true, the region will execute on the local device When the condition\nin theself clause evaluates to false , the region will execute on the current device\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct self clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of serial construct self clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct self clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct self clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 257 self clause\nTheself clause is optional\nTheself clause may have a single condition-argument  If the condition-argument is not present it\nis assumed to evaluate to true When both an ifclause and a self clause appear and the condition\nin theifclause evaluates to false , theself clause has no effect\nWhen the condition evaluates to true, the region will execute on the local device When the condition\nin theself clause evaluates to false , the region will execute on the current device\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct self clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of serial construct self clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct self clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct self clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 257 self clause\nTheself clause is optional\nTheself clause may have a single condition-argument  If the condition-argument is not present it\nis assumed to evaluate to true When both an ifclause and a self clause appear and the condition\nin theifclause evaluates to false , theself clause has no effect\nWhen the condition evaluates to true, the region will execute on the local device When the condition\nin theself clause evaluates to false , the region will execute on the current device\n\nTemplate:\n\n#ifndef T1\n!T1:serial construct self clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of kernels construct self clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct self clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct self clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 257 self clause\nTheself clause is optional\nTheself clause may have a single condition-argument  If the condition-argument is not present it\nis assumed to evaluate to true When both an ifclause and a self clause appear and the condition\nin theifclause evaluates to false , theself clause has no effect\nWhen the condition evaluates to true, the region will execute on the local device When the condition\nin theself clause evaluates to false , the region will execute on the current device\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct self clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of kernels construct self clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct self clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct self clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 257 self clause\nTheself clause is optional\nTheself clause may have a single condition-argument  If the condition-argument is not present it\nis assumed to evaluate to true When both an ifclause and a self clause appear and the condition\nin theifclause evaluates to false , theself clause has no effect\nWhen the condition evaluates to true, the region will execute on the local device When the condition\nin theself clause evaluates to false , the region will execute on the current device\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct self clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of kernels construct self clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct self clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct self clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 257 self clause\nTheself clause is optional\nTheself clause may have a single condition-argument  If the condition-argument is not present it\nis assumed to evaluate to true When both an ifclause and a self clause appear and the condition\nin theifclause evaluates to false , theself clause has no effect\nWhen the condition evaluates to true, the region will execute on the local device When the condition\nin theself clause evaluates to false , the region will execute on the current device\n\nTemplate:\n\n#ifndef T1\n!T1:kernels construct self clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of parallel construct async clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct async clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct async clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 258 async clause\nTheasync clause is optional; see Section 216 Asynchronous Behavior for more info rmation\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct async clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of parallel construct async clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct async clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct async clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 258 async clause\nTheasync clause is optional; see Section 216 Asynchronous Behavior for more info rmation\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct async clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of parallel construct async clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct async clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct async clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 258 async clause\nTheasync clause is optional; see Section 216 Asynchronous Behavior for more info rmation\n\nTemplate:\n\n#ifndef T1\n!T1:parallel construct async clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of serial construct async clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct async clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct async clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 258 async clause\nTheasync clause is optional; see Section 216 Asynchronous Behavior for more info rmation\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct async clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of serial construct async clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct async clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct async clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 258 async clause\nTheasync clause is optional; see Section 216 Asynchronous Behavior for more info rmation\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct async clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of serial construct async clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct async clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct async clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 258 async clause\nTheasync clause is optional; see Section 216 Asynchronous Behavior for more info rmation\n\nTemplate:\n\n#ifndef T1\n!T1:serial construct async clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of kernels construct async clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct async clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct async clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 258 async clause\nTheasync clause is optional; see Section 216 Asynchronous Behavior for more info rmation\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct async clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of kernels construct async clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct async clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct async clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 258 async clause\nTheasync clause is optional; see Section 216 Asynchronous Behavior for more info rmation\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct async clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of kernels construct async clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct async clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct async clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 258 async clause\nTheasync clause is optional; see Section 216 Asynchronous Behavior for more info rmation\n\nTemplate:\n\n#ifndef T1\n!T1:kernels construct async clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of parallel construct wait clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct wait clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct wait clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 259 wait clause\nThewait clause is optional; see Section 216 Asynchronous Behavior for more infor mation\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct wait clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of parallel construct wait clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct wait clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct wait clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 259 wait clause\nThewait clause is optional; see Section 216 Asynchronous Behavior for more infor mation\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct wait clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of parallel construct wait clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct wait clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct wait clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 259 wait clause\nThewait clause is optional; see Section 216 Asynchronous Behavior for more infor mation\n\nTemplate:\n\n#ifndef T1\n!T1:parallel construct wait clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of serial construct wait clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct wait clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct wait clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 259 wait clause\nThewait clause is optional; see Section 216 Asynchronous Behavior for more infor mation\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct wait clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of serial construct wait clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct wait clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct wait clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 259 wait clause\nThewait clause is optional; see Section 216 Asynchronous Behavior for more infor mation\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct wait clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of serial construct wait clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct wait clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct wait clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 259 wait clause\nThewait clause is optional; see Section 216 Asynchronous Behavior for more infor mation\n\nTemplate:\n\n#ifndef T1\n!T1:serial construct wait clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of kernels construct wait clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct wait clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct wait clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 259 wait clause\nThewait clause is optional; see Section 216 Asynchronous Behavior for more infor mation\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct wait clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of kernels construct wait clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct wait clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct wait clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 259 wait clause\nThewait clause is optional; see Section 216 Asynchronous Behavior for more infor mation\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct wait clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of kernels construct wait clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct wait clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct wait clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 259 wait clause\nThewait clause is optional; see Section 216 Asynchronous Behavior for more infor mation\n\nTemplate:\n\n#ifndef T1\n!T1:kernels construct wait clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of parallel construct num_gangs clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct num_gangs clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct num_gangs clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2510 num gangs clause\nThenum_gangs clause is allowed on the parallel andkernels constructs On a parallel\nconstruct, it may have one, two, or three arguments The values of the integ er expressions de\ufb01ne\nthe number of parallel gangs along dimensions one, two, and three that will e xecute the parallel\nregion If it has fewer than three arguments, the missing values are treated as having the value 1\nThe total number of gangs must be at least 1 and is the product of the value s of the arguments On a\nkernels construct, the num_gangs clause must have a single argument, the value of which will\nde\ufb01ne the number of parallel gangs that will execute each kernel create d for the kernels region\nIf thenum_gangs clause does not appear, an implementation-de\ufb01ned default will be used wh ich\nmay depend on the code within the construct The implementation may use a lower va lue than\nspeci\ufb01ed based on limitations imposed by the target architecture\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct num_gangs clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of parallel construct num_gangs clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct num_gangs clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct num_gangs clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2510 num gangs clause\nThenum_gangs clause is allowed on the parallel andkernels constructs On a parallel\nconstruct, it may have one, two, or three arguments The values of the integ er expressions de\ufb01ne\nthe number of parallel gangs along dimensions one, two, and three that will e xecute the parallel\nregion If it has fewer than three arguments, the missing values are treated as having the value 1\nThe total number of gangs must be at least 1 and is the product of the value s of the arguments On a\nkernels construct, the num_gangs clause must have a single argument, the value of which will\nde\ufb01ne the number of parallel gangs that will execute each kernel create d for the kernels region\nIf thenum_gangs clause does not appear, an implementation-de\ufb01ned default will be used wh ich\nmay depend on the code within the construct The implementation may use a lower va lue than\nspeci\ufb01ed based on limitations imposed by the target architecture\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct num_gangs clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of parallel construct num_gangs clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct num_gangs clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct num_gangs clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2510 num gangs clause\nThenum_gangs clause is allowed on the parallel andkernels constructs On a parallel\nconstruct, it may have one, two, or three arguments The values of the integ er expressions de\ufb01ne\nthe number of parallel gangs along dimensions one, two, and three that will e xecute the parallel\nregion If it has fewer than three arguments, the missing values are treated as having the value 1\nThe total number of gangs must be at least 1 and is the product of the value s of the arguments On a\nkernels construct, the num_gangs clause must have a single argument, the value of which will\nde\ufb01ne the number of parallel gangs that will execute each kernel create d for the kernels region\nIf thenum_gangs clause does not appear, an implementation-de\ufb01ned default will be used wh ich\nmay depend on the code within the construct The implementation may use a lower va lue than\nspeci\ufb01ed based on limitations imposed by the target architecture\n\nTemplate:\n\n#ifndef T1\n!T1:parallel construct num_gangs clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of serial construct num_gangs clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct num_gangs clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct num_gangs clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2510 num gangs clause\nThenum_gangs clause is allowed on the parallel andkernels constructs On a parallel\nconstruct, it may have one, two, or three arguments The values of the integ er expressions de\ufb01ne\nthe number of parallel gangs along dimensions one, two, and three that will e xecute the parallel\nregion If it has fewer than three arguments, the missing values are treated as having the value 1\nThe total number of gangs must be at least 1 and is the product of the value s of the arguments On a\nkernels construct, the num_gangs clause must have a single argument, the value of which will\nde\ufb01ne the number of parallel gangs that will execute each kernel create d for the kernels region\nIf thenum_gangs clause does not appear, an implementation-de\ufb01ned default will be used wh ich\nmay depend on the code within the construct The implementation may use a lower va lue than\nspeci\ufb01ed based on limitations imposed by the target architecture\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct num_gangs clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of serial construct num_gangs clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct num_gangs clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct num_gangs clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2510 num gangs clause\nThenum_gangs clause is allowed on the parallel andkernels constructs On a parallel\nconstruct, it may have one, two, or three arguments The values of the integ er expressions de\ufb01ne\nthe number of parallel gangs along dimensions one, two, and three that will e xecute the parallel\nregion If it has fewer than three arguments, the missing values are treated as having the value 1\nThe total number of gangs must be at least 1 and is the product of the value s of the arguments On a\nkernels construct, the num_gangs clause must have a single argument, the value of which will\nde\ufb01ne the number of parallel gangs that will execute each kernel create d for the kernels region\nIf thenum_gangs clause does not appear, an implementation-de\ufb01ned default will be used wh ich\nmay depend on the code within the construct The implementation may use a lower va lue than\nspeci\ufb01ed based on limitations imposed by the target architecture\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct num_gangs clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of serial construct num_gangs clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct num_gangs clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct num_gangs clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2510 num gangs clause\nThenum_gangs clause is allowed on the parallel andkernels constructs On a parallel\nconstruct, it may have one, two, or three arguments The values of the integ er expressions de\ufb01ne\nthe number of parallel gangs along dimensions one, two, and three that will e xecute the parallel\nregion If it has fewer than three arguments, the missing values are treated as having the value 1\nThe total number of gangs must be at least 1 and is the product of the value s of the arguments On a\nkernels construct, the num_gangs clause must have a single argument, the value of which will\nde\ufb01ne the number of parallel gangs that will execute each kernel create d for the kernels region\nIf thenum_gangs clause does not appear, an implementation-de\ufb01ned default will be used wh ich\nmay depend on the code within the construct The implementation may use a lower va lue than\nspeci\ufb01ed based on limitations imposed by the target architecture\n\nTemplate:\n\n#ifndef T1\n!T1:serial construct num_gangs clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of kernels construct num_gangs clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct num_gangs clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct num_gangs clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2510 num gangs clause\nThenum_gangs clause is allowed on the parallel andkernels constructs On a parallel\nconstruct, it may have one, two, or three arguments The values of the integ er expressions de\ufb01ne\nthe number of parallel gangs along dimensions one, two, and three that will e xecute the parallel\nregion If it has fewer than three arguments, the missing values are treated as having the value 1\nThe total number of gangs must be at least 1 and is the product of the value s of the arguments On a\nkernels construct, the num_gangs clause must have a single argument, the value of which will\nde\ufb01ne the number of parallel gangs that will execute each kernel create d for the kernels region\nIf thenum_gangs clause does not appear, an implementation-de\ufb01ned default will be used wh ich\nmay depend on the code within the construct The implementation may use a lower va lue than\nspeci\ufb01ed based on limitations imposed by the target architecture\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct num_gangs clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of kernels construct num_gangs clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct num_gangs clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct num_gangs clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2510 num gangs clause\nThenum_gangs clause is allowed on the parallel andkernels constructs On a parallel\nconstruct, it may have one, two, or three arguments The values of the integ er expressions de\ufb01ne\nthe number of parallel gangs along dimensions one, two, and three that will e xecute the parallel\nregion If it has fewer than three arguments, the missing values are treated as having the value 1\nThe total number of gangs must be at least 1 and is the product of the value s of the arguments On a\nkernels construct, the num_gangs clause must have a single argument, the value of which will\nde\ufb01ne the number of parallel gangs that will execute each kernel create d for the kernels region\nIf thenum_gangs clause does not appear, an implementation-de\ufb01ned default will be used wh ich\nmay depend on the code within the construct The implementation may use a lower va lue than\nspeci\ufb01ed based on limitations imposed by the target architecture\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct num_gangs clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of kernels construct num_gangs clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct num_gangs clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct num_gangs clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2510 num gangs clause\nThenum_gangs clause is allowed on the parallel andkernels constructs On a parallel\nconstruct, it may have one, two, or three arguments The values of the integ er expressions de\ufb01ne\nthe number of parallel gangs along dimensions one, two, and three that will e xecute the parallel\nregion If it has fewer than three arguments, the missing values are treated as having the value 1\nThe total number of gangs must be at least 1 and is the product of the value s of the arguments On a\nkernels construct, the num_gangs clause must have a single argument, the value of which will\nde\ufb01ne the number of parallel gangs that will execute each kernel create d for the kernels region\nIf thenum_gangs clause does not appear, an implementation-de\ufb01ned default will be used wh ich\nmay depend on the code within the construct The implementation may use a lower va lue than\nspeci\ufb01ed based on limitations imposed by the target architecture\n\nTemplate:\n\n#ifndef T1\n!T1:kernels construct num_gangs clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of parallel construct num_workers clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct num_workers clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct num_workers clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: No context available for this feature\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct num_workers clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of parallel construct num_workers clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct num_workers clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct num_workers clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: No context available for this feature\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct num_workers clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of parallel construct num_workers clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct num_workers clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct num_workers clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: No context available for this feature\n\nTemplate:\n\n#ifndef T1\n!T1:parallel construct num_workers clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of serial construct num_workers clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct num_workers clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct num_workers clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: No context available for this feature\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct num_workers clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of serial construct num_workers clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct num_workers clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct num_workers clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: No context available for this feature\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct num_workers clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of serial construct num_workers clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct num_workers clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct num_workers clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: No context available for this feature\n\nTemplate:\n\n#ifndef T1\n!T1:serial construct num_workers clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of kernels construct num_workers clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct num_workers clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct num_workers clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: No context available for this feature\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct num_workers clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of kernels construct num_workers clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct num_workers clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct num_workers clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: No context available for this feature\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct num_workers clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of kernels construct num_workers clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct num_workers clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct num_workers clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: No context available for this feature\n\nTemplate:\n\n#ifndef T1\n!T1:kernels construct num_workers clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of parallel construct vector_length clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct vector_length clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct vector_length clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2512 vector length clause\nThevector_length clause is allowed on the parallel andkernels constructs The value\nof the integer expression de\ufb01nes the number of vector lanes that will be ac tive after a worker transi-\ntions from vector-single mode to vector-partitioned mode This clause determin es the vector length\nto use for vector or SIMD operations If the clause does not appear, a n implementation-de\ufb01ned\n\ndefault will be used This vector length will be used for loop constructs an notated with the vector\nclause, as well as loops automatically vectorized by the compiler The implementatio n may use a\ndifferent value than speci\ufb01ed based on limitations imposed by the target arch itecture\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct vector_length clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of parallel construct vector_length clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct vector_length clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct vector_length clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2512 vector length clause\nThevector_length clause is allowed on the parallel andkernels constructs The value\nof the integer expression de\ufb01nes the number of vector lanes that will be ac tive after a worker transi-\ntions from vector-single mode to vector-partitioned mode This clause determin es the vector length\nto use for vector or SIMD operations If the clause does not appear, a n implementation-de\ufb01ned\n\ndefault will be used This vector length will be used for loop constructs an notated with the vector\nclause, as well as loops automatically vectorized by the compiler The implementatio n may use a\ndifferent value than speci\ufb01ed based on limitations imposed by the target arch itecture\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct vector_length clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of parallel construct vector_length clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct vector_length clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct vector_length clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2512 vector length clause\nThevector_length clause is allowed on the parallel andkernels constructs The value\nof the integer expression de\ufb01nes the number of vector lanes that will be ac tive after a worker transi-\ntions from vector-single mode to vector-partitioned mode This clause determin es the vector length\nto use for vector or SIMD operations If the clause does not appear, a n implementation-de\ufb01ned\n\ndefault will be used This vector length will be used for loop constructs an notated with the vector\nclause, as well as loops automatically vectorized by the compiler The implementatio n may use a\ndifferent value than speci\ufb01ed based on limitations imposed by the target arch itecture\n\nTemplate:\n\n#ifndef T1\n!T1:parallel construct vector_length clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of serial construct vector_length clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct vector_length clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct vector_length clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2512 vector length clause\nThevector_length clause is allowed on the parallel andkernels constructs The value\nof the integer expression de\ufb01nes the number of vector lanes that will be ac tive after a worker transi-\ntions from vector-single mode to vector-partitioned mode This clause determin es the vector length\nto use for vector or SIMD operations If the clause does not appear, a n implementation-de\ufb01ned\n\ndefault will be used This vector length will be used for loop constructs an notated with the vector\nclause, as well as loops automatically vectorized by the compiler The implementatio n may use a\ndifferent value than speci\ufb01ed based on limitations imposed by the target arch itecture\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct vector_length clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of serial construct vector_length clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct vector_length clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct vector_length clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2512 vector length clause\nThevector_length clause is allowed on the parallel andkernels constructs The value\nof the integer expression de\ufb01nes the number of vector lanes that will be ac tive after a worker transi-\ntions from vector-single mode to vector-partitioned mode This clause determin es the vector length\nto use for vector or SIMD operations If the clause does not appear, a n implementation-de\ufb01ned\n\ndefault will be used This vector length will be used for loop constructs an notated with the vector\nclause, as well as loops automatically vectorized by the compiler The implementatio n may use a\ndifferent value than speci\ufb01ed based on limitations imposed by the target arch itecture\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct vector_length clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of serial construct vector_length clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct vector_length clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct vector_length clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2512 vector length clause\nThevector_length clause is allowed on the parallel andkernels constructs The value\nof the integer expression de\ufb01nes the number of vector lanes that will be ac tive after a worker transi-\ntions from vector-single mode to vector-partitioned mode This clause determin es the vector length\nto use for vector or SIMD operations If the clause does not appear, a n implementation-de\ufb01ned\n\ndefault will be used This vector length will be used for loop constructs an notated with the vector\nclause, as well as loops automatically vectorized by the compiler The implementatio n may use a\ndifferent value than speci\ufb01ed based on limitations imposed by the target arch itecture\n\nTemplate:\n\n#ifndef T1\n!T1:serial construct vector_length clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of kernels construct vector_length clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct vector_length clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct vector_length clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2512 vector length clause\nThevector_length clause is allowed on the parallel andkernels constructs The value\nof the integer expression de\ufb01nes the number of vector lanes that will be ac tive after a worker transi-\ntions from vector-single mode to vector-partitioned mode This clause determin es the vector length\nto use for vector or SIMD operations If the clause does not appear, a n implementation-de\ufb01ned\n\ndefault will be used This vector length will be used for loop constructs an notated with the vector\nclause, as well as loops automatically vectorized by the compiler The implementatio n may use a\ndifferent value than speci\ufb01ed based on limitations imposed by the target arch itecture\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct vector_length clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of kernels construct vector_length clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct vector_length clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct vector_length clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2512 vector length clause\nThevector_length clause is allowed on the parallel andkernels constructs The value\nof the integer expression de\ufb01nes the number of vector lanes that will be ac tive after a worker transi-\ntions from vector-single mode to vector-partitioned mode This clause determin es the vector length\nto use for vector or SIMD operations If the clause does not appear, a n implementation-de\ufb01ned\n\ndefault will be used This vector length will be used for loop constructs an notated with the vector\nclause, as well as loops automatically vectorized by the compiler The implementatio n may use a\ndifferent value than speci\ufb01ed based on limitations imposed by the target arch itecture\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct vector_length clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of kernels construct vector_length clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct vector_length clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct vector_length clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2512 vector length clause\nThevector_length clause is allowed on the parallel andkernels constructs The value\nof the integer expression de\ufb01nes the number of vector lanes that will be ac tive after a worker transi-\ntions from vector-single mode to vector-partitioned mode This clause determin es the vector length\nto use for vector or SIMD operations If the clause does not appear, a n implementation-de\ufb01ned\n\ndefault will be used This vector length will be used for loop constructs an notated with the vector\nclause, as well as loops automatically vectorized by the compiler The implementatio n may use a\ndifferent value than speci\ufb01ed based on limitations imposed by the target arch itecture\n\nTemplate:\n\n#ifndef T1\n!T1:kernels construct vector_length clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of parallel construct private clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct private clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct private clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2513 private clause\nTheprivate clause is allowed on the parallel andserial constructs; it declares that a copy\nof each item on the list will be created for each gang in all dimensions\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in private\nclauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct private clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of parallel construct private clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct private clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct private clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2513 private clause\nTheprivate clause is allowed on the parallel andserial constructs; it declares that a copy\nof each item on the list will be created for each gang in all dimensions\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in private\nclauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct private clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of parallel construct private clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct private clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct private clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2513 private clause\nTheprivate clause is allowed on the parallel andserial constructs; it declares that a copy\nof each item on the list will be created for each gang in all dimensions\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in private\nclauses\n\nTemplate:\n\n#ifndef T1\n!T1:parallel construct private clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of serial construct private clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct private clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct private clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2513 private clause\nTheprivate clause is allowed on the parallel andserial constructs; it declares that a copy\nof each item on the list will be created for each gang in all dimensions\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in private\nclauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct private clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of serial construct private clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct private clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct private clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2513 private clause\nTheprivate clause is allowed on the parallel andserial constructs; it declares that a copy\nof each item on the list will be created for each gang in all dimensions\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in private\nclauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct private clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of serial construct private clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct private clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct private clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2513 private clause\nTheprivate clause is allowed on the parallel andserial constructs; it declares that a copy\nof each item on the list will be created for each gang in all dimensions\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in private\nclauses\n\nTemplate:\n\n#ifndef T1\n!T1:serial construct private clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of kernels construct private clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct private clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct private clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2513 private clause\nTheprivate clause is allowed on the parallel andserial constructs; it declares that a copy\nof each item on the list will be created for each gang in all dimensions\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in private\nclauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct private clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of kernels construct private clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct private clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct private clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2513 private clause\nTheprivate clause is allowed on the parallel andserial constructs; it declares that a copy\nof each item on the list will be created for each gang in all dimensions\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in private\nclauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct private clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of kernels construct private clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct private clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct private clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2513 private clause\nTheprivate clause is allowed on the parallel andserial constructs; it declares that a copy\nof each item on the list will be created for each gang in all dimensions\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in private\nclauses\n\nTemplate:\n\n#ifndef T1\n!T1:kernels construct private clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of parallel construct firstprivate clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct firstprivate clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct firstprivate clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2514 \ufb01rstprivate clause\nThefirstprivate clause is allowed on the parallel andserial constructs; it declares that\na copy of each item on the list will be created for each gang, and that the co py will be initialized with\nthe value of that item on the local thread when a parallel orserial construct is encountered\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nfirstprivate clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct firstprivate clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of parallel construct firstprivate clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct firstprivate clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct firstprivate clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2514 \ufb01rstprivate clause\nThefirstprivate clause is allowed on the parallel andserial constructs; it declares that\na copy of each item on the list will be created for each gang, and that the co py will be initialized with\nthe value of that item on the local thread when a parallel orserial construct is encountered\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nfirstprivate clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct firstprivate clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of parallel construct firstprivate clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct firstprivate clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct firstprivate clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2514 \ufb01rstprivate clause\nThefirstprivate clause is allowed on the parallel andserial constructs; it declares that\na copy of each item on the list will be created for each gang, and that the co py will be initialized with\nthe value of that item on the local thread when a parallel orserial construct is encountered\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nfirstprivate clauses\n\nTemplate:\n\n#ifndef T1\n!T1:parallel construct firstprivate clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of serial construct firstprivate clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct firstprivate clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct firstprivate clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2514 \ufb01rstprivate clause\nThefirstprivate clause is allowed on the parallel andserial constructs; it declares that\na copy of each item on the list will be created for each gang, and that the co py will be initialized with\nthe value of that item on the local thread when a parallel orserial construct is encountered\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nfirstprivate clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct firstprivate clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of serial construct firstprivate clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct firstprivate clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct firstprivate clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2514 \ufb01rstprivate clause\nThefirstprivate clause is allowed on the parallel andserial constructs; it declares that\na copy of each item on the list will be created for each gang, and that the co py will be initialized with\nthe value of that item on the local thread when a parallel orserial construct is encountered\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nfirstprivate clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct firstprivate clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of serial construct firstprivate clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct firstprivate clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct firstprivate clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2514 \ufb01rstprivate clause\nThefirstprivate clause is allowed on the parallel andserial constructs; it declares that\na copy of each item on the list will be created for each gang, and that the co py will be initialized with\nthe value of that item on the local thread when a parallel orserial construct is encountered\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nfirstprivate clauses\n\nTemplate:\n\n#ifndef T1\n!T1:serial construct firstprivate clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of kernels construct firstprivate clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct firstprivate clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct firstprivate clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2514 \ufb01rstprivate clause\nThefirstprivate clause is allowed on the parallel andserial constructs; it declares that\na copy of each item on the list will be created for each gang, and that the co py will be initialized with\nthe value of that item on the local thread when a parallel orserial construct is encountered\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nfirstprivate clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct firstprivate clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of kernels construct firstprivate clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct firstprivate clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct firstprivate clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2514 \ufb01rstprivate clause\nThefirstprivate clause is allowed on the parallel andserial constructs; it declares that\na copy of each item on the list will be created for each gang, and that the co py will be initialized with\nthe value of that item on the local thread when a parallel orserial construct is encountered\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nfirstprivate clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct firstprivate clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of kernels construct firstprivate clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct firstprivate clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct firstprivate clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2514 \ufb01rstprivate clause\nThefirstprivate clause is allowed on the parallel andserial constructs; it declares that\na copy of each item on the list will be created for each gang, and that the co py will be initialized with\nthe value of that item on the local thread when a parallel orserial construct is encountered\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nfirstprivate clauses\n\nTemplate:\n\n#ifndef T1\n!T1:kernels construct firstprivate clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of parallel construct reduction clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct reduction clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct reduction clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2515 reduction clause\nThereduction clause is allowed on the parallel andserial constructs It speci\ufb01es a\nreduction operator and one or more vars It implies copy clauses as described in Section 262 For\neach reduction var, a private copy is created for each parallel gang and initialized for that o perator\nAt the end of the region, the values for each gang are combined using the r eduction operator, and\nthe result combined with the value of the original varand stored in the original var If the reduction\nvaris an array or subarray, the array reduction operation is logically equiv alent to applying that\nreduction operation to each element of the array or subarray individually  If the reduction var\nis a composite variable, the reduction operation is logically equivalent to apply ing that reduction\noperation to each member of the composite variable individually The reduction result is available\nafter the region\nThe following table lists the operators that are valid and the initialization values; in each case, the\ninitialization value will be cast into the data type of the var Formax andmin reductions, the\ninitialization values are the least representable value and the largest repre sentable value for that data\ntype, respectively At a minimum, the supported data types include Fortran logical as well as\nthe numerical data types in C (eg, _Bool ,char ,int,float ,double ,float _Complex ,\ndouble _Complex ), C++ (eg, bool ,char ,wchar_t ,int,float ,double ), and Fortran\n(eg,integer ,real ,doubleprecision ,complex ) However, for each reduction operator,\nthe supported data types include only the types permitted as operands to the co rresponding operator\nin the base language where (1) for max and min, the corresponding opera tor is less-than and (2) for\nother operators, the operands and the result are the same type\n\nC and C++ Fortran\noperator initialization\nvalueoperator initialization\nvalue\n+ 0 +\n* 1 *\nmax least max least\nmin largest min largest\n& \u02dc0 iand all bits on\n| 0 ior\n\u02c6 0 ieor\n&& 1 and true\n|| 0 or false\neqv true\nneqv false\nRestrictions\n\tAvarin areduction clause must be a scalar variable name, an aggregate variable name,\nan array element, or a subarray (refer to Section 271)\n\tIf the reduction varis an array element or a subarray, accessing the elements of the array\noutside the speci\ufb01ed index range results in unspeci\ufb01ed behavior\n\tThe reduction varmay not be a member of a composite variable\n\tIf the reduction varis a composite variable, each member of the composite variable must be\na supported datatype for the reduction operation\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nreduction clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct reduction clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of parallel construct reduction clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct reduction clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct reduction clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2515 reduction clause\nThereduction clause is allowed on the parallel andserial constructs It speci\ufb01es a\nreduction operator and one or more vars It implies copy clauses as described in Section 262 For\neach reduction var, a private copy is created for each parallel gang and initialized for that o perator\nAt the end of the region, the values for each gang are combined using the r eduction operator, and\nthe result combined with the value of the original varand stored in the original var If the reduction\nvaris an array or subarray, the array reduction operation is logically equiv alent to applying that\nreduction operation to each element of the array or subarray individually  If the reduction var\nis a composite variable, the reduction operation is logically equivalent to apply ing that reduction\noperation to each member of the composite variable individually The reduction result is available\nafter the region\nThe following table lists the operators that are valid and the initialization values; in each case, the\ninitialization value will be cast into the data type of the var Formax andmin reductions, the\ninitialization values are the least representable value and the largest repre sentable value for that data\ntype, respectively At a minimum, the supported data types include Fortran logical as well as\nthe numerical data types in C (eg, _Bool ,char ,int,float ,double ,float _Complex ,\ndouble _Complex ), C++ (eg, bool ,char ,wchar_t ,int,float ,double ), and Fortran\n(eg,integer ,real ,doubleprecision ,complex ) However, for each reduction operator,\nthe supported data types include only the types permitted as operands to the co rresponding operator\nin the base language where (1) for max and min, the corresponding opera tor is less-than and (2) for\nother operators, the operands and the result are the same type\n\nC and C++ Fortran\noperator initialization\nvalueoperator initialization\nvalue\n+ 0 +\n* 1 *\nmax least max least\nmin largest min largest\n& \u02dc0 iand all bits on\n| 0 ior\n\u02c6 0 ieor\n&& 1 and true\n|| 0 or false\neqv true\nneqv false\nRestrictions\n\tAvarin areduction clause must be a scalar variable name, an aggregate variable name,\nan array element, or a subarray (refer to Section 271)\n\tIf the reduction varis an array element or a subarray, accessing the elements of the array\noutside the speci\ufb01ed index range results in unspeci\ufb01ed behavior\n\tThe reduction varmay not be a member of a composite variable\n\tIf the reduction varis a composite variable, each member of the composite variable must be\na supported datatype for the reduction operation\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nreduction clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct reduction clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of parallel construct reduction clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct reduction clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct reduction clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2515 reduction clause\nThereduction clause is allowed on the parallel andserial constructs It speci\ufb01es a\nreduction operator and one or more vars It implies copy clauses as described in Section 262 For\neach reduction var, a private copy is created for each parallel gang and initialized for that o perator\nAt the end of the region, the values for each gang are combined using the r eduction operator, and\nthe result combined with the value of the original varand stored in the original var If the reduction\nvaris an array or subarray, the array reduction operation is logically equiv alent to applying that\nreduction operation to each element of the array or subarray individually  If the reduction var\nis a composite variable, the reduction operation is logically equivalent to apply ing that reduction\noperation to each member of the composite variable individually The reduction result is available\nafter the region\nThe following table lists the operators that are valid and the initialization values; in each case, the\ninitialization value will be cast into the data type of the var Formax andmin reductions, the\ninitialization values are the least representable value and the largest repre sentable value for that data\ntype, respectively At a minimum, the supported data types include Fortran logical as well as\nthe numerical data types in C (eg, _Bool ,char ,int,float ,double ,float _Complex ,\ndouble _Complex ), C++ (eg, bool ,char ,wchar_t ,int,float ,double ), and Fortran\n(eg,integer ,real ,doubleprecision ,complex ) However, for each reduction operator,\nthe supported data types include only the types permitted as operands to the co rresponding operator\nin the base language where (1) for max and min, the corresponding opera tor is less-than and (2) for\nother operators, the operands and the result are the same type\n\nC and C++ Fortran\noperator initialization\nvalueoperator initialization\nvalue\n+ 0 +\n* 1 *\nmax least max least\nmin largest min largest\n& \u02dc0 iand all bits on\n| 0 ior\n\u02c6 0 ieor\n&& 1 and true\n|| 0 or false\neqv true\nneqv false\nRestrictions\n\tAvarin areduction clause must be a scalar variable name, an aggregate variable name,\nan array element, or a subarray (refer to Section 271)\n\tIf the reduction varis an array element or a subarray, accessing the elements of the array\noutside the speci\ufb01ed index range results in unspeci\ufb01ed behavior\n\tThe reduction varmay not be a member of a composite variable\n\tIf the reduction varis a composite variable, each member of the composite variable must be\na supported datatype for the reduction operation\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nreduction clauses\n\nTemplate:\n\n#ifndef T1\n!T1:parallel construct reduction clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of serial construct reduction clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct reduction clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct reduction clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2515 reduction clause\nThereduction clause is allowed on the parallel andserial constructs It speci\ufb01es a\nreduction operator and one or more vars It implies copy clauses as described in Section 262 For\neach reduction var, a private copy is created for each parallel gang and initialized for that o perator\nAt the end of the region, the values for each gang are combined using the r eduction operator, and\nthe result combined with the value of the original varand stored in the original var If the reduction\nvaris an array or subarray, the array reduction operation is logically equiv alent to applying that\nreduction operation to each element of the array or subarray individually  If the reduction var\nis a composite variable, the reduction operation is logically equivalent to apply ing that reduction\noperation to each member of the composite variable individually The reduction result is available\nafter the region\nThe following table lists the operators that are valid and the initialization values; in each case, the\ninitialization value will be cast into the data type of the var Formax andmin reductions, the\ninitialization values are the least representable value and the largest repre sentable value for that data\ntype, respectively At a minimum, the supported data types include Fortran logical as well as\nthe numerical data types in C (eg, _Bool ,char ,int,float ,double ,float _Complex ,\ndouble _Complex ), C++ (eg, bool ,char ,wchar_t ,int,float ,double ), and Fortran\n(eg,integer ,real ,doubleprecision ,complex ) However, for each reduction operator,\nthe supported data types include only the types permitted as operands to the co rresponding operator\nin the base language where (1) for max and min, the corresponding opera tor is less-than and (2) for\nother operators, the operands and the result are the same type\n\nC and C++ Fortran\noperator initialization\nvalueoperator initialization\nvalue\n+ 0 +\n* 1 *\nmax least max least\nmin largest min largest\n& \u02dc0 iand all bits on\n| 0 ior\n\u02c6 0 ieor\n&& 1 and true\n|| 0 or false\neqv true\nneqv false\nRestrictions\n\tAvarin areduction clause must be a scalar variable name, an aggregate variable name,\nan array element, or a subarray (refer to Section 271)\n\tIf the reduction varis an array element or a subarray, accessing the elements of the array\noutside the speci\ufb01ed index range results in unspeci\ufb01ed behavior\n\tThe reduction varmay not be a member of a composite variable\n\tIf the reduction varis a composite variable, each member of the composite variable must be\na supported datatype for the reduction operation\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nreduction clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct reduction clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of serial construct reduction clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct reduction clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct reduction clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2515 reduction clause\nThereduction clause is allowed on the parallel andserial constructs It speci\ufb01es a\nreduction operator and one or more vars It implies copy clauses as described in Section 262 For\neach reduction var, a private copy is created for each parallel gang and initialized for that o perator\nAt the end of the region, the values for each gang are combined using the r eduction operator, and\nthe result combined with the value of the original varand stored in the original var If the reduction\nvaris an array or subarray, the array reduction operation is logically equiv alent to applying that\nreduction operation to each element of the array or subarray individually  If the reduction var\nis a composite variable, the reduction operation is logically equivalent to apply ing that reduction\noperation to each member of the composite variable individually The reduction result is available\nafter the region\nThe following table lists the operators that are valid and the initialization values; in each case, the\ninitialization value will be cast into the data type of the var Formax andmin reductions, the\ninitialization values are the least representable value and the largest repre sentable value for that data\ntype, respectively At a minimum, the supported data types include Fortran logical as well as\nthe numerical data types in C (eg, _Bool ,char ,int,float ,double ,float _Complex ,\ndouble _Complex ), C++ (eg, bool ,char ,wchar_t ,int,float ,double ), and Fortran\n(eg,integer ,real ,doubleprecision ,complex ) However, for each reduction operator,\nthe supported data types include only the types permitted as operands to the co rresponding operator\nin the base language where (1) for max and min, the corresponding opera tor is less-than and (2) for\nother operators, the operands and the result are the same type\n\nC and C++ Fortran\noperator initialization\nvalueoperator initialization\nvalue\n+ 0 +\n* 1 *\nmax least max least\nmin largest min largest\n& \u02dc0 iand all bits on\n| 0 ior\n\u02c6 0 ieor\n&& 1 and true\n|| 0 or false\neqv true\nneqv false\nRestrictions\n\tAvarin areduction clause must be a scalar variable name, an aggregate variable name,\nan array element, or a subarray (refer to Section 271)\n\tIf the reduction varis an array element or a subarray, accessing the elements of the array\noutside the speci\ufb01ed index range results in unspeci\ufb01ed behavior\n\tThe reduction varmay not be a member of a composite variable\n\tIf the reduction varis a composite variable, each member of the composite variable must be\na supported datatype for the reduction operation\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nreduction clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct reduction clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of serial construct reduction clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct reduction clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct reduction clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2515 reduction clause\nThereduction clause is allowed on the parallel andserial constructs It speci\ufb01es a\nreduction operator and one or more vars It implies copy clauses as described in Section 262 For\neach reduction var, a private copy is created for each parallel gang and initialized for that o perator\nAt the end of the region, the values for each gang are combined using the r eduction operator, and\nthe result combined with the value of the original varand stored in the original var If the reduction\nvaris an array or subarray, the array reduction operation is logically equiv alent to applying that\nreduction operation to each element of the array or subarray individually  If the reduction var\nis a composite variable, the reduction operation is logically equivalent to apply ing that reduction\noperation to each member of the composite variable individually The reduction result is available\nafter the region\nThe following table lists the operators that are valid and the initialization values; in each case, the\ninitialization value will be cast into the data type of the var Formax andmin reductions, the\ninitialization values are the least representable value and the largest repre sentable value for that data\ntype, respectively At a minimum, the supported data types include Fortran logical as well as\nthe numerical data types in C (eg, _Bool ,char ,int,float ,double ,float _Complex ,\ndouble _Complex ), C++ (eg, bool ,char ,wchar_t ,int,float ,double ), and Fortran\n(eg,integer ,real ,doubleprecision ,complex ) However, for each reduction operator,\nthe supported data types include only the types permitted as operands to the co rresponding operator\nin the base language where (1) for max and min, the corresponding opera tor is less-than and (2) for\nother operators, the operands and the result are the same type\n\nC and C++ Fortran\noperator initialization\nvalueoperator initialization\nvalue\n+ 0 +\n* 1 *\nmax least max least\nmin largest min largest\n& \u02dc0 iand all bits on\n| 0 ior\n\u02c6 0 ieor\n&& 1 and true\n|| 0 or false\neqv true\nneqv false\nRestrictions\n\tAvarin areduction clause must be a scalar variable name, an aggregate variable name,\nan array element, or a subarray (refer to Section 271)\n\tIf the reduction varis an array element or a subarray, accessing the elements of the array\noutside the speci\ufb01ed index range results in unspeci\ufb01ed behavior\n\tThe reduction varmay not be a member of a composite variable\n\tIf the reduction varis a composite variable, each member of the composite variable must be\na supported datatype for the reduction operation\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nreduction clauses\n\nTemplate:\n\n#ifndef T1\n!T1:serial construct reduction clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of kernels construct reduction clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct reduction clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct reduction clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2515 reduction clause\nThereduction clause is allowed on the parallel andserial constructs It speci\ufb01es a\nreduction operator and one or more vars It implies copy clauses as described in Section 262 For\neach reduction var, a private copy is created for each parallel gang and initialized for that o perator\nAt the end of the region, the values for each gang are combined using the r eduction operator, and\nthe result combined with the value of the original varand stored in the original var If the reduction\nvaris an array or subarray, the array reduction operation is logically equiv alent to applying that\nreduction operation to each element of the array or subarray individually  If the reduction var\nis a composite variable, the reduction operation is logically equivalent to apply ing that reduction\noperation to each member of the composite variable individually The reduction result is available\nafter the region\nThe following table lists the operators that are valid and the initialization values; in each case, the\ninitialization value will be cast into the data type of the var Formax andmin reductions, the\ninitialization values are the least representable value and the largest repre sentable value for that data\ntype, respectively At a minimum, the supported data types include Fortran logical as well as\nthe numerical data types in C (eg, _Bool ,char ,int,float ,double ,float _Complex ,\ndouble _Complex ), C++ (eg, bool ,char ,wchar_t ,int,float ,double ), and Fortran\n(eg,integer ,real ,doubleprecision ,complex ) However, for each reduction operator,\nthe supported data types include only the types permitted as operands to the co rresponding operator\nin the base language where (1) for max and min, the corresponding opera tor is less-than and (2) for\nother operators, the operands and the result are the same type\n\nC and C++ Fortran\noperator initialization\nvalueoperator initialization\nvalue\n+ 0 +\n* 1 *\nmax least max least\nmin largest min largest\n& \u02dc0 iand all bits on\n| 0 ior\n\u02c6 0 ieor\n&& 1 and true\n|| 0 or false\neqv true\nneqv false\nRestrictions\n\tAvarin areduction clause must be a scalar variable name, an aggregate variable name,\nan array element, or a subarray (refer to Section 271)\n\tIf the reduction varis an array element or a subarray, accessing the elements of the array\noutside the speci\ufb01ed index range results in unspeci\ufb01ed behavior\n\tThe reduction varmay not be a member of a composite variable\n\tIf the reduction varis a composite variable, each member of the composite variable must be\na supported datatype for the reduction operation\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nreduction clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct reduction clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of kernels construct reduction clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct reduction clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct reduction clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2515 reduction clause\nThereduction clause is allowed on the parallel andserial constructs It speci\ufb01es a\nreduction operator and one or more vars It implies copy clauses as described in Section 262 For\neach reduction var, a private copy is created for each parallel gang and initialized for that o perator\nAt the end of the region, the values for each gang are combined using the r eduction operator, and\nthe result combined with the value of the original varand stored in the original var If the reduction\nvaris an array or subarray, the array reduction operation is logically equiv alent to applying that\nreduction operation to each element of the array or subarray individually  If the reduction var\nis a composite variable, the reduction operation is logically equivalent to apply ing that reduction\noperation to each member of the composite variable individually The reduction result is available\nafter the region\nThe following table lists the operators that are valid and the initialization values; in each case, the\ninitialization value will be cast into the data type of the var Formax andmin reductions, the\ninitialization values are the least representable value and the largest repre sentable value for that data\ntype, respectively At a minimum, the supported data types include Fortran logical as well as\nthe numerical data types in C (eg, _Bool ,char ,int,float ,double ,float _Complex ,\ndouble _Complex ), C++ (eg, bool ,char ,wchar_t ,int,float ,double ), and Fortran\n(eg,integer ,real ,doubleprecision ,complex ) However, for each reduction operator,\nthe supported data types include only the types permitted as operands to the co rresponding operator\nin the base language where (1) for max and min, the corresponding opera tor is less-than and (2) for\nother operators, the operands and the result are the same type\n\nC and C++ Fortran\noperator initialization\nvalueoperator initialization\nvalue\n+ 0 +\n* 1 *\nmax least max least\nmin largest min largest\n& \u02dc0 iand all bits on\n| 0 ior\n\u02c6 0 ieor\n&& 1 and true\n|| 0 or false\neqv true\nneqv false\nRestrictions\n\tAvarin areduction clause must be a scalar variable name, an aggregate variable name,\nan array element, or a subarray (refer to Section 271)\n\tIf the reduction varis an array element or a subarray, accessing the elements of the array\noutside the speci\ufb01ed index range results in unspeci\ufb01ed behavior\n\tThe reduction varmay not be a member of a composite variable\n\tIf the reduction varis a composite variable, each member of the composite variable must be\na supported datatype for the reduction operation\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nreduction clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct reduction clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of kernels construct reduction clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct reduction clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct reduction clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2515 reduction clause\nThereduction clause is allowed on the parallel andserial constructs It speci\ufb01es a\nreduction operator and one or more vars It implies copy clauses as described in Section 262 For\neach reduction var, a private copy is created for each parallel gang and initialized for that o perator\nAt the end of the region, the values for each gang are combined using the r eduction operator, and\nthe result combined with the value of the original varand stored in the original var If the reduction\nvaris an array or subarray, the array reduction operation is logically equiv alent to applying that\nreduction operation to each element of the array or subarray individually  If the reduction var\nis a composite variable, the reduction operation is logically equivalent to apply ing that reduction\noperation to each member of the composite variable individually The reduction result is available\nafter the region\nThe following table lists the operators that are valid and the initialization values; in each case, the\ninitialization value will be cast into the data type of the var Formax andmin reductions, the\ninitialization values are the least representable value and the largest repre sentable value for that data\ntype, respectively At a minimum, the supported data types include Fortran logical as well as\nthe numerical data types in C (eg, _Bool ,char ,int,float ,double ,float _Complex ,\ndouble _Complex ), C++ (eg, bool ,char ,wchar_t ,int,float ,double ), and Fortran\n(eg,integer ,real ,doubleprecision ,complex ) However, for each reduction operator,\nthe supported data types include only the types permitted as operands to the co rresponding operator\nin the base language where (1) for max and min, the corresponding opera tor is less-than and (2) for\nother operators, the operands and the result are the same type\n\nC and C++ Fortran\noperator initialization\nvalueoperator initialization\nvalue\n+ 0 +\n* 1 *\nmax least max least\nmin largest min largest\n& \u02dc0 iand all bits on\n| 0 ior\n\u02c6 0 ieor\n&& 1 and true\n|| 0 or false\neqv true\nneqv false\nRestrictions\n\tAvarin areduction clause must be a scalar variable name, an aggregate variable name,\nan array element, or a subarray (refer to Section 271)\n\tIf the reduction varis an array element or a subarray, accessing the elements of the array\noutside the speci\ufb01ed index range results in unspeci\ufb01ed behavior\n\tThe reduction varmay not be a member of a composite variable\n\tIf the reduction varis a composite variable, each member of the composite variable must be\na supported datatype for the reduction operation\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nreduction clauses\n\nTemplate:\n\n#ifndef T1\n!T1:kernels construct reduction clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of parallel construct default clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct default clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct default clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2516 default clause\nThedefault clause is optional At most one default clause may appear It adjusts what\ndata attributes are implicitly determined for variables used in the compute construc t as described in\nSection 262\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct default clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of parallel construct default clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct default clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct default clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2516 default clause\nThedefault clause is optional At most one default clause may appear It adjusts what\ndata attributes are implicitly determined for variables used in the compute construc t as described in\nSection 262\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct default clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of parallel construct default clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct default clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct default clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2516 default clause\nThedefault clause is optional At most one default clause may appear It adjusts what\ndata attributes are implicitly determined for variables used in the compute construc t as described in\nSection 262\n\nTemplate:\n\n#ifndef T1\n!T1:parallel construct default clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of serial construct default clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct default clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct default clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2516 default clause\nThedefault clause is optional At most one default clause may appear It adjusts what\ndata attributes are implicitly determined for variables used in the compute construc t as described in\nSection 262\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct default clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of serial construct default clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct default clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct default clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2516 default clause\nThedefault clause is optional At most one default clause may appear It adjusts what\ndata attributes are implicitly determined for variables used in the compute construc t as described in\nSection 262\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct default clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of serial construct default clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct default clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct default clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2516 default clause\nThedefault clause is optional At most one default clause may appear It adjusts what\ndata attributes are implicitly determined for variables used in the compute construc t as described in\nSection 262\n\nTemplate:\n\n#ifndef T1\n!T1:serial construct default clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of kernels construct default clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct default clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct default clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2516 default clause\nThedefault clause is optional At most one default clause may appear It adjusts what\ndata attributes are implicitly determined for variables used in the compute construc t as described in\nSection 262\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct default clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of kernels construct default clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct default clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct default clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2516 default clause\nThedefault clause is optional At most one default clause may appear It adjusts what\ndata attributes are implicitly determined for variables used in the compute construc t as described in\nSection 262\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:kernels construct default clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of kernels construct default clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test kernels construct default clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, kernels construct default clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2516 default clause\nThedefault clause is optional At most one default clause may appear It adjusts what\ndata attributes are implicitly determined for variables used in the compute construc t as described in\nSection 262\n\nTemplate:\n\n#ifndef T1\n!T1:kernels construct default clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of variable predetermined data attributes. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test variable predetermined data attributes in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, variable predetermined data attributes, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 261 Variables with Predetermined Data Attributes\nThe loop variable in a C for statement or Fortran dostatement that is associated with a loop\ndirective is predetermined to be private to each thread that will execute eac h iteration of the loop\nLoop variables in Fortran dostatements within a compute construct are predetermined to be private\nto the thread that executes the loop\nVariables declared in a C block or Fortran block construct that is execute d in vector-partitioned\nmode are private to the thread associated with each vector lane Variables d eclared in a C block\nor Fortran block construct that is executed in worker-partitioned vector-single mode are private to\nthe worker and shared across the threads associated with the vector lane s of that worker Variables\ndeclared in a C block or Fortran block construct that is executed in worker-single mode are private\nto the gang and shared across the threads associated with the workers an d vector lanes of that gang\nA procedure called from a compute construct will be annotated as seq,vector ,worker , or\ngang , as described Section 215 Procedure Calls in Compute Regions Variables declared in seq\nroutine are private to the thread that made the call Variables declared in vector routine are private\nto the worker that made the call and shared across the threads associated with the vector lanes of\nthat worker Variables declared in worker organg routine are private to the gang that made the\ncall and shared across the threads associated with the workers and vec tor lanes of that gang\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:variable predetermined data attributes,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of variable predetermined data attributes. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test variable predetermined data attributes in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, variable predetermined data attributes, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 261 Variables with Predetermined Data Attributes\nThe loop variable in a C for statement or Fortran dostatement that is associated with a loop\ndirective is predetermined to be private to each thread that will execute eac h iteration of the loop\nLoop variables in Fortran dostatements within a compute construct are predetermined to be private\nto the thread that executes the loop\nVariables declared in a C block or Fortran block construct that is execute d in vector-partitioned\nmode are private to the thread associated with each vector lane Variables d eclared in a C block\nor Fortran block construct that is executed in worker-partitioned vector-single mode are private to\nthe worker and shared across the threads associated with the vector lane s of that worker Variables\ndeclared in a C block or Fortran block construct that is executed in worker-single mode are private\nto the gang and shared across the threads associated with the workers an d vector lanes of that gang\nA procedure called from a compute construct will be annotated as seq,vector ,worker , or\ngang , as described Section 215 Procedure Calls in Compute Regions Variables declared in seq\nroutine are private to the thread that made the call Variables declared in vector routine are private\nto the worker that made the call and shared across the threads associated with the vector lanes of\nthat worker Variables declared in worker organg routine are private to the gang that made the\ncall and shared across the threads associated with the workers and vec tor lanes of that gang\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:variable predetermined data attributes,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of variable predetermined data attributes. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test variable predetermined data attributes in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, variable predetermined data attributes, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 261 Variables with Predetermined Data Attributes\nThe loop variable in a C for statement or Fortran dostatement that is associated with a loop\ndirective is predetermined to be private to each thread that will execute eac h iteration of the loop\nLoop variables in Fortran dostatements within a compute construct are predetermined to be private\nto the thread that executes the loop\nVariables declared in a C block or Fortran block construct that is execute d in vector-partitioned\nmode are private to the thread associated with each vector lane Variables d eclared in a C block\nor Fortran block construct that is executed in worker-partitioned vector-single mode are private to\nthe worker and shared across the threads associated with the vector lane s of that worker Variables\ndeclared in a C block or Fortran block construct that is executed in worker-single mode are private\nto the gang and shared across the threads associated with the workers an d vector lanes of that gang\nA procedure called from a compute construct will be annotated as seq,vector ,worker , or\ngang , as described Section 215 Procedure Calls in Compute Regions Variables declared in seq\nroutine are private to the thread that made the call Variables declared in vector routine are private\nto the worker that made the call and shared across the threads associated with the vector lanes of\nthat worker Variables declared in worker organg routine are private to the gang that made the\ncall and shared across the threads associated with the workers and vec tor lanes of that gang\n\nTemplate:\n\n#ifndef T1\n!T1:variable predetermined data attributes,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of variable implicit data attributes. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test variable implicit data attributes in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, variable implicit data attributes, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 262 Variables with Implicitly Determined Data Attributes\nWhen implicitly determining data attributes on a compute construct, the following claus es are visi-\nble and variable accesses are exposed to the compute construct:\n\tVisibledefault clause : The nearest default clause appearing on the compute construct\nor a lexically containing data construct\n\tVisible data clause : Any data clause on the compute construct, a lexically containing data\nconstruct, or a visible declare directive\n\tExposed variable access : Any access to the data or address of a variable at a point within the\ncompute construct where the variable is not private to a scope lexically enc losed within the\ncompute construct\nNote: In the argument of C\u2019s sizeof operator, the appearance of a variable is not an exposed\naccess because neither its data nor its address is accessed In the argu ment of areduction\nclause on an enclosed loop construct, the appearance of a variable that is not otherwise\nprivatized is an exposed access to the original variable\nOn a compute or combined construct, if a variable appears in a reduction clause but no other\ndata clause, it is treated as if it also appears in a copy clause Otherwise, for any variable, the\ncompiler will implicitly determine its data attribute on a compute construct if all of the follo wing\nconditions are met:\n\tThere is no default(none) clause visible at the compute construct\n\n\tAn access to the variable is exposed to the compute construct\n\tThe variable does not appear in a data clause visible at the compute constru ct\nAn aggregate variable will be treated as if it appears either:\n\tIn apresent clause if there is a default(present) clause visible at the compute con-\nstruct\n\tIn acopy clause otherwise\nA scalar variable will be treated as if it appears either:\n\tIn acopy clause if the compute construct is a kernels construct\n\tIn afirstprivate clause otherwise\nNote: Anydefault(none) clause visible at the compute construct applies to both aggregate\nand scalar variables However, any default(present) clause visible at the compute construct\napplies only to aggregate variables\nRestrictions\n\tIf there is a default(none) clause visible at a compute construct, for any variable access\nexposed to the compute construct, the compiler requires the variable to appea r either in an\nexplicit data clause visible at the compute construct or in a firstprivate ,private , or\nreduction clause on the compute construct\n\tIf a scalar variable appears in a reduction clause on a loop construct that has a parent\nparallel orserial construct, and if the reduction\u2019s access to the original variable is\nexposed to the parent compute construct, the variable must appear either in an explicit data\nclause visible at the compute construct or in a firstprivate ,private , orreduction\nclause on the compute construct Note: Implementations are encouraged to issue a compile-\ntime diagnostic when this restriction is violated to assist users in writing portable Op enACC\napplications\nIf a C++ lambda is called in a compute region and does not appear in a data clause, then it is\ntreated as if it appears in a copyin clause on the current construct A variable captured by a\nlambda is processed according to its data types: a pointer type variable is treated as if it appears\nin ano_create clause; a reference type variable is treated as if it appears in a present clause;\nfor a struct or a class type variable, any pointer member is treated as if it app ears in ano_create\nclause on the current construct If the variable is de\ufb01ned as global or \ufb01 le or function static, it must\nappear in a declare directive\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:variable implicit data attributes,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of variable implicit data attributes. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test variable implicit data attributes in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, variable implicit data attributes, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 262 Variables with Implicitly Determined Data Attributes\nWhen implicitly determining data attributes on a compute construct, the following claus es are visi-\nble and variable accesses are exposed to the compute construct:\n\tVisibledefault clause : The nearest default clause appearing on the compute construct\nor a lexically containing data construct\n\tVisible data clause : Any data clause on the compute construct, a lexically containing data\nconstruct, or a visible declare directive\n\tExposed variable access : Any access to the data or address of a variable at a point within the\ncompute construct where the variable is not private to a scope lexically enc losed within the\ncompute construct\nNote: In the argument of C\u2019s sizeof operator, the appearance of a variable is not an exposed\naccess because neither its data nor its address is accessed In the argu ment of areduction\nclause on an enclosed loop construct, the appearance of a variable that is not otherwise\nprivatized is an exposed access to the original variable\nOn a compute or combined construct, if a variable appears in a reduction clause but no other\ndata clause, it is treated as if it also appears in a copy clause Otherwise, for any variable, the\ncompiler will implicitly determine its data attribute on a compute construct if all of the follo wing\nconditions are met:\n\tThere is no default(none) clause visible at the compute construct\n\n\tAn access to the variable is exposed to the compute construct\n\tThe variable does not appear in a data clause visible at the compute constru ct\nAn aggregate variable will be treated as if it appears either:\n\tIn apresent clause if there is a default(present) clause visible at the compute con-\nstruct\n\tIn acopy clause otherwise\nA scalar variable will be treated as if it appears either:\n\tIn acopy clause if the compute construct is a kernels construct\n\tIn afirstprivate clause otherwise\nNote: Anydefault(none) clause visible at the compute construct applies to both aggregate\nand scalar variables However, any default(present) clause visible at the compute construct\napplies only to aggregate variables\nRestrictions\n\tIf there is a default(none) clause visible at a compute construct, for any variable access\nexposed to the compute construct, the compiler requires the variable to appea r either in an\nexplicit data clause visible at the compute construct or in a firstprivate ,private , or\nreduction clause on the compute construct\n\tIf a scalar variable appears in a reduction clause on a loop construct that has a parent\nparallel orserial construct, and if the reduction\u2019s access to the original variable is\nexposed to the parent compute construct, the variable must appear either in an explicit data\nclause visible at the compute construct or in a firstprivate ,private , orreduction\nclause on the compute construct Note: Implementations are encouraged to issue a compile-\ntime diagnostic when this restriction is violated to assist users in writing portable Op enACC\napplications\nIf a C++ lambda is called in a compute region and does not appear in a data clause, then it is\ntreated as if it appears in a copyin clause on the current construct A variable captured by a\nlambda is processed according to its data types: a pointer type variable is treated as if it appears\nin ano_create clause; a reference type variable is treated as if it appears in a present clause;\nfor a struct or a class type variable, any pointer member is treated as if it app ears in ano_create\nclause on the current construct If the variable is de\ufb01ned as global or \ufb01 le or function static, it must\nappear in a declare directive\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:variable implicit data attributes,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of variable implicit data attributes. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test variable implicit data attributes in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, variable implicit data attributes, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 262 Variables with Implicitly Determined Data Attributes\nWhen implicitly determining data attributes on a compute construct, the following claus es are visi-\nble and variable accesses are exposed to the compute construct:\n\tVisibledefault clause : The nearest default clause appearing on the compute construct\nor a lexically containing data construct\n\tVisible data clause : Any data clause on the compute construct, a lexically containing data\nconstruct, or a visible declare directive\n\tExposed variable access : Any access to the data or address of a variable at a point within the\ncompute construct where the variable is not private to a scope lexically enc losed within the\ncompute construct\nNote: In the argument of C\u2019s sizeof operator, the appearance of a variable is not an exposed\naccess because neither its data nor its address is accessed In the argu ment of areduction\nclause on an enclosed loop construct, the appearance of a variable that is not otherwise\nprivatized is an exposed access to the original variable\nOn a compute or combined construct, if a variable appears in a reduction clause but no other\ndata clause, it is treated as if it also appears in a copy clause Otherwise, for any variable, the\ncompiler will implicitly determine its data attribute on a compute construct if all of the follo wing\nconditions are met:\n\tThere is no default(none) clause visible at the compute construct\n\n\tAn access to the variable is exposed to the compute construct\n\tThe variable does not appear in a data clause visible at the compute constru ct\nAn aggregate variable will be treated as if it appears either:\n\tIn apresent clause if there is a default(present) clause visible at the compute con-\nstruct\n\tIn acopy clause otherwise\nA scalar variable will be treated as if it appears either:\n\tIn acopy clause if the compute construct is a kernels construct\n\tIn afirstprivate clause otherwise\nNote: Anydefault(none) clause visible at the compute construct applies to both aggregate\nand scalar variables However, any default(present) clause visible at the compute construct\napplies only to aggregate variables\nRestrictions\n\tIf there is a default(none) clause visible at a compute construct, for any variable access\nexposed to the compute construct, the compiler requires the variable to appea r either in an\nexplicit data clause visible at the compute construct or in a firstprivate ,private , or\nreduction clause on the compute construct\n\tIf a scalar variable appears in a reduction clause on a loop construct that has a parent\nparallel orserial construct, and if the reduction\u2019s access to the original variable is\nexposed to the parent compute construct, the variable must appear either in an explicit data\nclause visible at the compute construct or in a firstprivate ,private , orreduction\nclause on the compute construct Note: Implementations are encouraged to issue a compile-\ntime diagnostic when this restriction is violated to assist users in writing portable Op enACC\napplications\nIf a C++ lambda is called in a compute region and does not appear in a data clause, then it is\ntreated as if it appears in a copyin clause on the current construct A variable captured by a\nlambda is processed according to its data types: a pointer type variable is treated as if it appears\nin ano_create clause; a reference type variable is treated as if it appears in a present clause;\nfor a struct or a class type variable, any pointer member is treated as if it app ears in ano_create\nclause on the current construct If the variable is de\ufb01ned as global or \ufb01 le or function static, it must\nappear in a declare directive\n\nTemplate:\n\n#ifndef T1\n!T1:variable implicit data attributes,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of data construct. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 265 Data Construct\nSummary\nThedata construct de\ufb01nes vars to be allocated in the current device memory for the duration of\nthe region, whether data should be copied from local memory to the current device memory upon\nregion entry, and copied from device memory to local memory upon region ex it\nSyntax\nIn C and C++, the syntax of the OpenACC data construct is\n\n#pragma acc data [clause-list ]new-line\nstructured block\nand in Fortran, the syntax is\n!$acc data [clause-list ]\nstructured block\n!$acc end data\nor\n!$acc data [clause-list ]\nblock construct\n[!$acc end data ]\nwhere clause is one of the following:\nif( condition)\nasync [(int-expr)]\nwait [(wait-argument )]\ndevice_type( device-type-list )\ncopy( var-list)\ncopyin( [readonly: ]var-list)\ncopyout([zero:] var-list)\ncreate([zero:] var-list)\nno_create( var-list)\npresent( var-list)\ndeviceptr( var-list)\nattach( var-list)\ndefault( none | present )\nDescription\nData will be allocated in the memory of the current device and copied from loca l memory to device\nmemory, or copied back, as required The data clauses are described in Section 27 Data Clauses\nStructured reference counters are incremented for data when entering a data region, and decre-\nmented when leaving the region, as described in Section 267 Reference Co unters The device_type\nclause is described in Section 24 Device-Speci\ufb01c Clauses\nRestrictions\n\tAt least one copy ,copyin ,copyout ,create ,no_create ,present ,deviceptr ,\nattach , ordefault clause must appear on a data construct\n\tOnly theasync andwait clauses may follow a device_type clause\nif clause\nTheifclause is optional; when there is no ifclause, the compiler will generate code to allocate\nspace in the current device memory and move data from and to the local memory a s required When\nanifclause appears, the program will conditionally allocate memory in and move data to and/or\nfrom device memory When the condition in theifclause evaluates to false , no device memory\nwill be allocated, and no data will be moved When the condition evaluates to true, the data will be\nallocated and moved as speci\ufb01ed At most one ifclause may appear\n\nasync clause\nTheasync clause is optional; see Section 216 Asynchronous Behavior for more info rmation\nNote: Theasync clause only affects operations directly associated with this particular data con-\nstruct, such as data transfers Execution of the associated structured b lock or block construct remains\nsynchronous to the local thread Nested OpenACC constructs, directiv es, and calls to runtime li-\nbrary routines do not inherit the async clause from this construct, and the programmer must take\ncare to not accidentally introduce race conditions related to asynchronou s data transfers\nwait clause\nThewait clause is optional; see Section 216 Asynchronous Behavior for more infor mation\ndefault clause\nThedefault clause is optional At most one default clause may appear It adjusts what data\nattributes are implicitly determined for variables used in lexically contained compute constructs as\ndescribed in Section 262\nErrors\n\tSee Section 273 for errors due to data clauses\n\tSee Sections 2161 and 2162 for errors due to async orwait clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data construct,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of data construct. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 265 Data Construct\nSummary\nThedata construct de\ufb01nes vars to be allocated in the current device memory for the duration of\nthe region, whether data should be copied from local memory to the current device memory upon\nregion entry, and copied from device memory to local memory upon region ex it\nSyntax\nIn C and C++, the syntax of the OpenACC data construct is\n\n#pragma acc data [clause-list ]new-line\nstructured block\nand in Fortran, the syntax is\n!$acc data [clause-list ]\nstructured block\n!$acc end data\nor\n!$acc data [clause-list ]\nblock construct\n[!$acc end data ]\nwhere clause is one of the following:\nif( condition)\nasync [(int-expr)]\nwait [(wait-argument )]\ndevice_type( device-type-list )\ncopy( var-list)\ncopyin( [readonly: ]var-list)\ncopyout([zero:] var-list)\ncreate([zero:] var-list)\nno_create( var-list)\npresent( var-list)\ndeviceptr( var-list)\nattach( var-list)\ndefault( none | present )\nDescription\nData will be allocated in the memory of the current device and copied from loca l memory to device\nmemory, or copied back, as required The data clauses are described in Section 27 Data Clauses\nStructured reference counters are incremented for data when entering a data region, and decre-\nmented when leaving the region, as described in Section 267 Reference Co unters The device_type\nclause is described in Section 24 Device-Speci\ufb01c Clauses\nRestrictions\n\tAt least one copy ,copyin ,copyout ,create ,no_create ,present ,deviceptr ,\nattach , ordefault clause must appear on a data construct\n\tOnly theasync andwait clauses may follow a device_type clause\nif clause\nTheifclause is optional; when there is no ifclause, the compiler will generate code to allocate\nspace in the current device memory and move data from and to the local memory a s required When\nanifclause appears, the program will conditionally allocate memory in and move data to and/or\nfrom device memory When the condition in theifclause evaluates to false , no device memory\nwill be allocated, and no data will be moved When the condition evaluates to true, the data will be\nallocated and moved as speci\ufb01ed At most one ifclause may appear\n\nasync clause\nTheasync clause is optional; see Section 216 Asynchronous Behavior for more info rmation\nNote: Theasync clause only affects operations directly associated with this particular data con-\nstruct, such as data transfers Execution of the associated structured b lock or block construct remains\nsynchronous to the local thread Nested OpenACC constructs, directiv es, and calls to runtime li-\nbrary routines do not inherit the async clause from this construct, and the programmer must take\ncare to not accidentally introduce race conditions related to asynchronou s data transfers\nwait clause\nThewait clause is optional; see Section 216 Asynchronous Behavior for more infor mation\ndefault clause\nThedefault clause is optional At most one default clause may appear It adjusts what data\nattributes are implicitly determined for variables used in lexically contained compute constructs as\ndescribed in Section 262\nErrors\n\tSee Section 273 for errors due to data clauses\n\tSee Sections 2161 and 2162 for errors due to async orwait clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data construct,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of data construct. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 265 Data Construct\nSummary\nThedata construct de\ufb01nes vars to be allocated in the current device memory for the duration of\nthe region, whether data should be copied from local memory to the current device memory upon\nregion entry, and copied from device memory to local memory upon region ex it\nSyntax\nIn C and C++, the syntax of the OpenACC data construct is\n\n#pragma acc data [clause-list ]new-line\nstructured block\nand in Fortran, the syntax is\n!$acc data [clause-list ]\nstructured block\n!$acc end data\nor\n!$acc data [clause-list ]\nblock construct\n[!$acc end data ]\nwhere clause is one of the following:\nif( condition)\nasync [(int-expr)]\nwait [(wait-argument )]\ndevice_type( device-type-list )\ncopy( var-list)\ncopyin( [readonly: ]var-list)\ncopyout([zero:] var-list)\ncreate([zero:] var-list)\nno_create( var-list)\npresent( var-list)\ndeviceptr( var-list)\nattach( var-list)\ndefault( none | present )\nDescription\nData will be allocated in the memory of the current device and copied from loca l memory to device\nmemory, or copied back, as required The data clauses are described in Section 27 Data Clauses\nStructured reference counters are incremented for data when entering a data region, and decre-\nmented when leaving the region, as described in Section 267 Reference Co unters The device_type\nclause is described in Section 24 Device-Speci\ufb01c Clauses\nRestrictions\n\tAt least one copy ,copyin ,copyout ,create ,no_create ,present ,deviceptr ,\nattach , ordefault clause must appear on a data construct\n\tOnly theasync andwait clauses may follow a device_type clause\nif clause\nTheifclause is optional; when there is no ifclause, the compiler will generate code to allocate\nspace in the current device memory and move data from and to the local memory a s required When\nanifclause appears, the program will conditionally allocate memory in and move data to and/or\nfrom device memory When the condition in theifclause evaluates to false , no device memory\nwill be allocated, and no data will be moved When the condition evaluates to true, the data will be\nallocated and moved as speci\ufb01ed At most one ifclause may appear\n\nasync clause\nTheasync clause is optional; see Section 216 Asynchronous Behavior for more info rmation\nNote: Theasync clause only affects operations directly associated with this particular data con-\nstruct, such as data transfers Execution of the associated structured b lock or block construct remains\nsynchronous to the local thread Nested OpenACC constructs, directiv es, and calls to runtime li-\nbrary routines do not inherit the async clause from this construct, and the programmer must take\ncare to not accidentally introduce race conditions related to asynchronou s data transfers\nwait clause\nThewait clause is optional; see Section 216 Asynchronous Behavior for more infor mation\ndefault clause\nThedefault clause is optional At most one default clause may appear It adjusts what data\nattributes are implicitly determined for variables used in lexically contained compute constructs as\ndescribed in Section 262\nErrors\n\tSee Section 273 for errors due to data clauses\n\tSee Sections 2161 and 2162 for errors due to async orwait clauses\n\nTemplate:\n\n#ifndef T1\n!T1:data construct,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of reference counters. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test reference counters in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, reference counters, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 267 Reference Counters\nWhen device memory is allocated for data not in shared memory due to data claus es or OpenACC\nAPI routine calls, the OpenACC implementation keeps track of that section of de vice memory and\nits relationship to the corresponding data in host memory\nEach section of device memory is associated with two reference counters per device, a structured\nreference counter and a dynamic reference counter The structured and dynamic reference counters\nare used to determine when to allocate or deallocate data in device memory The s tructured reference\ncounter for a section of memory keeps track of how many nested data region s have been entered for\nthat data The initial value of the structured reference counter for static d ata in device memory (in a\nglobaldeclare directive) is one; for all other data, the initial value is zero The dynamic re ference\ncounter for a section of memory keeps track of how many dynamic data lifetimes a re currently active\nin device memory for that section The initial value of the dynamic reference c ounter is zero Data\nis considered present if the sum of the structured and dynamic reference counters is greater tha n\nzero\nA structured reference counter is incremented when entering each data o r compute region that con-\ntain an explicit data clause or implicitly-determined data attributes for that section o f memory, and\nis decremented when exiting that region A dynamic reference counter is inc remented for each\nenterdatacopyin orcreate clause, or each acc_copyin oracc_create API routine\ncall for that section of memory The dynamic reference counter is decreme nted for each exit\ndatacopyout ordelete clause when no finalize clause appears, or each acc_copyout\noracc_delete API routine call for that section of memory The dynamic reference counte r will\nbe set to zero with an exit data copyout ordelete clause when a finalize clause ap-\npears, or each acc_copyout_finalize oracc_delete_finalize API routine call for\nthe section of memory The reference counters are modi\ufb01ed synchronou sly with the local thread,\neven if the data directives include an async clause When both structured and dynamic reference\ncounters reach zero, the data lifetime in device memory for that data ends\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:reference counters,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of reference counters. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test reference counters in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, reference counters, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 267 Reference Counters\nWhen device memory is allocated for data not in shared memory due to data claus es or OpenACC\nAPI routine calls, the OpenACC implementation keeps track of that section of de vice memory and\nits relationship to the corresponding data in host memory\nEach section of device memory is associated with two reference counters per device, a structured\nreference counter and a dynamic reference counter The structured and dynamic reference counters\nare used to determine when to allocate or deallocate data in device memory The s tructured reference\ncounter for a section of memory keeps track of how many nested data region s have been entered for\nthat data The initial value of the structured reference counter for static d ata in device memory (in a\nglobaldeclare directive) is one; for all other data, the initial value is zero The dynamic re ference\ncounter for a section of memory keeps track of how many dynamic data lifetimes a re currently active\nin device memory for that section The initial value of the dynamic reference c ounter is zero Data\nis considered present if the sum of the structured and dynamic reference counters is greater tha n\nzero\nA structured reference counter is incremented when entering each data o r compute region that con-\ntain an explicit data clause or implicitly-determined data attributes for that section o f memory, and\nis decremented when exiting that region A dynamic reference counter is inc remented for each\nenterdatacopyin orcreate clause, or each acc_copyin oracc_create API routine\ncall for that section of memory The dynamic reference counter is decreme nted for each exit\ndatacopyout ordelete clause when no finalize clause appears, or each acc_copyout\noracc_delete API routine call for that section of memory The dynamic reference counte r will\nbe set to zero with an exit data copyout ordelete clause when a finalize clause ap-\npears, or each acc_copyout_finalize oracc_delete_finalize API routine call for\nthe section of memory The reference counters are modi\ufb01ed synchronou sly with the local thread,\neven if the data directives include an async clause When both structured and dynamic reference\ncounters reach zero, the data lifetime in device memory for that data ends\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:reference counters,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of reference counters. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test reference counters in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, reference counters, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 267 Reference Counters\nWhen device memory is allocated for data not in shared memory due to data claus es or OpenACC\nAPI routine calls, the OpenACC implementation keeps track of that section of de vice memory and\nits relationship to the corresponding data in host memory\nEach section of device memory is associated with two reference counters per device, a structured\nreference counter and a dynamic reference counter The structured and dynamic reference counters\nare used to determine when to allocate or deallocate data in device memory The s tructured reference\ncounter for a section of memory keeps track of how many nested data region s have been entered for\nthat data The initial value of the structured reference counter for static d ata in device memory (in a\nglobaldeclare directive) is one; for all other data, the initial value is zero The dynamic re ference\ncounter for a section of memory keeps track of how many dynamic data lifetimes a re currently active\nin device memory for that section The initial value of the dynamic reference c ounter is zero Data\nis considered present if the sum of the structured and dynamic reference counters is greater tha n\nzero\nA structured reference counter is incremented when entering each data o r compute region that con-\ntain an explicit data clause or implicitly-determined data attributes for that section o f memory, and\nis decremented when exiting that region A dynamic reference counter is inc remented for each\nenterdatacopyin orcreate clause, or each acc_copyin oracc_create API routine\ncall for that section of memory The dynamic reference counter is decreme nted for each exit\ndatacopyout ordelete clause when no finalize clause appears, or each acc_copyout\noracc_delete API routine call for that section of memory The dynamic reference counte r will\nbe set to zero with an exit data copyout ordelete clause when a finalize clause ap-\npears, or each acc_copyout_finalize oracc_delete_finalize API routine call for\nthe section of memory The reference counters are modi\ufb01ed synchronou sly with the local thread,\neven if the data directives include an async clause When both structured and dynamic reference\ncounters reach zero, the data lifetime in device memory for that data ends\n\nTemplate:\n\n#ifndef T1\n!T1:reference counters,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of attachment counter. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test attachment counter in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, attachment counter, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 268 Attachment Counter\nSince multiple pointers can target the same address, each pointer in device memo ry is associated\nwith an attachment counter per device The attachment counter for a pointer is initialized to zero\n\nwhen the pointer is allocated in device memory The attachment counter for a pointer is set to one\nwhenever the pointer is attached to new target address, and incremented whenever an attach action\nfor that pointer is performed for the same target address The attachment counter is decremented\nwhenever a detach action occurs for the pointer, and the pointer is detached when the attachment\ncounter reaches zero This is described in more detail in Section 272 Data Clause Ac tions\nA pointer in device memory can be assigned a device address in two ways Th e pointer can be\nattached to a device address due to data clauses or API routines, as desc ribed in Section 27\nData Clause Actions, or the pointer can be assigned in a compute region exec uted on that device\nUnspeci\ufb01ed behavior may result if both ways are used for the same pointer \nPointer members of structs, classes, or derived types in device or host me mory can be overwritten\ndue to update directives or API routines It is the user\u2019s responsibility to e nsure that the pointers\nhave the appropriate values before or after the data movement in either dire ction The behavior of\nthe program is unde\ufb01ned if any of the pointer members are attached when an update of a composite\nvariable is performed\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:attachment counter,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of attachment counter. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test attachment counter in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, attachment counter, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 268 Attachment Counter\nSince multiple pointers can target the same address, each pointer in device memo ry is associated\nwith an attachment counter per device The attachment counter for a pointer is initialized to zero\n\nwhen the pointer is allocated in device memory The attachment counter for a pointer is set to one\nwhenever the pointer is attached to new target address, and incremented whenever an attach action\nfor that pointer is performed for the same target address The attachment counter is decremented\nwhenever a detach action occurs for the pointer, and the pointer is detached when the attachment\ncounter reaches zero This is described in more detail in Section 272 Data Clause Ac tions\nA pointer in device memory can be assigned a device address in two ways Th e pointer can be\nattached to a device address due to data clauses or API routines, as desc ribed in Section 27\nData Clause Actions, or the pointer can be assigned in a compute region exec uted on that device\nUnspeci\ufb01ed behavior may result if both ways are used for the same pointer \nPointer members of structs, classes, or derived types in device or host me mory can be overwritten\ndue to update directives or API routines It is the user\u2019s responsibility to e nsure that the pointers\nhave the appropriate values before or after the data movement in either dire ction The behavior of\nthe program is unde\ufb01ned if any of the pointer members are attached when an update of a composite\nvariable is performed\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:attachment counter,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of attachment counter. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test attachment counter in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, attachment counter, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 268 Attachment Counter\nSince multiple pointers can target the same address, each pointer in device memo ry is associated\nwith an attachment counter per device The attachment counter for a pointer is initialized to zero\n\nwhen the pointer is allocated in device memory The attachment counter for a pointer is set to one\nwhenever the pointer is attached to new target address, and incremented whenever an attach action\nfor that pointer is performed for the same target address The attachment counter is decremented\nwhenever a detach action occurs for the pointer, and the pointer is detached when the attachment\ncounter reaches zero This is described in more detail in Section 272 Data Clause Ac tions\nA pointer in device memory can be assigned a device address in two ways Th e pointer can be\nattached to a device address due to data clauses or API routines, as desc ribed in Section 27\nData Clause Actions, or the pointer can be assigned in a compute region exec uted on that device\nUnspeci\ufb01ed behavior may result if both ways are used for the same pointer \nPointer members of structs, classes, or derived types in device or host me mory can be overwritten\ndue to update directives or API routines It is the user\u2019s responsibility to e nsure that the pointers\nhave the appropriate values before or after the data movement in either dire ction The behavior of\nthe program is unde\ufb01ned if any of the pointer members are attached when an update of a composite\nvariable is performed\n\nTemplate:\n\n#ifndef T1\n!T1:attachment counter,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of data deviceptr clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data deviceptr clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data deviceptr clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 274 deviceptr clause\nThedeviceptr clause may appear on structured data and compute constructs and declare\ndirectives\nThedeviceptr clause is used to declare that the pointers in var-list are device pointers, so the\ndata need not be allocated or moved between the host and device for this po inter\nIn C and C++, the vars invar-list must be pointer variables\nIn Fortran, the vars invar-list must be dummy arguments (arrays or scalars), and may not have the\nFortranpointer ,allocatable , orvalue attributes\nFor data in shared memory, host pointers are the same as device pointers, s o this clause has no\neffect\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data deviceptr clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of data deviceptr clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data deviceptr clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data deviceptr clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 274 deviceptr clause\nThedeviceptr clause may appear on structured data and compute constructs and declare\ndirectives\nThedeviceptr clause is used to declare that the pointers in var-list are device pointers, so the\ndata need not be allocated or moved between the host and device for this po inter\nIn C and C++, the vars invar-list must be pointer variables\nIn Fortran, the vars invar-list must be dummy arguments (arrays or scalars), and may not have the\nFortranpointer ,allocatable , orvalue attributes\nFor data in shared memory, host pointers are the same as device pointers, s o this clause has no\neffect\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data deviceptr clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of data deviceptr clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data deviceptr clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data deviceptr clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 274 deviceptr clause\nThedeviceptr clause may appear on structured data and compute constructs and declare\ndirectives\nThedeviceptr clause is used to declare that the pointers in var-list are device pointers, so the\ndata need not be allocated or moved between the host and device for this po inter\nIn C and C++, the vars invar-list must be pointer variables\nIn Fortran, the vars invar-list must be dummy arguments (arrays or scalars), and may not have the\nFortranpointer ,allocatable , orvalue attributes\nFor data in shared memory, host pointers are the same as device pointers, s o this clause has no\neffect\n\nTemplate:\n\n#ifndef T1\n!T1:data deviceptr clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of data present clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data present clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data present clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 275 present clause\nThepresent clause may appear on structured data and compute constructs and declare di-\nrectives The present clause speci\ufb01es that vars invar-list are in shared memory or are already\npresent in the current device memory due to data regions or data lifetimes that contain the construct\non which the present clause appears\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthepresent clause behaves as follows:\n\tAt entry to the region:\n\n\t\tAnattach action is performed if varis a pointer reference, and a present increment\naction with the structured reference counter is performed if varis not a null pointer\n\tAt exit from the region:\n\t\tIf the structured reference counter for varis zero, no action is taken\n\t\tOtherwise, a detach action is performed if varis a pointer reference, and a present decrement\naction with the structured reference counter is performed if varis not a null pointer If\nboth structured and dynamic reference counters are zero, a delete action is performed\nThe errors in Section 273 Data Clause Errors may be issued for this clause\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data present clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of data present clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data present clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data present clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 275 present clause\nThepresent clause may appear on structured data and compute constructs and declare di-\nrectives The present clause speci\ufb01es that vars invar-list are in shared memory or are already\npresent in the current device memory due to data regions or data lifetimes that contain the construct\non which the present clause appears\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthepresent clause behaves as follows:\n\tAt entry to the region:\n\n\t\tAnattach action is performed if varis a pointer reference, and a present increment\naction with the structured reference counter is performed if varis not a null pointer\n\tAt exit from the region:\n\t\tIf the structured reference counter for varis zero, no action is taken\n\t\tOtherwise, a detach action is performed if varis a pointer reference, and a present decrement\naction with the structured reference counter is performed if varis not a null pointer If\nboth structured and dynamic reference counters are zero, a delete action is performed\nThe errors in Section 273 Data Clause Errors may be issued for this clause\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data present clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of data present clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data present clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data present clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 275 present clause\nThepresent clause may appear on structured data and compute constructs and declare di-\nrectives The present clause speci\ufb01es that vars invar-list are in shared memory or are already\npresent in the current device memory due to data regions or data lifetimes that contain the construct\non which the present clause appears\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthepresent clause behaves as follows:\n\tAt entry to the region:\n\n\t\tAnattach action is performed if varis a pointer reference, and a present increment\naction with the structured reference counter is performed if varis not a null pointer\n\tAt exit from the region:\n\t\tIf the structured reference counter for varis zero, no action is taken\n\t\tOtherwise, a detach action is performed if varis a pointer reference, and a present decrement\naction with the structured reference counter is performed if varis not a null pointer If\nboth structured and dynamic reference counters are zero, a delete action is performed\nThe errors in Section 273 Data Clause Errors may be issued for this clause\n\nTemplate:\n\n#ifndef T1\n!T1:data present clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of data construct copy clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct copy clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct copy clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 276 copy clause\nThecopy clause may appear on structured data and compute constructs and on declare direc-\ntives\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthecopy clause behaves as follows:\n\tAt entry to the region:\n\t\tIfvaris present and is not a null pointer, a present increment action with the structured\nreference counter is performed\n\t\tIfvaris not present, a copyin action with the structured reference counter is performed\n\t\tIfvaris a pointer reference, an attach action is performed\n\tAt exit from the region:\n\t\tIf the structured reference counter for varis zero, no action is taken\n\t\tOtherwise, a detach action is performed if varis a pointer reference, and a present decrement\naction with the structured reference counter is performed if varis not a null pointer If\nboth structured and dynamic reference counters are zero, a copyout action is performed\nThe errors in Section 273 Data Clause Errors may be issued for this clause \nFor compatibility with OpenACC 20, present_or_copy andpcopy are alternate names for\ncopy\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data construct copy clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of data construct copy clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct copy clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct copy clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 276 copy clause\nThecopy clause may appear on structured data and compute constructs and on declare direc-\ntives\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthecopy clause behaves as follows:\n\tAt entry to the region:\n\t\tIfvaris present and is not a null pointer, a present increment action with the structured\nreference counter is performed\n\t\tIfvaris not present, a copyin action with the structured reference counter is performed\n\t\tIfvaris a pointer reference, an attach action is performed\n\tAt exit from the region:\n\t\tIf the structured reference counter for varis zero, no action is taken\n\t\tOtherwise, a detach action is performed if varis a pointer reference, and a present decrement\naction with the structured reference counter is performed if varis not a null pointer If\nboth structured and dynamic reference counters are zero, a copyout action is performed\nThe errors in Section 273 Data Clause Errors may be issued for this clause \nFor compatibility with OpenACC 20, present_or_copy andpcopy are alternate names for\ncopy\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data construct copy clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of data construct copy clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct copy clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct copy clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 276 copy clause\nThecopy clause may appear on structured data and compute constructs and on declare direc-\ntives\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthecopy clause behaves as follows:\n\tAt entry to the region:\n\t\tIfvaris present and is not a null pointer, a present increment action with the structured\nreference counter is performed\n\t\tIfvaris not present, a copyin action with the structured reference counter is performed\n\t\tIfvaris a pointer reference, an attach action is performed\n\tAt exit from the region:\n\t\tIf the structured reference counter for varis zero, no action is taken\n\t\tOtherwise, a detach action is performed if varis a pointer reference, and a present decrement\naction with the structured reference counter is performed if varis not a null pointer If\nboth structured and dynamic reference counters are zero, a copyout action is performed\nThe errors in Section 273 Data Clause Errors may be issued for this clause \nFor compatibility with OpenACC 20, present_or_copy andpcopy are alternate names for\ncopy\n\nTemplate:\n\n#ifndef T1\n!T1:data construct copy clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of data construct copyin clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct copyin clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct copyin clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 277 copyin clause\nThecopyin clause may appear on structured data and compute constructs, on declare direc-\ntives, and on enterdata directives\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthecopyin clause behaves as follows:\n\tAt entry to a region, the structured reference counter is used On an enterdata directive,\nthe dynamic reference counter is used\n\t\tIfvaris present and is not a null pointer, a present increment action with the appropriate\nreference counter is performed\n\n\t\tIfvaris not present, a copyin action with the appropriate reference counter is performed\n\t\tIfvaris a pointer reference, an attach action is performed\n\tAt exit from the region:\n\t\tIf the structured reference counter for varis zero, no action is taken\n\t\tOtherwise, a detach action is performed if varis a pointer reference, and a present decrement\naction with the structured reference counter is performed if varis not a null pointer If\nboth structured and dynamic reference counters are zero, a delete action is performed\nIf the optional readonly modi\ufb01er appears, then the implementation may assume that the data\nreferenced by var-list is never written to within the applicable region\nThe errors in Section 273 Data Clause Errors may be issued for this clause \nFor compatibility with OpenACC 20, present_or_copyin andpcopyin are alternate names\nforcopyin \nAnenterdata directive with a copyin clause is functionally equivalent to a call to the acc_copyin\nAPI routine, as described in Section 3218\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data construct copyin clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of data construct copyin clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct copyin clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct copyin clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 277 copyin clause\nThecopyin clause may appear on structured data and compute constructs, on declare direc-\ntives, and on enterdata directives\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthecopyin clause behaves as follows:\n\tAt entry to a region, the structured reference counter is used On an enterdata directive,\nthe dynamic reference counter is used\n\t\tIfvaris present and is not a null pointer, a present increment action with the appropriate\nreference counter is performed\n\n\t\tIfvaris not present, a copyin action with the appropriate reference counter is performed\n\t\tIfvaris a pointer reference, an attach action is performed\n\tAt exit from the region:\n\t\tIf the structured reference counter for varis zero, no action is taken\n\t\tOtherwise, a detach action is performed if varis a pointer reference, and a present decrement\naction with the structured reference counter is performed if varis not a null pointer If\nboth structured and dynamic reference counters are zero, a delete action is performed\nIf the optional readonly modi\ufb01er appears, then the implementation may assume that the data\nreferenced by var-list is never written to within the applicable region\nThe errors in Section 273 Data Clause Errors may be issued for this clause \nFor compatibility with OpenACC 20, present_or_copyin andpcopyin are alternate names\nforcopyin \nAnenterdata directive with a copyin clause is functionally equivalent to a call to the acc_copyin\nAPI routine, as described in Section 3218\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data construct copyin clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of data construct copyin clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct copyin clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct copyin clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 277 copyin clause\nThecopyin clause may appear on structured data and compute constructs, on declare direc-\ntives, and on enterdata directives\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthecopyin clause behaves as follows:\n\tAt entry to a region, the structured reference counter is used On an enterdata directive,\nthe dynamic reference counter is used\n\t\tIfvaris present and is not a null pointer, a present increment action with the appropriate\nreference counter is performed\n\n\t\tIfvaris not present, a copyin action with the appropriate reference counter is performed\n\t\tIfvaris a pointer reference, an attach action is performed\n\tAt exit from the region:\n\t\tIf the structured reference counter for varis zero, no action is taken\n\t\tOtherwise, a detach action is performed if varis a pointer reference, and a present decrement\naction with the structured reference counter is performed if varis not a null pointer If\nboth structured and dynamic reference counters are zero, a delete action is performed\nIf the optional readonly modi\ufb01er appears, then the implementation may assume that the data\nreferenced by var-list is never written to within the applicable region\nThe errors in Section 273 Data Clause Errors may be issued for this clause \nFor compatibility with OpenACC 20, present_or_copyin andpcopyin are alternate names\nforcopyin \nAnenterdata directive with a copyin clause is functionally equivalent to a call to the acc_copyin\nAPI routine, as described in Section 3218\n\nTemplate:\n\n#ifndef T1\n!T1:data construct copyin clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of data construct copyout clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct copyout clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct copyout clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 278 copyout clause\nThecopyout clause may appear on structured data and compute constructs, on declare di-\nrectives, and on exit data directives The clause may optionally have a zero modi\ufb01er if the\ncopyout clause appears on a structured data or compute construct\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthecopyout clause behaves as follows:\n\tAt entry to a region:\n\t\tIfvaris present and is not a null pointer, a present increment action with the structured\nreference counter is performed\n\t\tIfvaris not present, a create action with the structured reference counter is performed\nIf azero modi\ufb01er appears, the memory is zeroed after the create action\n\t\tIfvaris a pointer reference, an attach action is performed\n\tAt exit from a region, the structured reference counter is used On an exitdata directive,\nthe dynamic reference counter is used\n\t\tIf the appropriate reference counter for varis zero, no action is taken\n\t\tOtherwise, a detach action is performed if varis a pointer reference, and the reference\ncounter is updated if var is not a null pointer:\n\u2217On anexit data directive with a finalize clause, the dynamic reference\ncounter is set to zero\n\u2217Otherwise, a present decrement action with the appropriate reference counter is\nperformed\n\nIf both structured and dynamic reference counters are zero, a copyout action is per-\nformed\nThe errors in Section 273 Data Clause Errors may be issued for this clause \nFor compatibility with OpenACC 20, present_or_copyout andpcopyout are alternate\nnames forcopyout \nAnexitdata directive with a copyout clause and with or without a finalize clause is func-\ntionally equivalent to a call to the acc_copyout_finalize oracc_copyout API routine,\nrespectively, as described in Section 3219\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data construct copyout clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of data construct copyout clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct copyout clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct copyout clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 278 copyout clause\nThecopyout clause may appear on structured data and compute constructs, on declare di-\nrectives, and on exit data directives The clause may optionally have a zero modi\ufb01er if the\ncopyout clause appears on a structured data or compute construct\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthecopyout clause behaves as follows:\n\tAt entry to a region:\n\t\tIfvaris present and is not a null pointer, a present increment action with the structured\nreference counter is performed\n\t\tIfvaris not present, a create action with the structured reference counter is performed\nIf azero modi\ufb01er appears, the memory is zeroed after the create action\n\t\tIfvaris a pointer reference, an attach action is performed\n\tAt exit from a region, the structured reference counter is used On an exitdata directive,\nthe dynamic reference counter is used\n\t\tIf the appropriate reference counter for varis zero, no action is taken\n\t\tOtherwise, a detach action is performed if varis a pointer reference, and the reference\ncounter is updated if var is not a null pointer:\n\u2217On anexit data directive with a finalize clause, the dynamic reference\ncounter is set to zero\n\u2217Otherwise, a present decrement action with the appropriate reference counter is\nperformed\n\nIf both structured and dynamic reference counters are zero, a copyout action is per-\nformed\nThe errors in Section 273 Data Clause Errors may be issued for this clause \nFor compatibility with OpenACC 20, present_or_copyout andpcopyout are alternate\nnames forcopyout \nAnexitdata directive with a copyout clause and with or without a finalize clause is func-\ntionally equivalent to a call to the acc_copyout_finalize oracc_copyout API routine,\nrespectively, as described in Section 3219\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data construct copyout clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of data construct copyout clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct copyout clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct copyout clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 278 copyout clause\nThecopyout clause may appear on structured data and compute constructs, on declare di-\nrectives, and on exit data directives The clause may optionally have a zero modi\ufb01er if the\ncopyout clause appears on a structured data or compute construct\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthecopyout clause behaves as follows:\n\tAt entry to a region:\n\t\tIfvaris present and is not a null pointer, a present increment action with the structured\nreference counter is performed\n\t\tIfvaris not present, a create action with the structured reference counter is performed\nIf azero modi\ufb01er appears, the memory is zeroed after the create action\n\t\tIfvaris a pointer reference, an attach action is performed\n\tAt exit from a region, the structured reference counter is used On an exitdata directive,\nthe dynamic reference counter is used\n\t\tIf the appropriate reference counter for varis zero, no action is taken\n\t\tOtherwise, a detach action is performed if varis a pointer reference, and the reference\ncounter is updated if var is not a null pointer:\n\u2217On anexit data directive with a finalize clause, the dynamic reference\ncounter is set to zero\n\u2217Otherwise, a present decrement action with the appropriate reference counter is\nperformed\n\nIf both structured and dynamic reference counters are zero, a copyout action is per-\nformed\nThe errors in Section 273 Data Clause Errors may be issued for this clause \nFor compatibility with OpenACC 20, present_or_copyout andpcopyout are alternate\nnames forcopyout \nAnexitdata directive with a copyout clause and with or without a finalize clause is func-\ntionally equivalent to a call to the acc_copyout_finalize oracc_copyout API routine,\nrespectively, as described in Section 3219\n\nTemplate:\n\n#ifndef T1\n!T1:data construct copyout clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of data construct create clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct create clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct create clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 279 create clause\nThecreate clause may appear on structured data and compute constructs, on declare direc-\ntives, and on enterdata directives The clause may optionally have a zero modi\ufb01er\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthecreate clause behaves as follows:\n\tAt entry to a region, the structured reference counter is used On an enterdata directive,\nthe dynamic reference counter is used\n\t\tIfvaris present and is not a null pointer, a present increment action with the appropriate\nreference counter is performed\n\t\tIfvaris not present and is not a null pointer, a create action with the appropriate refer-\nence counter is performed If a zero modi\ufb01er appears, the memory is zeroed after the\ncreate action\n\t\tIfvaris a pointer reference, an attach action is performed\n\tAt exit from the region:\n\t\tIf the structured reference counter for varis zero, no action is taken\n\t\tOtherwise, a detach action is performed if varis a pointer reference, and a present decrement\naction with the structured reference counter is performed if varis not a null pointer If\nboth structured and dynamic reference counters are zero, a delete action is performed\nThe errors in Section 273 Data Clause Errors may be issued for this clause \nFor compatibility with OpenACC 20, present_or_create andpcreate are alternate names\nforcreate \nAnenterdata directive with a create clause is functionally equivalent to a call to the acc_create\nAPI routine, as described in Section 3218, except the directive may perf orm an attach action for a\npointer reference\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data construct create clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of data construct create clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct create clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct create clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 279 create clause\nThecreate clause may appear on structured data and compute constructs, on declare direc-\ntives, and on enterdata directives The clause may optionally have a zero modi\ufb01er\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthecreate clause behaves as follows:\n\tAt entry to a region, the structured reference counter is used On an enterdata directive,\nthe dynamic reference counter is used\n\t\tIfvaris present and is not a null pointer, a present increment action with the appropriate\nreference counter is performed\n\t\tIfvaris not present and is not a null pointer, a create action with the appropriate refer-\nence counter is performed If a zero modi\ufb01er appears, the memory is zeroed after the\ncreate action\n\t\tIfvaris a pointer reference, an attach action is performed\n\tAt exit from the region:\n\t\tIf the structured reference counter for varis zero, no action is taken\n\t\tOtherwise, a detach action is performed if varis a pointer reference, and a present decrement\naction with the structured reference counter is performed if varis not a null pointer If\nboth structured and dynamic reference counters are zero, a delete action is performed\nThe errors in Section 273 Data Clause Errors may be issued for this clause \nFor compatibility with OpenACC 20, present_or_create andpcreate are alternate names\nforcreate \nAnenterdata directive with a create clause is functionally equivalent to a call to the acc_create\nAPI routine, as described in Section 3218, except the directive may perf orm an attach action for a\npointer reference\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data construct create clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of data construct create clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct create clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct create clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 279 create clause\nThecreate clause may appear on structured data and compute constructs, on declare direc-\ntives, and on enterdata directives The clause may optionally have a zero modi\ufb01er\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthecreate clause behaves as follows:\n\tAt entry to a region, the structured reference counter is used On an enterdata directive,\nthe dynamic reference counter is used\n\t\tIfvaris present and is not a null pointer, a present increment action with the appropriate\nreference counter is performed\n\t\tIfvaris not present and is not a null pointer, a create action with the appropriate refer-\nence counter is performed If a zero modi\ufb01er appears, the memory is zeroed after the\ncreate action\n\t\tIfvaris a pointer reference, an attach action is performed\n\tAt exit from the region:\n\t\tIf the structured reference counter for varis zero, no action is taken\n\t\tOtherwise, a detach action is performed if varis a pointer reference, and a present decrement\naction with the structured reference counter is performed if varis not a null pointer If\nboth structured and dynamic reference counters are zero, a delete action is performed\nThe errors in Section 273 Data Clause Errors may be issued for this clause \nFor compatibility with OpenACC 20, present_or_create andpcreate are alternate names\nforcreate \nAnenterdata directive with a create clause is functionally equivalent to a call to the acc_create\nAPI routine, as described in Section 3218, except the directive may perf orm an attach action for a\npointer reference\n\nTemplate:\n\n#ifndef T1\n!T1:data construct create clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of data construct no_create clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct no_create clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct no_create clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2710 no create clause\nTheno_create clause may appear on structured data and compute constructs\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\ntheno_create clause behaves as follows:\n\n\tAt entry to the region:\n\t\tIfvaris present and is not a null pointer, a present increment action with the structured\nreference counter is performed If varis present and is a pointer reference, an attach\naction is performed\n\t\tIfvaris not present, no action is performed, and any device code in this constru ct will\nuse the local memory address for var\n\tAt exit from the region:\n\t\tIf the structured reference counter for varis zero, no action is taken\n\t\tOtherwise, a detach action is performed if varis a pointer reference, and a present decrement\naction with the structured reference counter is performed if varis not a null pointer If\nboth structured and dynamic reference counters are zero, a delete action is performed\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data construct no_create clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of data construct no_create clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct no_create clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct no_create clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2710 no create clause\nTheno_create clause may appear on structured data and compute constructs\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\ntheno_create clause behaves as follows:\n\n\tAt entry to the region:\n\t\tIfvaris present and is not a null pointer, a present increment action with the structured\nreference counter is performed If varis present and is a pointer reference, an attach\naction is performed\n\t\tIfvaris not present, no action is performed, and any device code in this constru ct will\nuse the local memory address for var\n\tAt exit from the region:\n\t\tIf the structured reference counter for varis zero, no action is taken\n\t\tOtherwise, a detach action is performed if varis a pointer reference, and a present decrement\naction with the structured reference counter is performed if varis not a null pointer If\nboth structured and dynamic reference counters are zero, a delete action is performed\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data construct no_create clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of data construct no_create clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct no_create clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct no_create clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2710 no create clause\nTheno_create clause may appear on structured data and compute constructs\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\ntheno_create clause behaves as follows:\n\n\tAt entry to the region:\n\t\tIfvaris present and is not a null pointer, a present increment action with the structured\nreference counter is performed If varis present and is a pointer reference, an attach\naction is performed\n\t\tIfvaris not present, no action is performed, and any device code in this constru ct will\nuse the local memory address for var\n\tAt exit from the region:\n\t\tIf the structured reference counter for varis zero, no action is taken\n\t\tOtherwise, a detach action is performed if varis a pointer reference, and a present decrement\naction with the structured reference counter is performed if varis not a null pointer If\nboth structured and dynamic reference counters are zero, a delete action is performed\n\nTemplate:\n\n#ifndef T1\n!T1:data construct no_create clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of data construct delete clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct delete clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct delete clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2711 delete clause\nThedelete clause may appear on exitdata directives\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthedelete clause behaves as follows:\n\tIf the dynamic reference counter for varis zero, no action is taken\n\tOtherwise, a detach action is performed if varis a pointer reference, and the dynamic refer-\nence counter is updated if varis not a null pointer:\n\t\tOn anexitdata directive with a finalize clause, the dynamic reference counter\nis set to zero\n\t\tOtherwise, a present decrement action with the dynamic reference counter is performed\nIfvaris a pointer reference, a detach action is performed If both structured and dynamic\nreference counters are zero, a delete action is performed\nAnexitdata directive with a delete clause and with or without a finalize clause is func-\ntionally equivalent to a call to the acc_delete_finalize oracc_delete API routine, re-\nspectively, as described in Section 3219\nThe errors in Section 273 Data Clause Errors may be issued for this clause\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data construct delete clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of data construct delete clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct delete clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct delete clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2711 delete clause\nThedelete clause may appear on exitdata directives\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthedelete clause behaves as follows:\n\tIf the dynamic reference counter for varis zero, no action is taken\n\tOtherwise, a detach action is performed if varis a pointer reference, and the dynamic refer-\nence counter is updated if varis not a null pointer:\n\t\tOn anexitdata directive with a finalize clause, the dynamic reference counter\nis set to zero\n\t\tOtherwise, a present decrement action with the dynamic reference counter is performed\nIfvaris a pointer reference, a detach action is performed If both structured and dynamic\nreference counters are zero, a delete action is performed\nAnexitdata directive with a delete clause and with or without a finalize clause is func-\ntionally equivalent to a call to the acc_delete_finalize oracc_delete API routine, re-\nspectively, as described in Section 3219\nThe errors in Section 273 Data Clause Errors may be issued for this clause\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data construct delete clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of data construct delete clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct delete clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct delete clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2711 delete clause\nThedelete clause may appear on exitdata directives\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthedelete clause behaves as follows:\n\tIf the dynamic reference counter for varis zero, no action is taken\n\tOtherwise, a detach action is performed if varis a pointer reference, and the dynamic refer-\nence counter is updated if varis not a null pointer:\n\t\tOn anexitdata directive with a finalize clause, the dynamic reference counter\nis set to zero\n\t\tOtherwise, a present decrement action with the dynamic reference counter is performed\nIfvaris a pointer reference, a detach action is performed If both structured and dynamic\nreference counters are zero, a delete action is performed\nAnexitdata directive with a delete clause and with or without a finalize clause is func-\ntionally equivalent to a call to the acc_delete_finalize oracc_delete API routine, re-\nspectively, as described in Section 3219\nThe errors in Section 273 Data Clause Errors may be issued for this clause\n\nTemplate:\n\n#ifndef T1\n!T1:data construct delete clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of data construct attach clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct attach clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct attach clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2712 attach clause\nTheattach clause may appear on structured data and compute constructs and on enterdata\ndirectives Each varargument to an attach clause must be a C or C++ pointer or a Fortran variable\nor array with the pointer orallocatable attribute\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\ntheattach clause behaves as follows:\n\tAt entry to a region or at an enterdata directive, an attach action is performed\n\tAt exit from the region, a detach action is performed\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data construct attach clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of data construct attach clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct attach clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct attach clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2712 attach clause\nTheattach clause may appear on structured data and compute constructs and on enterdata\ndirectives Each varargument to an attach clause must be a C or C++ pointer or a Fortran variable\nor array with the pointer orallocatable attribute\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\ntheattach clause behaves as follows:\n\tAt entry to a region or at an enterdata directive, an attach action is performed\n\tAt exit from the region, a detach action is performed\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data construct attach clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of data construct attach clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct attach clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct attach clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2712 attach clause\nTheattach clause may appear on structured data and compute constructs and on enterdata\ndirectives Each varargument to an attach clause must be a C or C++ pointer or a Fortran variable\nor array with the pointer orallocatable attribute\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\ntheattach clause behaves as follows:\n\tAt entry to a region or at an enterdata directive, an attach action is performed\n\tAt exit from the region, a detach action is performed\n\nTemplate:\n\n#ifndef T1\n!T1:data construct attach clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of data construct detach clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct detach clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct detach clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2713 detach clause\nThedetach clause may appear on exitdata directives Each varargument to a detach clause\nmust be a C or C++ pointer or a Fortran variable or array with the pointer orallocatable\nattribute\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthedetach clause behaves as follows:\n\tIf there is a finalize clause on the exitdata directive, an immediate detach action is\nperformed\n\tOtherwise, a detach action is performed\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data construct detach clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of data construct detach clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct detach clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct detach clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2713 detach clause\nThedetach clause may appear on exitdata directives Each varargument to a detach clause\nmust be a C or C++ pointer or a Fortran variable or array with the pointer orallocatable\nattribute\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthedetach clause behaves as follows:\n\tIf there is a finalize clause on the exitdata directive, an immediate detach action is\nperformed\n\tOtherwise, a detach action is performed\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:data construct detach clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of data construct detach clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test data construct detach clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, data construct detach clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2713 detach clause\nThedetach clause may appear on exitdata directives Each varargument to a detach clause\nmust be a C or C++ pointer or a Fortran variable or array with the pointer orallocatable\nattribute\nFor each varinvar-list , ifvaris in shared memory, no action is taken; if varis not in shared memory,\nthedetach clause behaves as follows:\n\tIf there is a finalize clause on the exitdata directive, an immediate detach action is\nperformed\n\tOtherwise, a detach action is performed\n\nTemplate:\n\n#ifndef T1\n!T1:data construct detach clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of host_data construct use_device clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test host_data construct use_device clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, host_data construct use_device clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 281 use device clause\nTheuse_device clause tells the compiler to use the current device address of any varinvar-list\nin code within the construct In particular, this may be used to pass the device a ddress of varto\noptimized procedures written in a lower-level API If varis a null pointer, the same value is used\nfor the device address Otherwise, when there is no if_present clause, and either there is no\nifclause or the condition in the ifclause evaluates to true, the varinvar-list must be present in\nthe accelerator memory due to data regions or data lifetimes that contain this cons truct For data in\nshared memory, the device address is the same as the host address\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:host_data construct use_device clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of host_data construct use_device clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test host_data construct use_device clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, host_data construct use_device clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 281 use device clause\nTheuse_device clause tells the compiler to use the current device address of any varinvar-list\nin code within the construct In particular, this may be used to pass the device a ddress of varto\noptimized procedures written in a lower-level API If varis a null pointer, the same value is used\nfor the device address Otherwise, when there is no if_present clause, and either there is no\nifclause or the condition in the ifclause evaluates to true, the varinvar-list must be present in\nthe accelerator memory due to data regions or data lifetimes that contain this cons truct For data in\nshared memory, the device address is the same as the host address\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:host_data construct use_device clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of host_data construct use_device clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test host_data construct use_device clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, host_data construct use_device clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 281 use device clause\nTheuse_device clause tells the compiler to use the current device address of any varinvar-list\nin code within the construct In particular, this may be used to pass the device a ddress of varto\noptimized procedures written in a lower-level API If varis a null pointer, the same value is used\nfor the device address Otherwise, when there is no if_present clause, and either there is no\nifclause or the condition in the ifclause evaluates to true, the varinvar-list must be present in\nthe accelerator memory due to data regions or data lifetimes that contain this cons truct For data in\nshared memory, the device address is the same as the host address\n\nTemplate:\n\n#ifndef T1\n!T1:host_data construct use_device clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of host_data construct if clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test host_data construct if clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, host_data construct if clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 282 if clause\nTheifclause is optional When an ifclause appears and the condition evaluates to false , the\ncompiler will not replace the addresses of any varin code within the construct When there is no if\nclause, or when an ifclause appears and the condition evaluates to true, the compiler will replace\nthe addresses as described in the previous subsection\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:host_data construct if clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of host_data construct if clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test host_data construct if clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, host_data construct if clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 282 if clause\nTheifclause is optional When an ifclause appears and the condition evaluates to false , the\ncompiler will not replace the addresses of any varin code within the construct When there is no if\nclause, or when an ifclause appears and the condition evaluates to true, the compiler will replace\nthe addresses as described in the previous subsection\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:host_data construct if clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of host_data construct if clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test host_data construct if clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, host_data construct if clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 282 if clause\nTheifclause is optional When an ifclause appears and the condition evaluates to false , the\ncompiler will not replace the addresses of any varin code within the construct When there is no if\nclause, or when an ifclause appears and the condition evaluates to true, the compiler will replace\nthe addresses as described in the previous subsection\n\nTemplate:\n\n#ifndef T1\n!T1:host_data construct if clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of host_data construct if_present clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test host_data construct if_present clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, host_data construct if_present clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 283 if present clause\nWhen anif_present clause appears on the directive, the compiler will only replace the address\nof any varwhich appears in var-list that is present in the current device memory\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:host_data construct if_present clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of host_data construct if_present clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test host_data construct if_present clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, host_data construct if_present clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 283 if present clause\nWhen anif_present clause appears on the directive, the compiler will only replace the address\nof any varwhich appears in var-list that is present in the current device memory\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:host_data construct if_present clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of host_data construct if_present clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test host_data construct if_present clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, host_data construct if_present clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 283 if present clause\nWhen anif_present clause appears on the directive, the compiler will only replace the address\nof any varwhich appears in var-list that is present in the current device memory\n\nTemplate:\n\n#ifndef T1\n!T1:host_data construct if_present clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of loop construct collapse clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct collapse clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct collapse clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 291 collapse clause\nThecollapse clause is used to specify how many nested loops are associated with the loop\nconstruct The argument to the collapse clause must be a constant positive integer expression\nIf nocollapse clause appears, only the immediately following loop is associated with the loop\nconstruct\nIf more than one loop is associated with the loop construct, the iterations of all the associated loops\nare all scheduled according to the rest of the clauses The trip count fo r all loops associated with\nthecollapse clause must be computable and invariant in all the loops The particular intege r\ntype used to compute the trip count for the collapsed loops is implementation de\ufb01ne d However, the\ninteger type used for the trip count has at least the precision of each loop variable of the associated\nloops\nIt is implementation-de\ufb01ned whether a gang ,worker orvector clause on the construct is ap-\nplied to each loop, or to the linearized iteration space\nThe associated loops are the nnested loops that immediately follow the loop construct If the\nforce modi\ufb01er does not appear, then the associated loops must be tightly nested I f theforce\nmodi\ufb01er appears, then any intervening code may be executed multiple times as ne eded to perform\nthe collapse\nRestrictions\n\tEach associated loop, except the innermost, must contain exactly one loop o r loop nest\n\tIntervening code must not contain other OpenACC directives or calls to AP I routines\n/triangledownsld /triangledownsld\nExamples\n\n\tIn the code below, a compiler may choose to move the call to tan inside the inner loop in\norder to collapse the two loops, resulting in redundant execution of the inter vening code\n#pragma acc parallel loop collapse(force:2)\n{\nfor ( int i = 0; i < 360; i++ )\n{\n// This operation may be executed additional times in order\n// to perform the forced collapse\ntanI = tan(a[i]);\nfor ( int j = 0; j < N; j++ )\n{\n\n// Do Something\n}\n}\n}\n/trianglesolid /trianglesolid\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct collapse clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of loop construct collapse clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct collapse clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct collapse clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 291 collapse clause\nThecollapse clause is used to specify how many nested loops are associated with the loop\nconstruct The argument to the collapse clause must be a constant positive integer expression\nIf nocollapse clause appears, only the immediately following loop is associated with the loop\nconstruct\nIf more than one loop is associated with the loop construct, the iterations of all the associated loops\nare all scheduled according to the rest of the clauses The trip count fo r all loops associated with\nthecollapse clause must be computable and invariant in all the loops The particular intege r\ntype used to compute the trip count for the collapsed loops is implementation de\ufb01ne d However, the\ninteger type used for the trip count has at least the precision of each loop variable of the associated\nloops\nIt is implementation-de\ufb01ned whether a gang ,worker orvector clause on the construct is ap-\nplied to each loop, or to the linearized iteration space\nThe associated loops are the nnested loops that immediately follow the loop construct If the\nforce modi\ufb01er does not appear, then the associated loops must be tightly nested I f theforce\nmodi\ufb01er appears, then any intervening code may be executed multiple times as ne eded to perform\nthe collapse\nRestrictions\n\tEach associated loop, except the innermost, must contain exactly one loop o r loop nest\n\tIntervening code must not contain other OpenACC directives or calls to AP I routines\n/triangledownsld /triangledownsld\nExamples\n\n\tIn the code below, a compiler may choose to move the call to tan inside the inner loop in\norder to collapse the two loops, resulting in redundant execution of the inter vening code\n#pragma acc parallel loop collapse(force:2)\n{\nfor ( int i = 0; i < 360; i++ )\n{\n// This operation may be executed additional times in order\n// to perform the forced collapse\ntanI = tan(a[i]);\nfor ( int j = 0; j < N; j++ )\n{\n\n// Do Something\n}\n}\n}\n/trianglesolid /trianglesolid\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct collapse clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of loop construct collapse clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct collapse clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct collapse clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 291 collapse clause\nThecollapse clause is used to specify how many nested loops are associated with the loop\nconstruct The argument to the collapse clause must be a constant positive integer expression\nIf nocollapse clause appears, only the immediately following loop is associated with the loop\nconstruct\nIf more than one loop is associated with the loop construct, the iterations of all the associated loops\nare all scheduled according to the rest of the clauses The trip count fo r all loops associated with\nthecollapse clause must be computable and invariant in all the loops The particular intege r\ntype used to compute the trip count for the collapsed loops is implementation de\ufb01ne d However, the\ninteger type used for the trip count has at least the precision of each loop variable of the associated\nloops\nIt is implementation-de\ufb01ned whether a gang ,worker orvector clause on the construct is ap-\nplied to each loop, or to the linearized iteration space\nThe associated loops are the nnested loops that immediately follow the loop construct If the\nforce modi\ufb01er does not appear, then the associated loops must be tightly nested I f theforce\nmodi\ufb01er appears, then any intervening code may be executed multiple times as ne eded to perform\nthe collapse\nRestrictions\n\tEach associated loop, except the innermost, must contain exactly one loop o r loop nest\n\tIntervening code must not contain other OpenACC directives or calls to AP I routines\n/triangledownsld /triangledownsld\nExamples\n\n\tIn the code below, a compiler may choose to move the call to tan inside the inner loop in\norder to collapse the two loops, resulting in redundant execution of the inter vening code\n#pragma acc parallel loop collapse(force:2)\n{\nfor ( int i = 0; i < 360; i++ )\n{\n// This operation may be executed additional times in order\n// to perform the forced collapse\ntanI = tan(a[i]);\nfor ( int j = 0; j < N; j++ )\n{\n\n// Do Something\n}\n}\n}\n/trianglesolid /trianglesolid\n\nTemplate:\n\n#ifndef T1\n!T1:loop construct collapse clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of loop construct gang clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct gang clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct gang clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 292 gang clause\nWhen the parent compute construct is a parallel construct, or on an orphaned loop construct,\nthegang clause behaves as follows It speci\ufb01es that the iterations of the associate d loop or loops\nare to be executed in parallel by distributing the iterations among the gangs alon g the associated\ndimension created by the compute construct The associated dimension is the va lue of thedim\nargument, if it appears, or is dimension one The dim argument must be a constant positive integer\nwith value 1, 2, or 3 If the associated dimension is d, aloop construct with the gang clause\ntransitions a compute region from gang-redundant mode to gang-partitione d mode on dimension d\n(GRdto GP d) The number of gangs in dimension dis controlled by the parallel construct; the\nnum argument is not allowed The loop iterations must be data independent, exce pt for vars which\nappear in a reduction clause or which are modi\ufb01ed in an atomic region\nWhen the parent compute construct is a kernels construct, the gang clause behaves as follows\nIt speci\ufb01es that the iterations of the associated loop or loops are to be exec uted in parallel across the\ngangs The dim argument is not allowed An argument with no keyword or with the num keyword\nis allowed only when the num_gangs does not appear on the kernels construct If an argument\nwith no keyword or an argument after the num keyword appears, it speci\ufb01es how many gangs to use\nto execute the iterations of this loop The region of a loop with the gang clause may not contain\nanother loop with a gang clause unless within a nested compute region\nThe scheduling of loop iterations to gangs is not speci\ufb01ed unless the static modi\ufb01er appears as\nan argument If the static modi\ufb01er appears with an integer expression, that expression is used\nas a chunk size If the static modi\ufb01er appears with an asterisk, the implementation will select a\nchunk size The iterations are divided into chunks of the selected chunk size, and the chunks are\nassigned to gangs starting with gang zero and continuing in round-robin fa shion Two gang loops\nin the same parallel region with the same number of iterations, and with static clauses with the\nsame argument, will assign the iterations to gangs in the same manner Two gang loops in the\nsame kernels region with the same number of iterations, the same number of gang s to use, and with\nstatic clauses with the same argument, will assign the iterations to gangs in the same manne r\nAgang(dim:1) clause is implied on a data-independent loop construct without an explicit\ngang clause if the following conditions hold while ignoring gang ,worker , andvector clauses\non any sequential loop constructs:\n\tThisloop construct\u2019s parent compute construct, if any, is not a kernels construct\n\tAn explicit gang(dim:1) clause would be permitted on this loop construct\n\tFor every lexically enclosing data-independent loop construct, either an explicit gang(dim:1)\nclause would not be permitted on the enclosing loop construct, or the enclosing loop con-\nstruct lexically encloses a compute construct that lexically encloses this loop construct\nNote: As a performance optimization, the implementation might select different levels of paral-\nlelism for a loop construct than speci\ufb01ed by explicitly or implicitly determined clauses as long\n\nas it can prove program semantics are preserved In particular, the imple mentation must consider\nsemantic differences between gang-redundant and gang-partitioned mo de For example, in a series\nof tightly nested, data-independent loop constructs, implementations often move gang-partitioning\nfrom oneloop construct to another without affecting semantics\nNote: If theauto ordevice_type clause appears on a loop construct, it is the programmer\u2019s\nresponsibility to ensure that program semantics are the same regardless of whether the auto clause\nis treated as independent orseq and regardless of the device type for which the program is\ncompiled In particular, the programmer must consider the effect on both ex plicitly and implicitly\ndetermined gang clauses and thus on gang-redundant and gang-partitioned mode Examp les in\nSection 2911 demonstrate this issue for the auto clause\nRestrictions\n\tAt most one gang clause may appear on a loop directive\n\tThe region of a loop with a gang(dim:d) clause may not contain a loop construct with a\ngang(dim:e) clause where e >= d unless it appears within a nested compute region\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct gang clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of loop construct gang clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct gang clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct gang clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 292 gang clause\nWhen the parent compute construct is a parallel construct, or on an orphaned loop construct,\nthegang clause behaves as follows It speci\ufb01es that the iterations of the associate d loop or loops\nare to be executed in parallel by distributing the iterations among the gangs alon g the associated\ndimension created by the compute construct The associated dimension is the va lue of thedim\nargument, if it appears, or is dimension one The dim argument must be a constant positive integer\nwith value 1, 2, or 3 If the associated dimension is d, aloop construct with the gang clause\ntransitions a compute region from gang-redundant mode to gang-partitione d mode on dimension d\n(GRdto GP d) The number of gangs in dimension dis controlled by the parallel construct; the\nnum argument is not allowed The loop iterations must be data independent, exce pt for vars which\nappear in a reduction clause or which are modi\ufb01ed in an atomic region\nWhen the parent compute construct is a kernels construct, the gang clause behaves as follows\nIt speci\ufb01es that the iterations of the associated loop or loops are to be exec uted in parallel across the\ngangs The dim argument is not allowed An argument with no keyword or with the num keyword\nis allowed only when the num_gangs does not appear on the kernels construct If an argument\nwith no keyword or an argument after the num keyword appears, it speci\ufb01es how many gangs to use\nto execute the iterations of this loop The region of a loop with the gang clause may not contain\nanother loop with a gang clause unless within a nested compute region\nThe scheduling of loop iterations to gangs is not speci\ufb01ed unless the static modi\ufb01er appears as\nan argument If the static modi\ufb01er appears with an integer expression, that expression is used\nas a chunk size If the static modi\ufb01er appears with an asterisk, the implementation will select a\nchunk size The iterations are divided into chunks of the selected chunk size, and the chunks are\nassigned to gangs starting with gang zero and continuing in round-robin fa shion Two gang loops\nin the same parallel region with the same number of iterations, and with static clauses with the\nsame argument, will assign the iterations to gangs in the same manner Two gang loops in the\nsame kernels region with the same number of iterations, the same number of gang s to use, and with\nstatic clauses with the same argument, will assign the iterations to gangs in the same manne r\nAgang(dim:1) clause is implied on a data-independent loop construct without an explicit\ngang clause if the following conditions hold while ignoring gang ,worker , andvector clauses\non any sequential loop constructs:\n\tThisloop construct\u2019s parent compute construct, if any, is not a kernels construct\n\tAn explicit gang(dim:1) clause would be permitted on this loop construct\n\tFor every lexically enclosing data-independent loop construct, either an explicit gang(dim:1)\nclause would not be permitted on the enclosing loop construct, or the enclosing loop con-\nstruct lexically encloses a compute construct that lexically encloses this loop construct\nNote: As a performance optimization, the implementation might select different levels of paral-\nlelism for a loop construct than speci\ufb01ed by explicitly or implicitly determined clauses as long\n\nas it can prove program semantics are preserved In particular, the imple mentation must consider\nsemantic differences between gang-redundant and gang-partitioned mo de For example, in a series\nof tightly nested, data-independent loop constructs, implementations often move gang-partitioning\nfrom oneloop construct to another without affecting semantics\nNote: If theauto ordevice_type clause appears on a loop construct, it is the programmer\u2019s\nresponsibility to ensure that program semantics are the same regardless of whether the auto clause\nis treated as independent orseq and regardless of the device type for which the program is\ncompiled In particular, the programmer must consider the effect on both ex plicitly and implicitly\ndetermined gang clauses and thus on gang-redundant and gang-partitioned mode Examp les in\nSection 2911 demonstrate this issue for the auto clause\nRestrictions\n\tAt most one gang clause may appear on a loop directive\n\tThe region of a loop with a gang(dim:d) clause may not contain a loop construct with a\ngang(dim:e) clause where e >= d unless it appears within a nested compute region\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct gang clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of loop construct gang clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct gang clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct gang clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 292 gang clause\nWhen the parent compute construct is a parallel construct, or on an orphaned loop construct,\nthegang clause behaves as follows It speci\ufb01es that the iterations of the associate d loop or loops\nare to be executed in parallel by distributing the iterations among the gangs alon g the associated\ndimension created by the compute construct The associated dimension is the va lue of thedim\nargument, if it appears, or is dimension one The dim argument must be a constant positive integer\nwith value 1, 2, or 3 If the associated dimension is d, aloop construct with the gang clause\ntransitions a compute region from gang-redundant mode to gang-partitione d mode on dimension d\n(GRdto GP d) The number of gangs in dimension dis controlled by the parallel construct; the\nnum argument is not allowed The loop iterations must be data independent, exce pt for vars which\nappear in a reduction clause or which are modi\ufb01ed in an atomic region\nWhen the parent compute construct is a kernels construct, the gang clause behaves as follows\nIt speci\ufb01es that the iterations of the associated loop or loops are to be exec uted in parallel across the\ngangs The dim argument is not allowed An argument with no keyword or with the num keyword\nis allowed only when the num_gangs does not appear on the kernels construct If an argument\nwith no keyword or an argument after the num keyword appears, it speci\ufb01es how many gangs to use\nto execute the iterations of this loop The region of a loop with the gang clause may not contain\nanother loop with a gang clause unless within a nested compute region\nThe scheduling of loop iterations to gangs is not speci\ufb01ed unless the static modi\ufb01er appears as\nan argument If the static modi\ufb01er appears with an integer expression, that expression is used\nas a chunk size If the static modi\ufb01er appears with an asterisk, the implementation will select a\nchunk size The iterations are divided into chunks of the selected chunk size, and the chunks are\nassigned to gangs starting with gang zero and continuing in round-robin fa shion Two gang loops\nin the same parallel region with the same number of iterations, and with static clauses with the\nsame argument, will assign the iterations to gangs in the same manner Two gang loops in the\nsame kernels region with the same number of iterations, the same number of gang s to use, and with\nstatic clauses with the same argument, will assign the iterations to gangs in the same manne r\nAgang(dim:1) clause is implied on a data-independent loop construct without an explicit\ngang clause if the following conditions hold while ignoring gang ,worker , andvector clauses\non any sequential loop constructs:\n\tThisloop construct\u2019s parent compute construct, if any, is not a kernels construct\n\tAn explicit gang(dim:1) clause would be permitted on this loop construct\n\tFor every lexically enclosing data-independent loop construct, either an explicit gang(dim:1)\nclause would not be permitted on the enclosing loop construct, or the enclosing loop con-\nstruct lexically encloses a compute construct that lexically encloses this loop construct\nNote: As a performance optimization, the implementation might select different levels of paral-\nlelism for a loop construct than speci\ufb01ed by explicitly or implicitly determined clauses as long\n\nas it can prove program semantics are preserved In particular, the imple mentation must consider\nsemantic differences between gang-redundant and gang-partitioned mo de For example, in a series\nof tightly nested, data-independent loop constructs, implementations often move gang-partitioning\nfrom oneloop construct to another without affecting semantics\nNote: If theauto ordevice_type clause appears on a loop construct, it is the programmer\u2019s\nresponsibility to ensure that program semantics are the same regardless of whether the auto clause\nis treated as independent orseq and regardless of the device type for which the program is\ncompiled In particular, the programmer must consider the effect on both ex plicitly and implicitly\ndetermined gang clauses and thus on gang-redundant and gang-partitioned mode Examp les in\nSection 2911 demonstrate this issue for the auto clause\nRestrictions\n\tAt most one gang clause may appear on a loop directive\n\tThe region of a loop with a gang(dim:d) clause may not contain a loop construct with a\ngang(dim:e) clause where e >= d unless it appears within a nested compute region\n\nTemplate:\n\n#ifndef T1\n!T1:loop construct gang clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of loop construct worker clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct worker clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct worker clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 293 worker clause\nWhen the parent compute construct is a parallel construct, or on an orphaned loop construct,\ntheworker clause speci\ufb01es that the iterations of the associated loop or loops are to be e xecuted\nin parallel by distributing the iterations among the multiple workers within a single gan g Aloop\nconstruct with a worker clause causes a gang to transition from worker-single mode to worker-\npartitioned mode In contrast to the gang clause, the worker clause \ufb01rst activates additional\nworker-level parallelism and then distributes the loop iterations across thos e workers No argu-\nment is allowed The loop iterations must be data independent, except for vars which appear in\nareduction clause or which are modi\ufb01ed in an atomic region The region of a loop with the\nworker clause may not contain a loop with the gang orworker clause unless within a nested\ncompute region\nWhen the parent compute construct is a kernels construct, the worker clause speci\ufb01es that the\niterations of the associated loop or loops are to be executed in parallel acro ss the workers within\na single gang An argument is allowed only when the num_workers does not appear on the\nkernels construct The optional argument speci\ufb01es how many workers per gang to use to execute\nthe iterations of this loop The region of a loop with the worker clause may not contain a loop\nwith agang orworker clause unless within a nested compute region\nAll workers will complete execution of their assigned iterations before any w orker proceeds beyond\nthe end of the loop\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct worker clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of loop construct worker clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct worker clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct worker clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 293 worker clause\nWhen the parent compute construct is a parallel construct, or on an orphaned loop construct,\ntheworker clause speci\ufb01es that the iterations of the associated loop or loops are to be e xecuted\nin parallel by distributing the iterations among the multiple workers within a single gan g Aloop\nconstruct with a worker clause causes a gang to transition from worker-single mode to worker-\npartitioned mode In contrast to the gang clause, the worker clause \ufb01rst activates additional\nworker-level parallelism and then distributes the loop iterations across thos e workers No argu-\nment is allowed The loop iterations must be data independent, except for vars which appear in\nareduction clause or which are modi\ufb01ed in an atomic region The region of a loop with the\nworker clause may not contain a loop with the gang orworker clause unless within a nested\ncompute region\nWhen the parent compute construct is a kernels construct, the worker clause speci\ufb01es that the\niterations of the associated loop or loops are to be executed in parallel acro ss the workers within\na single gang An argument is allowed only when the num_workers does not appear on the\nkernels construct The optional argument speci\ufb01es how many workers per gang to use to execute\nthe iterations of this loop The region of a loop with the worker clause may not contain a loop\nwith agang orworker clause unless within a nested compute region\nAll workers will complete execution of their assigned iterations before any w orker proceeds beyond\nthe end of the loop\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct worker clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of loop construct worker clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct worker clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct worker clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 293 worker clause\nWhen the parent compute construct is a parallel construct, or on an orphaned loop construct,\ntheworker clause speci\ufb01es that the iterations of the associated loop or loops are to be e xecuted\nin parallel by distributing the iterations among the multiple workers within a single gan g Aloop\nconstruct with a worker clause causes a gang to transition from worker-single mode to worker-\npartitioned mode In contrast to the gang clause, the worker clause \ufb01rst activates additional\nworker-level parallelism and then distributes the loop iterations across thos e workers No argu-\nment is allowed The loop iterations must be data independent, except for vars which appear in\nareduction clause or which are modi\ufb01ed in an atomic region The region of a loop with the\nworker clause may not contain a loop with the gang orworker clause unless within a nested\ncompute region\nWhen the parent compute construct is a kernels construct, the worker clause speci\ufb01es that the\niterations of the associated loop or loops are to be executed in parallel acro ss the workers within\na single gang An argument is allowed only when the num_workers does not appear on the\nkernels construct The optional argument speci\ufb01es how many workers per gang to use to execute\nthe iterations of this loop The region of a loop with the worker clause may not contain a loop\nwith agang orworker clause unless within a nested compute region\nAll workers will complete execution of their assigned iterations before any w orker proceeds beyond\nthe end of the loop\n\nTemplate:\n\n#ifndef T1\n!T1:loop construct worker clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of loop construct vector clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct vector clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct vector clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 294 vector clause\nWhen the parent compute construct is a parallel construct, or on an orphaned loop construct,\nthevector clause speci\ufb01es that the iterations of the associated loop or loops are to be e xecuted\nin vector or SIMD mode A loop construct with a vector clause causes a worker to transition\nfrom vector-single mode to vector-partitioned mode Similar to the worker clause, the vector\nclause \ufb01rst activates additional vector-level parallelism and then distribu tes the loop iterations across\nthose vector lanes The operations will execute using vectors of the length speci\ufb01ed or chosen for\nthe parallel region The loop iterations must be data independent, except f orvars which appear in\nareduction clause or which are modi\ufb01ed in an atomic region The region of a loop with the\n\nvector clause may not contain a loop with the gang ,worker , orvector clause unless within\na nested compute region\nWhen the parent compute construct is a kernels construct, the vector clause speci\ufb01es that the\niterations of the associated loop or loops are to be executed with vector or SI MD processing An\nargument is allowed only when the vector_length does not appear on the kernels construct\nIf an argument appears, the iterations will be processed in vector strips o f that length; if no argument\nappears, the implementation will choose an appropriate vector length The re gion of a loop with the\nvector clause may not contain a loop with a gang ,worker , orvector clause unless within a\nnested compute region\nAll vector lanes will complete execution of their assigned iterations before an y vector lane proceeds\nbeyond the end of the loop\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct vector clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of loop construct vector clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct vector clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct vector clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 294 vector clause\nWhen the parent compute construct is a parallel construct, or on an orphaned loop construct,\nthevector clause speci\ufb01es that the iterations of the associated loop or loops are to be e xecuted\nin vector or SIMD mode A loop construct with a vector clause causes a worker to transition\nfrom vector-single mode to vector-partitioned mode Similar to the worker clause, the vector\nclause \ufb01rst activates additional vector-level parallelism and then distribu tes the loop iterations across\nthose vector lanes The operations will execute using vectors of the length speci\ufb01ed or chosen for\nthe parallel region The loop iterations must be data independent, except f orvars which appear in\nareduction clause or which are modi\ufb01ed in an atomic region The region of a loop with the\n\nvector clause may not contain a loop with the gang ,worker , orvector clause unless within\na nested compute region\nWhen the parent compute construct is a kernels construct, the vector clause speci\ufb01es that the\niterations of the associated loop or loops are to be executed with vector or SI MD processing An\nargument is allowed only when the vector_length does not appear on the kernels construct\nIf an argument appears, the iterations will be processed in vector strips o f that length; if no argument\nappears, the implementation will choose an appropriate vector length The re gion of a loop with the\nvector clause may not contain a loop with a gang ,worker , orvector clause unless within a\nnested compute region\nAll vector lanes will complete execution of their assigned iterations before an y vector lane proceeds\nbeyond the end of the loop\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct vector clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of loop construct vector clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct vector clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct vector clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 294 vector clause\nWhen the parent compute construct is a parallel construct, or on an orphaned loop construct,\nthevector clause speci\ufb01es that the iterations of the associated loop or loops are to be e xecuted\nin vector or SIMD mode A loop construct with a vector clause causes a worker to transition\nfrom vector-single mode to vector-partitioned mode Similar to the worker clause, the vector\nclause \ufb01rst activates additional vector-level parallelism and then distribu tes the loop iterations across\nthose vector lanes The operations will execute using vectors of the length speci\ufb01ed or chosen for\nthe parallel region The loop iterations must be data independent, except f orvars which appear in\nareduction clause or which are modi\ufb01ed in an atomic region The region of a loop with the\n\nvector clause may not contain a loop with the gang ,worker , orvector clause unless within\na nested compute region\nWhen the parent compute construct is a kernels construct, the vector clause speci\ufb01es that the\niterations of the associated loop or loops are to be executed with vector or SI MD processing An\nargument is allowed only when the vector_length does not appear on the kernels construct\nIf an argument appears, the iterations will be processed in vector strips o f that length; if no argument\nappears, the implementation will choose an appropriate vector length The re gion of a loop with the\nvector clause may not contain a loop with a gang ,worker , orvector clause unless within a\nnested compute region\nAll vector lanes will complete execution of their assigned iterations before an y vector lane proceeds\nbeyond the end of the loop\n\nTemplate:\n\n#ifndef T1\n!T1:loop construct vector clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of loop construct seq clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct seq clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct seq clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 295 seq clause\nTheseq clause speci\ufb01es that the associated loop or loops are to be executed sequ entially by the\naccelerator This clause will override any automatic parallelization or vector ization\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct seq clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of loop construct seq clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct seq clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct seq clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 295 seq clause\nTheseq clause speci\ufb01es that the associated loop or loops are to be executed sequ entially by the\naccelerator This clause will override any automatic parallelization or vector ization\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct seq clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of loop construct seq clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct seq clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct seq clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 295 seq clause\nTheseq clause speci\ufb01es that the associated loop or loops are to be executed sequ entially by the\naccelerator This clause will override any automatic parallelization or vector ization\n\nTemplate:\n\n#ifndef T1\n!T1:loop construct seq clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of loop construct independent clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct independent clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct independent clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 296 independent clause\nTheindependent clause tells the implementation that the loop iterations must be data indepen-\ndent, except for vars which appear in a reduction clause or which are modi\ufb01ed in an atomic\nregion This allows the implementation to generate code to execute the iterations in p arallel with no\nsynchronization\nAloop construct with no auto orseq clause is treated as if it has the independent clause\nwhen it is an orphaned loop construct or its parent compute construct is a parallel construct\nNote\n\tIt is likely a programming error to use the independent clause on a loop if any iteration\nwrites to a variable or array element that any other iteration also writes or rea ds, except for\nvars which appear in a reduction clause or which are modi\ufb01ed in an atomic region\n\tThe implementation may be restricted in the levels of parallelism it can apply by the pr esence\nofloop constructs with gang ,worker , orvector clauses for outer or inner loops\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct independent clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of loop construct independent clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct independent clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct independent clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 296 independent clause\nTheindependent clause tells the implementation that the loop iterations must be data indepen-\ndent, except for vars which appear in a reduction clause or which are modi\ufb01ed in an atomic\nregion This allows the implementation to generate code to execute the iterations in p arallel with no\nsynchronization\nAloop construct with no auto orseq clause is treated as if it has the independent clause\nwhen it is an orphaned loop construct or its parent compute construct is a parallel construct\nNote\n\tIt is likely a programming error to use the independent clause on a loop if any iteration\nwrites to a variable or array element that any other iteration also writes or rea ds, except for\nvars which appear in a reduction clause or which are modi\ufb01ed in an atomic region\n\tThe implementation may be restricted in the levels of parallelism it can apply by the pr esence\nofloop constructs with gang ,worker , orvector clauses for outer or inner loops\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct independent clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of loop construct independent clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct independent clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct independent clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 296 independent clause\nTheindependent clause tells the implementation that the loop iterations must be data indepen-\ndent, except for vars which appear in a reduction clause or which are modi\ufb01ed in an atomic\nregion This allows the implementation to generate code to execute the iterations in p arallel with no\nsynchronization\nAloop construct with no auto orseq clause is treated as if it has the independent clause\nwhen it is an orphaned loop construct or its parent compute construct is a parallel construct\nNote\n\tIt is likely a programming error to use the independent clause on a loop if any iteration\nwrites to a variable or array element that any other iteration also writes or rea ds, except for\nvars which appear in a reduction clause or which are modi\ufb01ed in an atomic region\n\tThe implementation may be restricted in the levels of parallelism it can apply by the pr esence\nofloop constructs with gang ,worker , orvector clauses for outer or inner loops\n\nTemplate:\n\n#ifndef T1\n!T1:loop construct independent clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of loop construct auto clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct auto clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct auto clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 297 auto clause\nTheauto clause speci\ufb01es that the implementation must analyze the loop and determine wheth er the\nloop iterations are data-independent If it determines that the loop iterations a re data-independent,\nthe implementation must treat the auto clause as if it is an independent clause If not, or if it\nis unable to make a determination, it must treat the auto clause as if it is a seq clause, and it must\nignore anygang ,worker , orvector clauses on the loop construct\nWhen the parent compute construct is a kernels construct, a loop construct with no independent\norseq clause is treated as if it has the auto clause\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct auto clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of loop construct auto clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct auto clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct auto clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 297 auto clause\nTheauto clause speci\ufb01es that the implementation must analyze the loop and determine wheth er the\nloop iterations are data-independent If it determines that the loop iterations a re data-independent,\nthe implementation must treat the auto clause as if it is an independent clause If not, or if it\nis unable to make a determination, it must treat the auto clause as if it is a seq clause, and it must\nignore anygang ,worker , orvector clauses on the loop construct\nWhen the parent compute construct is a kernels construct, a loop construct with no independent\norseq clause is treated as if it has the auto clause\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct auto clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of loop construct auto clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct auto clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct auto clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 297 auto clause\nTheauto clause speci\ufb01es that the implementation must analyze the loop and determine wheth er the\nloop iterations are data-independent If it determines that the loop iterations a re data-independent,\nthe implementation must treat the auto clause as if it is an independent clause If not, or if it\nis unable to make a determination, it must treat the auto clause as if it is a seq clause, and it must\nignore anygang ,worker , orvector clauses on the loop construct\nWhen the parent compute construct is a kernels construct, a loop construct with no independent\norseq clause is treated as if it has the auto clause\n\nTemplate:\n\n#ifndef T1\n!T1:loop construct auto clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of loop construct tile clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct tile clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct tile clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 298 tile clause\nThetile clause speci\ufb01es that the implementation should split each loop in the loop nest into two\nloops, with an outer set of tileloops and an inner set of element loops The argument to the tile\n\nclause is a list of one or more tile sizes, where each tile size is a constant positi ve integer expression\nor an asterisk If there are ntile sizes in the list, the loop construct must be immediately followed\nbyntightly-nested loops The \ufb01rst argument in the size-expr-list corresponds to the innermost loop\nof the nassociated loops, and the last element corresponds to the outermost asso ciated loop If the\ntile size is an asterisk, the implementation will choose an appropriate value Each loop in the nest\nwill be split or strip-mined into two loops, an outer tileloop and an inner element loop The trip\ncount of the element loop will be limited to the corresponding tile size from the size-expr-list  The\ntileloops will be reordered to be outside all the element loops, and the element loops will all be\ninside the tileloops\nIf thevector clause appears on the loop construct, the vector clause is applied to the element\nloops If the gang clause appears on the loop construct, the gang clause is applied to the tile\nloops If the worker clause appears on the loop construct, the worker clause is applied to the\nelement loops if no vector clause appears, and to the tileloops otherwise\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct tile clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of loop construct tile clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct tile clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct tile clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 298 tile clause\nThetile clause speci\ufb01es that the implementation should split each loop in the loop nest into two\nloops, with an outer set of tileloops and an inner set of element loops The argument to the tile\n\nclause is a list of one or more tile sizes, where each tile size is a constant positi ve integer expression\nor an asterisk If there are ntile sizes in the list, the loop construct must be immediately followed\nbyntightly-nested loops The \ufb01rst argument in the size-expr-list corresponds to the innermost loop\nof the nassociated loops, and the last element corresponds to the outermost asso ciated loop If the\ntile size is an asterisk, the implementation will choose an appropriate value Each loop in the nest\nwill be split or strip-mined into two loops, an outer tileloop and an inner element loop The trip\ncount of the element loop will be limited to the corresponding tile size from the size-expr-list  The\ntileloops will be reordered to be outside all the element loops, and the element loops will all be\ninside the tileloops\nIf thevector clause appears on the loop construct, the vector clause is applied to the element\nloops If the gang clause appears on the loop construct, the gang clause is applied to the tile\nloops If the worker clause appears on the loop construct, the worker clause is applied to the\nelement loops if no vector clause appears, and to the tileloops otherwise\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct tile clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of loop construct tile clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct tile clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct tile clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 298 tile clause\nThetile clause speci\ufb01es that the implementation should split each loop in the loop nest into two\nloops, with an outer set of tileloops and an inner set of element loops The argument to the tile\n\nclause is a list of one or more tile sizes, where each tile size is a constant positi ve integer expression\nor an asterisk If there are ntile sizes in the list, the loop construct must be immediately followed\nbyntightly-nested loops The \ufb01rst argument in the size-expr-list corresponds to the innermost loop\nof the nassociated loops, and the last element corresponds to the outermost asso ciated loop If the\ntile size is an asterisk, the implementation will choose an appropriate value Each loop in the nest\nwill be split or strip-mined into two loops, an outer tileloop and an inner element loop The trip\ncount of the element loop will be limited to the corresponding tile size from the size-expr-list  The\ntileloops will be reordered to be outside all the element loops, and the element loops will all be\ninside the tileloops\nIf thevector clause appears on the loop construct, the vector clause is applied to the element\nloops If the gang clause appears on the loop construct, the gang clause is applied to the tile\nloops If the worker clause appears on the loop construct, the worker clause is applied to the\nelement loops if no vector clause appears, and to the tileloops otherwise\n\nTemplate:\n\n#ifndef T1\n!T1:loop construct tile clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of loop construct device_type clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct device_type clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct device_type clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 299 device type clause\nThedevice_type clause is described in Section 24 Device-Speci\ufb01c Clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct device_type clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of loop construct device_type clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct device_type clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct device_type clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 299 device type clause\nThedevice_type clause is described in Section 24 Device-Speci\ufb01c Clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct device_type clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of loop construct device_type clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct device_type clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct device_type clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 299 device type clause\nThedevice_type clause is described in Section 24 Device-Speci\ufb01c Clauses\n\nTemplate:\n\n#ifndef T1\n!T1:loop construct device_type clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of loop construct private clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct private clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct private clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2910 private clause\nTheprivate clause on a loop construct speci\ufb01es that a copy of each item in var-list will be\ncreated If the body of the loop is executed in vector-partitioned mode, a copy of the item is created\nfor each thread associated with each vector lane If the body of the loop is executed in worker-\npartitioned vector-single mode, a copy of the item is created for each worker and shared across th e\nset of threads associated with all the vector lanes of that worker Otherw ise, a copy of the item is\ncreated for each gang in all dimensions and shared across the set of thr eads associated with all the\nvector lanes of all the workers of that gang\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in private\nclauses\n/triangledownsld /triangledownsld\nExamples\n\n\tIn the example below, tmp is private to each worker of every gang but shared across all the\nvector lanes of a worker\n!$acc parallel\n!$acc loop gang\ndo k = 1, n\n!$acc loop worker private(tmp)\ndo j = 1, n\n!a single vector lane in each gang and worker assigns to tmp\ntmp = b(j,k) + c(j,k)\n!$acc loop vector\ndo i = 1, n\n!all vector lanes use the result of the above update to tmp\na(i,j,k) = a(i,j,k) + tmp/div\n\nenddo\nenddo\nenddo\n!$acc end parallel\n\tIn the example below, tmp is private to each gang in every dimension\n!$acc parallel num_gangs(3,50,150)\n!$acc loop gang(dim:3)\ndo k = 1, n\n!$acc loop gang(dim:2) private(tmp)\ndo j = 1, n\n!all gangs along dimension 1 execute in gang redundant mode a nd\n!assign to tmp which is private to each gang in all dimensions\ntmp = b(j,k) + c(j,k)\n!$acc loop gang(dim:1)\ndo i = 1, n\na(i,j,k) = a(i,j,k) + tmp/div\nenddo\nenddo\nenddo\n!$acc end parallel\n/trianglesolid /trianglesolid\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct private clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of loop construct private clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct private clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct private clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2910 private clause\nTheprivate clause on a loop construct speci\ufb01es that a copy of each item in var-list will be\ncreated If the body of the loop is executed in vector-partitioned mode, a copy of the item is created\nfor each thread associated with each vector lane If the body of the loop is executed in worker-\npartitioned vector-single mode, a copy of the item is created for each worker and shared across th e\nset of threads associated with all the vector lanes of that worker Otherw ise, a copy of the item is\ncreated for each gang in all dimensions and shared across the set of thr eads associated with all the\nvector lanes of all the workers of that gang\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in private\nclauses\n/triangledownsld /triangledownsld\nExamples\n\n\tIn the example below, tmp is private to each worker of every gang but shared across all the\nvector lanes of a worker\n!$acc parallel\n!$acc loop gang\ndo k = 1, n\n!$acc loop worker private(tmp)\ndo j = 1, n\n!a single vector lane in each gang and worker assigns to tmp\ntmp = b(j,k) + c(j,k)\n!$acc loop vector\ndo i = 1, n\n!all vector lanes use the result of the above update to tmp\na(i,j,k) = a(i,j,k) + tmp/div\n\nenddo\nenddo\nenddo\n!$acc end parallel\n\tIn the example below, tmp is private to each gang in every dimension\n!$acc parallel num_gangs(3,50,150)\n!$acc loop gang(dim:3)\ndo k = 1, n\n!$acc loop gang(dim:2) private(tmp)\ndo j = 1, n\n!all gangs along dimension 1 execute in gang redundant mode a nd\n!assign to tmp which is private to each gang in all dimensions\ntmp = b(j,k) + c(j,k)\n!$acc loop gang(dim:1)\ndo i = 1, n\na(i,j,k) = a(i,j,k) + tmp/div\nenddo\nenddo\nenddo\n!$acc end parallel\n/trianglesolid /trianglesolid\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct private clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of loop construct private clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct private clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct private clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2910 private clause\nTheprivate clause on a loop construct speci\ufb01es that a copy of each item in var-list will be\ncreated If the body of the loop is executed in vector-partitioned mode, a copy of the item is created\nfor each thread associated with each vector lane If the body of the loop is executed in worker-\npartitioned vector-single mode, a copy of the item is created for each worker and shared across th e\nset of threads associated with all the vector lanes of that worker Otherw ise, a copy of the item is\ncreated for each gang in all dimensions and shared across the set of thr eads associated with all the\nvector lanes of all the workers of that gang\nRestrictions\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in private\nclauses\n/triangledownsld /triangledownsld\nExamples\n\n\tIn the example below, tmp is private to each worker of every gang but shared across all the\nvector lanes of a worker\n!$acc parallel\n!$acc loop gang\ndo k = 1, n\n!$acc loop worker private(tmp)\ndo j = 1, n\n!a single vector lane in each gang and worker assigns to tmp\ntmp = b(j,k) + c(j,k)\n!$acc loop vector\ndo i = 1, n\n!all vector lanes use the result of the above update to tmp\na(i,j,k) = a(i,j,k) + tmp/div\n\nenddo\nenddo\nenddo\n!$acc end parallel\n\tIn the example below, tmp is private to each gang in every dimension\n!$acc parallel num_gangs(3,50,150)\n!$acc loop gang(dim:3)\ndo k = 1, n\n!$acc loop gang(dim:2) private(tmp)\ndo j = 1, n\n!all gangs along dimension 1 execute in gang redundant mode a nd\n!assign to tmp which is private to each gang in all dimensions\ntmp = b(j,k) + c(j,k)\n!$acc loop gang(dim:1)\ndo i = 1, n\na(i,j,k) = a(i,j,k) + tmp/div\nenddo\nenddo\nenddo\n!$acc end parallel\n/trianglesolid /trianglesolid\n\nTemplate:\n\n#ifndef T1\n!T1:loop construct private clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of loop construct reduction clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct reduction clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct reduction clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2911 reduction clause\nThereduction clause speci\ufb01es a reduction operator and one or more vars For each reduction\nvar, a private copy is created in the same manner as for a private clause on the loop construct,\nand initialized for that operator; see the table in Section 2515 reduction claus e After the loop, the\nvalues for each thread are combined using the speci\ufb01ed reduction opera tor, and the result combined\nwith the value of the original varand stored in the original var If the original varis not private,\nthis update occurs by the end of the compute region, and any access to the o riginal varis unde\ufb01ned\nwithin the compute region Otherwise, the update occurs at the end of the loop  If the reduction\nvaris an array or subarray, the reduction operation is logically equivalent to applying that reduction\noperation to each array element of the array or subarray individually I f the reduction varis a com-\nposite variable, the reduction operation is logically equivalent to applying tha t reduction operation\nto each member of the composite variable individually\nIf a variable is involved in a reduction that spans multiple nested loops where tw o or more of those\nloops have associated loop directives, a reduction clause containing that variable must appear\non each of those loop directives\nRestrictions\n\tAvarin areduction clause must be a scalar variable name, an aggregate variable name,\nan array element, or a subarray (refer to Section 271)\n\tReduction clauses on nested constructs for the same reduction varmust have the same reduc-\ntion operator\n\tEvery varin areduction clause appearing on an orphaned loop construct must be private\n\tThe restrictions for a reduction clause on a compute construct listed in in Section 25\nreduction clause also apply to a reduction clause on a loop construct\n\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nreduction clauses\n\tSee Section 262 Variables with Implicitly Determined Data Attributes for a restriction re-\nquiring certain loop reduction variables to have explicit data clauses on their parent compute\nconstructs\n\tAreduction clause may not appear on a loop directive that has a gang clause with a\ndim: argument whose value is greater than 1\n\tAreduction clause may not appear on a loop directive that has a gang clause and\nis within a compute construct that has a num_gangs clause with more than one explicit\nargument\n/triangledownsld /triangledownsld\nExamples\n\n\txis not private at the loop directive below, so its reduction normally updates xat the end\nof the parallel region, where gangs synchronize When possible, the imp lementation might\nchoose to partially update xat the loop exit instead, or fully if num_gangs(1) were added\nto theparallel directive However, portable applications cannot rely on such early up -\ndates, so accesses to xare unde\ufb01ned within the parallel region outside the loop\nint x = 0;\n#pragma acc parallel copy(x)\n{\n// gang-shared x undefined\n#pragma acc loop gang worker vector reduction(+:x)\nfor (int i = 0; i < I; ++i)\nx += 1; // vector-private x modified\n// gang-shared x undefined\n}// gang-shared x updated for gang/worker/vector reduction\n// x = I\n\txis private at each of the innermost two loop directives below, so each of their reductions\nupdatesxat the loop\u2019s exit However, xis not private at the outer loop directive, so its\nreduction updates xby the end of the parallel region instead\nint x = 0;\n#pragma acc parallel copy(x)\n{\n// gang-shared x undefined\n#pragma acc loop gang reduction(+:x)\nfor (int i = 0; i < I; ++i) {\n#pragma acc loop worker reduction(+:x)\nfor (int j = 0; j < J; ++j) {\n#pragma acc loop vector reduction(+:x)\nfor (int k = 0; k < K; ++k) {\nx += 1; // vector-private x modified\n}// worker-private x updated for vector reduction\n}// gang-private x updated for worker reduction\n}\n\n// gang-shared x undefined\n}// gang-shared x updated for gang reduction\n// x = I *J*K\n\tAt eachloop directive below, xis private and yis not private due to the data clauses on\ntheparallel directive Thus, each reduction updates xat the loop exit, but each reduction\nupdatesyby the end of the parallel region instead\nint x = 0, y = 0;\n#pragma acc parallel firstprivate(x) copy(y)\n{\n// gang-private x = 0; gang-shared y undefined\n#pragma acc loop seq reduction(+:x,y)\nfor (int i = 0; i < I; ++i) {\nx += 1; y += 2; // loop-private x and y modified\n}// gang-private x updated for trivial seq reduction\n// gang-private x = I; gang-shared y undefined\n#pragma acc loop worker reduction(+:x,y)\nfor (int i = 0; i < I; ++i) {\nx += 1; y += 2; // worker-private x and y modified\n}// gang-private x updated for worker reduction\n// gang-private x = 2 *I; gang-shared y undefined\n#pragma acc loop vector reduction(+:x,y)\nfor (int i = 0; i < I; ++i) {\nx += 1; y += 2; // vector-private x and y modified\n}// gang-private x updated for vector reduction\n// gang-private x = 3 *I; gang-shared y undefined\n}// gang-shared y updated for gang/seq/worker/vector reduc tions\n// x = 0; y = 3 *I*\n\tThe examples below are equivalent That is, the reduction clause on the combined con-\nstruct applies to the loop construct but implies a copy clause on the parallel construct Thus,\nxis not private at the loop directive, so the reduction updates xby the end of the parallel\nregion\nint x = 0;\n#pragma acc parallel loop worker reduction(+:x)\nfor (int i = 0; i < I; ++i) {\nx += 1; // worker-private x modified\n}// gang-shared x updated for gang/worker reduction\n// x = I\n\nint x = 0;\n#pragma acc parallel copy(x)\n{\n// gang-shared x undefined\n#pragma acc loop worker reduction(+:x)\nfor (int i = 0; i < I; ++i) {\nx += 1; // worker-private x modified\n}\n// gang-shared x undefined\n}// gang-shared x updated for gang/worker reduction\n// x = I\n\n\tIf the implementation treats the auto clause below as independent , the loop executes in\ngang-partitioned mode and thus examines every element of arr once to compute arr\u2019s max-\nimum However, if the implementation treats auto asseq, the gangs redundantly compute\narr\u2019s maximum, but the combined result is still arr\u2019s maximum Either way, because xis\nnot private at the loop directive, the reduction updates xby the end of the parallel region\nint x = 0;\nconst int *arr =/*array of I values */;\n#pragma acc parallel copy(x)\n{\n// gang-shared x undefined\n#pragma acc loop auto gang reduction(max:x)\nfor (int i = 0; i < I; ++i) {\n// complex loop body\nx = x < arr[i] ? arr[i] : x; // gang- or loop-private\n// x modified\n}\n// gang-shared x undefined\n}// gang-shared x updated for gang or gang/seq reduction\n// x = arr maximum\n\tThe following example is the same as the previous one except that the reductio n operator is\nnow+ While gang-partitioned mode sums the elements of arr once, gang-redundant mode\nsums them once per gang, producing a result many times arr\u2019s sum This example shows\nthat, for some reduction operators, combining auto ,gang , andreduction is typically\nnon-portable\nint x = 0;\nconst int *arr =/*array of I values */;\n#pragma acc parallel copy(x)\n{\n// gang-shared x undefined\n#pragma acc loop auto gang reduction(+:x)\nfor (int i = 0; i < I; ++i) {\n// complex loop body\nx += arr[i]; // gang or loop-private x modified\n}\n// gang-shared x undefined\n}// gang-shared x updated for gang or gang/seq reduction\n// x = arr sum possibly times number of gangs\n\tAt the following loop directive,xandzare private, so the loop reductions are not across\ngangs even though the loop is gang-partitioned Nevertheless, the reduction clause on the\nloop directive is important as the loop is also vector-partitioned These reduction s are only\npartial reductions relative to the full set of values computed by the loop, so th ereduction\nclause is needed on the parallel directive to reduce across gangs\nint x = 0, y = 0;\n#pragma acc parallel copy(x) reduction(+:x,y)\n{\nint z = 0;\n#pragma acc loop gang vector reduction(+:x,z)\nfor (int i = 0; i < I; ++i) {\nx += 1; z += 2; // vector-private x and z modified\n\n}// gang-private x and z updated for vector reduction\ny += z; // gang-private y modified\n}// gang-shared x and y updated for gang reduction\n// x = I; y = I *\n/trianglesolid /trianglesolid\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct reduction clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of loop construct reduction clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct reduction clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct reduction clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2911 reduction clause\nThereduction clause speci\ufb01es a reduction operator and one or more vars For each reduction\nvar, a private copy is created in the same manner as for a private clause on the loop construct,\nand initialized for that operator; see the table in Section 2515 reduction claus e After the loop, the\nvalues for each thread are combined using the speci\ufb01ed reduction opera tor, and the result combined\nwith the value of the original varand stored in the original var If the original varis not private,\nthis update occurs by the end of the compute region, and any access to the o riginal varis unde\ufb01ned\nwithin the compute region Otherwise, the update occurs at the end of the loop  If the reduction\nvaris an array or subarray, the reduction operation is logically equivalent to applying that reduction\noperation to each array element of the array or subarray individually I f the reduction varis a com-\nposite variable, the reduction operation is logically equivalent to applying tha t reduction operation\nto each member of the composite variable individually\nIf a variable is involved in a reduction that spans multiple nested loops where tw o or more of those\nloops have associated loop directives, a reduction clause containing that variable must appear\non each of those loop directives\nRestrictions\n\tAvarin areduction clause must be a scalar variable name, an aggregate variable name,\nan array element, or a subarray (refer to Section 271)\n\tReduction clauses on nested constructs for the same reduction varmust have the same reduc-\ntion operator\n\tEvery varin areduction clause appearing on an orphaned loop construct must be private\n\tThe restrictions for a reduction clause on a compute construct listed in in Section 25\nreduction clause also apply to a reduction clause on a loop construct\n\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nreduction clauses\n\tSee Section 262 Variables with Implicitly Determined Data Attributes for a restriction re-\nquiring certain loop reduction variables to have explicit data clauses on their parent compute\nconstructs\n\tAreduction clause may not appear on a loop directive that has a gang clause with a\ndim: argument whose value is greater than 1\n\tAreduction clause may not appear on a loop directive that has a gang clause and\nis within a compute construct that has a num_gangs clause with more than one explicit\nargument\n/triangledownsld /triangledownsld\nExamples\n\n\txis not private at the loop directive below, so its reduction normally updates xat the end\nof the parallel region, where gangs synchronize When possible, the imp lementation might\nchoose to partially update xat the loop exit instead, or fully if num_gangs(1) were added\nto theparallel directive However, portable applications cannot rely on such early up -\ndates, so accesses to xare unde\ufb01ned within the parallel region outside the loop\nint x = 0;\n#pragma acc parallel copy(x)\n{\n// gang-shared x undefined\n#pragma acc loop gang worker vector reduction(+:x)\nfor (int i = 0; i < I; ++i)\nx += 1; // vector-private x modified\n// gang-shared x undefined\n}// gang-shared x updated for gang/worker/vector reduction\n// x = I\n\txis private at each of the innermost two loop directives below, so each of their reductions\nupdatesxat the loop\u2019s exit However, xis not private at the outer loop directive, so its\nreduction updates xby the end of the parallel region instead\nint x = 0;\n#pragma acc parallel copy(x)\n{\n// gang-shared x undefined\n#pragma acc loop gang reduction(+:x)\nfor (int i = 0; i < I; ++i) {\n#pragma acc loop worker reduction(+:x)\nfor (int j = 0; j < J; ++j) {\n#pragma acc loop vector reduction(+:x)\nfor (int k = 0; k < K; ++k) {\nx += 1; // vector-private x modified\n}// worker-private x updated for vector reduction\n}// gang-private x updated for worker reduction\n}\n\n// gang-shared x undefined\n}// gang-shared x updated for gang reduction\n// x = I *J*K\n\tAt eachloop directive below, xis private and yis not private due to the data clauses on\ntheparallel directive Thus, each reduction updates xat the loop exit, but each reduction\nupdatesyby the end of the parallel region instead\nint x = 0, y = 0;\n#pragma acc parallel firstprivate(x) copy(y)\n{\n// gang-private x = 0; gang-shared y undefined\n#pragma acc loop seq reduction(+:x,y)\nfor (int i = 0; i < I; ++i) {\nx += 1; y += 2; // loop-private x and y modified\n}// gang-private x updated for trivial seq reduction\n// gang-private x = I; gang-shared y undefined\n#pragma acc loop worker reduction(+:x,y)\nfor (int i = 0; i < I; ++i) {\nx += 1; y += 2; // worker-private x and y modified\n}// gang-private x updated for worker reduction\n// gang-private x = 2 *I; gang-shared y undefined\n#pragma acc loop vector reduction(+:x,y)\nfor (int i = 0; i < I; ++i) {\nx += 1; y += 2; // vector-private x and y modified\n}// gang-private x updated for vector reduction\n// gang-private x = 3 *I; gang-shared y undefined\n}// gang-shared y updated for gang/seq/worker/vector reduc tions\n// x = 0; y = 3 *I*\n\tThe examples below are equivalent That is, the reduction clause on the combined con-\nstruct applies to the loop construct but implies a copy clause on the parallel construct Thus,\nxis not private at the loop directive, so the reduction updates xby the end of the parallel\nregion\nint x = 0;\n#pragma acc parallel loop worker reduction(+:x)\nfor (int i = 0; i < I; ++i) {\nx += 1; // worker-private x modified\n}// gang-shared x updated for gang/worker reduction\n// x = I\n\nint x = 0;\n#pragma acc parallel copy(x)\n{\n// gang-shared x undefined\n#pragma acc loop worker reduction(+:x)\nfor (int i = 0; i < I; ++i) {\nx += 1; // worker-private x modified\n}\n// gang-shared x undefined\n}// gang-shared x updated for gang/worker reduction\n// x = I\n\n\tIf the implementation treats the auto clause below as independent , the loop executes in\ngang-partitioned mode and thus examines every element of arr once to compute arr\u2019s max-\nimum However, if the implementation treats auto asseq, the gangs redundantly compute\narr\u2019s maximum, but the combined result is still arr\u2019s maximum Either way, because xis\nnot private at the loop directive, the reduction updates xby the end of the parallel region\nint x = 0;\nconst int *arr =/*array of I values */;\n#pragma acc parallel copy(x)\n{\n// gang-shared x undefined\n#pragma acc loop auto gang reduction(max:x)\nfor (int i = 0; i < I; ++i) {\n// complex loop body\nx = x < arr[i] ? arr[i] : x; // gang- or loop-private\n// x modified\n}\n// gang-shared x undefined\n}// gang-shared x updated for gang or gang/seq reduction\n// x = arr maximum\n\tThe following example is the same as the previous one except that the reductio n operator is\nnow+ While gang-partitioned mode sums the elements of arr once, gang-redundant mode\nsums them once per gang, producing a result many times arr\u2019s sum This example shows\nthat, for some reduction operators, combining auto ,gang , andreduction is typically\nnon-portable\nint x = 0;\nconst int *arr =/*array of I values */;\n#pragma acc parallel copy(x)\n{\n// gang-shared x undefined\n#pragma acc loop auto gang reduction(+:x)\nfor (int i = 0; i < I; ++i) {\n// complex loop body\nx += arr[i]; // gang or loop-private x modified\n}\n// gang-shared x undefined\n}// gang-shared x updated for gang or gang/seq reduction\n// x = arr sum possibly times number of gangs\n\tAt the following loop directive,xandzare private, so the loop reductions are not across\ngangs even though the loop is gang-partitioned Nevertheless, the reduction clause on the\nloop directive is important as the loop is also vector-partitioned These reduction s are only\npartial reductions relative to the full set of values computed by the loop, so th ereduction\nclause is needed on the parallel directive to reduce across gangs\nint x = 0, y = 0;\n#pragma acc parallel copy(x) reduction(+:x,y)\n{\nint z = 0;\n#pragma acc loop gang vector reduction(+:x,z)\nfor (int i = 0; i < I; ++i) {\nx += 1; z += 2; // vector-private x and z modified\n\n}// gang-private x and z updated for vector reduction\ny += z; // gang-private y modified\n}// gang-shared x and y updated for gang reduction\n// x = I; y = I *\n/trianglesolid /trianglesolid\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:loop construct reduction clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of loop construct reduction clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test loop construct reduction clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, loop construct reduction clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2911 reduction clause\nThereduction clause speci\ufb01es a reduction operator and one or more vars For each reduction\nvar, a private copy is created in the same manner as for a private clause on the loop construct,\nand initialized for that operator; see the table in Section 2515 reduction claus e After the loop, the\nvalues for each thread are combined using the speci\ufb01ed reduction opera tor, and the result combined\nwith the value of the original varand stored in the original var If the original varis not private,\nthis update occurs by the end of the compute region, and any access to the o riginal varis unde\ufb01ned\nwithin the compute region Otherwise, the update occurs at the end of the loop  If the reduction\nvaris an array or subarray, the reduction operation is logically equivalent to applying that reduction\noperation to each array element of the array or subarray individually I f the reduction varis a com-\nposite variable, the reduction operation is logically equivalent to applying tha t reduction operation\nto each member of the composite variable individually\nIf a variable is involved in a reduction that spans multiple nested loops where tw o or more of those\nloops have associated loop directives, a reduction clause containing that variable must appear\non each of those loop directives\nRestrictions\n\tAvarin areduction clause must be a scalar variable name, an aggregate variable name,\nan array element, or a subarray (refer to Section 271)\n\tReduction clauses on nested constructs for the same reduction varmust have the same reduc-\ntion operator\n\tEvery varin areduction clause appearing on an orphaned loop construct must be private\n\tThe restrictions for a reduction clause on a compute construct listed in in Section 25\nreduction clause also apply to a reduction clause on a loop construct\n\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in\nreduction clauses\n\tSee Section 262 Variables with Implicitly Determined Data Attributes for a restriction re-\nquiring certain loop reduction variables to have explicit data clauses on their parent compute\nconstructs\n\tAreduction clause may not appear on a loop directive that has a gang clause with a\ndim: argument whose value is greater than 1\n\tAreduction clause may not appear on a loop directive that has a gang clause and\nis within a compute construct that has a num_gangs clause with more than one explicit\nargument\n/triangledownsld /triangledownsld\nExamples\n\n\txis not private at the loop directive below, so its reduction normally updates xat the end\nof the parallel region, where gangs synchronize When possible, the imp lementation might\nchoose to partially update xat the loop exit instead, or fully if num_gangs(1) were added\nto theparallel directive However, portable applications cannot rely on such early up -\ndates, so accesses to xare unde\ufb01ned within the parallel region outside the loop\nint x = 0;\n#pragma acc parallel copy(x)\n{\n// gang-shared x undefined\n#pragma acc loop gang worker vector reduction(+:x)\nfor (int i = 0; i < I; ++i)\nx += 1; // vector-private x modified\n// gang-shared x undefined\n}// gang-shared x updated for gang/worker/vector reduction\n// x = I\n\txis private at each of the innermost two loop directives below, so each of their reductions\nupdatesxat the loop\u2019s exit However, xis not private at the outer loop directive, so its\nreduction updates xby the end of the parallel region instead\nint x = 0;\n#pragma acc parallel copy(x)\n{\n// gang-shared x undefined\n#pragma acc loop gang reduction(+:x)\nfor (int i = 0; i < I; ++i) {\n#pragma acc loop worker reduction(+:x)\nfor (int j = 0; j < J; ++j) {\n#pragma acc loop vector reduction(+:x)\nfor (int k = 0; k < K; ++k) {\nx += 1; // vector-private x modified\n}// worker-private x updated for vector reduction\n}// gang-private x updated for worker reduction\n}\n\n// gang-shared x undefined\n}// gang-shared x updated for gang reduction\n// x = I *J*K\n\tAt eachloop directive below, xis private and yis not private due to the data clauses on\ntheparallel directive Thus, each reduction updates xat the loop exit, but each reduction\nupdatesyby the end of the parallel region instead\nint x = 0, y = 0;\n#pragma acc parallel firstprivate(x) copy(y)\n{\n// gang-private x = 0; gang-shared y undefined\n#pragma acc loop seq reduction(+:x,y)\nfor (int i = 0; i < I; ++i) {\nx += 1; y += 2; // loop-private x and y modified\n}// gang-private x updated for trivial seq reduction\n// gang-private x = I; gang-shared y undefined\n#pragma acc loop worker reduction(+:x,y)\nfor (int i = 0; i < I; ++i) {\nx += 1; y += 2; // worker-private x and y modified\n}// gang-private x updated for worker reduction\n// gang-private x = 2 *I; gang-shared y undefined\n#pragma acc loop vector reduction(+:x,y)\nfor (int i = 0; i < I; ++i) {\nx += 1; y += 2; // vector-private x and y modified\n}// gang-private x updated for vector reduction\n// gang-private x = 3 *I; gang-shared y undefined\n}// gang-shared y updated for gang/seq/worker/vector reduc tions\n// x = 0; y = 3 *I*\n\tThe examples below are equivalent That is, the reduction clause on the combined con-\nstruct applies to the loop construct but implies a copy clause on the parallel construct Thus,\nxis not private at the loop directive, so the reduction updates xby the end of the parallel\nregion\nint x = 0;\n#pragma acc parallel loop worker reduction(+:x)\nfor (int i = 0; i < I; ++i) {\nx += 1; // worker-private x modified\n}// gang-shared x updated for gang/worker reduction\n// x = I\n\nint x = 0;\n#pragma acc parallel copy(x)\n{\n// gang-shared x undefined\n#pragma acc loop worker reduction(+:x)\nfor (int i = 0; i < I; ++i) {\nx += 1; // worker-private x modified\n}\n// gang-shared x undefined\n}// gang-shared x updated for gang/worker reduction\n// x = I\n\n\tIf the implementation treats the auto clause below as independent , the loop executes in\ngang-partitioned mode and thus examines every element of arr once to compute arr\u2019s max-\nimum However, if the implementation treats auto asseq, the gangs redundantly compute\narr\u2019s maximum, but the combined result is still arr\u2019s maximum Either way, because xis\nnot private at the loop directive, the reduction updates xby the end of the parallel region\nint x = 0;\nconst int *arr =/*array of I values */;\n#pragma acc parallel copy(x)\n{\n// gang-shared x undefined\n#pragma acc loop auto gang reduction(max:x)\nfor (int i = 0; i < I; ++i) {\n// complex loop body\nx = x < arr[i] ? arr[i] : x; // gang- or loop-private\n// x modified\n}\n// gang-shared x undefined\n}// gang-shared x updated for gang or gang/seq reduction\n// x = arr maximum\n\tThe following example is the same as the previous one except that the reductio n operator is\nnow+ While gang-partitioned mode sums the elements of arr once, gang-redundant mode\nsums them once per gang, producing a result many times arr\u2019s sum This example shows\nthat, for some reduction operators, combining auto ,gang , andreduction is typically\nnon-portable\nint x = 0;\nconst int *arr =/*array of I values */;\n#pragma acc parallel copy(x)\n{\n// gang-shared x undefined\n#pragma acc loop auto gang reduction(+:x)\nfor (int i = 0; i < I; ++i) {\n// complex loop body\nx += arr[i]; // gang or loop-private x modified\n}\n// gang-shared x undefined\n}// gang-shared x updated for gang or gang/seq reduction\n// x = arr sum possibly times number of gangs\n\tAt the following loop directive,xandzare private, so the loop reductions are not across\ngangs even though the loop is gang-partitioned Nevertheless, the reduction clause on the\nloop directive is important as the loop is also vector-partitioned These reduction s are only\npartial reductions relative to the full set of values computed by the loop, so th ereduction\nclause is needed on the parallel directive to reduce across gangs\nint x = 0, y = 0;\n#pragma acc parallel copy(x) reduction(+:x,y)\n{\nint z = 0;\n#pragma acc loop gang vector reduction(+:x,z)\nfor (int i = 0; i < I; ++i) {\nx += 1; z += 2; // vector-private x and z modified\n\n}// gang-private x and z updated for vector reduction\ny += z; // gang-private y modified\n}// gang-shared x and y updated for gang reduction\n// x = I; y = I *\n/trianglesolid /trianglesolid\n\nTemplate:\n\n#ifndef T1\n!T1:loop construct reduction clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of cache directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test cache directive in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, cache directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 210 Cache Directive\nSummary\nThecache directive may appear at the top of (inside of) a loop It speci\ufb01es array e lements or\nsubarrays that should be fetched into the highest level of the cache for the body of the loop\nSyntax\nIn C and C++, the syntax of the cache directive is\n#pragma acc cache( [readonly: ]var-list)new-line\nIn Fortran, the syntax of the cache directive is\n!$acc cache( [readonly: ]var-list)\nAvarin acache directive must be a single array element or a simple subarray In C and C++ ,\na simple subarray is an array name followed by an extended array range s peci\ufb01cation in brackets,\nwith start and length, such as\narr[ lower:length]\nwhere the lower bound is a constant, loop invariant, or the for loop variable plus or minus a\nconstant or loop invariant, and the length is a constant\nIn Fortran, a simple subarray is an array name followed by a comma-separa ted list of range speci\ufb01-\ncations in parentheses, with lower and upper bound subscripts, such as\narr( lower:upper,lower2:upper2)\nThe lower bounds must be constant, loop invariant, or the doloop variable plus or minus a constant\nor loop invariant; moreover the difference between the corresponding u pper and lower bounds must\nbe a constant\nIf the optional readonly modi\ufb01er appears, then the implementation may assume that the data\nreferenced by any varin that directive is never written to within the applicable region\nRestrictions\n\tIf an array element or subarray is listed in a cache directive, all references to that array\nduring execution of that loop iteration must not refer to elements of the array outside the\nindex range speci\ufb01ed in the cache directive\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in cache\ndirectives\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:cache directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of cache directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test cache directive in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, cache directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 210 Cache Directive\nSummary\nThecache directive may appear at the top of (inside of) a loop It speci\ufb01es array e lements or\nsubarrays that should be fetched into the highest level of the cache for the body of the loop\nSyntax\nIn C and C++, the syntax of the cache directive is\n#pragma acc cache( [readonly: ]var-list)new-line\nIn Fortran, the syntax of the cache directive is\n!$acc cache( [readonly: ]var-list)\nAvarin acache directive must be a single array element or a simple subarray In C and C++ ,\na simple subarray is an array name followed by an extended array range s peci\ufb01cation in brackets,\nwith start and length, such as\narr[ lower:length]\nwhere the lower bound is a constant, loop invariant, or the for loop variable plus or minus a\nconstant or loop invariant, and the length is a constant\nIn Fortran, a simple subarray is an array name followed by a comma-separa ted list of range speci\ufb01-\ncations in parentheses, with lower and upper bound subscripts, such as\narr( lower:upper,lower2:upper2)\nThe lower bounds must be constant, loop invariant, or the doloop variable plus or minus a constant\nor loop invariant; moreover the difference between the corresponding u pper and lower bounds must\nbe a constant\nIf the optional readonly modi\ufb01er appears, then the implementation may assume that the data\nreferenced by any varin that directive is never written to within the applicable region\nRestrictions\n\tIf an array element or subarray is listed in a cache directive, all references to that array\nduring execution of that loop iteration must not refer to elements of the array outside the\nindex range speci\ufb01ed in the cache directive\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in cache\ndirectives\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:cache directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of cache directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test cache directive in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, cache directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 210 Cache Directive\nSummary\nThecache directive may appear at the top of (inside of) a loop It speci\ufb01es array e lements or\nsubarrays that should be fetched into the highest level of the cache for the body of the loop\nSyntax\nIn C and C++, the syntax of the cache directive is\n#pragma acc cache( [readonly: ]var-list)new-line\nIn Fortran, the syntax of the cache directive is\n!$acc cache( [readonly: ]var-list)\nAvarin acache directive must be a single array element or a simple subarray In C and C++ ,\na simple subarray is an array name followed by an extended array range s peci\ufb01cation in brackets,\nwith start and length, such as\narr[ lower:length]\nwhere the lower bound is a constant, loop invariant, or the for loop variable plus or minus a\nconstant or loop invariant, and the length is a constant\nIn Fortran, a simple subarray is an array name followed by a comma-separa ted list of range speci\ufb01-\ncations in parentheses, with lower and upper bound subscripts, such as\narr( lower:upper,lower2:upper2)\nThe lower bounds must be constant, loop invariant, or the doloop variable plus or minus a constant\nor loop invariant; moreover the difference between the corresponding u pper and lower bounds must\nbe a constant\nIf the optional readonly modi\ufb01er appears, then the implementation may assume that the data\nreferenced by any varin that directive is never written to within the applicable region\nRestrictions\n\tIf an array element or subarray is listed in a cache directive, all references to that array\nduring execution of that loop iteration must not refer to elements of the array outside the\nindex range speci\ufb01ed in the cache directive\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in cache\ndirectives\n\nTemplate:\n\n#ifndef T1\n!T1:cache directive,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of combined constucts. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test combined constucts in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, combined constucts, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 211 Combined Constructs\n\nSummary\nThe combined OpenACC parallelloop ,serialloop , andkernelsloop constructs are\nshortcuts for specifying a loop construct nested immediately inside a parallel ,serial , or\nkernels construct The meaning is identical to explicitly specifying a parallel ,serial , or\nkernels construct containing a loop construct Any clause that is allowed on a parallel or\nloop construct is allowed on the parallelloop construct; any clause allowed on a serial or\nloop construct is allowed on a serialloop construct; and any clause allowed on a kernels\norloop construct is allowed on a kernelsloop construct\nSyntax\nIn C and C++, the syntax of the parallelloop construct is\n#pragma acc parallel loop [clause-list ]new-line\nfor loop\nIn Fortran, the syntax of the parallelloop construct is\n!$acc parallel loop [clause-list ]\ndo loop\n[!$acc end parallel loop ]\nThe associated structured block is the loop which must immediately follow the direc tive Any of\ntheparallel orloop clauses valid in a parallel region may appear\nIn C and C++, the syntax of the serialloop construct is\n#pragma acc serial loop [clause-list ]new-line\nfor loop\nIn Fortran, the syntax of the serialloop construct is\n!$acc serial loop [clause-list ]\ndo loop\n[!$acc end serial loop ]\nThe associated structured block is the loop which must immediately follow the direc tive Any of\ntheserial orloop clauses valid in a serial region may appear\nIn C and C++, the syntax of the kernelsloop construct is\n#pragma acc kernels loop [clause-list ]new-line\nfor loop\nIn Fortran, the syntax of the kernelsloop construct is\n!$acc kernels loop [clause-list ]\ndo loop\n[!$acc end kernels loop ]\nThe associated structured block is the loop which must immediately follow the direc tive Any of\nthekernels orloop clauses valid in a kernels region may appear\nAprivate orreduction clause on a combined construct is treated as if it appeared on the\nloop construct In addition, a reduction clause on a combined construct implies a copy clause\nas described in Section 262\n\nRestrictions\n\tThe restrictions for the parallel ,serial ,kernels , andloop constructs apply\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:combined constucts,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of combined constucts. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test combined constucts in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, combined constucts, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 211 Combined Constructs\n\nSummary\nThe combined OpenACC parallelloop ,serialloop , andkernelsloop constructs are\nshortcuts for specifying a loop construct nested immediately inside a parallel ,serial , or\nkernels construct The meaning is identical to explicitly specifying a parallel ,serial , or\nkernels construct containing a loop construct Any clause that is allowed on a parallel or\nloop construct is allowed on the parallelloop construct; any clause allowed on a serial or\nloop construct is allowed on a serialloop construct; and any clause allowed on a kernels\norloop construct is allowed on a kernelsloop construct\nSyntax\nIn C and C++, the syntax of the parallelloop construct is\n#pragma acc parallel loop [clause-list ]new-line\nfor loop\nIn Fortran, the syntax of the parallelloop construct is\n!$acc parallel loop [clause-list ]\ndo loop\n[!$acc end parallel loop ]\nThe associated structured block is the loop which must immediately follow the direc tive Any of\ntheparallel orloop clauses valid in a parallel region may appear\nIn C and C++, the syntax of the serialloop construct is\n#pragma acc serial loop [clause-list ]new-line\nfor loop\nIn Fortran, the syntax of the serialloop construct is\n!$acc serial loop [clause-list ]\ndo loop\n[!$acc end serial loop ]\nThe associated structured block is the loop which must immediately follow the direc tive Any of\ntheserial orloop clauses valid in a serial region may appear\nIn C and C++, the syntax of the kernelsloop construct is\n#pragma acc kernels loop [clause-list ]new-line\nfor loop\nIn Fortran, the syntax of the kernelsloop construct is\n!$acc kernels loop [clause-list ]\ndo loop\n[!$acc end kernels loop ]\nThe associated structured block is the loop which must immediately follow the direc tive Any of\nthekernels orloop clauses valid in a kernels region may appear\nAprivate orreduction clause on a combined construct is treated as if it appeared on the\nloop construct In addition, a reduction clause on a combined construct implies a copy clause\nas described in Section 262\n\nRestrictions\n\tThe restrictions for the parallel ,serial ,kernels , andloop constructs apply\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:combined constucts,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of combined constucts. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test combined constucts in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, combined constucts, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 211 Combined Constructs\n\nSummary\nThe combined OpenACC parallelloop ,serialloop , andkernelsloop constructs are\nshortcuts for specifying a loop construct nested immediately inside a parallel ,serial , or\nkernels construct The meaning is identical to explicitly specifying a parallel ,serial , or\nkernels construct containing a loop construct Any clause that is allowed on a parallel or\nloop construct is allowed on the parallelloop construct; any clause allowed on a serial or\nloop construct is allowed on a serialloop construct; and any clause allowed on a kernels\norloop construct is allowed on a kernelsloop construct\nSyntax\nIn C and C++, the syntax of the parallelloop construct is\n#pragma acc parallel loop [clause-list ]new-line\nfor loop\nIn Fortran, the syntax of the parallelloop construct is\n!$acc parallel loop [clause-list ]\ndo loop\n[!$acc end parallel loop ]\nThe associated structured block is the loop which must immediately follow the direc tive Any of\ntheparallel orloop clauses valid in a parallel region may appear\nIn C and C++, the syntax of the serialloop construct is\n#pragma acc serial loop [clause-list ]new-line\nfor loop\nIn Fortran, the syntax of the serialloop construct is\n!$acc serial loop [clause-list ]\ndo loop\n[!$acc end serial loop ]\nThe associated structured block is the loop which must immediately follow the direc tive Any of\ntheserial orloop clauses valid in a serial region may appear\nIn C and C++, the syntax of the kernelsloop construct is\n#pragma acc kernels loop [clause-list ]new-line\nfor loop\nIn Fortran, the syntax of the kernelsloop construct is\n!$acc kernels loop [clause-list ]\ndo loop\n[!$acc end kernels loop ]\nThe associated structured block is the loop which must immediately follow the direc tive Any of\nthekernels orloop clauses valid in a kernels region may appear\nAprivate orreduction clause on a combined construct is treated as if it appeared on the\nloop construct In addition, a reduction clause on a combined construct implies a copy clause\nas described in Section 262\n\nRestrictions\n\tThe restrictions for the parallel ,serial ,kernels , andloop constructs apply\n\nTemplate:\n\n#ifndef T1\n!T1:combined constucts,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of atomic construct. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test atomic construct in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, atomic construct, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 212 Atomic Construct\nSummary\nAnatomic construct ensures that a speci\ufb01c storage location is accessed and/or u pdated atomically,\npreventing simultaneous reading and writing by gangs, workers, and vec tor threads that could result\nin indeterminate values\nSyntax\nIn C and C++, the syntax of the atomic constructs is:\n#pragma acc atomic [atomic-clause ]new-line\nexpression-stmt\nor:\n#pragma acc atomic capture new-line\nstructured block\nWhere atomic-clause is one ofread ,write ,update , orcapture  The expression-stmt is an\nexpression statement with one of the following forms:\nIf the atomic-clause isread :\nv = x;\nIf the atomic-clause iswrite :\nx = expr;\nIf the atomic-clause isupdate or no clause appears:\nx++;\nx--;\n++x;\n--x;\nxbinop=expr;\nx = x binop expr ;\nx = expr binop x;\nIf the atomic-clause iscapture :\nv = x++;\nv = x--;\nv = ++x;\nv = --x;\nv = x binop=expr;\nv = x = x binop expr ;\nv = x = expr binop x;\nThestructured-block is a structured block with one of the following forms:\n\n{v = x; x binop=expr;}\n{xbinop=expr; v = x; }\n{v = x; x = x binop expr ;}\n{v = x; x = expr binop x;}\n{x = x binop expr ; v = x; }\n{x = expr binop x; v = x; }\n{v = x; x = expr;}\n{v = x; x++; }\n{v = x; ++x; }\n{++x; v = x; }\n{x++; v = x; }\n{v = x; x--; }\n{v = x; --x; }\n{--x; v = x; }\n{x--; v = x; }\nIn the preceding expressions:\n\txandv(as applicable) are both l-value expressions with scalar type\n\tDuring the execution of an atomic region, multiple syntactic occurrences of xmust designate\nthe same storage location\n\tNeither ofvandexpr (as applicable) may access the storage location designated by x\n\tNeither ofxandexpr (as applicable) may access the storage location designated by v\n\texpr is an expression with scalar type\n\tbinop is one of+,*,-,/,&,\u02c6,|,<<, or>>\n\tbinop ,binop=,++, and--are not overloaded operators\n\tThe expression xbinop expr must be mathematically equivalent to xbinop(expr) This\nrequirement is satis\ufb01ed if the operators in expr have precedence greater than binop , or by\nusing parentheses around expr or subexpressions of expr\n\tThe expression expr binop xmust be mathematically equivalent to (expr)binopx This\nrequirement is satis\ufb01ed if the operators in expr have precedence equal to or greater than binop ,\nor by using parentheses around expr or subexpressions of expr\n\tFor forms that allow multiple occurrences of x, the number of times that xis evaluated is\nunspeci\ufb01ed\nIn Fortran the syntax of the atomic constructs is:\n!$acc atomic read\ncapture-statement\n[!$acc end atomic ]\nor\n!$acc atomic write\nwrite-statement\n[!$acc end atomic ]\n\nor\n!$acc atomic [update ]\nupdate-statement\n[!$acc end atomic ]\nor\n!$acc atomic capture\nupdate-statement\ncapture-statement\n!$acc end atomic\nor\n!$acc atomic capture\ncapture-statement\nupdate-statement\n!$acc end atomic\nor\n!$acc atomic capture\ncapture-statement\nwrite-statement\n!$acc end atomic\nwhere write-statement has the following form (if atomic-clause iswrite orcapture ):\nx = expr\nwhere capture-statement has the following form (if atomic-clause iscapture orread ):\nv = x\nand where update-statement has one of the following forms (if atomic-clause isupdate ,capture ,\nor no clause appears):\nx = x operator expr\nx = expr operator x\nx = intrinsic procedure name( x, expr-list)\nx = intrinsic procedure name(expr-list, x )\nIn the preceding statements:\n\txandv(as applicable) are both scalar variables of intrinsic type\n\txmust not be an allocatable variable\n\tDuring the execution of an atomic region, multiple syntactic occurrences of xmust designate\nthe same storage location\n\tNone ofv,expr, and expr-list (as applicable) may access the same storage location as x\n\tNone ofx,expr, and expr-list (as applicable) may access the same storage location as v\n\texpr is a scalar expression\n\n\texpr-list is a comma-separated, non-empty list of scalar expressions If intrinsic procedure name\nrefers toiand ,ior, orieor , exactly one expression must appear in expr-list \n\tintrinsic procedure name is one ofmax,min,iand ,ior, orieor operator is one of+,\n*,-,/,and ,or ,eqv , orneqv \n\tThe expression xoperator expr must be mathematically equivalent to xoperator(expr)\nThis requirement is satis\ufb01ed if the operators in expr have precedence greater than operator ,\nor by using parentheses around expr or subexpressions of expr\n\tThe expression expr operator xmust be mathematically equivalent to (expr)operatorx\nThis requirement is satis\ufb01ed if the operators in expr have precedence equal to or greater than\noperator , or by using parentheses around expr or subexpressions of expr\n\tintrinsic procedure name must refer to the intrinsic procedure name and not to other program\nentities\n\toperator must refer to the intrinsic operator and not to a user-de\ufb01ned operator A ll assign-\nments must be intrinsic assignments\n\tFor forms that allow multiple occurrences of x, the number of times that xis evaluated is\nunspeci\ufb01ed\nAnatomic construct with the read clause forces an atomic read of the location designated by x\nAnatomic construct with the write clause forces an atomic write of the location designated by\nx\nAnatomic construct with the update clause forces an atomic update of the location designated\nbyxusing the designated operator or intrinsic Note that when no clause appea rs, the semantics\nare equivalent to atomic update  Only the read and write of the location designated by xare\nperformed mutually atomically The evaluation of expr orexpr-list need not be atomic with respect\nto the read or write of the location designated by x\nAnatomic construct with the capture clause forces an atomic update of the location designated\nbyxusing the designated operator or intrinsic while also capturing the original or \ufb01nal value of\nthe location designated by xwith respect to the atomic update The original or \ufb01nal value of the\nlocation designated by xis written into the location designated by vdepending on the form of the\natomic construct structured block or statements following the usual language sema ntics Only\nthe read and write of the location designated by xare performed mutually atomically Neither the\nevaluation of expr orexpr-list , nor the write to the location designated by v,need to be atomic with\nrespect to the read or write of the location designated by x\nFor all forms of the atomic construct, any combination of two or more of these atomic constructs\nenforces mutually exclusive access to the locations designated by x To avoid race conditions, all\naccesses of the locations designated by xthat could potentially occur in parallel must be protected\nwith anatomic construct\nAtomic regions do not guarantee exclusive access with respect to any ac cesses outside of atomic re-\ngions to the same storage location xeven if those accesses occur during the execution of a reduction\nclause\nIf the storage location designated by xis not size-aligned (that is, if the byte alignment of xis not a\nmultiple of the size of x), then the behavior of the atomic region is implementation-de\ufb01ned\n\nRestrictions\n\tAll atomic accesses to the storage locations designated by xthroughout the program are\nrequired to have the same type and type parameters\n\tStorage locations designated by xmust be less than or equal in size to the largest available\nnative atomic operator width\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:atomic construct,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of atomic construct. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test atomic construct in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, atomic construct, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 212 Atomic Construct\nSummary\nAnatomic construct ensures that a speci\ufb01c storage location is accessed and/or u pdated atomically,\npreventing simultaneous reading and writing by gangs, workers, and vec tor threads that could result\nin indeterminate values\nSyntax\nIn C and C++, the syntax of the atomic constructs is:\n#pragma acc atomic [atomic-clause ]new-line\nexpression-stmt\nor:\n#pragma acc atomic capture new-line\nstructured block\nWhere atomic-clause is one ofread ,write ,update , orcapture  The expression-stmt is an\nexpression statement with one of the following forms:\nIf the atomic-clause isread :\nv = x;\nIf the atomic-clause iswrite :\nx = expr;\nIf the atomic-clause isupdate or no clause appears:\nx++;\nx--;\n++x;\n--x;\nxbinop=expr;\nx = x binop expr ;\nx = expr binop x;\nIf the atomic-clause iscapture :\nv = x++;\nv = x--;\nv = ++x;\nv = --x;\nv = x binop=expr;\nv = x = x binop expr ;\nv = x = expr binop x;\nThestructured-block is a structured block with one of the following forms:\n\n{v = x; x binop=expr;}\n{xbinop=expr; v = x; }\n{v = x; x = x binop expr ;}\n{v = x; x = expr binop x;}\n{x = x binop expr ; v = x; }\n{x = expr binop x; v = x; }\n{v = x; x = expr;}\n{v = x; x++; }\n{v = x; ++x; }\n{++x; v = x; }\n{x++; v = x; }\n{v = x; x--; }\n{v = x; --x; }\n{--x; v = x; }\n{x--; v = x; }\nIn the preceding expressions:\n\txandv(as applicable) are both l-value expressions with scalar type\n\tDuring the execution of an atomic region, multiple syntactic occurrences of xmust designate\nthe same storage location\n\tNeither ofvandexpr (as applicable) may access the storage location designated by x\n\tNeither ofxandexpr (as applicable) may access the storage location designated by v\n\texpr is an expression with scalar type\n\tbinop is one of+,*,-,/,&,\u02c6,|,<<, or>>\n\tbinop ,binop=,++, and--are not overloaded operators\n\tThe expression xbinop expr must be mathematically equivalent to xbinop(expr) This\nrequirement is satis\ufb01ed if the operators in expr have precedence greater than binop , or by\nusing parentheses around expr or subexpressions of expr\n\tThe expression expr binop xmust be mathematically equivalent to (expr)binopx This\nrequirement is satis\ufb01ed if the operators in expr have precedence equal to or greater than binop ,\nor by using parentheses around expr or subexpressions of expr\n\tFor forms that allow multiple occurrences of x, the number of times that xis evaluated is\nunspeci\ufb01ed\nIn Fortran the syntax of the atomic constructs is:\n!$acc atomic read\ncapture-statement\n[!$acc end atomic ]\nor\n!$acc atomic write\nwrite-statement\n[!$acc end atomic ]\n\nor\n!$acc atomic [update ]\nupdate-statement\n[!$acc end atomic ]\nor\n!$acc atomic capture\nupdate-statement\ncapture-statement\n!$acc end atomic\nor\n!$acc atomic capture\ncapture-statement\nupdate-statement\n!$acc end atomic\nor\n!$acc atomic capture\ncapture-statement\nwrite-statement\n!$acc end atomic\nwhere write-statement has the following form (if atomic-clause iswrite orcapture ):\nx = expr\nwhere capture-statement has the following form (if atomic-clause iscapture orread ):\nv = x\nand where update-statement has one of the following forms (if atomic-clause isupdate ,capture ,\nor no clause appears):\nx = x operator expr\nx = expr operator x\nx = intrinsic procedure name( x, expr-list)\nx = intrinsic procedure name(expr-list, x )\nIn the preceding statements:\n\txandv(as applicable) are both scalar variables of intrinsic type\n\txmust not be an allocatable variable\n\tDuring the execution of an atomic region, multiple syntactic occurrences of xmust designate\nthe same storage location\n\tNone ofv,expr, and expr-list (as applicable) may access the same storage location as x\n\tNone ofx,expr, and expr-list (as applicable) may access the same storage location as v\n\texpr is a scalar expression\n\n\texpr-list is a comma-separated, non-empty list of scalar expressions If intrinsic procedure name\nrefers toiand ,ior, orieor , exactly one expression must appear in expr-list \n\tintrinsic procedure name is one ofmax,min,iand ,ior, orieor operator is one of+,\n*,-,/,and ,or ,eqv , orneqv \n\tThe expression xoperator expr must be mathematically equivalent to xoperator(expr)\nThis requirement is satis\ufb01ed if the operators in expr have precedence greater than operator ,\nor by using parentheses around expr or subexpressions of expr\n\tThe expression expr operator xmust be mathematically equivalent to (expr)operatorx\nThis requirement is satis\ufb01ed if the operators in expr have precedence equal to or greater than\noperator , or by using parentheses around expr or subexpressions of expr\n\tintrinsic procedure name must refer to the intrinsic procedure name and not to other program\nentities\n\toperator must refer to the intrinsic operator and not to a user-de\ufb01ned operator A ll assign-\nments must be intrinsic assignments\n\tFor forms that allow multiple occurrences of x, the number of times that xis evaluated is\nunspeci\ufb01ed\nAnatomic construct with the read clause forces an atomic read of the location designated by x\nAnatomic construct with the write clause forces an atomic write of the location designated by\nx\nAnatomic construct with the update clause forces an atomic update of the location designated\nbyxusing the designated operator or intrinsic Note that when no clause appea rs, the semantics\nare equivalent to atomic update  Only the read and write of the location designated by xare\nperformed mutually atomically The evaluation of expr orexpr-list need not be atomic with respect\nto the read or write of the location designated by x\nAnatomic construct with the capture clause forces an atomic update of the location designated\nbyxusing the designated operator or intrinsic while also capturing the original or \ufb01nal value of\nthe location designated by xwith respect to the atomic update The original or \ufb01nal value of the\nlocation designated by xis written into the location designated by vdepending on the form of the\natomic construct structured block or statements following the usual language sema ntics Only\nthe read and write of the location designated by xare performed mutually atomically Neither the\nevaluation of expr orexpr-list , nor the write to the location designated by v,need to be atomic with\nrespect to the read or write of the location designated by x\nFor all forms of the atomic construct, any combination of two or more of these atomic constructs\nenforces mutually exclusive access to the locations designated by x To avoid race conditions, all\naccesses of the locations designated by xthat could potentially occur in parallel must be protected\nwith anatomic construct\nAtomic regions do not guarantee exclusive access with respect to any ac cesses outside of atomic re-\ngions to the same storage location xeven if those accesses occur during the execution of a reduction\nclause\nIf the storage location designated by xis not size-aligned (that is, if the byte alignment of xis not a\nmultiple of the size of x), then the behavior of the atomic region is implementation-de\ufb01ned\n\nRestrictions\n\tAll atomic accesses to the storage locations designated by xthroughout the program are\nrequired to have the same type and type parameters\n\tStorage locations designated by xmust be less than or equal in size to the largest available\nnative atomic operator width\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:atomic construct,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of atomic construct. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test atomic construct in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, atomic construct, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 212 Atomic Construct\nSummary\nAnatomic construct ensures that a speci\ufb01c storage location is accessed and/or u pdated atomically,\npreventing simultaneous reading and writing by gangs, workers, and vec tor threads that could result\nin indeterminate values\nSyntax\nIn C and C++, the syntax of the atomic constructs is:\n#pragma acc atomic [atomic-clause ]new-line\nexpression-stmt\nor:\n#pragma acc atomic capture new-line\nstructured block\nWhere atomic-clause is one ofread ,write ,update , orcapture  The expression-stmt is an\nexpression statement with one of the following forms:\nIf the atomic-clause isread :\nv = x;\nIf the atomic-clause iswrite :\nx = expr;\nIf the atomic-clause isupdate or no clause appears:\nx++;\nx--;\n++x;\n--x;\nxbinop=expr;\nx = x binop expr ;\nx = expr binop x;\nIf the atomic-clause iscapture :\nv = x++;\nv = x--;\nv = ++x;\nv = --x;\nv = x binop=expr;\nv = x = x binop expr ;\nv = x = expr binop x;\nThestructured-block is a structured block with one of the following forms:\n\n{v = x; x binop=expr;}\n{xbinop=expr; v = x; }\n{v = x; x = x binop expr ;}\n{v = x; x = expr binop x;}\n{x = x binop expr ; v = x; }\n{x = expr binop x; v = x; }\n{v = x; x = expr;}\n{v = x; x++; }\n{v = x; ++x; }\n{++x; v = x; }\n{x++; v = x; }\n{v = x; x--; }\n{v = x; --x; }\n{--x; v = x; }\n{x--; v = x; }\nIn the preceding expressions:\n\txandv(as applicable) are both l-value expressions with scalar type\n\tDuring the execution of an atomic region, multiple syntactic occurrences of xmust designate\nthe same storage location\n\tNeither ofvandexpr (as applicable) may access the storage location designated by x\n\tNeither ofxandexpr (as applicable) may access the storage location designated by v\n\texpr is an expression with scalar type\n\tbinop is one of+,*,-,/,&,\u02c6,|,<<, or>>\n\tbinop ,binop=,++, and--are not overloaded operators\n\tThe expression xbinop expr must be mathematically equivalent to xbinop(expr) This\nrequirement is satis\ufb01ed if the operators in expr have precedence greater than binop , or by\nusing parentheses around expr or subexpressions of expr\n\tThe expression expr binop xmust be mathematically equivalent to (expr)binopx This\nrequirement is satis\ufb01ed if the operators in expr have precedence equal to or greater than binop ,\nor by using parentheses around expr or subexpressions of expr\n\tFor forms that allow multiple occurrences of x, the number of times that xis evaluated is\nunspeci\ufb01ed\nIn Fortran the syntax of the atomic constructs is:\n!$acc atomic read\ncapture-statement\n[!$acc end atomic ]\nor\n!$acc atomic write\nwrite-statement\n[!$acc end atomic ]\n\nor\n!$acc atomic [update ]\nupdate-statement\n[!$acc end atomic ]\nor\n!$acc atomic capture\nupdate-statement\ncapture-statement\n!$acc end atomic\nor\n!$acc atomic capture\ncapture-statement\nupdate-statement\n!$acc end atomic\nor\n!$acc atomic capture\ncapture-statement\nwrite-statement\n!$acc end atomic\nwhere write-statement has the following form (if atomic-clause iswrite orcapture ):\nx = expr\nwhere capture-statement has the following form (if atomic-clause iscapture orread ):\nv = x\nand where update-statement has one of the following forms (if atomic-clause isupdate ,capture ,\nor no clause appears):\nx = x operator expr\nx = expr operator x\nx = intrinsic procedure name( x, expr-list)\nx = intrinsic procedure name(expr-list, x )\nIn the preceding statements:\n\txandv(as applicable) are both scalar variables of intrinsic type\n\txmust not be an allocatable variable\n\tDuring the execution of an atomic region, multiple syntactic occurrences of xmust designate\nthe same storage location\n\tNone ofv,expr, and expr-list (as applicable) may access the same storage location as x\n\tNone ofx,expr, and expr-list (as applicable) may access the same storage location as v\n\texpr is a scalar expression\n\n\texpr-list is a comma-separated, non-empty list of scalar expressions If intrinsic procedure name\nrefers toiand ,ior, orieor , exactly one expression must appear in expr-list \n\tintrinsic procedure name is one ofmax,min,iand ,ior, orieor operator is one of+,\n*,-,/,and ,or ,eqv , orneqv \n\tThe expression xoperator expr must be mathematically equivalent to xoperator(expr)\nThis requirement is satis\ufb01ed if the operators in expr have precedence greater than operator ,\nor by using parentheses around expr or subexpressions of expr\n\tThe expression expr operator xmust be mathematically equivalent to (expr)operatorx\nThis requirement is satis\ufb01ed if the operators in expr have precedence equal to or greater than\noperator , or by using parentheses around expr or subexpressions of expr\n\tintrinsic procedure name must refer to the intrinsic procedure name and not to other program\nentities\n\toperator must refer to the intrinsic operator and not to a user-de\ufb01ned operator A ll assign-\nments must be intrinsic assignments\n\tFor forms that allow multiple occurrences of x, the number of times that xis evaluated is\nunspeci\ufb01ed\nAnatomic construct with the read clause forces an atomic read of the location designated by x\nAnatomic construct with the write clause forces an atomic write of the location designated by\nx\nAnatomic construct with the update clause forces an atomic update of the location designated\nbyxusing the designated operator or intrinsic Note that when no clause appea rs, the semantics\nare equivalent to atomic update  Only the read and write of the location designated by xare\nperformed mutually atomically The evaluation of expr orexpr-list need not be atomic with respect\nto the read or write of the location designated by x\nAnatomic construct with the capture clause forces an atomic update of the location designated\nbyxusing the designated operator or intrinsic while also capturing the original or \ufb01nal value of\nthe location designated by xwith respect to the atomic update The original or \ufb01nal value of the\nlocation designated by xis written into the location designated by vdepending on the form of the\natomic construct structured block or statements following the usual language sema ntics Only\nthe read and write of the location designated by xare performed mutually atomically Neither the\nevaluation of expr orexpr-list , nor the write to the location designated by v,need to be atomic with\nrespect to the read or write of the location designated by x\nFor all forms of the atomic construct, any combination of two or more of these atomic constructs\nenforces mutually exclusive access to the locations designated by x To avoid race conditions, all\naccesses of the locations designated by xthat could potentially occur in parallel must be protected\nwith anatomic construct\nAtomic regions do not guarantee exclusive access with respect to any ac cesses outside of atomic re-\ngions to the same storage location xeven if those accesses occur during the execution of a reduction\nclause\nIf the storage location designated by xis not size-aligned (that is, if the byte alignment of xis not a\nmultiple of the size of x), then the behavior of the atomic region is implementation-de\ufb01ned\n\nRestrictions\n\tAll atomic accesses to the storage locations designated by xthroughout the program are\nrequired to have the same type and type parameters\n\tStorage locations designated by xmust be less than or equal in size to the largest available\nnative atomic operator width\n\nTemplate:\n\n#ifndef T1\n!T1:atomic construct,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of declare directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test declare directive in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, declare directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 213 Declare Directive\nSummary\nAdeclare directive is used in the declaration section of a Fortran subroutine, functio n, block\nconstruct, or module, or following a variable declaration in C or C++ It can specify that a varis to\nbe allocated in device memory for the duration of the implicit data region of a func tion, subroutine\nor program, and specify whether the data values are to be transferred f rom local memory to device\nmemory upon entry to the implicit data region, and from device memory to local memor y upon exit\nfrom the implicit data region These directives create a visible device copy o f the var\nSyntax\nIn C and C++, the syntax of the declare directive is:\n#pragma acc declare clause-list new-line\nIn Fortran the syntax of the declare directive is:\n!$acc declare clause-list\nwhere clause is one of the following:\ncopy( var-list)\ncopyin( [readonly: ]var-list)\ncopyout( var-list)\ncreate( var-list)\npresent( var-list)\ndeviceptr( var-list)\ndevice_resident( var-list)\nlink( var-list)\nThe associated region is the implicit region associated with the function, subro utine, or program in\nwhich the directive appears If the directive appears in the declaration s ection of a Fortran module\nsubprogram, for a Fortran common block , or in a C or C++ global or namespace scope, the associated\nregion is the implicit region for the whole program The copy ,copyin ,copyout ,present ,\nanddeviceptr data clauses are described in Section 27 Data Clauses\nRestrictions\n\tAdeclare directive must be in the same scope as the declaration of any varthat appears\nin the clauses of the directive or any scope within a C or C++ function or For tran function,\nsubroutine, or program\n\tAt least one clause must appear on a declare directive\n\tAvarin adeclare declare must be a variable or array name, or a Fortran common block\nname between slashes\n\n\tAvarmay appear at most once in all the clauses of declare directives for a function,\nsubroutine, program, or module\n\tIn Fortran, assumed-size dummy arrays may not appear in a declare directive\n\tIn Fortran, pointer arrays may appear, but pointer association is not pr eserved in device mem-\nory\n\tIn a Fortran module declaration section, only create ,copyin ,device_resident , and\nlink clauses are allowed\n\tIn C or C++ global or namespace scope, only create ,copyin ,deviceptr ,\ndevice_resident andlink clauses are allowed\n\tC and C++ extern variables may only appear in create ,copyin ,deviceptr ,\ndevice_resident andlink clauses on a declare directive\n\tIn C or C++, the link clause must appear at global or namespace scope or the arguments\nmust be extern variables In Fortran, the link clause must appear in a module declaration\nsection, or the arguments must be common block names enclosed in slashes\n\tIn C or C++, a longjmp call in the region must return to a setjmp call within the region\n\tIn C++, an exception thrown in the region must be handled within the region\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional d ummy arguments\nin data clauses, including device_resident clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:declare directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of declare directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test declare directive in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, declare directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 213 Declare Directive\nSummary\nAdeclare directive is used in the declaration section of a Fortran subroutine, functio n, block\nconstruct, or module, or following a variable declaration in C or C++ It can specify that a varis to\nbe allocated in device memory for the duration of the implicit data region of a func tion, subroutine\nor program, and specify whether the data values are to be transferred f rom local memory to device\nmemory upon entry to the implicit data region, and from device memory to local memor y upon exit\nfrom the implicit data region These directives create a visible device copy o f the var\nSyntax\nIn C and C++, the syntax of the declare directive is:\n#pragma acc declare clause-list new-line\nIn Fortran the syntax of the declare directive is:\n!$acc declare clause-list\nwhere clause is one of the following:\ncopy( var-list)\ncopyin( [readonly: ]var-list)\ncopyout( var-list)\ncreate( var-list)\npresent( var-list)\ndeviceptr( var-list)\ndevice_resident( var-list)\nlink( var-list)\nThe associated region is the implicit region associated with the function, subro utine, or program in\nwhich the directive appears If the directive appears in the declaration s ection of a Fortran module\nsubprogram, for a Fortran common block , or in a C or C++ global or namespace scope, the associated\nregion is the implicit region for the whole program The copy ,copyin ,copyout ,present ,\nanddeviceptr data clauses are described in Section 27 Data Clauses\nRestrictions\n\tAdeclare directive must be in the same scope as the declaration of any varthat appears\nin the clauses of the directive or any scope within a C or C++ function or For tran function,\nsubroutine, or program\n\tAt least one clause must appear on a declare directive\n\tAvarin adeclare declare must be a variable or array name, or a Fortran common block\nname between slashes\n\n\tAvarmay appear at most once in all the clauses of declare directives for a function,\nsubroutine, program, or module\n\tIn Fortran, assumed-size dummy arrays may not appear in a declare directive\n\tIn Fortran, pointer arrays may appear, but pointer association is not pr eserved in device mem-\nory\n\tIn a Fortran module declaration section, only create ,copyin ,device_resident , and\nlink clauses are allowed\n\tIn C or C++ global or namespace scope, only create ,copyin ,deviceptr ,\ndevice_resident andlink clauses are allowed\n\tC and C++ extern variables may only appear in create ,copyin ,deviceptr ,\ndevice_resident andlink clauses on a declare directive\n\tIn C or C++, the link clause must appear at global or namespace scope or the arguments\nmust be extern variables In Fortran, the link clause must appear in a module declaration\nsection, or the arguments must be common block names enclosed in slashes\n\tIn C or C++, a longjmp call in the region must return to a setjmp call within the region\n\tIn C++, an exception thrown in the region must be handled within the region\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional d ummy arguments\nin data clauses, including device_resident clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:declare directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of declare directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test declare directive in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, declare directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 213 Declare Directive\nSummary\nAdeclare directive is used in the declaration section of a Fortran subroutine, functio n, block\nconstruct, or module, or following a variable declaration in C or C++ It can specify that a varis to\nbe allocated in device memory for the duration of the implicit data region of a func tion, subroutine\nor program, and specify whether the data values are to be transferred f rom local memory to device\nmemory upon entry to the implicit data region, and from device memory to local memor y upon exit\nfrom the implicit data region These directives create a visible device copy o f the var\nSyntax\nIn C and C++, the syntax of the declare directive is:\n#pragma acc declare clause-list new-line\nIn Fortran the syntax of the declare directive is:\n!$acc declare clause-list\nwhere clause is one of the following:\ncopy( var-list)\ncopyin( [readonly: ]var-list)\ncopyout( var-list)\ncreate( var-list)\npresent( var-list)\ndeviceptr( var-list)\ndevice_resident( var-list)\nlink( var-list)\nThe associated region is the implicit region associated with the function, subro utine, or program in\nwhich the directive appears If the directive appears in the declaration s ection of a Fortran module\nsubprogram, for a Fortran common block , or in a C or C++ global or namespace scope, the associated\nregion is the implicit region for the whole program The copy ,copyin ,copyout ,present ,\nanddeviceptr data clauses are described in Section 27 Data Clauses\nRestrictions\n\tAdeclare directive must be in the same scope as the declaration of any varthat appears\nin the clauses of the directive or any scope within a C or C++ function or For tran function,\nsubroutine, or program\n\tAt least one clause must appear on a declare directive\n\tAvarin adeclare declare must be a variable or array name, or a Fortran common block\nname between slashes\n\n\tAvarmay appear at most once in all the clauses of declare directives for a function,\nsubroutine, program, or module\n\tIn Fortran, assumed-size dummy arrays may not appear in a declare directive\n\tIn Fortran, pointer arrays may appear, but pointer association is not pr eserved in device mem-\nory\n\tIn a Fortran module declaration section, only create ,copyin ,device_resident , and\nlink clauses are allowed\n\tIn C or C++ global or namespace scope, only create ,copyin ,deviceptr ,\ndevice_resident andlink clauses are allowed\n\tC and C++ extern variables may only appear in create ,copyin ,deviceptr ,\ndevice_resident andlink clauses on a declare directive\n\tIn C or C++, the link clause must appear at global or namespace scope or the arguments\nmust be extern variables In Fortran, the link clause must appear in a module declaration\nsection, or the arguments must be common block names enclosed in slashes\n\tIn C or C++, a longjmp call in the region must return to a setjmp call within the region\n\tIn C++, an exception thrown in the region must be handled within the region\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional d ummy arguments\nin data clauses, including device_resident clauses\n\nTemplate:\n\n#ifndef T1\n!T1:declare directive,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of declare directive device_resident clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test declare directive device_resident clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, declare directive device_resident clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2131 device resident clause\nSummary\nThedevice_resident clause speci\ufb01es that the memory for the named variables should be\nallocated in the current device memory and not in local memory The host may n ot be able to access\nvariables in a device_resident clause The accelerator data lifetime of global variables or\ncommon blocks that appear in a device_resident clause is the entire execution of the program\nIn Fortran, if the variable has the Fortran allocatable attribute, the memory for the variable will\nbe allocated in and deallocated from the current device memory when the hos t thread executes\nanallocate ordeallocate statement for that variable, if the current device is a non-shared\nmemory device If the variable has the Fortran pointer attribute, it may be allocated or deallocated\nby the host in the current device memory, or may appear on the left hand sid e of a pointer assignment\nstatement, if the right hand side variable itself appears in a device_resident clause\nIn Fortran, the argument to a device_resident clause may be a common block name enclosed\nin slashes; in this case, all declarations of the common block must have a matchin g\ndevice_resident clause In this case, the common block will be statically allocated in de-\nvice memory, and not in local memory The common block will be available to accelerator routines;\nsee Section 215 Procedure Calls in Compute Regions\nIn a Fortran module declaration section, a varin adevice_resident clause will be available to\naccelerator subprograms\nIn C or C++ global scope, a varin adevice_resident clause will be available to accelerator\nroutines A C or C++ extern variable may appear in a device_resident clause only if the\n\nactual declaration and all extern declarations are also followed by device_resident clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:declare directive device_resident clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of declare directive device_resident clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test declare directive device_resident clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, declare directive device_resident clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2131 device resident clause\nSummary\nThedevice_resident clause speci\ufb01es that the memory for the named variables should be\nallocated in the current device memory and not in local memory The host may n ot be able to access\nvariables in a device_resident clause The accelerator data lifetime of global variables or\ncommon blocks that appear in a device_resident clause is the entire execution of the program\nIn Fortran, if the variable has the Fortran allocatable attribute, the memory for the variable will\nbe allocated in and deallocated from the current device memory when the hos t thread executes\nanallocate ordeallocate statement for that variable, if the current device is a non-shared\nmemory device If the variable has the Fortran pointer attribute, it may be allocated or deallocated\nby the host in the current device memory, or may appear on the left hand sid e of a pointer assignment\nstatement, if the right hand side variable itself appears in a device_resident clause\nIn Fortran, the argument to a device_resident clause may be a common block name enclosed\nin slashes; in this case, all declarations of the common block must have a matchin g\ndevice_resident clause In this case, the common block will be statically allocated in de-\nvice memory, and not in local memory The common block will be available to accelerator routines;\nsee Section 215 Procedure Calls in Compute Regions\nIn a Fortran module declaration section, a varin adevice_resident clause will be available to\naccelerator subprograms\nIn C or C++ global scope, a varin adevice_resident clause will be available to accelerator\nroutines A C or C++ extern variable may appear in a device_resident clause only if the\n\nactual declaration and all extern declarations are also followed by device_resident clauses\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:declare directive device_resident clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of declare directive device_resident clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test declare directive device_resident clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, declare directive device_resident clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2131 device resident clause\nSummary\nThedevice_resident clause speci\ufb01es that the memory for the named variables should be\nallocated in the current device memory and not in local memory The host may n ot be able to access\nvariables in a device_resident clause The accelerator data lifetime of global variables or\ncommon blocks that appear in a device_resident clause is the entire execution of the program\nIn Fortran, if the variable has the Fortran allocatable attribute, the memory for the variable will\nbe allocated in and deallocated from the current device memory when the hos t thread executes\nanallocate ordeallocate statement for that variable, if the current device is a non-shared\nmemory device If the variable has the Fortran pointer attribute, it may be allocated or deallocated\nby the host in the current device memory, or may appear on the left hand sid e of a pointer assignment\nstatement, if the right hand side variable itself appears in a device_resident clause\nIn Fortran, the argument to a device_resident clause may be a common block name enclosed\nin slashes; in this case, all declarations of the common block must have a matchin g\ndevice_resident clause In this case, the common block will be statically allocated in de-\nvice memory, and not in local memory The common block will be available to accelerator routines;\nsee Section 215 Procedure Calls in Compute Regions\nIn a Fortran module declaration section, a varin adevice_resident clause will be available to\naccelerator subprograms\nIn C or C++ global scope, a varin adevice_resident clause will be available to accelerator\nroutines A C or C++ extern variable may appear in a device_resident clause only if the\n\nactual declaration and all extern declarations are also followed by device_resident clauses\n\nTemplate:\n\n#ifndef T1\n!T1:declare directive device_resident clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of declare directive create clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test declare directive create clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, declare directive create clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2132 create clause\nFor data in shared memory, no action is taken\nFor data not in shared memory, the create clause on a declare directive behaves as follows,\nfor each varinvar-list :\n\tAt entry to an implicit data region where the declare directive appears:\n\t\tIfvaris present, a present increment action with the structured reference counter is\nperformed If varis a pointer reference, an attach action is performed\n\t\tOtherwise, a create action with the structured reference counter is performed If varis\na pointer reference, an attach action is performed\n\tAt exit from an implicit data region where the declare directive appears:\n\t\tIf the structured reference counter for varis zero, no action is taken\n\t\tOtherwise, a present decrement action with the structured reference counter is per-\nformed If varis a pointer reference, a detach action is performed If both structured\nand dynamic reference counters are zero, a delete action is performed\nIf thedeclare directive appears in a global context, then the data in var-list is statically allocated\nin device memory and the structured reference counter is set to one\nIn Fortran, if a variable varinvar-list has the Fortran allocatable orpointer attribute, then:\n\tAnallocate statement for varwill allocate memory in both local memory as well as in the\ncurrent device memory, for a non-shared memory device, and the dynamic reference counter\nwill be set to one\n\tAdeallocate statement for varwill deallocate memory from both local memory as well\nas the current device memory, for a non-shared memory device, and the d ynamic reference\ncounter will be set to zero If the structured reference counter is not z ero, a runtime error is\nissued\nIn Fortran, if a variable varinvar-list has the Fortran pointer attribute, then it may appear on the\nleft hand side of a pointer assignment statement, if the right hand side variab le itself appears in a\ncreate clause\nErrors\n\tIn Fortran, an acc_error_present error is issued at a deallocate statement if the struc-\ntured reference counter is not zero\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:declare directive create clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of declare directive create clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test declare directive create clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, declare directive create clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2132 create clause\nFor data in shared memory, no action is taken\nFor data not in shared memory, the create clause on a declare directive behaves as follows,\nfor each varinvar-list :\n\tAt entry to an implicit data region where the declare directive appears:\n\t\tIfvaris present, a present increment action with the structured reference counter is\nperformed If varis a pointer reference, an attach action is performed\n\t\tOtherwise, a create action with the structured reference counter is performed If varis\na pointer reference, an attach action is performed\n\tAt exit from an implicit data region where the declare directive appears:\n\t\tIf the structured reference counter for varis zero, no action is taken\n\t\tOtherwise, a present decrement action with the structured reference counter is per-\nformed If varis a pointer reference, a detach action is performed If both structured\nand dynamic reference counters are zero, a delete action is performed\nIf thedeclare directive appears in a global context, then the data in var-list is statically allocated\nin device memory and the structured reference counter is set to one\nIn Fortran, if a variable varinvar-list has the Fortran allocatable orpointer attribute, then:\n\tAnallocate statement for varwill allocate memory in both local memory as well as in the\ncurrent device memory, for a non-shared memory device, and the dynamic reference counter\nwill be set to one\n\tAdeallocate statement for varwill deallocate memory from both local memory as well\nas the current device memory, for a non-shared memory device, and the d ynamic reference\ncounter will be set to zero If the structured reference counter is not z ero, a runtime error is\nissued\nIn Fortran, if a variable varinvar-list has the Fortran pointer attribute, then it may appear on the\nleft hand side of a pointer assignment statement, if the right hand side variab le itself appears in a\ncreate clause\nErrors\n\tIn Fortran, an acc_error_present error is issued at a deallocate statement if the struc-\ntured reference counter is not zero\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:declare directive create clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of declare directive create clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test declare directive create clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, declare directive create clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2132 create clause\nFor data in shared memory, no action is taken\nFor data not in shared memory, the create clause on a declare directive behaves as follows,\nfor each varinvar-list :\n\tAt entry to an implicit data region where the declare directive appears:\n\t\tIfvaris present, a present increment action with the structured reference counter is\nperformed If varis a pointer reference, an attach action is performed\n\t\tOtherwise, a create action with the structured reference counter is performed If varis\na pointer reference, an attach action is performed\n\tAt exit from an implicit data region where the declare directive appears:\n\t\tIf the structured reference counter for varis zero, no action is taken\n\t\tOtherwise, a present decrement action with the structured reference counter is per-\nformed If varis a pointer reference, a detach action is performed If both structured\nand dynamic reference counters are zero, a delete action is performed\nIf thedeclare directive appears in a global context, then the data in var-list is statically allocated\nin device memory and the structured reference counter is set to one\nIn Fortran, if a variable varinvar-list has the Fortran allocatable orpointer attribute, then:\n\tAnallocate statement for varwill allocate memory in both local memory as well as in the\ncurrent device memory, for a non-shared memory device, and the dynamic reference counter\nwill be set to one\n\tAdeallocate statement for varwill deallocate memory from both local memory as well\nas the current device memory, for a non-shared memory device, and the d ynamic reference\ncounter will be set to zero If the structured reference counter is not z ero, a runtime error is\nissued\nIn Fortran, if a variable varinvar-list has the Fortran pointer attribute, then it may appear on the\nleft hand side of a pointer assignment statement, if the right hand side variab le itself appears in a\ncreate clause\nErrors\n\tIn Fortran, an acc_error_present error is issued at a deallocate statement if the struc-\ntured reference counter is not zero\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:declare directive create clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of declare directive link clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test declare directive link clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, declare directive link clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2133 link clause\nThelink clause is used for large global host static data that is referenced within an accelerator\nroutine and that should have a dynamic data lifetime on the device The link clause speci\ufb01es that\nonly a global link for the named variables should be statically created in accele rator memory The\nhost data structure remains statically allocated and globally available The dev ice data memory will\n\nbe allocated only when the global variable appears on a data clause for a data construct, compute\nconstruct, or enter data directive The arguments to the link clause must be global data A\ndeclarelink clause must be visible everywhere the global variables or common block var iables\nare explicitly or implicitly used in a data clause, compute construct, or accelerato r routine The\nglobal variable or common block variables may be used in accelerator routines The accelerator\ndata lifetime of variables or common blocks that appear in a link clause is the data region that\nallocates the variable or common block with a data clause, or from the execution of theenter\ndata directive that allocates the data until an exitdata directive deallocates it or until the end\nof the program\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:declare directive link clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of declare directive link clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test declare directive link clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, declare directive link clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2133 link clause\nThelink clause is used for large global host static data that is referenced within an accelerator\nroutine and that should have a dynamic data lifetime on the device The link clause speci\ufb01es that\nonly a global link for the named variables should be statically created in accele rator memory The\nhost data structure remains statically allocated and globally available The dev ice data memory will\n\nbe allocated only when the global variable appears on a data clause for a data construct, compute\nconstruct, or enter data directive The arguments to the link clause must be global data A\ndeclarelink clause must be visible everywhere the global variables or common block var iables\nare explicitly or implicitly used in a data clause, compute construct, or accelerato r routine The\nglobal variable or common block variables may be used in accelerator routines The accelerator\ndata lifetime of variables or common blocks that appear in a link clause is the data region that\nallocates the variable or common block with a data clause, or from the execution of theenter\ndata directive that allocates the data until an exitdata directive deallocates it or until the end\nof the program\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:declare directive link clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of declare directive link clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test declare directive link clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, declare directive link clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2133 link clause\nThelink clause is used for large global host static data that is referenced within an accelerator\nroutine and that should have a dynamic data lifetime on the device The link clause speci\ufb01es that\nonly a global link for the named variables should be statically created in accele rator memory The\nhost data structure remains statically allocated and globally available The dev ice data memory will\n\nbe allocated only when the global variable appears on a data clause for a data construct, compute\nconstruct, or enter data directive The arguments to the link clause must be global data A\ndeclarelink clause must be visible everywhere the global variables or common block var iables\nare explicitly or implicitly used in a data clause, compute construct, or accelerato r routine The\nglobal variable or common block variables may be used in accelerator routines The accelerator\ndata lifetime of variables or common blocks that appear in a link clause is the data region that\nallocates the variable or common block with a data clause, or from the execution of theenter\ndata directive that allocates the data until an exitdata directive deallocates it or until the end\nof the program\n\nTemplate:\n\n#ifndef T1\n!T1:declare directive link clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of init directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test init directive in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, init directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2141 Init Directive\nSummary\nTheinit directive initializes the runtime for the given device or devices of the given d evice type\nThis can be used to isolate any initialization cost from the computational cost, wh en collecting\nperformance statistics If no device type appears all devices will be initialize d Aninit directive\nmay be used in place of a call to the acc_init oracc_init_device runtime API routine, as\ndescribed in Section 327\nSyntax\nIn C and C++, the syntax of the init directive is:\n#pragma acc init [clause-list ]new-line\nIn Fortran the syntax of the init directive is:\n!$acc init [clause-list ]\nwhere clause is one of the following:\ndevice_type( device-type-list )\ndevice_num( int-expr)\nif( condition)\n\ndevice type clause\nThedevice_type clause speci\ufb01es the type of device that is to be initialized in the runtime If the\ndevice_type clause appears, then the acc-current-device-type-var for the current thread is set to\nthe argument value If no device_num clause appears then all devices of this type are initialized\ndevice num clause\nThedevice_num clause speci\ufb01es the device id to be initialized If the device_num clause\nappears, then the acc-current-device-num-var for the current thread is set to the argument value If\nnodevice_type clause appears, then the speci\ufb01ed device id will be initialized for all available\ndevice types\n\nif clause\nTheifclause is optional; when there is no ifclause, the implementation will generate code to\nperform the initialization unconditionally When an ifclause appears, the implementation will\ngenerate code to conditionally perform the initialization only when the condition evaluates to true\nRestrictions\n\tThis directive may only appear in code executed on the host\n\tIf the directive is called more than once without an intervening acc_shutdown call or\nshutdown directive, with a different value for the device type argument, the behavio r is\nimplementation-de\ufb01ned\n\tIf some accelerator regions are compiled to only use one device type, using this directive with\na different device type may produce unde\ufb01ned behavior\nErrors\n\tAnacc_error_device_type_unavailable error is issued if a device_type clause\nappears and no device of that device type is available, or if no device_type clause appears\nand no device of the current device type is available\n\tAnacc_error_device_unavailable error is issued if a device_num clause ap-\npears and the int-expr is not a valid device number or that device is not available, or if no\ndevice_num clause appears and the current device is not available\n\tAnacc_error_device_init error is issued if the device cannot be initialized\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:init directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of init directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test init directive in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, init directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2141 Init Directive\nSummary\nTheinit directive initializes the runtime for the given device or devices of the given d evice type\nThis can be used to isolate any initialization cost from the computational cost, wh en collecting\nperformance statistics If no device type appears all devices will be initialize d Aninit directive\nmay be used in place of a call to the acc_init oracc_init_device runtime API routine, as\ndescribed in Section 327\nSyntax\nIn C and C++, the syntax of the init directive is:\n#pragma acc init [clause-list ]new-line\nIn Fortran the syntax of the init directive is:\n!$acc init [clause-list ]\nwhere clause is one of the following:\ndevice_type( device-type-list )\ndevice_num( int-expr)\nif( condition)\n\ndevice type clause\nThedevice_type clause speci\ufb01es the type of device that is to be initialized in the runtime If the\ndevice_type clause appears, then the acc-current-device-type-var for the current thread is set to\nthe argument value If no device_num clause appears then all devices of this type are initialized\ndevice num clause\nThedevice_num clause speci\ufb01es the device id to be initialized If the device_num clause\nappears, then the acc-current-device-num-var for the current thread is set to the argument value If\nnodevice_type clause appears, then the speci\ufb01ed device id will be initialized for all available\ndevice types\n\nif clause\nTheifclause is optional; when there is no ifclause, the implementation will generate code to\nperform the initialization unconditionally When an ifclause appears, the implementation will\ngenerate code to conditionally perform the initialization only when the condition evaluates to true\nRestrictions\n\tThis directive may only appear in code executed on the host\n\tIf the directive is called more than once without an intervening acc_shutdown call or\nshutdown directive, with a different value for the device type argument, the behavio r is\nimplementation-de\ufb01ned\n\tIf some accelerator regions are compiled to only use one device type, using this directive with\na different device type may produce unde\ufb01ned behavior\nErrors\n\tAnacc_error_device_type_unavailable error is issued if a device_type clause\nappears and no device of that device type is available, or if no device_type clause appears\nand no device of the current device type is available\n\tAnacc_error_device_unavailable error is issued if a device_num clause ap-\npears and the int-expr is not a valid device number or that device is not available, or if no\ndevice_num clause appears and the current device is not available\n\tAnacc_error_device_init error is issued if the device cannot be initialized\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:init directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of init directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test init directive in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, init directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2141 Init Directive\nSummary\nTheinit directive initializes the runtime for the given device or devices of the given d evice type\nThis can be used to isolate any initialization cost from the computational cost, wh en collecting\nperformance statistics If no device type appears all devices will be initialize d Aninit directive\nmay be used in place of a call to the acc_init oracc_init_device runtime API routine, as\ndescribed in Section 327\nSyntax\nIn C and C++, the syntax of the init directive is:\n#pragma acc init [clause-list ]new-line\nIn Fortran the syntax of the init directive is:\n!$acc init [clause-list ]\nwhere clause is one of the following:\ndevice_type( device-type-list )\ndevice_num( int-expr)\nif( condition)\n\ndevice type clause\nThedevice_type clause speci\ufb01es the type of device that is to be initialized in the runtime If the\ndevice_type clause appears, then the acc-current-device-type-var for the current thread is set to\nthe argument value If no device_num clause appears then all devices of this type are initialized\ndevice num clause\nThedevice_num clause speci\ufb01es the device id to be initialized If the device_num clause\nappears, then the acc-current-device-num-var for the current thread is set to the argument value If\nnodevice_type clause appears, then the speci\ufb01ed device id will be initialized for all available\ndevice types\n\nif clause\nTheifclause is optional; when there is no ifclause, the implementation will generate code to\nperform the initialization unconditionally When an ifclause appears, the implementation will\ngenerate code to conditionally perform the initialization only when the condition evaluates to true\nRestrictions\n\tThis directive may only appear in code executed on the host\n\tIf the directive is called more than once without an intervening acc_shutdown call or\nshutdown directive, with a different value for the device type argument, the behavio r is\nimplementation-de\ufb01ned\n\tIf some accelerator regions are compiled to only use one device type, using this directive with\na different device type may produce unde\ufb01ned behavior\nErrors\n\tAnacc_error_device_type_unavailable error is issued if a device_type clause\nappears and no device of that device type is available, or if no device_type clause appears\nand no device of the current device type is available\n\tAnacc_error_device_unavailable error is issued if a device_num clause ap-\npears and the int-expr is not a valid device number or that device is not available, or if no\ndevice_num clause appears and the current device is not available\n\tAnacc_error_device_init error is issued if the device cannot be initialized\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:init directive,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of shutdown directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test shutdown directive in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, shutdown directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2142 Shutdown Directive\nSummary\nTheshutdown directive shuts down the connection to the given device or devices of the g iven\ndevice type, and frees any associated runtime resources This ends all data lifetimes in device\nmemory, which effectively sets structured and dynamic reference counte rs to zero A shutdown\ndirective may be used in place of a call to the acc_shutdown oracc_shutdown_device\nruntime API routine, as described in Section 328\nSyntax\nIn C and C++, the syntax of the shutdown directive is:\n#pragma acc shutdown [clause-list ]new-line\nIn Fortran the syntax of the shutdown directive is:\n!$acc shutdown [clause-list ]\nwhere clause is one of the following:\ndevice_type( device-type-list )\ndevice_num( int-expr)\nif( condition)\n\n\ndevice type clause\nThedevice_type clause speci\ufb01es the type of device that is to be disconnected from the runtime \nIf nodevice_num clause appears then all devices of this type are disconnected\ndevice num clause\nThedevice_num clause speci\ufb01es the device id to be disconnected\nIf no clauses appear then all available devices will be disconnected\nif clause\nTheifclause is optional; when there is no ifclause, the implementation will generate code\nto perform the shutdown unconditionally When an ifclause appears, the implementation will\ngenerate code to conditionally perform the shutdown only when the condition evaluates to true\nRestrictions\n\tThis directive may only appear in code executed on the host\nErrors\n\tAnacc_error_device_type_unavailable error is issued if a device_type clause\nappears and no device of that device type is available,\n\tAnacc_error_device_unavailable error is issued if a device_num clause ap-\npears and the int-expr is not a valid device number or that device is not available\n\tAnacc_error_device_shutdown error is issued if there is an error shutting down the\ndevice\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:shutdown directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of shutdown directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test shutdown directive in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, shutdown directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2142 Shutdown Directive\nSummary\nTheshutdown directive shuts down the connection to the given device or devices of the g iven\ndevice type, and frees any associated runtime resources This ends all data lifetimes in device\nmemory, which effectively sets structured and dynamic reference counte rs to zero A shutdown\ndirective may be used in place of a call to the acc_shutdown oracc_shutdown_device\nruntime API routine, as described in Section 328\nSyntax\nIn C and C++, the syntax of the shutdown directive is:\n#pragma acc shutdown [clause-list ]new-line\nIn Fortran the syntax of the shutdown directive is:\n!$acc shutdown [clause-list ]\nwhere clause is one of the following:\ndevice_type( device-type-list )\ndevice_num( int-expr)\nif( condition)\n\n\ndevice type clause\nThedevice_type clause speci\ufb01es the type of device that is to be disconnected from the runtime \nIf nodevice_num clause appears then all devices of this type are disconnected\ndevice num clause\nThedevice_num clause speci\ufb01es the device id to be disconnected\nIf no clauses appear then all available devices will be disconnected\nif clause\nTheifclause is optional; when there is no ifclause, the implementation will generate code\nto perform the shutdown unconditionally When an ifclause appears, the implementation will\ngenerate code to conditionally perform the shutdown only when the condition evaluates to true\nRestrictions\n\tThis directive may only appear in code executed on the host\nErrors\n\tAnacc_error_device_type_unavailable error is issued if a device_type clause\nappears and no device of that device type is available,\n\tAnacc_error_device_unavailable error is issued if a device_num clause ap-\npears and the int-expr is not a valid device number or that device is not available\n\tAnacc_error_device_shutdown error is issued if there is an error shutting down the\ndevice\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:shutdown directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of shutdown directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test shutdown directive in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, shutdown directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2142 Shutdown Directive\nSummary\nTheshutdown directive shuts down the connection to the given device or devices of the g iven\ndevice type, and frees any associated runtime resources This ends all data lifetimes in device\nmemory, which effectively sets structured and dynamic reference counte rs to zero A shutdown\ndirective may be used in place of a call to the acc_shutdown oracc_shutdown_device\nruntime API routine, as described in Section 328\nSyntax\nIn C and C++, the syntax of the shutdown directive is:\n#pragma acc shutdown [clause-list ]new-line\nIn Fortran the syntax of the shutdown directive is:\n!$acc shutdown [clause-list ]\nwhere clause is one of the following:\ndevice_type( device-type-list )\ndevice_num( int-expr)\nif( condition)\n\n\ndevice type clause\nThedevice_type clause speci\ufb01es the type of device that is to be disconnected from the runtime \nIf nodevice_num clause appears then all devices of this type are disconnected\ndevice num clause\nThedevice_num clause speci\ufb01es the device id to be disconnected\nIf no clauses appear then all available devices will be disconnected\nif clause\nTheifclause is optional; when there is no ifclause, the implementation will generate code\nto perform the shutdown unconditionally When an ifclause appears, the implementation will\ngenerate code to conditionally perform the shutdown only when the condition evaluates to true\nRestrictions\n\tThis directive may only appear in code executed on the host\nErrors\n\tAnacc_error_device_type_unavailable error is issued if a device_type clause\nappears and no device of that device type is available,\n\tAnacc_error_device_unavailable error is issued if a device_num clause ap-\npears and the int-expr is not a valid device number or that device is not available\n\tAnacc_error_device_shutdown error is issued if there is an error shutting down the\ndevice\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:shutdown directive,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of set directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test set directive in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, set directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2143 Set Directive\nSummary\nTheset directive provides a means to modify internal control variables using direc tives Each form\nof theset directive is functionally equivalent to a matching runtime API routine\nSyntax\nIn C and C++, the syntax of the set directive is:\n#pragma acc set [clause-list ]new-line\nIn Fortran the syntax of the set directive is:\n!$acc set [clause-list ]\nwhere clause is one of the following\ndefault_async( int-expr)\ndevice_num( int-expr)\ndevice_type( device-type-list )\nif( condition)\n\ndefault async clause\nThedefault_async clause speci\ufb01es the asynchronous queue that should be used if no que ue ap-\npears and changes the value of acc-default-async-var for the current thread to the argument value\nIf the value is acc_async_default , the value of acc-default-async-var will revert to the ini-\ntial value, which is implementation-de\ufb01ned A set default_async directive is functionally\nequivalent to a call to the acc_set_default_async runtime API routine, as described in Sec-\ntion 3214\ndevice num clause\nThedevice_num clause speci\ufb01es the device number to set as the default device for accele rator\nregions and changes the value of acc-current-device-num-var for the current thread to the argument\nvalue If the value of device_num argument is negative, the runtime will revert to the default be-\nhavior, which is implementation-de\ufb01ned A setdevice_num directive is functionally equivalent\nto theacc_set_device_num runtime API routine, as described in Section 324\ndevice type clause\nThedevice_type clause speci\ufb01es the device type to set as the default device type for acce lerator\nregions and sets the value of acc-current-device-type-var for the current thread to the argument\nvalue If the value of the device_type argument is zero or the clause does not appear, the\nselected device number will be used for all attached accelerator types A set device_type\ndirective is functionally equivalent to a call to the acc_set_device_type runtime API routine,\nas described in Section 322\nif clause\nTheifclause is optional; when there is no ifclause, the implementation will generate code to\nperform the set operation unconditionally When an ifclause appears, the implementation will\ngenerate code to conditionally perform the set operation only when the condition evaluates to true\nRestrictions\n\tThis directive may only appear in code executed on the host\n\tPassingdefault_async the value of acc_async_noval has no effect\n\tPassingdefault_async the value of acc_async_sync will cause all asynchronous\ndirectives in the default asynchronous queue to become synchronous \n\tPassingdefault_async the value of acc_async_default will restore the default\nasynchronous queue to the initial value, which is implementation-de\ufb01ned\n\tAt least one default_async ,device_num , ordevice_type clause must appear\n\tTwo instances of the same clause may not appear on the same directive\nErrors\n\tAnacc_error_device_type_unavailable error is issued if a device_type clause\nappears, and no device of that device type is available\n\tAnacc_error_device_unavailable error is issued if a device_num clause ap-\npears, and the int-expr is not a valid device number\n\n\tAnacc_error_invalid_async error is issued if a default_async clause appears,\nand the int-expr is not a valid async-argument \nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:set directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of set directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test set directive in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, set directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2143 Set Directive\nSummary\nTheset directive provides a means to modify internal control variables using direc tives Each form\nof theset directive is functionally equivalent to a matching runtime API routine\nSyntax\nIn C and C++, the syntax of the set directive is:\n#pragma acc set [clause-list ]new-line\nIn Fortran the syntax of the set directive is:\n!$acc set [clause-list ]\nwhere clause is one of the following\ndefault_async( int-expr)\ndevice_num( int-expr)\ndevice_type( device-type-list )\nif( condition)\n\ndefault async clause\nThedefault_async clause speci\ufb01es the asynchronous queue that should be used if no que ue ap-\npears and changes the value of acc-default-async-var for the current thread to the argument value\nIf the value is acc_async_default , the value of acc-default-async-var will revert to the ini-\ntial value, which is implementation-de\ufb01ned A set default_async directive is functionally\nequivalent to a call to the acc_set_default_async runtime API routine, as described in Sec-\ntion 3214\ndevice num clause\nThedevice_num clause speci\ufb01es the device number to set as the default device for accele rator\nregions and changes the value of acc-current-device-num-var for the current thread to the argument\nvalue If the value of device_num argument is negative, the runtime will revert to the default be-\nhavior, which is implementation-de\ufb01ned A setdevice_num directive is functionally equivalent\nto theacc_set_device_num runtime API routine, as described in Section 324\ndevice type clause\nThedevice_type clause speci\ufb01es the device type to set as the default device type for acce lerator\nregions and sets the value of acc-current-device-type-var for the current thread to the argument\nvalue If the value of the device_type argument is zero or the clause does not appear, the\nselected device number will be used for all attached accelerator types A set device_type\ndirective is functionally equivalent to a call to the acc_set_device_type runtime API routine,\nas described in Section 322\nif clause\nTheifclause is optional; when there is no ifclause, the implementation will generate code to\nperform the set operation unconditionally When an ifclause appears, the implementation will\ngenerate code to conditionally perform the set operation only when the condition evaluates to true\nRestrictions\n\tThis directive may only appear in code executed on the host\n\tPassingdefault_async the value of acc_async_noval has no effect\n\tPassingdefault_async the value of acc_async_sync will cause all asynchronous\ndirectives in the default asynchronous queue to become synchronous \n\tPassingdefault_async the value of acc_async_default will restore the default\nasynchronous queue to the initial value, which is implementation-de\ufb01ned\n\tAt least one default_async ,device_num , ordevice_type clause must appear\n\tTwo instances of the same clause may not appear on the same directive\nErrors\n\tAnacc_error_device_type_unavailable error is issued if a device_type clause\nappears, and no device of that device type is available\n\tAnacc_error_device_unavailable error is issued if a device_num clause ap-\npears, and the int-expr is not a valid device number\n\n\tAnacc_error_invalid_async error is issued if a default_async clause appears,\nand the int-expr is not a valid async-argument \nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:set directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of set directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test set directive in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, set directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2143 Set Directive\nSummary\nTheset directive provides a means to modify internal control variables using direc tives Each form\nof theset directive is functionally equivalent to a matching runtime API routine\nSyntax\nIn C and C++, the syntax of the set directive is:\n#pragma acc set [clause-list ]new-line\nIn Fortran the syntax of the set directive is:\n!$acc set [clause-list ]\nwhere clause is one of the following\ndefault_async( int-expr)\ndevice_num( int-expr)\ndevice_type( device-type-list )\nif( condition)\n\ndefault async clause\nThedefault_async clause speci\ufb01es the asynchronous queue that should be used if no que ue ap-\npears and changes the value of acc-default-async-var for the current thread to the argument value\nIf the value is acc_async_default , the value of acc-default-async-var will revert to the ini-\ntial value, which is implementation-de\ufb01ned A set default_async directive is functionally\nequivalent to a call to the acc_set_default_async runtime API routine, as described in Sec-\ntion 3214\ndevice num clause\nThedevice_num clause speci\ufb01es the device number to set as the default device for accele rator\nregions and changes the value of acc-current-device-num-var for the current thread to the argument\nvalue If the value of device_num argument is negative, the runtime will revert to the default be-\nhavior, which is implementation-de\ufb01ned A setdevice_num directive is functionally equivalent\nto theacc_set_device_num runtime API routine, as described in Section 324\ndevice type clause\nThedevice_type clause speci\ufb01es the device type to set as the default device type for acce lerator\nregions and sets the value of acc-current-device-type-var for the current thread to the argument\nvalue If the value of the device_type argument is zero or the clause does not appear, the\nselected device number will be used for all attached accelerator types A set device_type\ndirective is functionally equivalent to a call to the acc_set_device_type runtime API routine,\nas described in Section 322\nif clause\nTheifclause is optional; when there is no ifclause, the implementation will generate code to\nperform the set operation unconditionally When an ifclause appears, the implementation will\ngenerate code to conditionally perform the set operation only when the condition evaluates to true\nRestrictions\n\tThis directive may only appear in code executed on the host\n\tPassingdefault_async the value of acc_async_noval has no effect\n\tPassingdefault_async the value of acc_async_sync will cause all asynchronous\ndirectives in the default asynchronous queue to become synchronous \n\tPassingdefault_async the value of acc_async_default will restore the default\nasynchronous queue to the initial value, which is implementation-de\ufb01ned\n\tAt least one default_async ,device_num , ordevice_type clause must appear\n\tTwo instances of the same clause may not appear on the same directive\nErrors\n\tAnacc_error_device_type_unavailable error is issued if a device_type clause\nappears, and no device of that device type is available\n\tAnacc_error_device_unavailable error is issued if a device_num clause ap-\npears, and the int-expr is not a valid device number\n\n\tAnacc_error_invalid_async error is issued if a default_async clause appears,\nand the int-expr is not a valid async-argument \nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:set directive,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of update directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test update directive in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, update directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2144 Update Directive\nSummary\nTheupdate directive is used during the lifetime of accelerator data to update vars in local memory\nwith values from the corresponding data in device memory, or to update vars in device memory with\nvalues from the corresponding data in local memory\nSyntax\nIn C and C++, the syntax of the update directive is:\n#pragma acc update clause-list new-line\nIn Fortran the syntax of the update data directive is:\n!$acc update clause-list\nwhere clause is one of the following:\nasync [(int-expr)]\nwait [(wait-argument )]\ndevice_type( device-type-list )\nif( condition)\nif_present\nself( var-list)\nhost( var-list)\ndevice( var-list)\nMultiple subarrays of the same array may appear in a var-list of the same or different clauses on\nthe same directive The effect of an update clause is to copy data from device memory to local\nmemory for updateself , and from local memory to device memory for updatedevice  The\nupdates are done in the order in which they appear on the directive\nRestrictions\n\tAt least one self ,host , ordevice clause must appear on an update directive\nself clause\nTheself clause speci\ufb01es that the vars invar-list are to be copied from the current device memory\nto local memory for data not in shared memory For data in shared memory, no a ction is taken An\nupdate directive with the self clause is equivalent to a call to the acc_update_self routine,\ndescribed in Section 3220\nhost clause\nThehost clause is a synonym for the self clause\n\ndevice clause\nThedevice clause speci\ufb01es that the vars invar-list are to be copied from local memory to the cur-\nrent device memory, for data not in shared memory For data in shared memory , no action is taken\nAnupdate directive with the device clause is equivalent to a call to the acc_update_device\nroutine, described in Section 3220\nif clause\nTheifclause is optional; when there is no ifclause, the implementation will generate code to\nperform the updates unconditionally When an ifclause appears, the implementation will generate\ncode to conditionally perform the updates only when the condition evaluates to true\nasync clause\nTheasync clause is optional; see Section 216 Asynchronous Behavior for more info rmation\nwait clause\nThewait clause is optional; see Section 216 Asynchronous Behavior for more infor mation\nifpresent clause\nWhen anif_present clause appears on the directive, no action is taken for a varwhich appears\ninvar-list that is not present in the current device memory\nRestrictions\n\tTheupdate directive is executable It must not appear in place of the statement followin g\nanif,while ,do,switch , orlabel in C or C++, or in place of the statement following a logical\nifin Fortran\n\tIf noif_present clause appears on the directive, each varinvar-list must be present in\nthe current device memory\n\tOnly theasync andwait clauses may follow a device_type clause\n\tAt most one ifclause may appear In Fortran, the condition must evaluate to a scalar logica l\nvalue; in C or C++, the condition must evaluate to a scalar integer value\n\tNoncontiguous subarrays may appear It is implementation-speci\ufb01c whethe r noncontiguous\nregions are updated by using one transfer for each contiguous subre gion, or whether the non-\ncontiguous data is packed, transferred once, and unpacked, or whe ther one or more larger\nsubarrays (no larger than the smallest contiguous region that contains the speci\ufb01ed subarray)\nare updated\n\tIn C and C++, a member of a struct or class may appear, including a subarr ay of a member\nMembers of a subarray of struct or class type may not appear\n\tIn C and C++, if a subarray notation is used for a struct member, subarra y notation may not\nbe used for any parent of that struct member\n\tIn Fortran, members of variables of derived type may appear, including a subarray of a mem-\nber Members of subarrays of derived type may not appear\n\n\tIn Fortran, if array or subarray notation is used for a derived type memb er, array or subarray\nnotation may not be used for a parent of that derived type member\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in self ,\nhost , anddevice clauses\nErrors\n\tAnacc_error_not_present error is issued if no if_present clause appears and\nanyvarin adevice orself clause is not present on the current device\n\tAnacc_error_partly_present error is issued if part of varis present in the current\ndevice memory but all of varis not\n\tAnasync orwait clause can cause an error to be issued; see Sections 2161 and 2162\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:update directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of update directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test update directive in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, update directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2144 Update Directive\nSummary\nTheupdate directive is used during the lifetime of accelerator data to update vars in local memory\nwith values from the corresponding data in device memory, or to update vars in device memory with\nvalues from the corresponding data in local memory\nSyntax\nIn C and C++, the syntax of the update directive is:\n#pragma acc update clause-list new-line\nIn Fortran the syntax of the update data directive is:\n!$acc update clause-list\nwhere clause is one of the following:\nasync [(int-expr)]\nwait [(wait-argument )]\ndevice_type( device-type-list )\nif( condition)\nif_present\nself( var-list)\nhost( var-list)\ndevice( var-list)\nMultiple subarrays of the same array may appear in a var-list of the same or different clauses on\nthe same directive The effect of an update clause is to copy data from device memory to local\nmemory for updateself , and from local memory to device memory for updatedevice  The\nupdates are done in the order in which they appear on the directive\nRestrictions\n\tAt least one self ,host , ordevice clause must appear on an update directive\nself clause\nTheself clause speci\ufb01es that the vars invar-list are to be copied from the current device memory\nto local memory for data not in shared memory For data in shared memory, no a ction is taken An\nupdate directive with the self clause is equivalent to a call to the acc_update_self routine,\ndescribed in Section 3220\nhost clause\nThehost clause is a synonym for the self clause\n\ndevice clause\nThedevice clause speci\ufb01es that the vars invar-list are to be copied from local memory to the cur-\nrent device memory, for data not in shared memory For data in shared memory , no action is taken\nAnupdate directive with the device clause is equivalent to a call to the acc_update_device\nroutine, described in Section 3220\nif clause\nTheifclause is optional; when there is no ifclause, the implementation will generate code to\nperform the updates unconditionally When an ifclause appears, the implementation will generate\ncode to conditionally perform the updates only when the condition evaluates to true\nasync clause\nTheasync clause is optional; see Section 216 Asynchronous Behavior for more info rmation\nwait clause\nThewait clause is optional; see Section 216 Asynchronous Behavior for more infor mation\nifpresent clause\nWhen anif_present clause appears on the directive, no action is taken for a varwhich appears\ninvar-list that is not present in the current device memory\nRestrictions\n\tTheupdate directive is executable It must not appear in place of the statement followin g\nanif,while ,do,switch , orlabel in C or C++, or in place of the statement following a logical\nifin Fortran\n\tIf noif_present clause appears on the directive, each varinvar-list must be present in\nthe current device memory\n\tOnly theasync andwait clauses may follow a device_type clause\n\tAt most one ifclause may appear In Fortran, the condition must evaluate to a scalar logica l\nvalue; in C or C++, the condition must evaluate to a scalar integer value\n\tNoncontiguous subarrays may appear It is implementation-speci\ufb01c whethe r noncontiguous\nregions are updated by using one transfer for each contiguous subre gion, or whether the non-\ncontiguous data is packed, transferred once, and unpacked, or whe ther one or more larger\nsubarrays (no larger than the smallest contiguous region that contains the speci\ufb01ed subarray)\nare updated\n\tIn C and C++, a member of a struct or class may appear, including a subarr ay of a member\nMembers of a subarray of struct or class type may not appear\n\tIn C and C++, if a subarray notation is used for a struct member, subarra y notation may not\nbe used for any parent of that struct member\n\tIn Fortran, members of variables of derived type may appear, including a subarray of a mem-\nber Members of subarrays of derived type may not appear\n\n\tIn Fortran, if array or subarray notation is used for a derived type memb er, array or subarray\nnotation may not be used for a parent of that derived type member\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in self ,\nhost , anddevice clauses\nErrors\n\tAnacc_error_not_present error is issued if no if_present clause appears and\nanyvarin adevice orself clause is not present on the current device\n\tAnacc_error_partly_present error is issued if part of varis present in the current\ndevice memory but all of varis not\n\tAnasync orwait clause can cause an error to be issued; see Sections 2161 and 2162\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:update directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of update directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test update directive in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, update directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2144 Update Directive\nSummary\nTheupdate directive is used during the lifetime of accelerator data to update vars in local memory\nwith values from the corresponding data in device memory, or to update vars in device memory with\nvalues from the corresponding data in local memory\nSyntax\nIn C and C++, the syntax of the update directive is:\n#pragma acc update clause-list new-line\nIn Fortran the syntax of the update data directive is:\n!$acc update clause-list\nwhere clause is one of the following:\nasync [(int-expr)]\nwait [(wait-argument )]\ndevice_type( device-type-list )\nif( condition)\nif_present\nself( var-list)\nhost( var-list)\ndevice( var-list)\nMultiple subarrays of the same array may appear in a var-list of the same or different clauses on\nthe same directive The effect of an update clause is to copy data from device memory to local\nmemory for updateself , and from local memory to device memory for updatedevice  The\nupdates are done in the order in which they appear on the directive\nRestrictions\n\tAt least one self ,host , ordevice clause must appear on an update directive\nself clause\nTheself clause speci\ufb01es that the vars invar-list are to be copied from the current device memory\nto local memory for data not in shared memory For data in shared memory, no a ction is taken An\nupdate directive with the self clause is equivalent to a call to the acc_update_self routine,\ndescribed in Section 3220\nhost clause\nThehost clause is a synonym for the self clause\n\ndevice clause\nThedevice clause speci\ufb01es that the vars invar-list are to be copied from local memory to the cur-\nrent device memory, for data not in shared memory For data in shared memory , no action is taken\nAnupdate directive with the device clause is equivalent to a call to the acc_update_device\nroutine, described in Section 3220\nif clause\nTheifclause is optional; when there is no ifclause, the implementation will generate code to\nperform the updates unconditionally When an ifclause appears, the implementation will generate\ncode to conditionally perform the updates only when the condition evaluates to true\nasync clause\nTheasync clause is optional; see Section 216 Asynchronous Behavior for more info rmation\nwait clause\nThewait clause is optional; see Section 216 Asynchronous Behavior for more infor mation\nifpresent clause\nWhen anif_present clause appears on the directive, no action is taken for a varwhich appears\ninvar-list that is not present in the current device memory\nRestrictions\n\tTheupdate directive is executable It must not appear in place of the statement followin g\nanif,while ,do,switch , orlabel in C or C++, or in place of the statement following a logical\nifin Fortran\n\tIf noif_present clause appears on the directive, each varinvar-list must be present in\nthe current device memory\n\tOnly theasync andwait clauses may follow a device_type clause\n\tAt most one ifclause may appear In Fortran, the condition must evaluate to a scalar logica l\nvalue; in C or C++, the condition must evaluate to a scalar integer value\n\tNoncontiguous subarrays may appear It is implementation-speci\ufb01c whethe r noncontiguous\nregions are updated by using one transfer for each contiguous subre gion, or whether the non-\ncontiguous data is packed, transferred once, and unpacked, or whe ther one or more larger\nsubarrays (no larger than the smallest contiguous region that contains the speci\ufb01ed subarray)\nare updated\n\tIn C and C++, a member of a struct or class may appear, including a subarr ay of a member\nMembers of a subarray of struct or class type may not appear\n\tIn C and C++, if a subarray notation is used for a struct member, subarra y notation may not\nbe used for any parent of that struct member\n\tIn Fortran, members of variables of derived type may appear, including a subarray of a mem-\nber Members of subarrays of derived type may not appear\n\n\tIn Fortran, if array or subarray notation is used for a derived type memb er, array or subarray\nnotation may not be used for a parent of that derived type member\n\tSee Section 2171 Optional Arguments for discussion of Fortran optional a rguments in self ,\nhost , anddevice clauses\nErrors\n\tAnacc_error_not_present error is issued if no if_present clause appears and\nanyvarin adevice orself clause is not present on the current device\n\tAnacc_error_partly_present error is issued if part of varis present in the current\ndevice memory but all of varis not\n\tAnasync orwait clause can cause an error to be issued; see Sections 2161 and 2162\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:update directive,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of wait directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test wait directive in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, wait directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2163 Wait Directive\nSummary\nThewait directive causes the local thread or operations enqueued onto a device activity queue on\nthe current device to wait for completion of asynchronous operations\nSyntax\nIn C and C++, the syntax of the wait directive is:\n\n#pragma acc wait [(wait-argument )] [clause-list ]new-line\nIn Fortran the syntax of the wait directive is:\n!$acc wait [(wait-argument )] [clause-list ]\nwhere clause is:\nasync [(async-argument )]\nif( condition)\nIf it appears, the wait-argument is as de\ufb01ned in Section 216, and the associated device and activity\nqueues are as speci\ufb01ed in the wait-argument  If there is no wait-argument clause, the associated\ndevice is the current device and associated activity queues are all activ ity queues\nIf there is no async clause, the local thread will wait until all operations enqueued by this threa d\nonto each of the associated device activity queues for the associated dev ice have completed There\nis no guarantee that all the asynchronous operations initiated by other thre ads onto those queues will\nhave completed without additional synchronization with those threads\nIf there is an async clause, no new operation may be launched or executed on the activity queu e\nassociated with the async-argument on the current device until all operations enqueued up to this\npoint by this thread on the activity queues associated with the wait-argument have completed Note:\nOne legal implementation is for the local thread to wait for all the associated acti vity queues; another\nlegal implementation is for the thread to enqueue a synchronization operation in such a way that\nno new operation will start until the operations enqueued on the associated activity queues have\ncompleted\nTheifclause is optional; when there is no ifclause, the implementation will generate code to\nperform the wait operation unconditionally When an ifclause appears, the implementation will\ngenerate code to conditionally perform the wait operation only when the condition evaluates to true\nAwait directive is functionally equivalent to a call to one of the acc_wait ,acc_wait_async ,\nacc_wait_all , oracc_wait_all_async runtime API routines, as described in Sections 32\nand 3211\nErrors\n\tAnacc_error_device_unavailable error is issued if a devnum modi\ufb01er appears\nand the int-expr is not a valid device number\n\tAnacc_error_invalid_async error is issued if a queues modi\ufb01er or no modi\ufb01er\nappears and any value in the associated list is not a valid async-argument \nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:wait directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of wait directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test wait directive in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, wait directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2163 Wait Directive\nSummary\nThewait directive causes the local thread or operations enqueued onto a device activity queue on\nthe current device to wait for completion of asynchronous operations\nSyntax\nIn C and C++, the syntax of the wait directive is:\n\n#pragma acc wait [(wait-argument )] [clause-list ]new-line\nIn Fortran the syntax of the wait directive is:\n!$acc wait [(wait-argument )] [clause-list ]\nwhere clause is:\nasync [(async-argument )]\nif( condition)\nIf it appears, the wait-argument is as de\ufb01ned in Section 216, and the associated device and activity\nqueues are as speci\ufb01ed in the wait-argument  If there is no wait-argument clause, the associated\ndevice is the current device and associated activity queues are all activ ity queues\nIf there is no async clause, the local thread will wait until all operations enqueued by this threa d\nonto each of the associated device activity queues for the associated dev ice have completed There\nis no guarantee that all the asynchronous operations initiated by other thre ads onto those queues will\nhave completed without additional synchronization with those threads\nIf there is an async clause, no new operation may be launched or executed on the activity queu e\nassociated with the async-argument on the current device until all operations enqueued up to this\npoint by this thread on the activity queues associated with the wait-argument have completed Note:\nOne legal implementation is for the local thread to wait for all the associated acti vity queues; another\nlegal implementation is for the thread to enqueue a synchronization operation in such a way that\nno new operation will start until the operations enqueued on the associated activity queues have\ncompleted\nTheifclause is optional; when there is no ifclause, the implementation will generate code to\nperform the wait operation unconditionally When an ifclause appears, the implementation will\ngenerate code to conditionally perform the wait operation only when the condition evaluates to true\nAwait directive is functionally equivalent to a call to one of the acc_wait ,acc_wait_async ,\nacc_wait_all , oracc_wait_all_async runtime API routines, as described in Sections 32\nand 3211\nErrors\n\tAnacc_error_device_unavailable error is issued if a devnum modi\ufb01er appears\nand the int-expr is not a valid device number\n\tAnacc_error_invalid_async error is issued if a queues modi\ufb01er or no modi\ufb01er\nappears and any value in the associated list is not a valid async-argument \nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:wait directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of wait directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test wait directive in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, wait directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2163 Wait Directive\nSummary\nThewait directive causes the local thread or operations enqueued onto a device activity queue on\nthe current device to wait for completion of asynchronous operations\nSyntax\nIn C and C++, the syntax of the wait directive is:\n\n#pragma acc wait [(wait-argument )] [clause-list ]new-line\nIn Fortran the syntax of the wait directive is:\n!$acc wait [(wait-argument )] [clause-list ]\nwhere clause is:\nasync [(async-argument )]\nif( condition)\nIf it appears, the wait-argument is as de\ufb01ned in Section 216, and the associated device and activity\nqueues are as speci\ufb01ed in the wait-argument  If there is no wait-argument clause, the associated\ndevice is the current device and associated activity queues are all activ ity queues\nIf there is no async clause, the local thread will wait until all operations enqueued by this threa d\nonto each of the associated device activity queues for the associated dev ice have completed There\nis no guarantee that all the asynchronous operations initiated by other thre ads onto those queues will\nhave completed without additional synchronization with those threads\nIf there is an async clause, no new operation may be launched or executed on the activity queu e\nassociated with the async-argument on the current device until all operations enqueued up to this\npoint by this thread on the activity queues associated with the wait-argument have completed Note:\nOne legal implementation is for the local thread to wait for all the associated acti vity queues; another\nlegal implementation is for the thread to enqueue a synchronization operation in such a way that\nno new operation will start until the operations enqueued on the associated activity queues have\ncompleted\nTheifclause is optional; when there is no ifclause, the implementation will generate code to\nperform the wait operation unconditionally When an ifclause appears, the implementation will\ngenerate code to conditionally perform the wait operation only when the condition evaluates to true\nAwait directive is functionally equivalent to a call to one of the acc_wait ,acc_wait_async ,\nacc_wait_all , oracc_wait_all_async runtime API routines, as described in Sections 32\nand 3211\nErrors\n\tAnacc_error_device_unavailable error is issued if a devnum modi\ufb01er appears\nand the int-expr is not a valid device number\n\tAnacc_error_invalid_async error is issued if a queues modi\ufb01er or no modi\ufb01er\nappears and any value in the associated list is not a valid async-argument \nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:wait directive,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of enter data directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test enter data directive in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, enter data directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2146 Enter Data Directive\nSee Section 266 Enter Data and Exit Data Directives for more information\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:enter data directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of enter data directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test enter data directive in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, enter data directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2146 Enter Data Directive\nSee Section 266 Enter Data and Exit Data Directives for more information\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:enter data directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of enter data directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test enter data directive in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, enter data directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2146 Enter Data Directive\nSee Section 266 Enter Data and Exit Data Directives for more information\n\nTemplate:\n\n#ifndef T1\n!T1:enter data directive,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of exit data directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test exit data directive in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, exit data directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2147 Exit Data Directive\nSee Section 266 Enter Data and Exit Data Directives for more information\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:exit data directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of exit data directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test exit data directive in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, exit data directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2147 Exit Data Directive\nSee Section 266 Enter Data and Exit Data Directives for more information\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:exit data directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of exit data directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test exit data directive in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, exit data directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2147 Exit Data Directive\nSee Section 266 Enter Data and Exit Data Directives for more information\n\nTemplate:\n\n#ifndef T1\n!T1:exit data directive,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of routine directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test routine directive in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, routine directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2151 Routine Directive\nSummary\nTheroutine directive is used to tell the compiler to compile the de\ufb01nition for a procedure, su ch\nas a function or C++ lambda, for an accelerator as well as for the host Th eroutine directive is\nalso used to tell the compiler the attributes of the procedure when called on the a ccelerator\nSyntax\nIn C and C++, the syntax of the routine directive is:\n#pragma acc routine clause-list new-line\n#pragma acc routine( name)clause-list new-line\nIn C and C++, the routine directive without a name may appear immediately before a function\nde\ufb01nition, a function prototype, or a C++ lambda and applies to the function or C++ lambda The\nroutine directive with a name may appear anywhere that a function prototype is allowe d and\napplies to the function or the C++ lambda in scope with that name See Section A34 for recom-\nmended diagnostics for a routine directive with a name\n\nIn Fortran the syntax of the routine directive is:\n!$acc routine clause-list\n!$acc routine( name)clause-list\nIn Fortran, the routine directive without a name may appear within the speci\ufb01cation part of a\nsubroutine or function de\ufb01nition, or within an interface body for a subrou tine or function in an\ninterface block, and applies to the containing subroutine or function The routine directive with\na name may appear in the speci\ufb01cation part of a subroutine, function or modu le, and applies to the\nnamed subroutine or function\nTheclause is one of the following:\ngang [(dim: int-expr)]\nworker\nvector\nseq\nbind( name)\nbind( string)\ndevice_type( device-type-list )\nnohost\nAgang ,worker ,vector , orseq clause speci\ufb01es the level of parallelism in the routine\nA procedure compiled with the routine directive for an accelerator is called an accelerator rou-\ntine\nIf no explicit routine directive applies to a procedure that is called or whose address is acces sed\nin a compute region, and the procedure\u2019s de\ufb01nition appears in the progra m unit being compiled, then\nthe implementation applies an implicit routine directive with a seq clause to that procedure A\nC++ lambda\u2019s implicit routine directive also has a nohost clause if the lambda is de\ufb01ned in an\naccelerator routine that has a nohost clause\nWhen the implementation applies an implicit routine directive, it must recursively handle proce-\ndure references in that accelerator routine\nThe implementation may apply predetermined routine directives with a seq clause to any pro-\ncedures that it provides for an accelerator, such as those of base lan guage standard libraries\ngang clause\nThe associated dimension is the value of the dim clause, if it appears, or is dimension one The dim\nargument must be a constant positive integer with value 1, 2, or 3 The gang clause with dimension\ndspeci\ufb01es that the procedure contains, may contain, or may call another pr ocedure that contains a\nloop with a gang clause associated with dimension dor less\nworker clause\nTheworker clause speci\ufb01es that the procedure contains, may contain, or may call ano ther pro-\ncedure that contains a loop with a worker clause, but does not contain nor does it call another\nprocedure that contains a loop with the gang clause A loop in this procedure with an auto clause\nmay be selected by the compiler to execute in worker orvector mode A call to this procedure\nmust appear in code that is executed in worker-single mode, though it may be in gang-redundant\n\norgang-partitioned mode For instance, a procedure with a routineworker directive may be\ncalled from within a loop that has the gang clause, but not from within a loop that has the worker\nclause\nvector clause\nThevector clause speci\ufb01es that the procedure contains, may contain, or may call ano ther pro-\ncedure that contains a loop with the vector clause, but does not contain nor does it call another\nprocedure that contains a loop with either a gang orworker clause A loop in this procedure with\nanauto clause may be selected by the compiler to execute in vector mode, but not worker\nmode A call to this procedure must appear in code that is executed in vector-single mode, though\nit may be in gang-redundant organg-partitioned mode, and in worker-single orworker-partitioned\nmode For instance, a procedure with a routine vector directive may be called from within\na loop that has the gang clause or the worker clause, but not from within a loop that has the\nvector clause\nseq clause\nTheseq clause speci\ufb01es that the procedure does not contain nor does it call an other procedure that\ncontains a loop with a gang ,worker , orvector clause A loop in this procedure with an auto\nclause will be executed in seq mode A call to this procedure may appear in any mode\nbind clause\nThebind clause speci\ufb01es the name to use when calling the procedure on a device othe r than the\nhost If the name is speci\ufb01ed as an identi\ufb01er, it is called as if that name were sp eci\ufb01ed in the\nlanguage being compiled If the name is speci\ufb01ed as a string, the string is used for the procedure\nname unmodi\ufb01ed A bind clause on a procedure de\ufb01nition behaves as if it had appeared on a\ndeclaration by changing the name used to call the procedure on a device oth er than the host; however,\nthe procedure is not compiled for the device with either the original name or the name in the bind\nclause\nIf there is both a Fortran bind and an acc bind clause for a procedure de\ufb01nition then a call on the\nhost will call the Fortran bound name and a call on another device will call th e name in the bind\nclause\ndevice type clause\nThedevice_type clause is described in Section 24 Device-Speci\ufb01c Clauses\nnohost clause\nThenohost clause tells the compiler not to compile a version of this procedure for the host\nRestrictions\n\tOnly thegang ,worker ,vector ,seq andbind clauses may follow a device_type\nclause\n\tExactly one of the gang ,worker ,vector , orseq clauses must appear\n\tIn C and C++, function static variables are not supported in functions to wh ich aroutine\ndirective applies\n\n\tIn Fortran, variables with the save attribute, either explicitly or implicitly, are not supported\nin subprograms to which a routine directive applies\n\tA call to a procedure with a nohost clause must not appear in a compute construct that is\ncompiled for the host See examples below\n\tIf a call to a procedure with a nohost clause appears in another procedure but outside any\ncompute construct, that other procedure must also have a nohost clause\n\tA call to a procedure with a gang(dim: d)clause must appear in code that is executed\ningang-redundant mode in all dimensions dand lower For instance, a procedure with a\ngang(dim:2) clause may not be called from within a loop that has a gang(dim:1)\nor agang(dim:2) clause The user needs to ensure that a call to a procedure with a\ngang(dim: d)clause, when present in a region executing in GRe orGPe mode with e>d\nand called by a gang along dimension e, is executed by all of its corresponding gangs along\ndimension d\n\tAbind clause may not bind to a routine name that has a visible bind clause\n\tIf a procedure has a bind clause on both the declaration and the de\ufb01nition then they both\nmust bind to the same name\n\tIn C and C++, a de\ufb01nition or use of a procedure must appear within the sco pe of at least\none explicit and applying routine directive if any appears in the same compilation unit\nAn explicit routine directive\u2019s scope is from the directive to the end of the compilation\nunit If the routine directive appears in the member list of a C++ class, then its scope also\nextends in the same manner as any class member\u2019s scope (eg, it includes the bo dies of all\nother member functions)\n/triangledownsld /triangledownsld\nExamples\n\n\tA function, such as fbelow, requires a nohost clause if it contains accelerator-speci\ufb01c code\nthat cannot be compiled for the host By default, some implementations compile all c ompute\nconstructs for the host in addition to accelerators In that case, a call to fmust not appear in\nany compute construct or compilation will fail However, fcan appear in the bind clause of\nanother function, such as gbelow, that does not have a nohost clause, and a call to gcan\nappear in a compute construct Thus, gis called when the compute construct is compiled for\nthe host, and fis called when the compute construct is compiled for accelerators\n#pragma acc routine seq nohost\nvoid f() { /*accelerator implementation */}\n\n#pragma acc routine seq bind(f)\nvoid g() { /*host implementation */}\n\nvoid h() {\n#pragma acc parallel\ng();\n}\n\n\tIn C, the restriction that a function\u2019s de\ufb01nitions and uses must appear within any applying\nroutine directive\u2019s scope has a simple interpretation: the routine directive must appear\n\ufb01rst This interpretation seems intuitive for the common case in C where prototyp es, de\ufb01ni-\ntions, androutine directives for a function, such as fbelow, appear at global scope\nvoid f();\nvoid scopeA() {\n#pragma acc parallel\nf();// nonconforming\n}\n// The routine directive\u2019s scope is not f\u2019s full scope\n// Instead, it starts at the routine directive\n#pragma acc routine(f) gang\nvoid scopeB() {\n#pragma acc parallel\nf();// conforming\n}\nvoid f() {} // conforming\n\tC++ classes permit forward references from member function bodies to o ther members de-\nclared later For example, immediately within classA below,g\u2019s scope does not start until\nafterf\u2019s de\ufb01nition Nevertheless, within f\u2019s body,gis in scope throughout The same is true\nforg\u2019sroutine directive Thus, f\u2019s call togis conforming\nclass A {\nvoid f() {\n#pragma acc parallel\ng();// conforming\n}\n#pragma acc routine gang\nvoid g();\n};\n\tIn some places, C++ classes do not permit forward references For e xample, in the return type\nof a member function, a member typedef that is declared later is not in scope L ikewise,g\u2019s\nde\ufb01nition below is not fully within the scope of g\u2019sroutine directive even though its body\nis, so its de\ufb01nition is nonconforming\nclass A {\n#pragma acc routine(f) gang\nvoid f() {} // conforming\nvoid g() {} // nonconforming\n#pragma acc routine(g) gang\n};\n\tThe C++ scope resolution operator and using directive do not affect the scope of routine\ndirectives For example, the routine directive below is speci\ufb01ed for the name f, which\nresolves to A::f  Every reference to both A::f andC::f afterward is in the routine\ndirective\u2019s scope, but the routine directive always applies to A::f and neverC::f even\nwhen referenced as just f\nnamespace A {\nvoid f();\nnamespace B {\n\n#pragma acc routine(f) gang // applies to A::f\n}\n}\nvoid g() {\n#pragma acc parallel\nA::f(); // conforming\n}\nvoid h() {\nusing A::f;\n#pragma acc parallel\nf();// conforming\n}\nnamespace C {\nvoid f();\nusing namespace A::B;\nvoid i() {\n#pragma acc parallel\nf();// nonconforming\n}\n}\n/trianglesolid /trianglesolid\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:routine directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of routine directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test routine directive in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, routine directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2151 Routine Directive\nSummary\nTheroutine directive is used to tell the compiler to compile the de\ufb01nition for a procedure, su ch\nas a function or C++ lambda, for an accelerator as well as for the host Th eroutine directive is\nalso used to tell the compiler the attributes of the procedure when called on the a ccelerator\nSyntax\nIn C and C++, the syntax of the routine directive is:\n#pragma acc routine clause-list new-line\n#pragma acc routine( name)clause-list new-line\nIn C and C++, the routine directive without a name may appear immediately before a function\nde\ufb01nition, a function prototype, or a C++ lambda and applies to the function or C++ lambda The\nroutine directive with a name may appear anywhere that a function prototype is allowe d and\napplies to the function or the C++ lambda in scope with that name See Section A34 for recom-\nmended diagnostics for a routine directive with a name\n\nIn Fortran the syntax of the routine directive is:\n!$acc routine clause-list\n!$acc routine( name)clause-list\nIn Fortran, the routine directive without a name may appear within the speci\ufb01cation part of a\nsubroutine or function de\ufb01nition, or within an interface body for a subrou tine or function in an\ninterface block, and applies to the containing subroutine or function The routine directive with\na name may appear in the speci\ufb01cation part of a subroutine, function or modu le, and applies to the\nnamed subroutine or function\nTheclause is one of the following:\ngang [(dim: int-expr)]\nworker\nvector\nseq\nbind( name)\nbind( string)\ndevice_type( device-type-list )\nnohost\nAgang ,worker ,vector , orseq clause speci\ufb01es the level of parallelism in the routine\nA procedure compiled with the routine directive for an accelerator is called an accelerator rou-\ntine\nIf no explicit routine directive applies to a procedure that is called or whose address is acces sed\nin a compute region, and the procedure\u2019s de\ufb01nition appears in the progra m unit being compiled, then\nthe implementation applies an implicit routine directive with a seq clause to that procedure A\nC++ lambda\u2019s implicit routine directive also has a nohost clause if the lambda is de\ufb01ned in an\naccelerator routine that has a nohost clause\nWhen the implementation applies an implicit routine directive, it must recursively handle proce-\ndure references in that accelerator routine\nThe implementation may apply predetermined routine directives with a seq clause to any pro-\ncedures that it provides for an accelerator, such as those of base lan guage standard libraries\ngang clause\nThe associated dimension is the value of the dim clause, if it appears, or is dimension one The dim\nargument must be a constant positive integer with value 1, 2, or 3 The gang clause with dimension\ndspeci\ufb01es that the procedure contains, may contain, or may call another pr ocedure that contains a\nloop with a gang clause associated with dimension dor less\nworker clause\nTheworker clause speci\ufb01es that the procedure contains, may contain, or may call ano ther pro-\ncedure that contains a loop with a worker clause, but does not contain nor does it call another\nprocedure that contains a loop with the gang clause A loop in this procedure with an auto clause\nmay be selected by the compiler to execute in worker orvector mode A call to this procedure\nmust appear in code that is executed in worker-single mode, though it may be in gang-redundant\n\norgang-partitioned mode For instance, a procedure with a routineworker directive may be\ncalled from within a loop that has the gang clause, but not from within a loop that has the worker\nclause\nvector clause\nThevector clause speci\ufb01es that the procedure contains, may contain, or may call ano ther pro-\ncedure that contains a loop with the vector clause, but does not contain nor does it call another\nprocedure that contains a loop with either a gang orworker clause A loop in this procedure with\nanauto clause may be selected by the compiler to execute in vector mode, but not worker\nmode A call to this procedure must appear in code that is executed in vector-single mode, though\nit may be in gang-redundant organg-partitioned mode, and in worker-single orworker-partitioned\nmode For instance, a procedure with a routine vector directive may be called from within\na loop that has the gang clause or the worker clause, but not from within a loop that has the\nvector clause\nseq clause\nTheseq clause speci\ufb01es that the procedure does not contain nor does it call an other procedure that\ncontains a loop with a gang ,worker , orvector clause A loop in this procedure with an auto\nclause will be executed in seq mode A call to this procedure may appear in any mode\nbind clause\nThebind clause speci\ufb01es the name to use when calling the procedure on a device othe r than the\nhost If the name is speci\ufb01ed as an identi\ufb01er, it is called as if that name were sp eci\ufb01ed in the\nlanguage being compiled If the name is speci\ufb01ed as a string, the string is used for the procedure\nname unmodi\ufb01ed A bind clause on a procedure de\ufb01nition behaves as if it had appeared on a\ndeclaration by changing the name used to call the procedure on a device oth er than the host; however,\nthe procedure is not compiled for the device with either the original name or the name in the bind\nclause\nIf there is both a Fortran bind and an acc bind clause for a procedure de\ufb01nition then a call on the\nhost will call the Fortran bound name and a call on another device will call th e name in the bind\nclause\ndevice type clause\nThedevice_type clause is described in Section 24 Device-Speci\ufb01c Clauses\nnohost clause\nThenohost clause tells the compiler not to compile a version of this procedure for the host\nRestrictions\n\tOnly thegang ,worker ,vector ,seq andbind clauses may follow a device_type\nclause\n\tExactly one of the gang ,worker ,vector , orseq clauses must appear\n\tIn C and C++, function static variables are not supported in functions to wh ich aroutine\ndirective applies\n\n\tIn Fortran, variables with the save attribute, either explicitly or implicitly, are not supported\nin subprograms to which a routine directive applies\n\tA call to a procedure with a nohost clause must not appear in a compute construct that is\ncompiled for the host See examples below\n\tIf a call to a procedure with a nohost clause appears in another procedure but outside any\ncompute construct, that other procedure must also have a nohost clause\n\tA call to a procedure with a gang(dim: d)clause must appear in code that is executed\ningang-redundant mode in all dimensions dand lower For instance, a procedure with a\ngang(dim:2) clause may not be called from within a loop that has a gang(dim:1)\nor agang(dim:2) clause The user needs to ensure that a call to a procedure with a\ngang(dim: d)clause, when present in a region executing in GRe orGPe mode with e>d\nand called by a gang along dimension e, is executed by all of its corresponding gangs along\ndimension d\n\tAbind clause may not bind to a routine name that has a visible bind clause\n\tIf a procedure has a bind clause on both the declaration and the de\ufb01nition then they both\nmust bind to the same name\n\tIn C and C++, a de\ufb01nition or use of a procedure must appear within the sco pe of at least\none explicit and applying routine directive if any appears in the same compilation unit\nAn explicit routine directive\u2019s scope is from the directive to the end of the compilation\nunit If the routine directive appears in the member list of a C++ class, then its scope also\nextends in the same manner as any class member\u2019s scope (eg, it includes the bo dies of all\nother member functions)\n/triangledownsld /triangledownsld\nExamples\n\n\tA function, such as fbelow, requires a nohost clause if it contains accelerator-speci\ufb01c code\nthat cannot be compiled for the host By default, some implementations compile all c ompute\nconstructs for the host in addition to accelerators In that case, a call to fmust not appear in\nany compute construct or compilation will fail However, fcan appear in the bind clause of\nanother function, such as gbelow, that does not have a nohost clause, and a call to gcan\nappear in a compute construct Thus, gis called when the compute construct is compiled for\nthe host, and fis called when the compute construct is compiled for accelerators\n#pragma acc routine seq nohost\nvoid f() { /*accelerator implementation */}\n\n#pragma acc routine seq bind(f)\nvoid g() { /*host implementation */}\n\nvoid h() {\n#pragma acc parallel\ng();\n}\n\n\tIn C, the restriction that a function\u2019s de\ufb01nitions and uses must appear within any applying\nroutine directive\u2019s scope has a simple interpretation: the routine directive must appear\n\ufb01rst This interpretation seems intuitive for the common case in C where prototyp es, de\ufb01ni-\ntions, androutine directives for a function, such as fbelow, appear at global scope\nvoid f();\nvoid scopeA() {\n#pragma acc parallel\nf();// nonconforming\n}\n// The routine directive\u2019s scope is not f\u2019s full scope\n// Instead, it starts at the routine directive\n#pragma acc routine(f) gang\nvoid scopeB() {\n#pragma acc parallel\nf();// conforming\n}\nvoid f() {} // conforming\n\tC++ classes permit forward references from member function bodies to o ther members de-\nclared later For example, immediately within classA below,g\u2019s scope does not start until\nafterf\u2019s de\ufb01nition Nevertheless, within f\u2019s body,gis in scope throughout The same is true\nforg\u2019sroutine directive Thus, f\u2019s call togis conforming\nclass A {\nvoid f() {\n#pragma acc parallel\ng();// conforming\n}\n#pragma acc routine gang\nvoid g();\n};\n\tIn some places, C++ classes do not permit forward references For e xample, in the return type\nof a member function, a member typedef that is declared later is not in scope L ikewise,g\u2019s\nde\ufb01nition below is not fully within the scope of g\u2019sroutine directive even though its body\nis, so its de\ufb01nition is nonconforming\nclass A {\n#pragma acc routine(f) gang\nvoid f() {} // conforming\nvoid g() {} // nonconforming\n#pragma acc routine(g) gang\n};\n\tThe C++ scope resolution operator and using directive do not affect the scope of routine\ndirectives For example, the routine directive below is speci\ufb01ed for the name f, which\nresolves to A::f  Every reference to both A::f andC::f afterward is in the routine\ndirective\u2019s scope, but the routine directive always applies to A::f and neverC::f even\nwhen referenced as just f\nnamespace A {\nvoid f();\nnamespace B {\n\n#pragma acc routine(f) gang // applies to A::f\n}\n}\nvoid g() {\n#pragma acc parallel\nA::f(); // conforming\n}\nvoid h() {\nusing A::f;\n#pragma acc parallel\nf();// conforming\n}\nnamespace C {\nvoid f();\nusing namespace A::B;\nvoid i() {\n#pragma acc parallel\nf();// nonconforming\n}\n}\n/trianglesolid /trianglesolid\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:routine directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of routine directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test routine directive in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, routine directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2151 Routine Directive\nSummary\nTheroutine directive is used to tell the compiler to compile the de\ufb01nition for a procedure, su ch\nas a function or C++ lambda, for an accelerator as well as for the host Th eroutine directive is\nalso used to tell the compiler the attributes of the procedure when called on the a ccelerator\nSyntax\nIn C and C++, the syntax of the routine directive is:\n#pragma acc routine clause-list new-line\n#pragma acc routine( name)clause-list new-line\nIn C and C++, the routine directive without a name may appear immediately before a function\nde\ufb01nition, a function prototype, or a C++ lambda and applies to the function or C++ lambda The\nroutine directive with a name may appear anywhere that a function prototype is allowe d and\napplies to the function or the C++ lambda in scope with that name See Section A34 for recom-\nmended diagnostics for a routine directive with a name\n\nIn Fortran the syntax of the routine directive is:\n!$acc routine clause-list\n!$acc routine( name)clause-list\nIn Fortran, the routine directive without a name may appear within the speci\ufb01cation part of a\nsubroutine or function de\ufb01nition, or within an interface body for a subrou tine or function in an\ninterface block, and applies to the containing subroutine or function The routine directive with\na name may appear in the speci\ufb01cation part of a subroutine, function or modu le, and applies to the\nnamed subroutine or function\nTheclause is one of the following:\ngang [(dim: int-expr)]\nworker\nvector\nseq\nbind( name)\nbind( string)\ndevice_type( device-type-list )\nnohost\nAgang ,worker ,vector , orseq clause speci\ufb01es the level of parallelism in the routine\nA procedure compiled with the routine directive for an accelerator is called an accelerator rou-\ntine\nIf no explicit routine directive applies to a procedure that is called or whose address is acces sed\nin a compute region, and the procedure\u2019s de\ufb01nition appears in the progra m unit being compiled, then\nthe implementation applies an implicit routine directive with a seq clause to that procedure A\nC++ lambda\u2019s implicit routine directive also has a nohost clause if the lambda is de\ufb01ned in an\naccelerator routine that has a nohost clause\nWhen the implementation applies an implicit routine directive, it must recursively handle proce-\ndure references in that accelerator routine\nThe implementation may apply predetermined routine directives with a seq clause to any pro-\ncedures that it provides for an accelerator, such as those of base lan guage standard libraries\ngang clause\nThe associated dimension is the value of the dim clause, if it appears, or is dimension one The dim\nargument must be a constant positive integer with value 1, 2, or 3 The gang clause with dimension\ndspeci\ufb01es that the procedure contains, may contain, or may call another pr ocedure that contains a\nloop with a gang clause associated with dimension dor less\nworker clause\nTheworker clause speci\ufb01es that the procedure contains, may contain, or may call ano ther pro-\ncedure that contains a loop with a worker clause, but does not contain nor does it call another\nprocedure that contains a loop with the gang clause A loop in this procedure with an auto clause\nmay be selected by the compiler to execute in worker orvector mode A call to this procedure\nmust appear in code that is executed in worker-single mode, though it may be in gang-redundant\n\norgang-partitioned mode For instance, a procedure with a routineworker directive may be\ncalled from within a loop that has the gang clause, but not from within a loop that has the worker\nclause\nvector clause\nThevector clause speci\ufb01es that the procedure contains, may contain, or may call ano ther pro-\ncedure that contains a loop with the vector clause, but does not contain nor does it call another\nprocedure that contains a loop with either a gang orworker clause A loop in this procedure with\nanauto clause may be selected by the compiler to execute in vector mode, but not worker\nmode A call to this procedure must appear in code that is executed in vector-single mode, though\nit may be in gang-redundant organg-partitioned mode, and in worker-single orworker-partitioned\nmode For instance, a procedure with a routine vector directive may be called from within\na loop that has the gang clause or the worker clause, but not from within a loop that has the\nvector clause\nseq clause\nTheseq clause speci\ufb01es that the procedure does not contain nor does it call an other procedure that\ncontains a loop with a gang ,worker , orvector clause A loop in this procedure with an auto\nclause will be executed in seq mode A call to this procedure may appear in any mode\nbind clause\nThebind clause speci\ufb01es the name to use when calling the procedure on a device othe r than the\nhost If the name is speci\ufb01ed as an identi\ufb01er, it is called as if that name were sp eci\ufb01ed in the\nlanguage being compiled If the name is speci\ufb01ed as a string, the string is used for the procedure\nname unmodi\ufb01ed A bind clause on a procedure de\ufb01nition behaves as if it had appeared on a\ndeclaration by changing the name used to call the procedure on a device oth er than the host; however,\nthe procedure is not compiled for the device with either the original name or the name in the bind\nclause\nIf there is both a Fortran bind and an acc bind clause for a procedure de\ufb01nition then a call on the\nhost will call the Fortran bound name and a call on another device will call th e name in the bind\nclause\ndevice type clause\nThedevice_type clause is described in Section 24 Device-Speci\ufb01c Clauses\nnohost clause\nThenohost clause tells the compiler not to compile a version of this procedure for the host\nRestrictions\n\tOnly thegang ,worker ,vector ,seq andbind clauses may follow a device_type\nclause\n\tExactly one of the gang ,worker ,vector , orseq clauses must appear\n\tIn C and C++, function static variables are not supported in functions to wh ich aroutine\ndirective applies\n\n\tIn Fortran, variables with the save attribute, either explicitly or implicitly, are not supported\nin subprograms to which a routine directive applies\n\tA call to a procedure with a nohost clause must not appear in a compute construct that is\ncompiled for the host See examples below\n\tIf a call to a procedure with a nohost clause appears in another procedure but outside any\ncompute construct, that other procedure must also have a nohost clause\n\tA call to a procedure with a gang(dim: d)clause must appear in code that is executed\ningang-redundant mode in all dimensions dand lower For instance, a procedure with a\ngang(dim:2) clause may not be called from within a loop that has a gang(dim:1)\nor agang(dim:2) clause The user needs to ensure that a call to a procedure with a\ngang(dim: d)clause, when present in a region executing in GRe orGPe mode with e>d\nand called by a gang along dimension e, is executed by all of its corresponding gangs along\ndimension d\n\tAbind clause may not bind to a routine name that has a visible bind clause\n\tIf a procedure has a bind clause on both the declaration and the de\ufb01nition then they both\nmust bind to the same name\n\tIn C and C++, a de\ufb01nition or use of a procedure must appear within the sco pe of at least\none explicit and applying routine directive if any appears in the same compilation unit\nAn explicit routine directive\u2019s scope is from the directive to the end of the compilation\nunit If the routine directive appears in the member list of a C++ class, then its scope also\nextends in the same manner as any class member\u2019s scope (eg, it includes the bo dies of all\nother member functions)\n/triangledownsld /triangledownsld\nExamples\n\n\tA function, such as fbelow, requires a nohost clause if it contains accelerator-speci\ufb01c code\nthat cannot be compiled for the host By default, some implementations compile all c ompute\nconstructs for the host in addition to accelerators In that case, a call to fmust not appear in\nany compute construct or compilation will fail However, fcan appear in the bind clause of\nanother function, such as gbelow, that does not have a nohost clause, and a call to gcan\nappear in a compute construct Thus, gis called when the compute construct is compiled for\nthe host, and fis called when the compute construct is compiled for accelerators\n#pragma acc routine seq nohost\nvoid f() { /*accelerator implementation */}\n\n#pragma acc routine seq bind(f)\nvoid g() { /*host implementation */}\n\nvoid h() {\n#pragma acc parallel\ng();\n}\n\n\tIn C, the restriction that a function\u2019s de\ufb01nitions and uses must appear within any applying\nroutine directive\u2019s scope has a simple interpretation: the routine directive must appear\n\ufb01rst This interpretation seems intuitive for the common case in C where prototyp es, de\ufb01ni-\ntions, androutine directives for a function, such as fbelow, appear at global scope\nvoid f();\nvoid scopeA() {\n#pragma acc parallel\nf();// nonconforming\n}\n// The routine directive\u2019s scope is not f\u2019s full scope\n// Instead, it starts at the routine directive\n#pragma acc routine(f) gang\nvoid scopeB() {\n#pragma acc parallel\nf();// conforming\n}\nvoid f() {} // conforming\n\tC++ classes permit forward references from member function bodies to o ther members de-\nclared later For example, immediately within classA below,g\u2019s scope does not start until\nafterf\u2019s de\ufb01nition Nevertheless, within f\u2019s body,gis in scope throughout The same is true\nforg\u2019sroutine directive Thus, f\u2019s call togis conforming\nclass A {\nvoid f() {\n#pragma acc parallel\ng();// conforming\n}\n#pragma acc routine gang\nvoid g();\n};\n\tIn some places, C++ classes do not permit forward references For e xample, in the return type\nof a member function, a member typedef that is declared later is not in scope L ikewise,g\u2019s\nde\ufb01nition below is not fully within the scope of g\u2019sroutine directive even though its body\nis, so its de\ufb01nition is nonconforming\nclass A {\n#pragma acc routine(f) gang\nvoid f() {} // conforming\nvoid g() {} // nonconforming\n#pragma acc routine(g) gang\n};\n\tThe C++ scope resolution operator and using directive do not affect the scope of routine\ndirectives For example, the routine directive below is speci\ufb01ed for the name f, which\nresolves to A::f  Every reference to both A::f andC::f afterward is in the routine\ndirective\u2019s scope, but the routine directive always applies to A::f and neverC::f even\nwhen referenced as just f\nnamespace A {\nvoid f();\nnamespace B {\n\n#pragma acc routine(f) gang // applies to A::f\n}\n}\nvoid g() {\n#pragma acc parallel\nA::f(); // conforming\n}\nvoid h() {\nusing A::f;\n#pragma acc parallel\nf();// conforming\n}\nnamespace C {\nvoid f();\nusing namespace A::B;\nvoid i() {\n#pragma acc parallel\nf();// nonconforming\n}\n}\n/trianglesolid /trianglesolid\n\nTemplate:\n\n#ifndef T1\n!T1:routine directive,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of async clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test async clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, async clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2161 async clause\nTheasync clause may appear on a parallel ,serial ,kernels , ordata construct, or an\nenterdata ,exitdata ,update , orwait directive In all cases, the async clause is optional\nTheasync clause may have a single async-argument , as de\ufb01ned above If the async clause does\nnot appear, the behavior is as if the async-argument isacc_async_sync  If theasync clause\nappears with no argument, the behavior is as if the async-argument isacc_async_noval  The\nasync-value for a construct or directive is de\ufb01ned in Section 216\nErrors\n\tAnacc_error_invalid_async error is issued if an async clause with an argument\nappears on any directive and the argument is not a valid async-argument \nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:async clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of async clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test async clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, async clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2161 async clause\nTheasync clause may appear on a parallel ,serial ,kernels , ordata construct, or an\nenterdata ,exitdata ,update , orwait directive In all cases, the async clause is optional\nTheasync clause may have a single async-argument , as de\ufb01ned above If the async clause does\nnot appear, the behavior is as if the async-argument isacc_async_sync  If theasync clause\nappears with no argument, the behavior is as if the async-argument isacc_async_noval  The\nasync-value for a construct or directive is de\ufb01ned in Section 216\nErrors\n\tAnacc_error_invalid_async error is issued if an async clause with an argument\nappears on any directive and the argument is not a valid async-argument \nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:async clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of async clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test async clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, async clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2161 async clause\nTheasync clause may appear on a parallel ,serial ,kernels , ordata construct, or an\nenterdata ,exitdata ,update , orwait directive In all cases, the async clause is optional\nTheasync clause may have a single async-argument , as de\ufb01ned above If the async clause does\nnot appear, the behavior is as if the async-argument isacc_async_sync  If theasync clause\nappears with no argument, the behavior is as if the async-argument isacc_async_noval  The\nasync-value for a construct or directive is de\ufb01ned in Section 216\nErrors\n\tAnacc_error_invalid_async error is issued if an async clause with an argument\nappears on any directive and the argument is not a valid async-argument \nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:async clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of wait clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test wait clause in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, wait clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2162 wait clause\nThewait clause may appear on a parallel ,serial , orkernels , ordata construct, or\nanenter data ,exit data , orupdate directive In all cases, the wait clause is optional\nWhen there is no wait clause, the associated operations may be enqueued or launched or exec uted\nimmediately on the device\nIf there is an argument to the wait clause, it must be a wait-argument , the associated device and\nactivity queues are as speci\ufb01ed in the wait-argument ; see Section 216 If there is no argument to\nthewait clause, the associated device is the current device and associated activ ity queues are all\nactivity queues The associated operations may not be launched or exec uted until all operations\nalready enqueued up to this point by this thread on the associated asynchr onous device activity\nqueues have completed Note: One legal implementation is for the local thread to wait until the\noperations already enqueued on the associated asynchronous device activity queues have completed;\nanother legal implementation is for the local thread to enqueue the associated o perations in such a\nway that they will not start until the operations already enqueued on the as sociated asynchronous\ndevice activity queues have completed\nErrors\n\tAnacc_error_device_unavailable error is issued if a wait clause appears on any\ndirective with a devnum modi\ufb01er and the associated int-expr is not a valid device number\n\tAnacc_error_invalid_async error is issued if a wait clause appears on any direc-\ntive with aqueues modi\ufb01er or no modi\ufb01er and any value in the associated list is not a valid\nasync-argument \nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:wait clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of wait clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test wait clause in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, wait clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2162 wait clause\nThewait clause may appear on a parallel ,serial , orkernels , ordata construct, or\nanenter data ,exit data , orupdate directive In all cases, the wait clause is optional\nWhen there is no wait clause, the associated operations may be enqueued or launched or exec uted\nimmediately on the device\nIf there is an argument to the wait clause, it must be a wait-argument , the associated device and\nactivity queues are as speci\ufb01ed in the wait-argument ; see Section 216 If there is no argument to\nthewait clause, the associated device is the current device and associated activ ity queues are all\nactivity queues The associated operations may not be launched or exec uted until all operations\nalready enqueued up to this point by this thread on the associated asynchr onous device activity\nqueues have completed Note: One legal implementation is for the local thread to wait until the\noperations already enqueued on the associated asynchronous device activity queues have completed;\nanother legal implementation is for the local thread to enqueue the associated o perations in such a\nway that they will not start until the operations already enqueued on the as sociated asynchronous\ndevice activity queues have completed\nErrors\n\tAnacc_error_device_unavailable error is issued if a wait clause appears on any\ndirective with a devnum modi\ufb01er and the associated int-expr is not a valid device number\n\tAnacc_error_invalid_async error is issued if a wait clause appears on any direc-\ntive with aqueues modi\ufb01er or no modi\ufb01er and any value in the associated list is not a valid\nasync-argument \nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:wait clause,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of wait clause. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test wait clause in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, wait clause, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2162 wait clause\nThewait clause may appear on a parallel ,serial , orkernels , ordata construct, or\nanenter data ,exit data , orupdate directive In all cases, the wait clause is optional\nWhen there is no wait clause, the associated operations may be enqueued or launched or exec uted\nimmediately on the device\nIf there is an argument to the wait clause, it must be a wait-argument , the associated device and\nactivity queues are as speci\ufb01ed in the wait-argument ; see Section 216 If there is no argument to\nthewait clause, the associated device is the current device and associated activ ity queues are all\nactivity queues The associated operations may not be launched or exec uted until all operations\nalready enqueued up to this point by this thread on the associated asynchr onous device activity\nqueues have completed Note: One legal implementation is for the local thread to wait until the\noperations already enqueued on the associated asynchronous device activity queues have completed;\nanother legal implementation is for the local thread to enqueue the associated o perations in such a\nway that they will not start until the operations already enqueued on the as sociated asynchronous\ndevice activity queues have completed\nErrors\n\tAnacc_error_device_unavailable error is issued if a wait clause appears on any\ndirective with a devnum modi\ufb01er and the associated int-expr is not a valid device number\n\tAnacc_error_invalid_async error is issued if a wait clause appears on any direc-\ntive with aqueues modi\ufb01er or no modi\ufb01er and any value in the associated list is not a valid\nasync-argument \nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:wait clause,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of wait directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test wait directive in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, wait directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2163 Wait Directive\nSummary\nThewait directive causes the local thread or operations enqueued onto a device activity queue on\nthe current device to wait for completion of asynchronous operations\nSyntax\nIn C and C++, the syntax of the wait directive is:\n\n#pragma acc wait [(wait-argument )] [clause-list ]new-line\nIn Fortran the syntax of the wait directive is:\n!$acc wait [(wait-argument )] [clause-list ]\nwhere clause is:\nasync [(async-argument )]\nif( condition)\nIf it appears, the wait-argument is as de\ufb01ned in Section 216, and the associated device and activity\nqueues are as speci\ufb01ed in the wait-argument  If there is no wait-argument clause, the associated\ndevice is the current device and associated activity queues are all activ ity queues\nIf there is no async clause, the local thread will wait until all operations enqueued by this threa d\nonto each of the associated device activity queues for the associated dev ice have completed There\nis no guarantee that all the asynchronous operations initiated by other thre ads onto those queues will\nhave completed without additional synchronization with those threads\nIf there is an async clause, no new operation may be launched or executed on the activity queu e\nassociated with the async-argument on the current device until all operations enqueued up to this\npoint by this thread on the activity queues associated with the wait-argument have completed Note:\nOne legal implementation is for the local thread to wait for all the associated acti vity queues; another\nlegal implementation is for the thread to enqueue a synchronization operation in such a way that\nno new operation will start until the operations enqueued on the associated activity queues have\ncompleted\nTheifclause is optional; when there is no ifclause, the implementation will generate code to\nperform the wait operation unconditionally When an ifclause appears, the implementation will\ngenerate code to conditionally perform the wait operation only when the condition evaluates to true\nAwait directive is functionally equivalent to a call to one of the acc_wait ,acc_wait_async ,\nacc_wait_all , oracc_wait_all_async runtime API routines, as described in Sections 32\nand 3211\nErrors\n\tAnacc_error_device_unavailable error is issued if a devnum modi\ufb01er appears\nand the int-expr is not a valid device number\n\tAnacc_error_invalid_async error is issued if a queues modi\ufb01er or no modi\ufb01er\nappears and any value in the associated list is not a valid async-argument \nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:wait directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of wait directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test wait directive in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, wait directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2163 Wait Directive\nSummary\nThewait directive causes the local thread or operations enqueued onto a device activity queue on\nthe current device to wait for completion of asynchronous operations\nSyntax\nIn C and C++, the syntax of the wait directive is:\n\n#pragma acc wait [(wait-argument )] [clause-list ]new-line\nIn Fortran the syntax of the wait directive is:\n!$acc wait [(wait-argument )] [clause-list ]\nwhere clause is:\nasync [(async-argument )]\nif( condition)\nIf it appears, the wait-argument is as de\ufb01ned in Section 216, and the associated device and activity\nqueues are as speci\ufb01ed in the wait-argument  If there is no wait-argument clause, the associated\ndevice is the current device and associated activity queues are all activ ity queues\nIf there is no async clause, the local thread will wait until all operations enqueued by this threa d\nonto each of the associated device activity queues for the associated dev ice have completed There\nis no guarantee that all the asynchronous operations initiated by other thre ads onto those queues will\nhave completed without additional synchronization with those threads\nIf there is an async clause, no new operation may be launched or executed on the activity queu e\nassociated with the async-argument on the current device until all operations enqueued up to this\npoint by this thread on the activity queues associated with the wait-argument have completed Note:\nOne legal implementation is for the local thread to wait for all the associated acti vity queues; another\nlegal implementation is for the thread to enqueue a synchronization operation in such a way that\nno new operation will start until the operations enqueued on the associated activity queues have\ncompleted\nTheifclause is optional; when there is no ifclause, the implementation will generate code to\nperform the wait operation unconditionally When an ifclause appears, the implementation will\ngenerate code to conditionally perform the wait operation only when the condition evaluates to true\nAwait directive is functionally equivalent to a call to one of the acc_wait ,acc_wait_async ,\nacc_wait_all , oracc_wait_all_async runtime API routines, as described in Sections 32\nand 3211\nErrors\n\tAnacc_error_device_unavailable error is issued if a devnum modi\ufb01er appears\nand the int-expr is not a valid device number\n\tAnacc_error_invalid_async error is issued if a queues modi\ufb01er or no modi\ufb01er\nappears and any value in the associated list is not a valid async-argument \nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:wait directive,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of wait directive. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test wait directive in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, wait directive, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 2163 Wait Directive\nSummary\nThewait directive causes the local thread or operations enqueued onto a device activity queue on\nthe current device to wait for completion of asynchronous operations\nSyntax\nIn C and C++, the syntax of the wait directive is:\n\n#pragma acc wait [(wait-argument )] [clause-list ]new-line\nIn Fortran the syntax of the wait directive is:\n!$acc wait [(wait-argument )] [clause-list ]\nwhere clause is:\nasync [(async-argument )]\nif( condition)\nIf it appears, the wait-argument is as de\ufb01ned in Section 216, and the associated device and activity\nqueues are as speci\ufb01ed in the wait-argument  If there is no wait-argument clause, the associated\ndevice is the current device and associated activity queues are all activ ity queues\nIf there is no async clause, the local thread will wait until all operations enqueued by this threa d\nonto each of the associated device activity queues for the associated dev ice have completed There\nis no guarantee that all the asynchronous operations initiated by other thre ads onto those queues will\nhave completed without additional synchronization with those threads\nIf there is an async clause, no new operation may be launched or executed on the activity queu e\nassociated with the async-argument on the current device until all operations enqueued up to this\npoint by this thread on the activity queues associated with the wait-argument have completed Note:\nOne legal implementation is for the local thread to wait for all the associated acti vity queues; another\nlegal implementation is for the thread to enqueue a synchronization operation in such a way that\nno new operation will start until the operations enqueued on the associated activity queues have\ncompleted\nTheifclause is optional; when there is no ifclause, the implementation will generate code to\nperform the wait operation unconditionally When an ifclause appears, the implementation will\ngenerate code to conditionally perform the wait operation only when the condition evaluates to true\nAwait directive is functionally equivalent to a call to one of the acc_wait ,acc_wait_async ,\nacc_wait_all , oracc_wait_all_async runtime API routines, as described in Sections 32\nand 3211\nErrors\n\tAnacc_error_device_unavailable error is issued if a devnum modi\ufb01er appears\nand the int-expr is not a valid device number\n\tAnacc_error_invalid_async error is issued if a queues modi\ufb01er or no modi\ufb01er\nappears and any value in the associated list is not a valid async-argument \nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:wait directive,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc get num devices. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc get num devices in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc get num devices, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 321 acc getnum devices\nSummary\nTheacc_get_num_devices routine returns the number of available devices of the given type\nFormat\nC or C++:\nint acc_get_num_devices(acc_device_t dev_type);\nFortran:\ninteger function acc_get_num_devices(dev_type)\ninteger(acc_device_kind) :: dev_type\nDescription\nTheacc_get_num_devices routine returns the number of available devices of device type\ndev_type  If device type dev_type is not supported or no device of dev_type is available,\nthis routine returns zero\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc get num devices,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc get num devices. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc get num devices in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc get num devices, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 321 acc getnum devices\nSummary\nTheacc_get_num_devices routine returns the number of available devices of the given type\nFormat\nC or C++:\nint acc_get_num_devices(acc_device_t dev_type);\nFortran:\ninteger function acc_get_num_devices(dev_type)\ninteger(acc_device_kind) :: dev_type\nDescription\nTheacc_get_num_devices routine returns the number of available devices of device type\ndev_type  If device type dev_type is not supported or no device of dev_type is available,\nthis routine returns zero\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc get num devices,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc get num devices. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc get num devices in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc get num devices, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 321 acc getnum devices\nSummary\nTheacc_get_num_devices routine returns the number of available devices of the given type\nFormat\nC or C++:\nint acc_get_num_devices(acc_device_t dev_type);\nFortran:\ninteger function acc_get_num_devices(dev_type)\ninteger(acc_device_kind) :: dev_type\nDescription\nTheacc_get_num_devices routine returns the number of available devices of device type\ndev_type  If device type dev_type is not supported or no device of dev_type is available,\nthis routine returns zero\n\nTemplate:\n\n#ifndef T1\n!T1:acc get num devices,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc set device type. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc set device type in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc set device type, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 322 acc setdevice type\nSummary\nTheacc_set_device_type routine tells the runtime which type of device to use when exe-\ncuting a compute region and sets the value of acc-current-device-type-var  This is useful when the\nimplementation allows the program to be compiled to use more than one type of device \n\nFormat\nC or C++:\nvoid acc_set_device_type(acc_device_t dev_type);\nFortran:\nsubroutine acc_set_device_type(dev_type)\ninteger(acc_device_kind) :: dev_type\nDescription\nA call toacc_set_device_type is functionally equivalent to a setdevice_type(dev_type)\ndirective, as described in Section 2143 This routine tells the runtime which typ e of device to use\namong those available and sets the value of acc-current-device-type-var for the current thread to\ndev_type \nRestrictions\n\tIf some compute regions are compiled to only use one device type, the result o f calling this\nroutine with a different device type may produce unde\ufb01ned behavior\nErrors\n\tAnacc_error_device_type_unavailable error is issued if device type dev_type\nis not supported or no device of dev_type is available\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc set device type,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc set device type. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc set device type in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc set device type, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 322 acc setdevice type\nSummary\nTheacc_set_device_type routine tells the runtime which type of device to use when exe-\ncuting a compute region and sets the value of acc-current-device-type-var  This is useful when the\nimplementation allows the program to be compiled to use more than one type of device \n\nFormat\nC or C++:\nvoid acc_set_device_type(acc_device_t dev_type);\nFortran:\nsubroutine acc_set_device_type(dev_type)\ninteger(acc_device_kind) :: dev_type\nDescription\nA call toacc_set_device_type is functionally equivalent to a setdevice_type(dev_type)\ndirective, as described in Section 2143 This routine tells the runtime which typ e of device to use\namong those available and sets the value of acc-current-device-type-var for the current thread to\ndev_type \nRestrictions\n\tIf some compute regions are compiled to only use one device type, the result o f calling this\nroutine with a different device type may produce unde\ufb01ned behavior\nErrors\n\tAnacc_error_device_type_unavailable error is issued if device type dev_type\nis not supported or no device of dev_type is available\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc set device type,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc set device type. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc set device type in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc set device type, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 322 acc setdevice type\nSummary\nTheacc_set_device_type routine tells the runtime which type of device to use when exe-\ncuting a compute region and sets the value of acc-current-device-type-var  This is useful when the\nimplementation allows the program to be compiled to use more than one type of device \n\nFormat\nC or C++:\nvoid acc_set_device_type(acc_device_t dev_type);\nFortran:\nsubroutine acc_set_device_type(dev_type)\ninteger(acc_device_kind) :: dev_type\nDescription\nA call toacc_set_device_type is functionally equivalent to a setdevice_type(dev_type)\ndirective, as described in Section 2143 This routine tells the runtime which typ e of device to use\namong those available and sets the value of acc-current-device-type-var for the current thread to\ndev_type \nRestrictions\n\tIf some compute regions are compiled to only use one device type, the result o f calling this\nroutine with a different device type may produce unde\ufb01ned behavior\nErrors\n\tAnacc_error_device_type_unavailable error is issued if device type dev_type\nis not supported or no device of dev_type is available\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc set device type,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc get device type. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc get device type in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc get device type, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 323 acc getdevice type\nSummary\nTheacc_get_device_type routine returns the value of acc-current-device-type-var , which is\nthe device type of the current device This is useful when the implementation a llows the program to\nbe compiled to use more than one type of device\nFormat\nC or C++:\nacc_device_t acc_get_device_type(void);\nFortran:\nfunction acc_get_device_type()\ninteger(acc_device_kind) :: acc_get_device_type\nDescription\nTheacc_get_device_type routine returns the value of acc-current-device-type-var for the\ncurrent thread to tell the program what type of device will be used to run th e next compute region, if\none has been selected The device type may have been selected by the pro gram with a runtime API\ncall or a directive, by an environment variable, or by the default behav ior of the implementation; see\nthe table in Section 231\nRestrictions\n\tIf the device type has not yet been selected, the value acc_device_none may be returned\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc get device type,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc get device type. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc get device type in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc get device type, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 323 acc getdevice type\nSummary\nTheacc_get_device_type routine returns the value of acc-current-device-type-var , which is\nthe device type of the current device This is useful when the implementation a llows the program to\nbe compiled to use more than one type of device\nFormat\nC or C++:\nacc_device_t acc_get_device_type(void);\nFortran:\nfunction acc_get_device_type()\ninteger(acc_device_kind) :: acc_get_device_type\nDescription\nTheacc_get_device_type routine returns the value of acc-current-device-type-var for the\ncurrent thread to tell the program what type of device will be used to run th e next compute region, if\none has been selected The device type may have been selected by the pro gram with a runtime API\ncall or a directive, by an environment variable, or by the default behav ior of the implementation; see\nthe table in Section 231\nRestrictions\n\tIf the device type has not yet been selected, the value acc_device_none may be returned\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc get device type,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc get device type. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc get device type in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc get device type, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 323 acc getdevice type\nSummary\nTheacc_get_device_type routine returns the value of acc-current-device-type-var , which is\nthe device type of the current device This is useful when the implementation a llows the program to\nbe compiled to use more than one type of device\nFormat\nC or C++:\nacc_device_t acc_get_device_type(void);\nFortran:\nfunction acc_get_device_type()\ninteger(acc_device_kind) :: acc_get_device_type\nDescription\nTheacc_get_device_type routine returns the value of acc-current-device-type-var for the\ncurrent thread to tell the program what type of device will be used to run th e next compute region, if\none has been selected The device type may have been selected by the pro gram with a runtime API\ncall or a directive, by an environment variable, or by the default behav ior of the implementation; see\nthe table in Section 231\nRestrictions\n\tIf the device type has not yet been selected, the value acc_device_none may be returned\n\nTemplate:\n\n#ifndef T1\n!T1:acc get device type,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc set device num. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc set device num in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc set device num, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 324 acc setdevice num\nSummary\nTheacc_set_device_num routine tells the runtime which device to use and sets the value of\nacc-current-device-num-var \nFormat\nC or C++:\nvoid acc_set_device_num(int dev_num, acc_device_t dev_t ype);\nFortran:\nsubroutine acc_set_device_num(dev_num, dev_type)\ninteger :: dev_num\ninteger(acc_device_kind) :: dev_type\nDescription\nA call toacc_set_device_num is functionally equivalent to a setdevice_type(dev_type)\ndevice_num(dev_num) directive, as described in Section 2143 This routine tells the runtime\nwhich device to use among those available of the given type for compute or da ta regions in the cur-\nrent thread and sets the value of acc-current-device-num-var todev_num  If the value of dev_num\nis negative, the runtime will revert to its default behavior, which is implementation -de\ufb01ned If the\nvalue of the dev_type is zero, the selected device number will be used for all device types Calling\nacc_set_device_num implies a call to acc_set_device_type(dev_type) \nErrors\n\tAnacc_error_device_type_unavailable error is issued if device type dev_type\nis not supported or no device of dev_type is available\n\tAnacc_error_device_unavailable error is issued if the value of dev_num is not\na valid device number\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc set device num,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc set device num. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc set device num in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc set device num, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 324 acc setdevice num\nSummary\nTheacc_set_device_num routine tells the runtime which device to use and sets the value of\nacc-current-device-num-var \nFormat\nC or C++:\nvoid acc_set_device_num(int dev_num, acc_device_t dev_t ype);\nFortran:\nsubroutine acc_set_device_num(dev_num, dev_type)\ninteger :: dev_num\ninteger(acc_device_kind) :: dev_type\nDescription\nA call toacc_set_device_num is functionally equivalent to a setdevice_type(dev_type)\ndevice_num(dev_num) directive, as described in Section 2143 This routine tells the runtime\nwhich device to use among those available of the given type for compute or da ta regions in the cur-\nrent thread and sets the value of acc-current-device-num-var todev_num  If the value of dev_num\nis negative, the runtime will revert to its default behavior, which is implementation -de\ufb01ned If the\nvalue of the dev_type is zero, the selected device number will be used for all device types Calling\nacc_set_device_num implies a call to acc_set_device_type(dev_type) \nErrors\n\tAnacc_error_device_type_unavailable error is issued if device type dev_type\nis not supported or no device of dev_type is available\n\tAnacc_error_device_unavailable error is issued if the value of dev_num is not\na valid device number\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc set device num,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc set device num. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc set device num in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc set device num, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 324 acc setdevice num\nSummary\nTheacc_set_device_num routine tells the runtime which device to use and sets the value of\nacc-current-device-num-var \nFormat\nC or C++:\nvoid acc_set_device_num(int dev_num, acc_device_t dev_t ype);\nFortran:\nsubroutine acc_set_device_num(dev_num, dev_type)\ninteger :: dev_num\ninteger(acc_device_kind) :: dev_type\nDescription\nA call toacc_set_device_num is functionally equivalent to a setdevice_type(dev_type)\ndevice_num(dev_num) directive, as described in Section 2143 This routine tells the runtime\nwhich device to use among those available of the given type for compute or da ta regions in the cur-\nrent thread and sets the value of acc-current-device-num-var todev_num  If the value of dev_num\nis negative, the runtime will revert to its default behavior, which is implementation -de\ufb01ned If the\nvalue of the dev_type is zero, the selected device number will be used for all device types Calling\nacc_set_device_num implies a call to acc_set_device_type(dev_type) \nErrors\n\tAnacc_error_device_type_unavailable error is issued if device type dev_type\nis not supported or no device of dev_type is available\n\tAnacc_error_device_unavailable error is issued if the value of dev_num is not\na valid device number\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc set device num,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc get device num. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc get device num in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc get device num, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 325 acc getdevice num\nSummary\nTheacc_get_device_num routine returns the value of acc-current-device-num-var for the cur-\nrent thread\nFormat\nC or C++:\nint acc_get_device_num(acc_device_t dev_type);\nFortran:\ninteger function acc_get_device_num(dev_type)\ninteger(acc_device_kind) :: dev_type\nDescription\nTheacc_get_device_num routine returns the value of acc-current-device-num-var for the cur-\nrent thread If there are no devices of device type dev_type or if device type dev_type is not\nsupported, this routine returns -1\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc get device num,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc get device num. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc get device num in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc get device num, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 325 acc getdevice num\nSummary\nTheacc_get_device_num routine returns the value of acc-current-device-num-var for the cur-\nrent thread\nFormat\nC or C++:\nint acc_get_device_num(acc_device_t dev_type);\nFortran:\ninteger function acc_get_device_num(dev_type)\ninteger(acc_device_kind) :: dev_type\nDescription\nTheacc_get_device_num routine returns the value of acc-current-device-num-var for the cur-\nrent thread If there are no devices of device type dev_type or if device type dev_type is not\nsupported, this routine returns -1\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc get device num,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc get device num. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc get device num in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc get device num, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 325 acc getdevice num\nSummary\nTheacc_get_device_num routine returns the value of acc-current-device-num-var for the cur-\nrent thread\nFormat\nC or C++:\nint acc_get_device_num(acc_device_t dev_type);\nFortran:\ninteger function acc_get_device_num(dev_type)\ninteger(acc_device_kind) :: dev_type\nDescription\nTheacc_get_device_num routine returns the value of acc-current-device-num-var for the cur-\nrent thread If there are no devices of device type dev_type or if device type dev_type is not\nsupported, this routine returns -1\n\nTemplate:\n\n#ifndef T1\n!T1:acc get device num,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc get property. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc get property in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc get property, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 326 acc getproperty\nSummary\nTheacc_get_property andacc_get_property_string routines return the value of a\ndevice-property for the speci\ufb01ed device\nFormat\nC or C++:\nsize_t acc_get_property(int dev_num,\nacc_device_t dev_type,\nacc_device_property_t property);\nconst\nchar*acc_get_property_string(int dev_num,\nacc_device_t dev_type,\nacc_device_property_t property);\nFortran:\nfunction acc_get_property(dev_num, dev_type, property)\nsubroutine acc_get_property_string(dev_num, dev_type, &\nproperty, string)\ninteger, value :: dev_num\ninteger(acc_device_kind), value :: dev_type\ninteger(acc_device_property_kind), value :: property\ninteger(c_size_t) :: acc_get_property\ncharacter *(*) :: string\nDescription\nTheacc_get_property andacc_get_property_string routines return the value of the\nproperty dev_num anddev_type specify the device being queried If dev_type has the\nvalueacc_device_current , thendev_num is ignored and the value of the property for the\ncurrent device is returned property is an enumeration constant, de\ufb01ned in openacch , for\nC or C++, or an integer parameter, de\ufb01ned in the openacc module, for Fortran Integer-valued\nproperties are returned by acc_get_property , and string-valued properties are returned by\nacc_get_property_string  In Fortran, acc_get_property_string returns the result\ninto thestring argument\nThe supported values of property are given in the following table\nproperty return type return value\nacc_property_memory integer size of device memory in bytes\nacc_property_free_memory integer free device memory in bytes\nacc_property_shared_memory_support\ninteger nonzero if the speci\ufb01ed device sup-\nports sharing memory with the local\nthread\nacc_property_name string device name\nacc_property_vendor string device vendor\nacc_property_driver string device driver version\nAn implementation may support additional properties for some devices\n\nRestrictions\n\tacc_get_property will return 0 and acc_get_property_string will return a null\npointer (in C or C++) or a blank string (in Fortran) in the following cases:\n\t\tIf device type dev_type is not supported or no device of dev_type is available\n\t\tIf the value of dev_num is not a valid device number for device type dev_type \n\t\tIf the value of property is not one of the known values for that query routine, or that\nproperty has no value for the speci\ufb01ed device\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc get property,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc get property. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc get property in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc get property, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 326 acc getproperty\nSummary\nTheacc_get_property andacc_get_property_string routines return the value of a\ndevice-property for the speci\ufb01ed device\nFormat\nC or C++:\nsize_t acc_get_property(int dev_num,\nacc_device_t dev_type,\nacc_device_property_t property);\nconst\nchar*acc_get_property_string(int dev_num,\nacc_device_t dev_type,\nacc_device_property_t property);\nFortran:\nfunction acc_get_property(dev_num, dev_type, property)\nsubroutine acc_get_property_string(dev_num, dev_type, &\nproperty, string)\ninteger, value :: dev_num\ninteger(acc_device_kind), value :: dev_type\ninteger(acc_device_property_kind), value :: property\ninteger(c_size_t) :: acc_get_property\ncharacter *(*) :: string\nDescription\nTheacc_get_property andacc_get_property_string routines return the value of the\nproperty dev_num anddev_type specify the device being queried If dev_type has the\nvalueacc_device_current , thendev_num is ignored and the value of the property for the\ncurrent device is returned property is an enumeration constant, de\ufb01ned in openacch , for\nC or C++, or an integer parameter, de\ufb01ned in the openacc module, for Fortran Integer-valued\nproperties are returned by acc_get_property , and string-valued properties are returned by\nacc_get_property_string  In Fortran, acc_get_property_string returns the result\ninto thestring argument\nThe supported values of property are given in the following table\nproperty return type return value\nacc_property_memory integer size of device memory in bytes\nacc_property_free_memory integer free device memory in bytes\nacc_property_shared_memory_support\ninteger nonzero if the speci\ufb01ed device sup-\nports sharing memory with the local\nthread\nacc_property_name string device name\nacc_property_vendor string device vendor\nacc_property_driver string device driver version\nAn implementation may support additional properties for some devices\n\nRestrictions\n\tacc_get_property will return 0 and acc_get_property_string will return a null\npointer (in C or C++) or a blank string (in Fortran) in the following cases:\n\t\tIf device type dev_type is not supported or no device of dev_type is available\n\t\tIf the value of dev_num is not a valid device number for device type dev_type \n\t\tIf the value of property is not one of the known values for that query routine, or that\nproperty has no value for the speci\ufb01ed device\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc get property,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc get property. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc get property in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc get property, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 326 acc getproperty\nSummary\nTheacc_get_property andacc_get_property_string routines return the value of a\ndevice-property for the speci\ufb01ed device\nFormat\nC or C++:\nsize_t acc_get_property(int dev_num,\nacc_device_t dev_type,\nacc_device_property_t property);\nconst\nchar*acc_get_property_string(int dev_num,\nacc_device_t dev_type,\nacc_device_property_t property);\nFortran:\nfunction acc_get_property(dev_num, dev_type, property)\nsubroutine acc_get_property_string(dev_num, dev_type, &\nproperty, string)\ninteger, value :: dev_num\ninteger(acc_device_kind), value :: dev_type\ninteger(acc_device_property_kind), value :: property\ninteger(c_size_t) :: acc_get_property\ncharacter *(*) :: string\nDescription\nTheacc_get_property andacc_get_property_string routines return the value of the\nproperty dev_num anddev_type specify the device being queried If dev_type has the\nvalueacc_device_current , thendev_num is ignored and the value of the property for the\ncurrent device is returned property is an enumeration constant, de\ufb01ned in openacch , for\nC or C++, or an integer parameter, de\ufb01ned in the openacc module, for Fortran Integer-valued\nproperties are returned by acc_get_property , and string-valued properties are returned by\nacc_get_property_string  In Fortran, acc_get_property_string returns the result\ninto thestring argument\nThe supported values of property are given in the following table\nproperty return type return value\nacc_property_memory integer size of device memory in bytes\nacc_property_free_memory integer free device memory in bytes\nacc_property_shared_memory_support\ninteger nonzero if the speci\ufb01ed device sup-\nports sharing memory with the local\nthread\nacc_property_name string device name\nacc_property_vendor string device vendor\nacc_property_driver string device driver version\nAn implementation may support additional properties for some devices\n\nRestrictions\n\tacc_get_property will return 0 and acc_get_property_string will return a null\npointer (in C or C++) or a blank string (in Fortran) in the following cases:\n\t\tIf device type dev_type is not supported or no device of dev_type is available\n\t\tIf the value of dev_num is not a valid device number for device type dev_type \n\t\tIf the value of property is not one of the known values for that query routine, or that\nproperty has no value for the speci\ufb01ed device\n\nTemplate:\n\n#ifndef T1\n!T1:acc get property,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc init. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc init in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc init, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 327 acc init\nSummary\nTheacc_init andacc_init_device routines initialize the runtime for the speci\ufb01ed device\ntype and device number This can be used to isolate any initialization cost from the computational\ncost, such as when collecting performance statistics\nFormat\nC or C++:\nvoid acc_init(acc_device_t dev_type);\nvoid acc_init_device(int dev_num, acc_device_t dev_type );\nFortran:\nsubroutine acc_init(dev_type)\nsubroutine acc_init_device(dev_num, dev_type)\ninteger :: dev_num\ninteger(acc_device_kind) :: dev_type\nDescription\nA call toacc_init oracc_init_device is functionally equivalent to an init directive with\nmatchingdev_type anddev_num arguments, as described in Section 2141 dev_type must\nbe one of the de\ufb01ned accelerator types dev_num must be a valid device number of the device type\ndev_type  These routines also implicitly call acc_set_device_type(dev_type)  In the\ncase ofacc_init_device ,acc_set_device_num(dev_num) is also called\nIf a program initializes one or more devices without an intervening shutdown directive or\nacc_shutdown call to shut down those same devices, no action is taken\nErrors\n\tAnacc_error_device_type_unavailable error is issued if device type dev_type\nis not supported or no device of dev_type is available\n\tAnacc_error_device_unavailable error is issued if dev_num is not a valid device\nnumber\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc init,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc init. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc init in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc init, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 327 acc init\nSummary\nTheacc_init andacc_init_device routines initialize the runtime for the speci\ufb01ed device\ntype and device number This can be used to isolate any initialization cost from the computational\ncost, such as when collecting performance statistics\nFormat\nC or C++:\nvoid acc_init(acc_device_t dev_type);\nvoid acc_init_device(int dev_num, acc_device_t dev_type );\nFortran:\nsubroutine acc_init(dev_type)\nsubroutine acc_init_device(dev_num, dev_type)\ninteger :: dev_num\ninteger(acc_device_kind) :: dev_type\nDescription\nA call toacc_init oracc_init_device is functionally equivalent to an init directive with\nmatchingdev_type anddev_num arguments, as described in Section 2141 dev_type must\nbe one of the de\ufb01ned accelerator types dev_num must be a valid device number of the device type\ndev_type  These routines also implicitly call acc_set_device_type(dev_type)  In the\ncase ofacc_init_device ,acc_set_device_num(dev_num) is also called\nIf a program initializes one or more devices without an intervening shutdown directive or\nacc_shutdown call to shut down those same devices, no action is taken\nErrors\n\tAnacc_error_device_type_unavailable error is issued if device type dev_type\nis not supported or no device of dev_type is available\n\tAnacc_error_device_unavailable error is issued if dev_num is not a valid device\nnumber\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc init,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc init. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc init in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc init, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 327 acc init\nSummary\nTheacc_init andacc_init_device routines initialize the runtime for the speci\ufb01ed device\ntype and device number This can be used to isolate any initialization cost from the computational\ncost, such as when collecting performance statistics\nFormat\nC or C++:\nvoid acc_init(acc_device_t dev_type);\nvoid acc_init_device(int dev_num, acc_device_t dev_type );\nFortran:\nsubroutine acc_init(dev_type)\nsubroutine acc_init_device(dev_num, dev_type)\ninteger :: dev_num\ninteger(acc_device_kind) :: dev_type\nDescription\nA call toacc_init oracc_init_device is functionally equivalent to an init directive with\nmatchingdev_type anddev_num arguments, as described in Section 2141 dev_type must\nbe one of the de\ufb01ned accelerator types dev_num must be a valid device number of the device type\ndev_type  These routines also implicitly call acc_set_device_type(dev_type)  In the\ncase ofacc_init_device ,acc_set_device_num(dev_num) is also called\nIf a program initializes one or more devices without an intervening shutdown directive or\nacc_shutdown call to shut down those same devices, no action is taken\nErrors\n\tAnacc_error_device_type_unavailable error is issued if device type dev_type\nis not supported or no device of dev_type is available\n\tAnacc_error_device_unavailable error is issued if dev_num is not a valid device\nnumber\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc init,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc shutdown. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc shutdown in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc shutdown, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 328 acc shutdown\n\nSummary\nTheacc_shutdown andacc_shutdown_device routines shut down the connection to spec-\ni\ufb01ed devices and free up any related resources in the runtime This ends a ll data lifetimes in device\nmemory for the device or devices that are shut down, which effectively s ets structured and dynamic\nreference counters to zero\nFormat\nC or C++:\nvoid acc_shutdown(acc_device_t dev_type);\nvoid acc_shutdown_device(int dev_num, acc_device_t dev_ type);\nFortran:\nsubroutine acc_shutdown(dev_type)\nsubroutine acc_shutdown_device(dev_num, dev_type)\ninteger :: dev_num\ninteger(acc_device_kind) :: dev_type\nDescription\nA call toacc_shutdown oracc_shutdown_device is functionally equivalent to a shutdown\ndirective, with matching dev_type anddev_num arguments, as described in Section 2142\ndev_type must be one of the de\ufb01ned accelerator types dev_num must be a valid device number\nof the device type dev_type acc_shutdown routine disconnects the program from all devices\nof device type dev_type  Theacc_shutdown_device routine disconnects the program from\ndev_num of typedev_type  Any data that is present in the memory of a device that is shut down\nis immediately deallocated\nRestrictions\n\tThis routine may not be called while a compute region is executing on a device of type\ndev_type \n\tIf the program attempts to execute a compute region on a device or to access a ny data in the\nmemory of a device that was shut down, the behavior is unde\ufb01ned\n\tIf the program attempts to shut down the acc_device_host device type, the behavior is\nunde\ufb01ned\nErrors\n\tAnacc_error_device_type_unavailable error is issued if device type dev_type\nis not supported or no device of dev_type is available\n\tAnacc_error_device_unavailable error is issued if dev_num is not a valid device\nnumber\n\tAnacc_error_device_shutdown error is issued if there is an error shutting down the\ndevice\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc shutdown,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc shutdown. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc shutdown in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc shutdown, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 328 acc shutdown\n\nSummary\nTheacc_shutdown andacc_shutdown_device routines shut down the connection to spec-\ni\ufb01ed devices and free up any related resources in the runtime This ends a ll data lifetimes in device\nmemory for the device or devices that are shut down, which effectively s ets structured and dynamic\nreference counters to zero\nFormat\nC or C++:\nvoid acc_shutdown(acc_device_t dev_type);\nvoid acc_shutdown_device(int dev_num, acc_device_t dev_ type);\nFortran:\nsubroutine acc_shutdown(dev_type)\nsubroutine acc_shutdown_device(dev_num, dev_type)\ninteger :: dev_num\ninteger(acc_device_kind) :: dev_type\nDescription\nA call toacc_shutdown oracc_shutdown_device is functionally equivalent to a shutdown\ndirective, with matching dev_type anddev_num arguments, as described in Section 2142\ndev_type must be one of the de\ufb01ned accelerator types dev_num must be a valid device number\nof the device type dev_type acc_shutdown routine disconnects the program from all devices\nof device type dev_type  Theacc_shutdown_device routine disconnects the program from\ndev_num of typedev_type  Any data that is present in the memory of a device that is shut down\nis immediately deallocated\nRestrictions\n\tThis routine may not be called while a compute region is executing on a device of type\ndev_type \n\tIf the program attempts to execute a compute region on a device or to access a ny data in the\nmemory of a device that was shut down, the behavior is unde\ufb01ned\n\tIf the program attempts to shut down the acc_device_host device type, the behavior is\nunde\ufb01ned\nErrors\n\tAnacc_error_device_type_unavailable error is issued if device type dev_type\nis not supported or no device of dev_type is available\n\tAnacc_error_device_unavailable error is issued if dev_num is not a valid device\nnumber\n\tAnacc_error_device_shutdown error is issued if there is an error shutting down the\ndevice\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc shutdown,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc shutdown. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc shutdown in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc shutdown, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 328 acc shutdown\n\nSummary\nTheacc_shutdown andacc_shutdown_device routines shut down the connection to spec-\ni\ufb01ed devices and free up any related resources in the runtime This ends a ll data lifetimes in device\nmemory for the device or devices that are shut down, which effectively s ets structured and dynamic\nreference counters to zero\nFormat\nC or C++:\nvoid acc_shutdown(acc_device_t dev_type);\nvoid acc_shutdown_device(int dev_num, acc_device_t dev_ type);\nFortran:\nsubroutine acc_shutdown(dev_type)\nsubroutine acc_shutdown_device(dev_num, dev_type)\ninteger :: dev_num\ninteger(acc_device_kind) :: dev_type\nDescription\nA call toacc_shutdown oracc_shutdown_device is functionally equivalent to a shutdown\ndirective, with matching dev_type anddev_num arguments, as described in Section 2142\ndev_type must be one of the de\ufb01ned accelerator types dev_num must be a valid device number\nof the device type dev_type acc_shutdown routine disconnects the program from all devices\nof device type dev_type  Theacc_shutdown_device routine disconnects the program from\ndev_num of typedev_type  Any data that is present in the memory of a device that is shut down\nis immediately deallocated\nRestrictions\n\tThis routine may not be called while a compute region is executing on a device of type\ndev_type \n\tIf the program attempts to execute a compute region on a device or to access a ny data in the\nmemory of a device that was shut down, the behavior is unde\ufb01ned\n\tIf the program attempts to shut down the acc_device_host device type, the behavior is\nunde\ufb01ned\nErrors\n\tAnacc_error_device_type_unavailable error is issued if device type dev_type\nis not supported or no device of dev_type is available\n\tAnacc_error_device_unavailable error is issued if dev_num is not a valid device\nnumber\n\tAnacc_error_device_shutdown error is issued if there is an error shutting down the\ndevice\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc shutdown,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc async test. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc async test in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc async test, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 329 acc async test\nSummary\nTheacc_async_test routines test for completion of all associated asynchronous operations f or\na single speci\ufb01ed async queue or for all async queues on the current device or on a speci\ufb01ed device\n\nFormat\nC or C++:\nint acc_async_test(int wait_arg);\nint acc_async_test_device(int wait_arg, int dev_num);\nint acc_async_test_all(void);\nint acc_async_test_all_device(int dev_num);\nFortran:\nlogical function acc_async_test(wait_arg)\nlogical function acc_async_test_device(wait_arg, dev_n um)\nlogical function acc_async_test_all()\nlogical function acc_async_test_all_device(dev_num)\ninteger(acc_handle_kind) :: wait_arg\ninteger :: dev_num\nDescription\nwait_arg must be an async-argument as de\ufb01ned in Section 216 Asynchronous Behavior dev_num\nmust be a valid device number of the current device type\nThe behavior of the acc_async_test routines is:\n\tIf there is no dev_num argument, it is treated as if dev_num is the current device number\n\tIf any asynchronous operations initiated by this host thread on device dev_num either on\nasync queue wait_arg (if there is a wait_arg argument), or on any async queue (if there\nis nowait_arg argument) have not completed, a call to the routine returns false \n\tIf all such asynchronous operations have completed, or there are no s uch asynchronous op-\nerations, a call to the routine returns true A return value of true is no guarantee that asyn-\nchronous operations initiated by other host threads have completed\nErrors\n\tAnacc_error_invalid_async error is issued if wait_arg is not a valid async-\nargument value\n\tAnacc_error_device_unavailable error is issued if dev_num is not a valid device\nnumber\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc async test,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc async test. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc async test in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc async test, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 329 acc async test\nSummary\nTheacc_async_test routines test for completion of all associated asynchronous operations f or\na single speci\ufb01ed async queue or for all async queues on the current device or on a speci\ufb01ed device\n\nFormat\nC or C++:\nint acc_async_test(int wait_arg);\nint acc_async_test_device(int wait_arg, int dev_num);\nint acc_async_test_all(void);\nint acc_async_test_all_device(int dev_num);\nFortran:\nlogical function acc_async_test(wait_arg)\nlogical function acc_async_test_device(wait_arg, dev_n um)\nlogical function acc_async_test_all()\nlogical function acc_async_test_all_device(dev_num)\ninteger(acc_handle_kind) :: wait_arg\ninteger :: dev_num\nDescription\nwait_arg must be an async-argument as de\ufb01ned in Section 216 Asynchronous Behavior dev_num\nmust be a valid device number of the current device type\nThe behavior of the acc_async_test routines is:\n\tIf there is no dev_num argument, it is treated as if dev_num is the current device number\n\tIf any asynchronous operations initiated by this host thread on device dev_num either on\nasync queue wait_arg (if there is a wait_arg argument), or on any async queue (if there\nis nowait_arg argument) have not completed, a call to the routine returns false \n\tIf all such asynchronous operations have completed, or there are no s uch asynchronous op-\nerations, a call to the routine returns true A return value of true is no guarantee that asyn-\nchronous operations initiated by other host threads have completed\nErrors\n\tAnacc_error_invalid_async error is issued if wait_arg is not a valid async-\nargument value\n\tAnacc_error_device_unavailable error is issued if dev_num is not a valid device\nnumber\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc async test,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc async test. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc async test in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc async test, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 329 acc async test\nSummary\nTheacc_async_test routines test for completion of all associated asynchronous operations f or\na single speci\ufb01ed async queue or for all async queues on the current device or on a speci\ufb01ed device\n\nFormat\nC or C++:\nint acc_async_test(int wait_arg);\nint acc_async_test_device(int wait_arg, int dev_num);\nint acc_async_test_all(void);\nint acc_async_test_all_device(int dev_num);\nFortran:\nlogical function acc_async_test(wait_arg)\nlogical function acc_async_test_device(wait_arg, dev_n um)\nlogical function acc_async_test_all()\nlogical function acc_async_test_all_device(dev_num)\ninteger(acc_handle_kind) :: wait_arg\ninteger :: dev_num\nDescription\nwait_arg must be an async-argument as de\ufb01ned in Section 216 Asynchronous Behavior dev_num\nmust be a valid device number of the current device type\nThe behavior of the acc_async_test routines is:\n\tIf there is no dev_num argument, it is treated as if dev_num is the current device number\n\tIf any asynchronous operations initiated by this host thread on device dev_num either on\nasync queue wait_arg (if there is a wait_arg argument), or on any async queue (if there\nis nowait_arg argument) have not completed, a call to the routine returns false \n\tIf all such asynchronous operations have completed, or there are no s uch asynchronous op-\nerations, a call to the routine returns true A return value of true is no guarantee that asyn-\nchronous operations initiated by other host threads have completed\nErrors\n\tAnacc_error_invalid_async error is issued if wait_arg is not a valid async-\nargument value\n\tAnacc_error_device_unavailable error is issued if dev_num is not a valid device\nnumber\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc async test,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc wait. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc wait in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc wait, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3210 acc wait\nSummary\nTheacc_wait routines wait for completion of all associated asynchronous operations o n a single\nspeci\ufb01ed async queue or on all async queues on the current device o r on a speci\ufb01ed device\nFormat\nC or C++:\nvoid acc_wait(int wait_arg);\nvoid acc_wait_device(int wait_arg, int dev_num);\nvoid acc_wait_all(void);\nvoid acc_wait_all_device(int dev_num);\n\nFortran:\nsubroutine acc_wait(wait_arg)\nsubroutine acc_wait_device(wait_arg, dev_num)\nsubroutine acc_wait_all()\nsubroutine acc_wait_all_device(dev_num)\ninteger(acc_handle_kind) :: wait_arg\ninteger :: dev_num\nDescription\nA call to an acc_wait routine is functionally equivalent to a wait directive as follows, see Sec-\ntion 2163:\n\tacc_wait to await(wait_arg) directive\n\tacc_wait_device to await(devnum:dev_num,queues:wait_arg) directive\n\tacc_wait_all to await directive with no wait-argument \n\tacc_wait_all_device to await(devnum:dev_num) directive\nwait_arg must be an async-argument as de\ufb01ned in Section 216 Asynchronous Behavior dev_num\nmust be a valid device number of the current device type\nThe behavior of the acc_wait routines is:\n\tIf there is no dev_num argument, it is treated as if dev_num is the current device number\n\tThe routine will not return until all asynchronous operations initiated by this host thread on\ndevicedev_num either on async queue wait_arg (if there is a wait_arg argument) or\non all async queues (if there is no wait_arg argument) have completed\n\tIf two or more threads share the same accelerator, there is no guarantee th at matching asyn-\nchronous operations initiated by other threads have completed\nFor compatibility with OpenACC version 10, acc_wait may also be spelled acc_async_wait ,\nandacc_wait_all may also be spelled acc_async_wait_all \nErrors\n\tAnacc_error_invalid_async error is issued if wait_arg is not a valid async-\nargument value\n\tAnacc_error_device_unavailable error is issued if dev_num is not a valid device\nnumber\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc wait,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc wait. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc wait in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc wait, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3210 acc wait\nSummary\nTheacc_wait routines wait for completion of all associated asynchronous operations o n a single\nspeci\ufb01ed async queue or on all async queues on the current device o r on a speci\ufb01ed device\nFormat\nC or C++:\nvoid acc_wait(int wait_arg);\nvoid acc_wait_device(int wait_arg, int dev_num);\nvoid acc_wait_all(void);\nvoid acc_wait_all_device(int dev_num);\n\nFortran:\nsubroutine acc_wait(wait_arg)\nsubroutine acc_wait_device(wait_arg, dev_num)\nsubroutine acc_wait_all()\nsubroutine acc_wait_all_device(dev_num)\ninteger(acc_handle_kind) :: wait_arg\ninteger :: dev_num\nDescription\nA call to an acc_wait routine is functionally equivalent to a wait directive as follows, see Sec-\ntion 2163:\n\tacc_wait to await(wait_arg) directive\n\tacc_wait_device to await(devnum:dev_num,queues:wait_arg) directive\n\tacc_wait_all to await directive with no wait-argument \n\tacc_wait_all_device to await(devnum:dev_num) directive\nwait_arg must be an async-argument as de\ufb01ned in Section 216 Asynchronous Behavior dev_num\nmust be a valid device number of the current device type\nThe behavior of the acc_wait routines is:\n\tIf there is no dev_num argument, it is treated as if dev_num is the current device number\n\tThe routine will not return until all asynchronous operations initiated by this host thread on\ndevicedev_num either on async queue wait_arg (if there is a wait_arg argument) or\non all async queues (if there is no wait_arg argument) have completed\n\tIf two or more threads share the same accelerator, there is no guarantee th at matching asyn-\nchronous operations initiated by other threads have completed\nFor compatibility with OpenACC version 10, acc_wait may also be spelled acc_async_wait ,\nandacc_wait_all may also be spelled acc_async_wait_all \nErrors\n\tAnacc_error_invalid_async error is issued if wait_arg is not a valid async-\nargument value\n\tAnacc_error_device_unavailable error is issued if dev_num is not a valid device\nnumber\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc wait,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc wait. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc wait in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc wait, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3210 acc wait\nSummary\nTheacc_wait routines wait for completion of all associated asynchronous operations o n a single\nspeci\ufb01ed async queue or on all async queues on the current device o r on a speci\ufb01ed device\nFormat\nC or C++:\nvoid acc_wait(int wait_arg);\nvoid acc_wait_device(int wait_arg, int dev_num);\nvoid acc_wait_all(void);\nvoid acc_wait_all_device(int dev_num);\n\nFortran:\nsubroutine acc_wait(wait_arg)\nsubroutine acc_wait_device(wait_arg, dev_num)\nsubroutine acc_wait_all()\nsubroutine acc_wait_all_device(dev_num)\ninteger(acc_handle_kind) :: wait_arg\ninteger :: dev_num\nDescription\nA call to an acc_wait routine is functionally equivalent to a wait directive as follows, see Sec-\ntion 2163:\n\tacc_wait to await(wait_arg) directive\n\tacc_wait_device to await(devnum:dev_num,queues:wait_arg) directive\n\tacc_wait_all to await directive with no wait-argument \n\tacc_wait_all_device to await(devnum:dev_num) directive\nwait_arg must be an async-argument as de\ufb01ned in Section 216 Asynchronous Behavior dev_num\nmust be a valid device number of the current device type\nThe behavior of the acc_wait routines is:\n\tIf there is no dev_num argument, it is treated as if dev_num is the current device number\n\tThe routine will not return until all asynchronous operations initiated by this host thread on\ndevicedev_num either on async queue wait_arg (if there is a wait_arg argument) or\non all async queues (if there is no wait_arg argument) have completed\n\tIf two or more threads share the same accelerator, there is no guarantee th at matching asyn-\nchronous operations initiated by other threads have completed\nFor compatibility with OpenACC version 10, acc_wait may also be spelled acc_async_wait ,\nandacc_wait_all may also be spelled acc_async_wait_all \nErrors\n\tAnacc_error_invalid_async error is issued if wait_arg is not a valid async-\nargument value\n\tAnacc_error_device_unavailable error is issued if dev_num is not a valid device\nnumber\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc wait,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc wait async. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc wait async in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc wait async, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3211 acc wait async\nSummary\nTheacc_wait_async routines enqueue a wait operation on one async queue of the current\ndevice or a speci\ufb01ed device for the operations previously enqueued on a single speci\ufb01ed async\nqueue or on all other async queues\n\nFormat\nC or C++:\nvoid acc_wait_async(int wait_arg, int async_arg);\nvoid acc_wait_device_async(int wait_arg, int async_arg,\nint dev_num);\nvoid acc_wait_all_async(int async_arg);\nvoid acc_wait_all_device_async(int async_arg, int dev_n um);\nFortran:\nsubroutine acc_wait_async(wait_arg, async_arg)\nsubroutine acc_wait_device_async(wait_arg, async_arg, dev_num)\nsubroutine acc_wait_all_async(async_arg)\nsubroutine acc_wait_all_device_async(async_arg, dev_n um)\ninteger(acc_handle_kind) :: wait_arg, async_arg\ninteger :: dev_num\nDescription\nA call to an acc_wait_async routine is functionally equivalent to a waitasync(async_arg)\ndirective as follows, see Section 2163:\n\tA call toacc_wait_async is functionally equivalent to a wait(wait_arg)\nasync(async_arg) directive\n\tA call toacc_wait_device_async is functionally equivalent to a wait(devnum:\ndev_num,queues:wait_arg)async(async_arg) directive\n\tA call toacc_wait_all_async is functionally equivalent to a waitasync(async_arg)\ndirective with no wait-argument \n\tA call toacc_wait_all_device_async is functionally equivalent to a\nwait(devnum:dev_num)async(async_arg) directive\nasync_arg andwait_arg must must be async-arguments , as de\ufb01ned in\nSection 216 Asynchronous Behavior dev_num must be a valid device number of the current\ndevice type\nThe behavior of the acc_wait_async routines is:\n\tIf there is no dev_num argument, it is treated as if dev_num is the current device number\n\tThe routine will enqueue a wait operation on the async queue associated w ithasync_arg\nfor the current device which will wait for operations initiated on the async q ueuewait_arg\nof devicedev_num (if there is a wait_arg argument), or for each async queue of device\ndev_num (if there is no wait_arg argument)\nSee Section 216 Asynchronous Behavior for more information\nErrors\n\tAnacc_error_invalid_async error is issued if either async_arg orwait_arg is\nnot a valid async-argument value\n\tAnacc_error_device_unavailable error is issued if dev_num is not a valid device\nnumber\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc wait async,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc wait async. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc wait async in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc wait async, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3211 acc wait async\nSummary\nTheacc_wait_async routines enqueue a wait operation on one async queue of the current\ndevice or a speci\ufb01ed device for the operations previously enqueued on a single speci\ufb01ed async\nqueue or on all other async queues\n\nFormat\nC or C++:\nvoid acc_wait_async(int wait_arg, int async_arg);\nvoid acc_wait_device_async(int wait_arg, int async_arg,\nint dev_num);\nvoid acc_wait_all_async(int async_arg);\nvoid acc_wait_all_device_async(int async_arg, int dev_n um);\nFortran:\nsubroutine acc_wait_async(wait_arg, async_arg)\nsubroutine acc_wait_device_async(wait_arg, async_arg, dev_num)\nsubroutine acc_wait_all_async(async_arg)\nsubroutine acc_wait_all_device_async(async_arg, dev_n um)\ninteger(acc_handle_kind) :: wait_arg, async_arg\ninteger :: dev_num\nDescription\nA call to an acc_wait_async routine is functionally equivalent to a waitasync(async_arg)\ndirective as follows, see Section 2163:\n\tA call toacc_wait_async is functionally equivalent to a wait(wait_arg)\nasync(async_arg) directive\n\tA call toacc_wait_device_async is functionally equivalent to a wait(devnum:\ndev_num,queues:wait_arg)async(async_arg) directive\n\tA call toacc_wait_all_async is functionally equivalent to a waitasync(async_arg)\ndirective with no wait-argument \n\tA call toacc_wait_all_device_async is functionally equivalent to a\nwait(devnum:dev_num)async(async_arg) directive\nasync_arg andwait_arg must must be async-arguments , as de\ufb01ned in\nSection 216 Asynchronous Behavior dev_num must be a valid device number of the current\ndevice type\nThe behavior of the acc_wait_async routines is:\n\tIf there is no dev_num argument, it is treated as if dev_num is the current device number\n\tThe routine will enqueue a wait operation on the async queue associated w ithasync_arg\nfor the current device which will wait for operations initiated on the async q ueuewait_arg\nof devicedev_num (if there is a wait_arg argument), or for each async queue of device\ndev_num (if there is no wait_arg argument)\nSee Section 216 Asynchronous Behavior for more information\nErrors\n\tAnacc_error_invalid_async error is issued if either async_arg orwait_arg is\nnot a valid async-argument value\n\tAnacc_error_device_unavailable error is issued if dev_num is not a valid device\nnumber\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc wait async,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc wait async. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc wait async in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc wait async, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3211 acc wait async\nSummary\nTheacc_wait_async routines enqueue a wait operation on one async queue of the current\ndevice or a speci\ufb01ed device for the operations previously enqueued on a single speci\ufb01ed async\nqueue or on all other async queues\n\nFormat\nC or C++:\nvoid acc_wait_async(int wait_arg, int async_arg);\nvoid acc_wait_device_async(int wait_arg, int async_arg,\nint dev_num);\nvoid acc_wait_all_async(int async_arg);\nvoid acc_wait_all_device_async(int async_arg, int dev_n um);\nFortran:\nsubroutine acc_wait_async(wait_arg, async_arg)\nsubroutine acc_wait_device_async(wait_arg, async_arg, dev_num)\nsubroutine acc_wait_all_async(async_arg)\nsubroutine acc_wait_all_device_async(async_arg, dev_n um)\ninteger(acc_handle_kind) :: wait_arg, async_arg\ninteger :: dev_num\nDescription\nA call to an acc_wait_async routine is functionally equivalent to a waitasync(async_arg)\ndirective as follows, see Section 2163:\n\tA call toacc_wait_async is functionally equivalent to a wait(wait_arg)\nasync(async_arg) directive\n\tA call toacc_wait_device_async is functionally equivalent to a wait(devnum:\ndev_num,queues:wait_arg)async(async_arg) directive\n\tA call toacc_wait_all_async is functionally equivalent to a waitasync(async_arg)\ndirective with no wait-argument \n\tA call toacc_wait_all_device_async is functionally equivalent to a\nwait(devnum:dev_num)async(async_arg) directive\nasync_arg andwait_arg must must be async-arguments , as de\ufb01ned in\nSection 216 Asynchronous Behavior dev_num must be a valid device number of the current\ndevice type\nThe behavior of the acc_wait_async routines is:\n\tIf there is no dev_num argument, it is treated as if dev_num is the current device number\n\tThe routine will enqueue a wait operation on the async queue associated w ithasync_arg\nfor the current device which will wait for operations initiated on the async q ueuewait_arg\nof devicedev_num (if there is a wait_arg argument), or for each async queue of device\ndev_num (if there is no wait_arg argument)\nSee Section 216 Asynchronous Behavior for more information\nErrors\n\tAnacc_error_invalid_async error is issued if either async_arg orwait_arg is\nnot a valid async-argument value\n\tAnacc_error_device_unavailable error is issued if dev_num is not a valid device\nnumber\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc wait async,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc wait any. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc wait any in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc wait any, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3212 acc wait any\nSummary\nTheacc_wait_any andacc_wait_any_device routines wait for any of the speci\ufb01ed asyn-\nchronous queues to complete all pending operations on the current devic e or the speci\ufb01ed device\nnumber, respectively Both routines return the queue\u2019s index in the prov ided array of asynchronous\nqueues\nFormat\nC or C++:\nint acc_wait_any(int count, int wait_arg[]);\nint acc_wait_any_device(int count, int wait_arg[], int de v_num);\nFortran:\ninteger function acc_wait_any(count, wait_arg)\ninteger function acc_wait_any_device(count, wait_arg, d ev_num)\ninteger :: count, dev_num\ninteger(acc_handle_kind) :: wait_arg(count)\nDescription\nwait_arg is an array of async-arguments as de\ufb01ned in Section 216 and count is a nonneg-\native integer indicating the array length If there is no dev_num argument, it is treated as if\ndev_num is the current device number Otherwise, dev_num must be a valid device number\nof the current device type A call to any of these routines returns an inde xiassociated with\nawait_arg[i] that is not acc_async_sync and meets the conditions that would evalu-\nateacc_async_test_device(wait_arg[i], dev_num) totrue If all the elements in\nwait_arg are equal to acc_async_sync orcount is equal to 0, these routines return -1\nOtherwise, the return value is an integer in the range of 0\u2264i<count in C or C++ and\n1\u2264i\u2264count in Fortran\nErrors\n\tAnacc_error_invalid_argument error is issued if count is a negative number\n\tAnacc_error_invalid_async error is issued if any element encountered in wait_arg\nis not a valid async-argument value\n\tAnacc_error_device_unavailable error is issued if dev_num is not a valid device\nnumber\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc wait any,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc wait any. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc wait any in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc wait any, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3212 acc wait any\nSummary\nTheacc_wait_any andacc_wait_any_device routines wait for any of the speci\ufb01ed asyn-\nchronous queues to complete all pending operations on the current devic e or the speci\ufb01ed device\nnumber, respectively Both routines return the queue\u2019s index in the prov ided array of asynchronous\nqueues\nFormat\nC or C++:\nint acc_wait_any(int count, int wait_arg[]);\nint acc_wait_any_device(int count, int wait_arg[], int de v_num);\nFortran:\ninteger function acc_wait_any(count, wait_arg)\ninteger function acc_wait_any_device(count, wait_arg, d ev_num)\ninteger :: count, dev_num\ninteger(acc_handle_kind) :: wait_arg(count)\nDescription\nwait_arg is an array of async-arguments as de\ufb01ned in Section 216 and count is a nonneg-\native integer indicating the array length If there is no dev_num argument, it is treated as if\ndev_num is the current device number Otherwise, dev_num must be a valid device number\nof the current device type A call to any of these routines returns an inde xiassociated with\nawait_arg[i] that is not acc_async_sync and meets the conditions that would evalu-\nateacc_async_test_device(wait_arg[i], dev_num) totrue If all the elements in\nwait_arg are equal to acc_async_sync orcount is equal to 0, these routines return -1\nOtherwise, the return value is an integer in the range of 0\u2264i<count in C or C++ and\n1\u2264i\u2264count in Fortran\nErrors\n\tAnacc_error_invalid_argument error is issued if count is a negative number\n\tAnacc_error_invalid_async error is issued if any element encountered in wait_arg\nis not a valid async-argument value\n\tAnacc_error_device_unavailable error is issued if dev_num is not a valid device\nnumber\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc wait any,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc wait any. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc wait any in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc wait any, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3212 acc wait any\nSummary\nTheacc_wait_any andacc_wait_any_device routines wait for any of the speci\ufb01ed asyn-\nchronous queues to complete all pending operations on the current devic e or the speci\ufb01ed device\nnumber, respectively Both routines return the queue\u2019s index in the prov ided array of asynchronous\nqueues\nFormat\nC or C++:\nint acc_wait_any(int count, int wait_arg[]);\nint acc_wait_any_device(int count, int wait_arg[], int de v_num);\nFortran:\ninteger function acc_wait_any(count, wait_arg)\ninteger function acc_wait_any_device(count, wait_arg, d ev_num)\ninteger :: count, dev_num\ninteger(acc_handle_kind) :: wait_arg(count)\nDescription\nwait_arg is an array of async-arguments as de\ufb01ned in Section 216 and count is a nonneg-\native integer indicating the array length If there is no dev_num argument, it is treated as if\ndev_num is the current device number Otherwise, dev_num must be a valid device number\nof the current device type A call to any of these routines returns an inde xiassociated with\nawait_arg[i] that is not acc_async_sync and meets the conditions that would evalu-\nateacc_async_test_device(wait_arg[i], dev_num) totrue If all the elements in\nwait_arg are equal to acc_async_sync orcount is equal to 0, these routines return -1\nOtherwise, the return value is an integer in the range of 0\u2264i<count in C or C++ and\n1\u2264i\u2264count in Fortran\nErrors\n\tAnacc_error_invalid_argument error is issued if count is a negative number\n\tAnacc_error_invalid_async error is issued if any element encountered in wait_arg\nis not a valid async-argument value\n\tAnacc_error_device_unavailable error is issued if dev_num is not a valid device\nnumber\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc wait any,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc get default async. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc get default async in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc get default async, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3213 acc getdefault async\nSummary\nTheacc_get_default_async routine returns the value of acc-default-async-var for the cur-\nrent thread\nFormat\nC or C++:\nint acc_get_default_async(void);\n\nFortran:\nfunction acc_get_default_async()\ninteger(acc_handle_kind) :: acc_get_default_async\nDescription\nTheacc_get_default_async routine returns the value of acc-default-async-var for the cur-\nrent thread, which is the asynchronous queue used when an async clause appears without an\nasync-argument or with the value acc_async_noval\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc get default async,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc get default async. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc get default async in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc get default async, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3213 acc getdefault async\nSummary\nTheacc_get_default_async routine returns the value of acc-default-async-var for the cur-\nrent thread\nFormat\nC or C++:\nint acc_get_default_async(void);\n\nFortran:\nfunction acc_get_default_async()\ninteger(acc_handle_kind) :: acc_get_default_async\nDescription\nTheacc_get_default_async routine returns the value of acc-default-async-var for the cur-\nrent thread, which is the asynchronous queue used when an async clause appears without an\nasync-argument or with the value acc_async_noval\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc get default async,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc get default async. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc get default async in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc get default async, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3213 acc getdefault async\nSummary\nTheacc_get_default_async routine returns the value of acc-default-async-var for the cur-\nrent thread\nFormat\nC or C++:\nint acc_get_default_async(void);\n\nFortran:\nfunction acc_get_default_async()\ninteger(acc_handle_kind) :: acc_get_default_async\nDescription\nTheacc_get_default_async routine returns the value of acc-default-async-var for the cur-\nrent thread, which is the asynchronous queue used when an async clause appears without an\nasync-argument or with the value acc_async_noval\n\nTemplate:\n\n#ifndef T1\n!T1:acc get default async,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc set default async. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc set default async in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc set default async, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3214 acc setdefault async\nSummary\nTheacc_set_default_async routine tells the runtime which asynchronous queue to use\nwhen anasync clause appears with no queue argument\nFormat\nC or C++:\nvoid acc_set_default_async(int async_arg);\nFortran:\nsubroutine acc_set_default_async(async_arg)\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call toacc_set_default_async is functionally equivalent to a setdefault_async(async_arg)\ndirective, as described in Section 2143 This acc_set_default_async routine tells the\nruntime to place any directives with an async clause that does not have an async-argument or\nwith the special acc_async_noval value into the asynchronous activity queue associated with\nasync_arg instead of the default asynchronous activity queue for that device by s etting the value\nofacc-default-async-var for the current thread The special argument acc_async_default will\nreset the default asynchronous activity queue to the initial value, which is implementation-de\ufb01ned\nErrors\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc set default async,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc set default async. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc set default async in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc set default async, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3214 acc setdefault async\nSummary\nTheacc_set_default_async routine tells the runtime which asynchronous queue to use\nwhen anasync clause appears with no queue argument\nFormat\nC or C++:\nvoid acc_set_default_async(int async_arg);\nFortran:\nsubroutine acc_set_default_async(async_arg)\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call toacc_set_default_async is functionally equivalent to a setdefault_async(async_arg)\ndirective, as described in Section 2143 This acc_set_default_async routine tells the\nruntime to place any directives with an async clause that does not have an async-argument or\nwith the special acc_async_noval value into the asynchronous activity queue associated with\nasync_arg instead of the default asynchronous activity queue for that device by s etting the value\nofacc-default-async-var for the current thread The special argument acc_async_default will\nreset the default asynchronous activity queue to the initial value, which is implementation-de\ufb01ned\nErrors\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc set default async,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc set default async. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc set default async in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc set default async, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3214 acc setdefault async\nSummary\nTheacc_set_default_async routine tells the runtime which asynchronous queue to use\nwhen anasync clause appears with no queue argument\nFormat\nC or C++:\nvoid acc_set_default_async(int async_arg);\nFortran:\nsubroutine acc_set_default_async(async_arg)\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call toacc_set_default_async is functionally equivalent to a setdefault_async(async_arg)\ndirective, as described in Section 2143 This acc_set_default_async routine tells the\nruntime to place any directives with an async clause that does not have an async-argument or\nwith the special acc_async_noval value into the asynchronous activity queue associated with\nasync_arg instead of the default asynchronous activity queue for that device by s etting the value\nofacc-default-async-var for the current thread The special argument acc_async_default will\nreset the default asynchronous activity queue to the initial value, which is implementation-de\ufb01ned\nErrors\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc set default async,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc on device. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc on device in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc on device, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3215 acc ondevice\nSummary\nTheacc_on_device routine tells the program whether it is executing on a particular device\nFormat\nC or C++:\nint acc_on_device(acc_device_t dev_type);\nFortran:\nlogical function acc_on_device(dev_type)\ninteger(acc_device_kind) :: dev_type\n\nDescription\nTheacc_on_device routine may be used to execute different paths depending on whether the\ncode is running on the host or on some accelerator If the acc_on_device routine has a compile-\ntime constant argument, the call evaluates at compile time to a constant dev_type must be one\nof the de\ufb01ned accelerator types\nThe behavior of the acc_on_device routine is:\n\tIfdev_type isacc_device_host , then outside of a compute region or accelerator rou-\ntine, or in a compute region or accelerator routine that is executed on the hos t CPU, a call to\nthis routine will evaluate to true; otherwise, it will evaluate to false \n\tIfdev_type isacc_device_not_host , the result is the negation of the result with\nargumentacc_device_host \n\tIfdev_type is an accelerator device type, then in a compute region or routine that is ex-\necuted on a device of that type, a call to this routine will evaluate to true; otherwise, it will\nevaluate to false \n\tThe result with argument acc_device_default is unde\ufb01ned\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc on device,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc on device. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc on device in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc on device, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3215 acc ondevice\nSummary\nTheacc_on_device routine tells the program whether it is executing on a particular device\nFormat\nC or C++:\nint acc_on_device(acc_device_t dev_type);\nFortran:\nlogical function acc_on_device(dev_type)\ninteger(acc_device_kind) :: dev_type\n\nDescription\nTheacc_on_device routine may be used to execute different paths depending on whether the\ncode is running on the host or on some accelerator If the acc_on_device routine has a compile-\ntime constant argument, the call evaluates at compile time to a constant dev_type must be one\nof the de\ufb01ned accelerator types\nThe behavior of the acc_on_device routine is:\n\tIfdev_type isacc_device_host , then outside of a compute region or accelerator rou-\ntine, or in a compute region or accelerator routine that is executed on the hos t CPU, a call to\nthis routine will evaluate to true; otherwise, it will evaluate to false \n\tIfdev_type isacc_device_not_host , the result is the negation of the result with\nargumentacc_device_host \n\tIfdev_type is an accelerator device type, then in a compute region or routine that is ex-\necuted on a device of that type, a call to this routine will evaluate to true; otherwise, it will\nevaluate to false \n\tThe result with argument acc_device_default is unde\ufb01ned\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc on device,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc on device. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc on device in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc on device, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3215 acc ondevice\nSummary\nTheacc_on_device routine tells the program whether it is executing on a particular device\nFormat\nC or C++:\nint acc_on_device(acc_device_t dev_type);\nFortran:\nlogical function acc_on_device(dev_type)\ninteger(acc_device_kind) :: dev_type\n\nDescription\nTheacc_on_device routine may be used to execute different paths depending on whether the\ncode is running on the host or on some accelerator If the acc_on_device routine has a compile-\ntime constant argument, the call evaluates at compile time to a constant dev_type must be one\nof the de\ufb01ned accelerator types\nThe behavior of the acc_on_device routine is:\n\tIfdev_type isacc_device_host , then outside of a compute region or accelerator rou-\ntine, or in a compute region or accelerator routine that is executed on the hos t CPU, a call to\nthis routine will evaluate to true; otherwise, it will evaluate to false \n\tIfdev_type isacc_device_not_host , the result is the negation of the result with\nargumentacc_device_host \n\tIfdev_type is an accelerator device type, then in a compute region or routine that is ex-\necuted on a device of that type, a call to this routine will evaluate to true; otherwise, it will\nevaluate to false \n\tThe result with argument acc_device_default is unde\ufb01ned\n\nTemplate:\n\n#ifndef T1\n!T1:acc on device,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc malloc. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc malloc in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc malloc, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3216 acc malloc\nSummary\nTheacc_malloc routine allocates space in the current device memory\nFormat\nC or C++:\nd_void*acc_malloc(size_t bytes);\nFortran:\ntype(c_ptr) function acc_malloc(bytes)\ninteger(c_size_t), value :: bytes\nDescription\nTheacc_malloc routine may be used to allocate space in the current device memory Pointers\nassigned from this routine may be used in deviceptr clauses to tell the compiler that the pointer\ntarget is resident on the device In case of an allocation error or if bytes has the value zero,\nacc_malloc returns a null pointer\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc malloc,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc malloc. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc malloc in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc malloc, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3216 acc malloc\nSummary\nTheacc_malloc routine allocates space in the current device memory\nFormat\nC or C++:\nd_void*acc_malloc(size_t bytes);\nFortran:\ntype(c_ptr) function acc_malloc(bytes)\ninteger(c_size_t), value :: bytes\nDescription\nTheacc_malloc routine may be used to allocate space in the current device memory Pointers\nassigned from this routine may be used in deviceptr clauses to tell the compiler that the pointer\ntarget is resident on the device In case of an allocation error or if bytes has the value zero,\nacc_malloc returns a null pointer\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc malloc,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc malloc. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc malloc in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc malloc, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3216 acc malloc\nSummary\nTheacc_malloc routine allocates space in the current device memory\nFormat\nC or C++:\nd_void*acc_malloc(size_t bytes);\nFortran:\ntype(c_ptr) function acc_malloc(bytes)\ninteger(c_size_t), value :: bytes\nDescription\nTheacc_malloc routine may be used to allocate space in the current device memory Pointers\nassigned from this routine may be used in deviceptr clauses to tell the compiler that the pointer\ntarget is resident on the device In case of an allocation error or if bytes has the value zero,\nacc_malloc returns a null pointer\n\nTemplate:\n\n#ifndef T1\n!T1:acc malloc,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc free. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc free in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc free, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3217 acc free\nSummary\nTheacc_free routine frees memory on the current device\nFormat\nC or C++:\nvoid acc_free(d_void *data_dev);\nFortran:\nsubroutine acc_free(data_dev)\ntype(c_ptr), value :: data_dev\n\nDescription\nTheacc_free routine will free previously allocated space in the current device memory; data_dev\nshould be a pointer value that was returned by a call to acc_malloc  Ifdata_dev is a null\npointer, no operation is performed\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc free,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc free. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc free in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc free, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3217 acc free\nSummary\nTheacc_free routine frees memory on the current device\nFormat\nC or C++:\nvoid acc_free(d_void *data_dev);\nFortran:\nsubroutine acc_free(data_dev)\ntype(c_ptr), value :: data_dev\n\nDescription\nTheacc_free routine will free previously allocated space in the current device memory; data_dev\nshould be a pointer value that was returned by a call to acc_malloc  Ifdata_dev is a null\npointer, no operation is performed\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc free,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc free. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc free in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc free, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3217 acc free\nSummary\nTheacc_free routine frees memory on the current device\nFormat\nC or C++:\nvoid acc_free(d_void *data_dev);\nFortran:\nsubroutine acc_free(data_dev)\ntype(c_ptr), value :: data_dev\n\nDescription\nTheacc_free routine will free previously allocated space in the current device memory; data_dev\nshould be a pointer value that was returned by a call to acc_malloc  Ifdata_dev is a null\npointer, no operation is performed\n\nTemplate:\n\n#ifndef T1\n!T1:acc free,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc copyin. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc copyin in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc copyin, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3218 acc copyin and acc create\nSummary\nTheacc_copyin andacc_create routines test to see if the argument is in shared memory\nor already present in the current device memory; if not, they allocate spac e in the current device\nmemory to correspond to the speci\ufb01ed local memory, and the acc_copyin routines copy the data\nto that device memory\nFormat\nC or C++:\nd_void*acc_copyin(h_void *data_arg, size_t bytes);\nd_void*acc_create(h_void *data_arg, size_t bytes);\n\nvoid acc_copyin_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_create_async(h_void *data_arg, size_t bytes,\nint async_arg);\n\nFortran:\nsubroutine acc_copyin(data_arg [, bytes ])\nsubroutine acc_create(data_arg [, bytes ])\n\nsubroutine acc_copyin_async(data_arg [, bytes ], async_arg)\nsubroutine acc_create_async(data_arg [, bytes ], async_arg)\n\ntype(*), dimension() :: data_arg\ninteger :: bytes\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call to an acc_copyin oracc_create routine is similar to an enterdata directive with\nacopyin orcreate clause, respectively, as described in Sections 277 and 279, except th at\nnoattach action is performed for a pointer reference In C/C++, data_arg is a pointer to the\ndata, andbytes speci\ufb01es the data size in bytes; the associated data section starts at the address\nindata_arg and continues for bytes bytes The synchronous routines return a pointer to the\nallocated device memory, as with acc_malloc  In Fortran, two forms are supported In the \ufb01rst,\ndata_arg is a variable or a contiguous array section; the associated data section starts at the\naddress of, and continues to the end of the variable or array section In the second, data_arg\nis a variable or array element and bytes is the length in bytes; the associated data section starts\nat the address of the variable or array element and continues for bytes bytes For the _async\nversions of these routines, async_arg must be an async-argument as de\ufb01ned in Section 2\nAsynchronous Behavior\nThe behavior of these routines for the associated data section is:\n\n\tIf the data section is in shared memory, no action is taken The C/C++ synchronous acc_copyin\nandacc_create routines return the incoming pointer\n\tIf the data section is present in the current device memory, the routines perform a present increment\naction with the dynamic reference counter The C/C++ synchronous acc_copyin and\nacc_create routines return a pointer to the existing device memory\n\tOtherwise:\n\t\tTheacc_copyin routines perform a copyin action with the dynamic reference counter\n\t\tTheacc_create routines perform a create action with the dynamic reference counter\nThe C/C++ synchronous acc_copyin andacc_create routines return a pointer to the\nnewly allocated device memory\nThis data may be accessed using the present data clause Pointers assigned from the C/C++\nsynchronous acc_copyin andacc_create routines may be used in deviceptr clauses to\ntell the compiler that the pointer target is resident on the device\nThe synchronous versions will not return until the memory has been alloca ted and any data transfers\nare complete\nThe_async versions of these routines will perform any data transfers asynchron ously on the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The data will be treated as present in\nthe current device memory even if the data has not been allocated or transf erred before the routine\nreturns\nFor compatibility with OpenACC 20, acc_present_or_copyin andacc_pcopyin are al-\nternate names for acc_copyin , andacc_present_or_create andacc_pcreate are al-\nternate names for acc_create \nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer and\nbytes is nonzero\n\tAnacc_error_partly_present error is issued if part of the data section is already\npresent in the current device memory but all of the data section is not\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\n\tAnacc_error_out_of_memory error is issued if the accelerator device does not have\nenough memory for the data\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc copyin,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc copyin. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc copyin in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc copyin, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3218 acc copyin and acc create\nSummary\nTheacc_copyin andacc_create routines test to see if the argument is in shared memory\nor already present in the current device memory; if not, they allocate spac e in the current device\nmemory to correspond to the speci\ufb01ed local memory, and the acc_copyin routines copy the data\nto that device memory\nFormat\nC or C++:\nd_void*acc_copyin(h_void *data_arg, size_t bytes);\nd_void*acc_create(h_void *data_arg, size_t bytes);\n\nvoid acc_copyin_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_create_async(h_void *data_arg, size_t bytes,\nint async_arg);\n\nFortran:\nsubroutine acc_copyin(data_arg [, bytes ])\nsubroutine acc_create(data_arg [, bytes ])\n\nsubroutine acc_copyin_async(data_arg [, bytes ], async_arg)\nsubroutine acc_create_async(data_arg [, bytes ], async_arg)\n\ntype(*), dimension() :: data_arg\ninteger :: bytes\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call to an acc_copyin oracc_create routine is similar to an enterdata directive with\nacopyin orcreate clause, respectively, as described in Sections 277 and 279, except th at\nnoattach action is performed for a pointer reference In C/C++, data_arg is a pointer to the\ndata, andbytes speci\ufb01es the data size in bytes; the associated data section starts at the address\nindata_arg and continues for bytes bytes The synchronous routines return a pointer to the\nallocated device memory, as with acc_malloc  In Fortran, two forms are supported In the \ufb01rst,\ndata_arg is a variable or a contiguous array section; the associated data section starts at the\naddress of, and continues to the end of the variable or array section In the second, data_arg\nis a variable or array element and bytes is the length in bytes; the associated data section starts\nat the address of the variable or array element and continues for bytes bytes For the _async\nversions of these routines, async_arg must be an async-argument as de\ufb01ned in Section 2\nAsynchronous Behavior\nThe behavior of these routines for the associated data section is:\n\n\tIf the data section is in shared memory, no action is taken The C/C++ synchronous acc_copyin\nandacc_create routines return the incoming pointer\n\tIf the data section is present in the current device memory, the routines perform a present increment\naction with the dynamic reference counter The C/C++ synchronous acc_copyin and\nacc_create routines return a pointer to the existing device memory\n\tOtherwise:\n\t\tTheacc_copyin routines perform a copyin action with the dynamic reference counter\n\t\tTheacc_create routines perform a create action with the dynamic reference counter\nThe C/C++ synchronous acc_copyin andacc_create routines return a pointer to the\nnewly allocated device memory\nThis data may be accessed using the present data clause Pointers assigned from the C/C++\nsynchronous acc_copyin andacc_create routines may be used in deviceptr clauses to\ntell the compiler that the pointer target is resident on the device\nThe synchronous versions will not return until the memory has been alloca ted and any data transfers\nare complete\nThe_async versions of these routines will perform any data transfers asynchron ously on the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The data will be treated as present in\nthe current device memory even if the data has not been allocated or transf erred before the routine\nreturns\nFor compatibility with OpenACC 20, acc_present_or_copyin andacc_pcopyin are al-\nternate names for acc_copyin , andacc_present_or_create andacc_pcreate are al-\nternate names for acc_create \nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer and\nbytes is nonzero\n\tAnacc_error_partly_present error is issued if part of the data section is already\npresent in the current device memory but all of the data section is not\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\n\tAnacc_error_out_of_memory error is issued if the accelerator device does not have\nenough memory for the data\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc copyin,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc copyin. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc copyin in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc copyin, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3218 acc copyin and acc create\nSummary\nTheacc_copyin andacc_create routines test to see if the argument is in shared memory\nor already present in the current device memory; if not, they allocate spac e in the current device\nmemory to correspond to the speci\ufb01ed local memory, and the acc_copyin routines copy the data\nto that device memory\nFormat\nC or C++:\nd_void*acc_copyin(h_void *data_arg, size_t bytes);\nd_void*acc_create(h_void *data_arg, size_t bytes);\n\nvoid acc_copyin_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_create_async(h_void *data_arg, size_t bytes,\nint async_arg);\n\nFortran:\nsubroutine acc_copyin(data_arg [, bytes ])\nsubroutine acc_create(data_arg [, bytes ])\n\nsubroutine acc_copyin_async(data_arg [, bytes ], async_arg)\nsubroutine acc_create_async(data_arg [, bytes ], async_arg)\n\ntype(*), dimension() :: data_arg\ninteger :: bytes\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call to an acc_copyin oracc_create routine is similar to an enterdata directive with\nacopyin orcreate clause, respectively, as described in Sections 277 and 279, except th at\nnoattach action is performed for a pointer reference In C/C++, data_arg is a pointer to the\ndata, andbytes speci\ufb01es the data size in bytes; the associated data section starts at the address\nindata_arg and continues for bytes bytes The synchronous routines return a pointer to the\nallocated device memory, as with acc_malloc  In Fortran, two forms are supported In the \ufb01rst,\ndata_arg is a variable or a contiguous array section; the associated data section starts at the\naddress of, and continues to the end of the variable or array section In the second, data_arg\nis a variable or array element and bytes is the length in bytes; the associated data section starts\nat the address of the variable or array element and continues for bytes bytes For the _async\nversions of these routines, async_arg must be an async-argument as de\ufb01ned in Section 2\nAsynchronous Behavior\nThe behavior of these routines for the associated data section is:\n\n\tIf the data section is in shared memory, no action is taken The C/C++ synchronous acc_copyin\nandacc_create routines return the incoming pointer\n\tIf the data section is present in the current device memory, the routines perform a present increment\naction with the dynamic reference counter The C/C++ synchronous acc_copyin and\nacc_create routines return a pointer to the existing device memory\n\tOtherwise:\n\t\tTheacc_copyin routines perform a copyin action with the dynamic reference counter\n\t\tTheacc_create routines perform a create action with the dynamic reference counter\nThe C/C++ synchronous acc_copyin andacc_create routines return a pointer to the\nnewly allocated device memory\nThis data may be accessed using the present data clause Pointers assigned from the C/C++\nsynchronous acc_copyin andacc_create routines may be used in deviceptr clauses to\ntell the compiler that the pointer target is resident on the device\nThe synchronous versions will not return until the memory has been alloca ted and any data transfers\nare complete\nThe_async versions of these routines will perform any data transfers asynchron ously on the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The data will be treated as present in\nthe current device memory even if the data has not been allocated or transf erred before the routine\nreturns\nFor compatibility with OpenACC 20, acc_present_or_copyin andacc_pcopyin are al-\nternate names for acc_copyin , andacc_present_or_create andacc_pcreate are al-\nternate names for acc_create \nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer and\nbytes is nonzero\n\tAnacc_error_partly_present error is issued if part of the data section is already\npresent in the current device memory but all of the data section is not\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\n\tAnacc_error_out_of_memory error is issued if the accelerator device does not have\nenough memory for the data\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc copyin,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc create. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc create in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc create, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3218 acc copyin and acc create\nSummary\nTheacc_copyin andacc_create routines test to see if the argument is in shared memory\nor already present in the current device memory; if not, they allocate spac e in the current device\nmemory to correspond to the speci\ufb01ed local memory, and the acc_copyin routines copy the data\nto that device memory\nFormat\nC or C++:\nd_void*acc_copyin(h_void *data_arg, size_t bytes);\nd_void*acc_create(h_void *data_arg, size_t bytes);\n\nvoid acc_copyin_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_create_async(h_void *data_arg, size_t bytes,\nint async_arg);\n\nFortran:\nsubroutine acc_copyin(data_arg [, bytes ])\nsubroutine acc_create(data_arg [, bytes ])\n\nsubroutine acc_copyin_async(data_arg [, bytes ], async_arg)\nsubroutine acc_create_async(data_arg [, bytes ], async_arg)\n\ntype(*), dimension() :: data_arg\ninteger :: bytes\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call to an acc_copyin oracc_create routine is similar to an enterdata directive with\nacopyin orcreate clause, respectively, as described in Sections 277 and 279, except th at\nnoattach action is performed for a pointer reference In C/C++, data_arg is a pointer to the\ndata, andbytes speci\ufb01es the data size in bytes; the associated data section starts at the address\nindata_arg and continues for bytes bytes The synchronous routines return a pointer to the\nallocated device memory, as with acc_malloc  In Fortran, two forms are supported In the \ufb01rst,\ndata_arg is a variable or a contiguous array section; the associated data section starts at the\naddress of, and continues to the end of the variable or array section In the second, data_arg\nis a variable or array element and bytes is the length in bytes; the associated data section starts\nat the address of the variable or array element and continues for bytes bytes For the _async\nversions of these routines, async_arg must be an async-argument as de\ufb01ned in Section 2\nAsynchronous Behavior\nThe behavior of these routines for the associated data section is:\n\n\tIf the data section is in shared memory, no action is taken The C/C++ synchronous acc_copyin\nandacc_create routines return the incoming pointer\n\tIf the data section is present in the current device memory, the routines perform a present increment\naction with the dynamic reference counter The C/C++ synchronous acc_copyin and\nacc_create routines return a pointer to the existing device memory\n\tOtherwise:\n\t\tTheacc_copyin routines perform a copyin action with the dynamic reference counter\n\t\tTheacc_create routines perform a create action with the dynamic reference counter\nThe C/C++ synchronous acc_copyin andacc_create routines return a pointer to the\nnewly allocated device memory\nThis data may be accessed using the present data clause Pointers assigned from the C/C++\nsynchronous acc_copyin andacc_create routines may be used in deviceptr clauses to\ntell the compiler that the pointer target is resident on the device\nThe synchronous versions will not return until the memory has been alloca ted and any data transfers\nare complete\nThe_async versions of these routines will perform any data transfers asynchron ously on the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The data will be treated as present in\nthe current device memory even if the data has not been allocated or transf erred before the routine\nreturns\nFor compatibility with OpenACC 20, acc_present_or_copyin andacc_pcopyin are al-\nternate names for acc_copyin , andacc_present_or_create andacc_pcreate are al-\nternate names for acc_create \nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer and\nbytes is nonzero\n\tAnacc_error_partly_present error is issued if part of the data section is already\npresent in the current device memory but all of the data section is not\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\n\tAnacc_error_out_of_memory error is issued if the accelerator device does not have\nenough memory for the data\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc create,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc create. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc create in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc create, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3218 acc copyin and acc create\nSummary\nTheacc_copyin andacc_create routines test to see if the argument is in shared memory\nor already present in the current device memory; if not, they allocate spac e in the current device\nmemory to correspond to the speci\ufb01ed local memory, and the acc_copyin routines copy the data\nto that device memory\nFormat\nC or C++:\nd_void*acc_copyin(h_void *data_arg, size_t bytes);\nd_void*acc_create(h_void *data_arg, size_t bytes);\n\nvoid acc_copyin_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_create_async(h_void *data_arg, size_t bytes,\nint async_arg);\n\nFortran:\nsubroutine acc_copyin(data_arg [, bytes ])\nsubroutine acc_create(data_arg [, bytes ])\n\nsubroutine acc_copyin_async(data_arg [, bytes ], async_arg)\nsubroutine acc_create_async(data_arg [, bytes ], async_arg)\n\ntype(*), dimension() :: data_arg\ninteger :: bytes\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call to an acc_copyin oracc_create routine is similar to an enterdata directive with\nacopyin orcreate clause, respectively, as described in Sections 277 and 279, except th at\nnoattach action is performed for a pointer reference In C/C++, data_arg is a pointer to the\ndata, andbytes speci\ufb01es the data size in bytes; the associated data section starts at the address\nindata_arg and continues for bytes bytes The synchronous routines return a pointer to the\nallocated device memory, as with acc_malloc  In Fortran, two forms are supported In the \ufb01rst,\ndata_arg is a variable or a contiguous array section; the associated data section starts at the\naddress of, and continues to the end of the variable or array section In the second, data_arg\nis a variable or array element and bytes is the length in bytes; the associated data section starts\nat the address of the variable or array element and continues for bytes bytes For the _async\nversions of these routines, async_arg must be an async-argument as de\ufb01ned in Section 2\nAsynchronous Behavior\nThe behavior of these routines for the associated data section is:\n\n\tIf the data section is in shared memory, no action is taken The C/C++ synchronous acc_copyin\nandacc_create routines return the incoming pointer\n\tIf the data section is present in the current device memory, the routines perform a present increment\naction with the dynamic reference counter The C/C++ synchronous acc_copyin and\nacc_create routines return a pointer to the existing device memory\n\tOtherwise:\n\t\tTheacc_copyin routines perform a copyin action with the dynamic reference counter\n\t\tTheacc_create routines perform a create action with the dynamic reference counter\nThe C/C++ synchronous acc_copyin andacc_create routines return a pointer to the\nnewly allocated device memory\nThis data may be accessed using the present data clause Pointers assigned from the C/C++\nsynchronous acc_copyin andacc_create routines may be used in deviceptr clauses to\ntell the compiler that the pointer target is resident on the device\nThe synchronous versions will not return until the memory has been alloca ted and any data transfers\nare complete\nThe_async versions of these routines will perform any data transfers asynchron ously on the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The data will be treated as present in\nthe current device memory even if the data has not been allocated or transf erred before the routine\nreturns\nFor compatibility with OpenACC 20, acc_present_or_copyin andacc_pcopyin are al-\nternate names for acc_copyin , andacc_present_or_create andacc_pcreate are al-\nternate names for acc_create \nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer and\nbytes is nonzero\n\tAnacc_error_partly_present error is issued if part of the data section is already\npresent in the current device memory but all of the data section is not\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\n\tAnacc_error_out_of_memory error is issued if the accelerator device does not have\nenough memory for the data\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc create,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc create. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc create in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc create, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3218 acc copyin and acc create\nSummary\nTheacc_copyin andacc_create routines test to see if the argument is in shared memory\nor already present in the current device memory; if not, they allocate spac e in the current device\nmemory to correspond to the speci\ufb01ed local memory, and the acc_copyin routines copy the data\nto that device memory\nFormat\nC or C++:\nd_void*acc_copyin(h_void *data_arg, size_t bytes);\nd_void*acc_create(h_void *data_arg, size_t bytes);\n\nvoid acc_copyin_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_create_async(h_void *data_arg, size_t bytes,\nint async_arg);\n\nFortran:\nsubroutine acc_copyin(data_arg [, bytes ])\nsubroutine acc_create(data_arg [, bytes ])\n\nsubroutine acc_copyin_async(data_arg [, bytes ], async_arg)\nsubroutine acc_create_async(data_arg [, bytes ], async_arg)\n\ntype(*), dimension() :: data_arg\ninteger :: bytes\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call to an acc_copyin oracc_create routine is similar to an enterdata directive with\nacopyin orcreate clause, respectively, as described in Sections 277 and 279, except th at\nnoattach action is performed for a pointer reference In C/C++, data_arg is a pointer to the\ndata, andbytes speci\ufb01es the data size in bytes; the associated data section starts at the address\nindata_arg and continues for bytes bytes The synchronous routines return a pointer to the\nallocated device memory, as with acc_malloc  In Fortran, two forms are supported In the \ufb01rst,\ndata_arg is a variable or a contiguous array section; the associated data section starts at the\naddress of, and continues to the end of the variable or array section In the second, data_arg\nis a variable or array element and bytes is the length in bytes; the associated data section starts\nat the address of the variable or array element and continues for bytes bytes For the _async\nversions of these routines, async_arg must be an async-argument as de\ufb01ned in Section 2\nAsynchronous Behavior\nThe behavior of these routines for the associated data section is:\n\n\tIf the data section is in shared memory, no action is taken The C/C++ synchronous acc_copyin\nandacc_create routines return the incoming pointer\n\tIf the data section is present in the current device memory, the routines perform a present increment\naction with the dynamic reference counter The C/C++ synchronous acc_copyin and\nacc_create routines return a pointer to the existing device memory\n\tOtherwise:\n\t\tTheacc_copyin routines perform a copyin action with the dynamic reference counter\n\t\tTheacc_create routines perform a create action with the dynamic reference counter\nThe C/C++ synchronous acc_copyin andacc_create routines return a pointer to the\nnewly allocated device memory\nThis data may be accessed using the present data clause Pointers assigned from the C/C++\nsynchronous acc_copyin andacc_create routines may be used in deviceptr clauses to\ntell the compiler that the pointer target is resident on the device\nThe synchronous versions will not return until the memory has been alloca ted and any data transfers\nare complete\nThe_async versions of these routines will perform any data transfers asynchron ously on the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The data will be treated as present in\nthe current device memory even if the data has not been allocated or transf erred before the routine\nreturns\nFor compatibility with OpenACC 20, acc_present_or_copyin andacc_pcopyin are al-\nternate names for acc_copyin , andacc_present_or_create andacc_pcreate are al-\nternate names for acc_create \nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer and\nbytes is nonzero\n\tAnacc_error_partly_present error is issued if part of the data section is already\npresent in the current device memory but all of the data section is not\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\n\tAnacc_error_out_of_memory error is issued if the accelerator device does not have\nenough memory for the data\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc create,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc copyout. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc copyout in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc copyout, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3219 acc copyout and acc delete\n\nSummary\nTheacc_copyout andacc_delete routines test to see if the argument is in shared memory;\nif not, the argument must be present in the current device memory The acc_copyout routines\ncopy data from device memory to the corresponding local memory, and both acc_copyout and\nacc_delete routines deallocate that space from the device memory\nFormat\nC or C++:\nvoid acc_copyout(h_void *data_arg, size_t bytes);\nvoid acc_delete (h_void *data_arg, size_t bytes);\n\nvoid acc_copyout_finalize(h_void *data_arg, size_t bytes);\nvoid acc_delete_finalize (h_void *data_arg, size_t bytes);\n\nvoid acc_copyout_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_delete_async (h_void *data_arg, size_t bytes,\nint async_arg);\n\nvoid acc_copyout_finalize_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_delete_finalize_async (h_void *data_arg, size_t bytes,\nint async_arg);\n\nFortran:\nsubroutine acc_copyout(data_arg [, bytes ])\nsubroutine acc_delete (data_arg [, bytes ])\n\nsubroutine acc_copyout_finalize(data_arg [, bytes ])\nsubroutine acc_delete_finalize (data_arg [, bytes ])\n\nsubroutine acc_copyout_async(data_arg [, bytes ], async_arg)\nsubroutine acc_delete_async (data_arg [, bytes ], async_arg)\n\nsubroutine acc_copyout_finalize_async(data_arg [, bytes ], &\nasync_arg)\nsubroutine acc_delete_finalize_async (data_arg [, bytes ], &\nasync_arg)\n\ntype(*), dimension() :: data_arg\ninteger :: bytes\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call to an acc_copyout oracc_delete routine is similar to an exit data directive\nwith acopyout ordelete clause, respectively, and a call to an acc_copyout_finalize\noracc_delete_finalize routine is similar to an exit data finalize directive with a\ncopyout ordelete clause, respectively, as described in Section 278 and 2711, except th at no\n\ndetach action is performed for a pointer reference The arguments and the asso ciated data section\nare as foracc_copyin \nThe behavior of these routines for the associated data section is:\n\tIf the data section is in shared memory, no action is taken\n\tIf the dynamic reference counter for the data section is zero, no action is taken\n\tOtherwise, the dynamic reference counter is updated:\n\t\tTheacc_copyout andacc_delete ) routines perform a present decrement action\nwith the dynamic reference counter\n\t\tTheacc_copyout_finalize oracc_delete_finalize routines set the dy-\nnamic reference counter to zero\nIf both reference counters are then zero:\n\t\tTheacc_copyout routines perform a copyout action\n\t\tTheacc_delete routines perform a delete action\nThe synchronous versions will not return until the data has been complete ly transferred and the\nmemory has been deallocated\nThe_async versions of these routines will perform any associated data transfers a synchronously\non the async queue associated with async_arg  The routine may return before the data has been\ntransferred or deallocated; see Section 216 Asynchronous Behavior for more details Even if the\ndata has not been transferred or deallocated before the routine return s, the data will be treated as not\npresent in the current device memory if both reference counters are ze ro\nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer and\nbytes is nonzero\n\tAnacc_error_not_present error is issued if the data section is not in shared memory\nand is not present in the current device memory\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\n\tAnacc_error_partly_present error is issued if part of the data section is already\npresent in the current device memory but all of the data section is not\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc copyout,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc copyout. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc copyout in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc copyout, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3219 acc copyout and acc delete\n\nSummary\nTheacc_copyout andacc_delete routines test to see if the argument is in shared memory;\nif not, the argument must be present in the current device memory The acc_copyout routines\ncopy data from device memory to the corresponding local memory, and both acc_copyout and\nacc_delete routines deallocate that space from the device memory\nFormat\nC or C++:\nvoid acc_copyout(h_void *data_arg, size_t bytes);\nvoid acc_delete (h_void *data_arg, size_t bytes);\n\nvoid acc_copyout_finalize(h_void *data_arg, size_t bytes);\nvoid acc_delete_finalize (h_void *data_arg, size_t bytes);\n\nvoid acc_copyout_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_delete_async (h_void *data_arg, size_t bytes,\nint async_arg);\n\nvoid acc_copyout_finalize_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_delete_finalize_async (h_void *data_arg, size_t bytes,\nint async_arg);\n\nFortran:\nsubroutine acc_copyout(data_arg [, bytes ])\nsubroutine acc_delete (data_arg [, bytes ])\n\nsubroutine acc_copyout_finalize(data_arg [, bytes ])\nsubroutine acc_delete_finalize (data_arg [, bytes ])\n\nsubroutine acc_copyout_async(data_arg [, bytes ], async_arg)\nsubroutine acc_delete_async (data_arg [, bytes ], async_arg)\n\nsubroutine acc_copyout_finalize_async(data_arg [, bytes ], &\nasync_arg)\nsubroutine acc_delete_finalize_async (data_arg [, bytes ], &\nasync_arg)\n\ntype(*), dimension() :: data_arg\ninteger :: bytes\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call to an acc_copyout oracc_delete routine is similar to an exit data directive\nwith acopyout ordelete clause, respectively, and a call to an acc_copyout_finalize\noracc_delete_finalize routine is similar to an exit data finalize directive with a\ncopyout ordelete clause, respectively, as described in Section 278 and 2711, except th at no\n\ndetach action is performed for a pointer reference The arguments and the asso ciated data section\nare as foracc_copyin \nThe behavior of these routines for the associated data section is:\n\tIf the data section is in shared memory, no action is taken\n\tIf the dynamic reference counter for the data section is zero, no action is taken\n\tOtherwise, the dynamic reference counter is updated:\n\t\tTheacc_copyout andacc_delete ) routines perform a present decrement action\nwith the dynamic reference counter\n\t\tTheacc_copyout_finalize oracc_delete_finalize routines set the dy-\nnamic reference counter to zero\nIf both reference counters are then zero:\n\t\tTheacc_copyout routines perform a copyout action\n\t\tTheacc_delete routines perform a delete action\nThe synchronous versions will not return until the data has been complete ly transferred and the\nmemory has been deallocated\nThe_async versions of these routines will perform any associated data transfers a synchronously\non the async queue associated with async_arg  The routine may return before the data has been\ntransferred or deallocated; see Section 216 Asynchronous Behavior for more details Even if the\ndata has not been transferred or deallocated before the routine return s, the data will be treated as not\npresent in the current device memory if both reference counters are ze ro\nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer and\nbytes is nonzero\n\tAnacc_error_not_present error is issued if the data section is not in shared memory\nand is not present in the current device memory\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\n\tAnacc_error_partly_present error is issued if part of the data section is already\npresent in the current device memory but all of the data section is not\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc copyout,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc copyout. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc copyout in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc copyout, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3219 acc copyout and acc delete\n\nSummary\nTheacc_copyout andacc_delete routines test to see if the argument is in shared memory;\nif not, the argument must be present in the current device memory The acc_copyout routines\ncopy data from device memory to the corresponding local memory, and both acc_copyout and\nacc_delete routines deallocate that space from the device memory\nFormat\nC or C++:\nvoid acc_copyout(h_void *data_arg, size_t bytes);\nvoid acc_delete (h_void *data_arg, size_t bytes);\n\nvoid acc_copyout_finalize(h_void *data_arg, size_t bytes);\nvoid acc_delete_finalize (h_void *data_arg, size_t bytes);\n\nvoid acc_copyout_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_delete_async (h_void *data_arg, size_t bytes,\nint async_arg);\n\nvoid acc_copyout_finalize_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_delete_finalize_async (h_void *data_arg, size_t bytes,\nint async_arg);\n\nFortran:\nsubroutine acc_copyout(data_arg [, bytes ])\nsubroutine acc_delete (data_arg [, bytes ])\n\nsubroutine acc_copyout_finalize(data_arg [, bytes ])\nsubroutine acc_delete_finalize (data_arg [, bytes ])\n\nsubroutine acc_copyout_async(data_arg [, bytes ], async_arg)\nsubroutine acc_delete_async (data_arg [, bytes ], async_arg)\n\nsubroutine acc_copyout_finalize_async(data_arg [, bytes ], &\nasync_arg)\nsubroutine acc_delete_finalize_async (data_arg [, bytes ], &\nasync_arg)\n\ntype(*), dimension() :: data_arg\ninteger :: bytes\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call to an acc_copyout oracc_delete routine is similar to an exit data directive\nwith acopyout ordelete clause, respectively, and a call to an acc_copyout_finalize\noracc_delete_finalize routine is similar to an exit data finalize directive with a\ncopyout ordelete clause, respectively, as described in Section 278 and 2711, except th at no\n\ndetach action is performed for a pointer reference The arguments and the asso ciated data section\nare as foracc_copyin \nThe behavior of these routines for the associated data section is:\n\tIf the data section is in shared memory, no action is taken\n\tIf the dynamic reference counter for the data section is zero, no action is taken\n\tOtherwise, the dynamic reference counter is updated:\n\t\tTheacc_copyout andacc_delete ) routines perform a present decrement action\nwith the dynamic reference counter\n\t\tTheacc_copyout_finalize oracc_delete_finalize routines set the dy-\nnamic reference counter to zero\nIf both reference counters are then zero:\n\t\tTheacc_copyout routines perform a copyout action\n\t\tTheacc_delete routines perform a delete action\nThe synchronous versions will not return until the data has been complete ly transferred and the\nmemory has been deallocated\nThe_async versions of these routines will perform any associated data transfers a synchronously\non the async queue associated with async_arg  The routine may return before the data has been\ntransferred or deallocated; see Section 216 Asynchronous Behavior for more details Even if the\ndata has not been transferred or deallocated before the routine return s, the data will be treated as not\npresent in the current device memory if both reference counters are ze ro\nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer and\nbytes is nonzero\n\tAnacc_error_not_present error is issued if the data section is not in shared memory\nand is not present in the current device memory\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\n\tAnacc_error_partly_present error is issued if part of the data section is already\npresent in the current device memory but all of the data section is not\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc copyout,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc delete. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc delete in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc delete, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3219 acc copyout and acc delete\n\nSummary\nTheacc_copyout andacc_delete routines test to see if the argument is in shared memory;\nif not, the argument must be present in the current device memory The acc_copyout routines\ncopy data from device memory to the corresponding local memory, and both acc_copyout and\nacc_delete routines deallocate that space from the device memory\nFormat\nC or C++:\nvoid acc_copyout(h_void *data_arg, size_t bytes);\nvoid acc_delete (h_void *data_arg, size_t bytes);\n\nvoid acc_copyout_finalize(h_void *data_arg, size_t bytes);\nvoid acc_delete_finalize (h_void *data_arg, size_t bytes);\n\nvoid acc_copyout_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_delete_async (h_void *data_arg, size_t bytes,\nint async_arg);\n\nvoid acc_copyout_finalize_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_delete_finalize_async (h_void *data_arg, size_t bytes,\nint async_arg);\n\nFortran:\nsubroutine acc_copyout(data_arg [, bytes ])\nsubroutine acc_delete (data_arg [, bytes ])\n\nsubroutine acc_copyout_finalize(data_arg [, bytes ])\nsubroutine acc_delete_finalize (data_arg [, bytes ])\n\nsubroutine acc_copyout_async(data_arg [, bytes ], async_arg)\nsubroutine acc_delete_async (data_arg [, bytes ], async_arg)\n\nsubroutine acc_copyout_finalize_async(data_arg [, bytes ], &\nasync_arg)\nsubroutine acc_delete_finalize_async (data_arg [, bytes ], &\nasync_arg)\n\ntype(*), dimension() :: data_arg\ninteger :: bytes\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call to an acc_copyout oracc_delete routine is similar to an exit data directive\nwith acopyout ordelete clause, respectively, and a call to an acc_copyout_finalize\noracc_delete_finalize routine is similar to an exit data finalize directive with a\ncopyout ordelete clause, respectively, as described in Section 278 and 2711, except th at no\n\ndetach action is performed for a pointer reference The arguments and the asso ciated data section\nare as foracc_copyin \nThe behavior of these routines for the associated data section is:\n\tIf the data section is in shared memory, no action is taken\n\tIf the dynamic reference counter for the data section is zero, no action is taken\n\tOtherwise, the dynamic reference counter is updated:\n\t\tTheacc_copyout andacc_delete ) routines perform a present decrement action\nwith the dynamic reference counter\n\t\tTheacc_copyout_finalize oracc_delete_finalize routines set the dy-\nnamic reference counter to zero\nIf both reference counters are then zero:\n\t\tTheacc_copyout routines perform a copyout action\n\t\tTheacc_delete routines perform a delete action\nThe synchronous versions will not return until the data has been complete ly transferred and the\nmemory has been deallocated\nThe_async versions of these routines will perform any associated data transfers a synchronously\non the async queue associated with async_arg  The routine may return before the data has been\ntransferred or deallocated; see Section 216 Asynchronous Behavior for more details Even if the\ndata has not been transferred or deallocated before the routine return s, the data will be treated as not\npresent in the current device memory if both reference counters are ze ro\nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer and\nbytes is nonzero\n\tAnacc_error_not_present error is issued if the data section is not in shared memory\nand is not present in the current device memory\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\n\tAnacc_error_partly_present error is issued if part of the data section is already\npresent in the current device memory but all of the data section is not\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc delete,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc delete. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc delete in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc delete, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3219 acc copyout and acc delete\n\nSummary\nTheacc_copyout andacc_delete routines test to see if the argument is in shared memory;\nif not, the argument must be present in the current device memory The acc_copyout routines\ncopy data from device memory to the corresponding local memory, and both acc_copyout and\nacc_delete routines deallocate that space from the device memory\nFormat\nC or C++:\nvoid acc_copyout(h_void *data_arg, size_t bytes);\nvoid acc_delete (h_void *data_arg, size_t bytes);\n\nvoid acc_copyout_finalize(h_void *data_arg, size_t bytes);\nvoid acc_delete_finalize (h_void *data_arg, size_t bytes);\n\nvoid acc_copyout_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_delete_async (h_void *data_arg, size_t bytes,\nint async_arg);\n\nvoid acc_copyout_finalize_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_delete_finalize_async (h_void *data_arg, size_t bytes,\nint async_arg);\n\nFortran:\nsubroutine acc_copyout(data_arg [, bytes ])\nsubroutine acc_delete (data_arg [, bytes ])\n\nsubroutine acc_copyout_finalize(data_arg [, bytes ])\nsubroutine acc_delete_finalize (data_arg [, bytes ])\n\nsubroutine acc_copyout_async(data_arg [, bytes ], async_arg)\nsubroutine acc_delete_async (data_arg [, bytes ], async_arg)\n\nsubroutine acc_copyout_finalize_async(data_arg [, bytes ], &\nasync_arg)\nsubroutine acc_delete_finalize_async (data_arg [, bytes ], &\nasync_arg)\n\ntype(*), dimension() :: data_arg\ninteger :: bytes\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call to an acc_copyout oracc_delete routine is similar to an exit data directive\nwith acopyout ordelete clause, respectively, and a call to an acc_copyout_finalize\noracc_delete_finalize routine is similar to an exit data finalize directive with a\ncopyout ordelete clause, respectively, as described in Section 278 and 2711, except th at no\n\ndetach action is performed for a pointer reference The arguments and the asso ciated data section\nare as foracc_copyin \nThe behavior of these routines for the associated data section is:\n\tIf the data section is in shared memory, no action is taken\n\tIf the dynamic reference counter for the data section is zero, no action is taken\n\tOtherwise, the dynamic reference counter is updated:\n\t\tTheacc_copyout andacc_delete ) routines perform a present decrement action\nwith the dynamic reference counter\n\t\tTheacc_copyout_finalize oracc_delete_finalize routines set the dy-\nnamic reference counter to zero\nIf both reference counters are then zero:\n\t\tTheacc_copyout routines perform a copyout action\n\t\tTheacc_delete routines perform a delete action\nThe synchronous versions will not return until the data has been complete ly transferred and the\nmemory has been deallocated\nThe_async versions of these routines will perform any associated data transfers a synchronously\non the async queue associated with async_arg  The routine may return before the data has been\ntransferred or deallocated; see Section 216 Asynchronous Behavior for more details Even if the\ndata has not been transferred or deallocated before the routine return s, the data will be treated as not\npresent in the current device memory if both reference counters are ze ro\nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer and\nbytes is nonzero\n\tAnacc_error_not_present error is issued if the data section is not in shared memory\nand is not present in the current device memory\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\n\tAnacc_error_partly_present error is issued if part of the data section is already\npresent in the current device memory but all of the data section is not\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc delete,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc delete. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc delete in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc delete, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3219 acc copyout and acc delete\n\nSummary\nTheacc_copyout andacc_delete routines test to see if the argument is in shared memory;\nif not, the argument must be present in the current device memory The acc_copyout routines\ncopy data from device memory to the corresponding local memory, and both acc_copyout and\nacc_delete routines deallocate that space from the device memory\nFormat\nC or C++:\nvoid acc_copyout(h_void *data_arg, size_t bytes);\nvoid acc_delete (h_void *data_arg, size_t bytes);\n\nvoid acc_copyout_finalize(h_void *data_arg, size_t bytes);\nvoid acc_delete_finalize (h_void *data_arg, size_t bytes);\n\nvoid acc_copyout_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_delete_async (h_void *data_arg, size_t bytes,\nint async_arg);\n\nvoid acc_copyout_finalize_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_delete_finalize_async (h_void *data_arg, size_t bytes,\nint async_arg);\n\nFortran:\nsubroutine acc_copyout(data_arg [, bytes ])\nsubroutine acc_delete (data_arg [, bytes ])\n\nsubroutine acc_copyout_finalize(data_arg [, bytes ])\nsubroutine acc_delete_finalize (data_arg [, bytes ])\n\nsubroutine acc_copyout_async(data_arg [, bytes ], async_arg)\nsubroutine acc_delete_async (data_arg [, bytes ], async_arg)\n\nsubroutine acc_copyout_finalize_async(data_arg [, bytes ], &\nasync_arg)\nsubroutine acc_delete_finalize_async (data_arg [, bytes ], &\nasync_arg)\n\ntype(*), dimension() :: data_arg\ninteger :: bytes\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call to an acc_copyout oracc_delete routine is similar to an exit data directive\nwith acopyout ordelete clause, respectively, and a call to an acc_copyout_finalize\noracc_delete_finalize routine is similar to an exit data finalize directive with a\ncopyout ordelete clause, respectively, as described in Section 278 and 2711, except th at no\n\ndetach action is performed for a pointer reference The arguments and the asso ciated data section\nare as foracc_copyin \nThe behavior of these routines for the associated data section is:\n\tIf the data section is in shared memory, no action is taken\n\tIf the dynamic reference counter for the data section is zero, no action is taken\n\tOtherwise, the dynamic reference counter is updated:\n\t\tTheacc_copyout andacc_delete ) routines perform a present decrement action\nwith the dynamic reference counter\n\t\tTheacc_copyout_finalize oracc_delete_finalize routines set the dy-\nnamic reference counter to zero\nIf both reference counters are then zero:\n\t\tTheacc_copyout routines perform a copyout action\n\t\tTheacc_delete routines perform a delete action\nThe synchronous versions will not return until the data has been complete ly transferred and the\nmemory has been deallocated\nThe_async versions of these routines will perform any associated data transfers a synchronously\non the async queue associated with async_arg  The routine may return before the data has been\ntransferred or deallocated; see Section 216 Asynchronous Behavior for more details Even if the\ndata has not been transferred or deallocated before the routine return s, the data will be treated as not\npresent in the current device memory if both reference counters are ze ro\nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer and\nbytes is nonzero\n\tAnacc_error_not_present error is issued if the data section is not in shared memory\nand is not present in the current device memory\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\n\tAnacc_error_partly_present error is issued if part of the data section is already\npresent in the current device memory but all of the data section is not\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc delete,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc update device. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc update device in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc update device, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3220 acc update device and acc update self\nSummary\nTheacc_update_device andacc_update_self routines test to see if the argument is in\nshared memory; if not, the argument must be present in the current device memory, and the routines\n\nupdate the data in device memory from the corresponding local memory ( acc_update_device )\nor update the data in local memory from the corresponding device memory ( acc_update_self )\nFormat\nC or C++:\nvoid acc_update_device(h_void *data_arg, size_t bytes);\nvoid acc_update_self (h_void *data_arg, size_t bytes);\n\nvoid acc_update_device_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_update_self_async (h_void *data_arg, size_t bytes,\nint async_arg);\n\nFortran:\nsubroutine acc_update_device(data_arg [, bytes ])\nsubroutine acc_update_self (data_arg [, bytes ])\n\nsubroutine acc_update_device_async(data_arg [, bytes ], async_arg)\nsubroutine acc_update_self_async (data_arg [, bytes ], async_arg)\n\ntype(*), dimension() :: data_arg\ninteger :: bytes\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call to an acc_update_device routine is functionally equivalent to an update device\ndirective A call to an acc_update_self routine is functionally equivalent to an updateself\ndirective See Section 2144 The arguments and the data section are as foracc_copyin \nThe behavior of these routines for the associated data section is:\n\tIf the data section is in shared memory or bytes is zero, no action is taken\n\tOtherwise:\n\t\tA call to an acc_update_device routine copies the data in the local memory to the\ncorresponding device memory\n\t\tA call to an acc_update_self routine copies the data in the corresponding device\nmemory to the local memory\nThe_async versions of these routines will perform the data transfers asynchrono usly on the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The synchro nous versions will not return\nuntil the data has been completely transferred\nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer and\nbytes is nonzero\n\tAnacc_error_not_present error is issued if the data section is not in shared memory\nand is not present in the current device memory\n\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\n\tAnacc_error_partly_present error is issued if part of the data section is already\npresent in the current device memory but all of the data section is not\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc update device,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc update device. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc update device in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc update device, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3220 acc update device and acc update self\nSummary\nTheacc_update_device andacc_update_self routines test to see if the argument is in\nshared memory; if not, the argument must be present in the current device memory, and the routines\n\nupdate the data in device memory from the corresponding local memory ( acc_update_device )\nor update the data in local memory from the corresponding device memory ( acc_update_self )\nFormat\nC or C++:\nvoid acc_update_device(h_void *data_arg, size_t bytes);\nvoid acc_update_self (h_void *data_arg, size_t bytes);\n\nvoid acc_update_device_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_update_self_async (h_void *data_arg, size_t bytes,\nint async_arg);\n\nFortran:\nsubroutine acc_update_device(data_arg [, bytes ])\nsubroutine acc_update_self (data_arg [, bytes ])\n\nsubroutine acc_update_device_async(data_arg [, bytes ], async_arg)\nsubroutine acc_update_self_async (data_arg [, bytes ], async_arg)\n\ntype(*), dimension() :: data_arg\ninteger :: bytes\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call to an acc_update_device routine is functionally equivalent to an update device\ndirective A call to an acc_update_self routine is functionally equivalent to an updateself\ndirective See Section 2144 The arguments and the data section are as foracc_copyin \nThe behavior of these routines for the associated data section is:\n\tIf the data section is in shared memory or bytes is zero, no action is taken\n\tOtherwise:\n\t\tA call to an acc_update_device routine copies the data in the local memory to the\ncorresponding device memory\n\t\tA call to an acc_update_self routine copies the data in the corresponding device\nmemory to the local memory\nThe_async versions of these routines will perform the data transfers asynchrono usly on the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The synchro nous versions will not return\nuntil the data has been completely transferred\nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer and\nbytes is nonzero\n\tAnacc_error_not_present error is issued if the data section is not in shared memory\nand is not present in the current device memory\n\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\n\tAnacc_error_partly_present error is issued if part of the data section is already\npresent in the current device memory but all of the data section is not\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc update device,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc update device. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc update device in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc update device, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3220 acc update device and acc update self\nSummary\nTheacc_update_device andacc_update_self routines test to see if the argument is in\nshared memory; if not, the argument must be present in the current device memory, and the routines\n\nupdate the data in device memory from the corresponding local memory ( acc_update_device )\nor update the data in local memory from the corresponding device memory ( acc_update_self )\nFormat\nC or C++:\nvoid acc_update_device(h_void *data_arg, size_t bytes);\nvoid acc_update_self (h_void *data_arg, size_t bytes);\n\nvoid acc_update_device_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_update_self_async (h_void *data_arg, size_t bytes,\nint async_arg);\n\nFortran:\nsubroutine acc_update_device(data_arg [, bytes ])\nsubroutine acc_update_self (data_arg [, bytes ])\n\nsubroutine acc_update_device_async(data_arg [, bytes ], async_arg)\nsubroutine acc_update_self_async (data_arg [, bytes ], async_arg)\n\ntype(*), dimension() :: data_arg\ninteger :: bytes\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call to an acc_update_device routine is functionally equivalent to an update device\ndirective A call to an acc_update_self routine is functionally equivalent to an updateself\ndirective See Section 2144 The arguments and the data section are as foracc_copyin \nThe behavior of these routines for the associated data section is:\n\tIf the data section is in shared memory or bytes is zero, no action is taken\n\tOtherwise:\n\t\tA call to an acc_update_device routine copies the data in the local memory to the\ncorresponding device memory\n\t\tA call to an acc_update_self routine copies the data in the corresponding device\nmemory to the local memory\nThe_async versions of these routines will perform the data transfers asynchrono usly on the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The synchro nous versions will not return\nuntil the data has been completely transferred\nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer and\nbytes is nonzero\n\tAnacc_error_not_present error is issued if the data section is not in shared memory\nand is not present in the current device memory\n\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\n\tAnacc_error_partly_present error is issued if part of the data section is already\npresent in the current device memory but all of the data section is not\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc update device,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc update self. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc update self in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc update self, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3220 acc update device and acc update self\nSummary\nTheacc_update_device andacc_update_self routines test to see if the argument is in\nshared memory; if not, the argument must be present in the current device memory, and the routines\n\nupdate the data in device memory from the corresponding local memory ( acc_update_device )\nor update the data in local memory from the corresponding device memory ( acc_update_self )\nFormat\nC or C++:\nvoid acc_update_device(h_void *data_arg, size_t bytes);\nvoid acc_update_self (h_void *data_arg, size_t bytes);\n\nvoid acc_update_device_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_update_self_async (h_void *data_arg, size_t bytes,\nint async_arg);\n\nFortran:\nsubroutine acc_update_device(data_arg [, bytes ])\nsubroutine acc_update_self (data_arg [, bytes ])\n\nsubroutine acc_update_device_async(data_arg [, bytes ], async_arg)\nsubroutine acc_update_self_async (data_arg [, bytes ], async_arg)\n\ntype(*), dimension() :: data_arg\ninteger :: bytes\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call to an acc_update_device routine is functionally equivalent to an update device\ndirective A call to an acc_update_self routine is functionally equivalent to an updateself\ndirective See Section 2144 The arguments and the data section are as foracc_copyin \nThe behavior of these routines for the associated data section is:\n\tIf the data section is in shared memory or bytes is zero, no action is taken\n\tOtherwise:\n\t\tA call to an acc_update_device routine copies the data in the local memory to the\ncorresponding device memory\n\t\tA call to an acc_update_self routine copies the data in the corresponding device\nmemory to the local memory\nThe_async versions of these routines will perform the data transfers asynchrono usly on the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The synchro nous versions will not return\nuntil the data has been completely transferred\nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer and\nbytes is nonzero\n\tAnacc_error_not_present error is issued if the data section is not in shared memory\nand is not present in the current device memory\n\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\n\tAnacc_error_partly_present error is issued if part of the data section is already\npresent in the current device memory but all of the data section is not\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc update self,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc update self. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc update self in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc update self, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3220 acc update device and acc update self\nSummary\nTheacc_update_device andacc_update_self routines test to see if the argument is in\nshared memory; if not, the argument must be present in the current device memory, and the routines\n\nupdate the data in device memory from the corresponding local memory ( acc_update_device )\nor update the data in local memory from the corresponding device memory ( acc_update_self )\nFormat\nC or C++:\nvoid acc_update_device(h_void *data_arg, size_t bytes);\nvoid acc_update_self (h_void *data_arg, size_t bytes);\n\nvoid acc_update_device_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_update_self_async (h_void *data_arg, size_t bytes,\nint async_arg);\n\nFortran:\nsubroutine acc_update_device(data_arg [, bytes ])\nsubroutine acc_update_self (data_arg [, bytes ])\n\nsubroutine acc_update_device_async(data_arg [, bytes ], async_arg)\nsubroutine acc_update_self_async (data_arg [, bytes ], async_arg)\n\ntype(*), dimension() :: data_arg\ninteger :: bytes\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call to an acc_update_device routine is functionally equivalent to an update device\ndirective A call to an acc_update_self routine is functionally equivalent to an updateself\ndirective See Section 2144 The arguments and the data section are as foracc_copyin \nThe behavior of these routines for the associated data section is:\n\tIf the data section is in shared memory or bytes is zero, no action is taken\n\tOtherwise:\n\t\tA call to an acc_update_device routine copies the data in the local memory to the\ncorresponding device memory\n\t\tA call to an acc_update_self routine copies the data in the corresponding device\nmemory to the local memory\nThe_async versions of these routines will perform the data transfers asynchrono usly on the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The synchro nous versions will not return\nuntil the data has been completely transferred\nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer and\nbytes is nonzero\n\tAnacc_error_not_present error is issued if the data section is not in shared memory\nand is not present in the current device memory\n\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\n\tAnacc_error_partly_present error is issued if part of the data section is already\npresent in the current device memory but all of the data section is not\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc update self,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc update self. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc update self in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc update self, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3220 acc update device and acc update self\nSummary\nTheacc_update_device andacc_update_self routines test to see if the argument is in\nshared memory; if not, the argument must be present in the current device memory, and the routines\n\nupdate the data in device memory from the corresponding local memory ( acc_update_device )\nor update the data in local memory from the corresponding device memory ( acc_update_self )\nFormat\nC or C++:\nvoid acc_update_device(h_void *data_arg, size_t bytes);\nvoid acc_update_self (h_void *data_arg, size_t bytes);\n\nvoid acc_update_device_async(h_void *data_arg, size_t bytes,\nint async_arg);\nvoid acc_update_self_async (h_void *data_arg, size_t bytes,\nint async_arg);\n\nFortran:\nsubroutine acc_update_device(data_arg [, bytes ])\nsubroutine acc_update_self (data_arg [, bytes ])\n\nsubroutine acc_update_device_async(data_arg [, bytes ], async_arg)\nsubroutine acc_update_self_async (data_arg [, bytes ], async_arg)\n\ntype(*), dimension() :: data_arg\ninteger :: bytes\ninteger(acc_handle_kind) :: async_arg\nDescription\nA call to an acc_update_device routine is functionally equivalent to an update device\ndirective A call to an acc_update_self routine is functionally equivalent to an updateself\ndirective See Section 2144 The arguments and the data section are as foracc_copyin \nThe behavior of these routines for the associated data section is:\n\tIf the data section is in shared memory or bytes is zero, no action is taken\n\tOtherwise:\n\t\tA call to an acc_update_device routine copies the data in the local memory to the\ncorresponding device memory\n\t\tA call to an acc_update_self routine copies the data in the corresponding device\nmemory to the local memory\nThe_async versions of these routines will perform the data transfers asynchrono usly on the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The synchro nous versions will not return\nuntil the data has been completely transferred\nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer and\nbytes is nonzero\n\tAnacc_error_not_present error is issued if the data section is not in shared memory\nand is not present in the current device memory\n\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\n\tAnacc_error_partly_present error is issued if part of the data section is already\npresent in the current device memory but all of the data section is not\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc update self,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc map data. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc map data in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc map data, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3221 acc map data\nSummary\nTheacc_map_data routine maps previously allocated space in the current device memory to the\nspeci\ufb01ed host data\nFormat\nC or C++:\nvoid acc_map_data(h_void *data_arg, d_void *data_dev,\nsize_t bytes);\nFortran:\nsubroutine acc_map_data(data_arg, data_dev, bytes)\ntype(*),dimension( *) :: data_arg\ntype(c_ptr), value :: data_dev\ninteger(c_size_t), value :: bytes\nDescription\nA call to the acc_map_data routine is similar to a call to acc_create , except that instead of\nallocating new device memory to start a data lifetime, the device address to use fo r the data lifetime\nis speci\ufb01ed as an argument data_arg is a host address, data_dev is the corresponding device\naddress, and bytes is the length in bytes data_dev may be the result of a call to acc_malloc ,\nor may come from some other device-speci\ufb01c API routine The associated data section is as for\nacc_copyin \nThe behavior of the acc_map_data routine is:\n\tIf the data section is in shared memory, the behavior is unde\ufb01ned\n\tIf any of the data referred to by data_dev is already mapped to any host memory address,\nthe behavior is unde\ufb01ned\n\tOtherwise, after this call, when data_arg appears in a data clause, the data_dev address\nwill be used The dynamic reference count for the data referred to by data_arg is set to\none, but no data movement will occur\nMemory mapped by acc_map_data may not have the associated dynamic reference count decre-\nmented to zero, except by a call to acc_unmap_data  See Section 267 Reference Counters\nErrors\n\tAnacc_invalid_null_pointer error is issued if either data_arg ordata_dev is\na null pointer\n\n\tAnacc_invalid_argument error is issued if bytes is zero\n\tAnacc_error_present error is issued if any part of the data section is already present\nin the current device memory\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc map data,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc map data. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc map data in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc map data, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3221 acc map data\nSummary\nTheacc_map_data routine maps previously allocated space in the current device memory to the\nspeci\ufb01ed host data\nFormat\nC or C++:\nvoid acc_map_data(h_void *data_arg, d_void *data_dev,\nsize_t bytes);\nFortran:\nsubroutine acc_map_data(data_arg, data_dev, bytes)\ntype(*),dimension( *) :: data_arg\ntype(c_ptr), value :: data_dev\ninteger(c_size_t), value :: bytes\nDescription\nA call to the acc_map_data routine is similar to a call to acc_create , except that instead of\nallocating new device memory to start a data lifetime, the device address to use fo r the data lifetime\nis speci\ufb01ed as an argument data_arg is a host address, data_dev is the corresponding device\naddress, and bytes is the length in bytes data_dev may be the result of a call to acc_malloc ,\nor may come from some other device-speci\ufb01c API routine The associated data section is as for\nacc_copyin \nThe behavior of the acc_map_data routine is:\n\tIf the data section is in shared memory, the behavior is unde\ufb01ned\n\tIf any of the data referred to by data_dev is already mapped to any host memory address,\nthe behavior is unde\ufb01ned\n\tOtherwise, after this call, when data_arg appears in a data clause, the data_dev address\nwill be used The dynamic reference count for the data referred to by data_arg is set to\none, but no data movement will occur\nMemory mapped by acc_map_data may not have the associated dynamic reference count decre-\nmented to zero, except by a call to acc_unmap_data  See Section 267 Reference Counters\nErrors\n\tAnacc_invalid_null_pointer error is issued if either data_arg ordata_dev is\na null pointer\n\n\tAnacc_invalid_argument error is issued if bytes is zero\n\tAnacc_error_present error is issued if any part of the data section is already present\nin the current device memory\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc map data,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc map data. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc map data in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc map data, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3221 acc map data\nSummary\nTheacc_map_data routine maps previously allocated space in the current device memory to the\nspeci\ufb01ed host data\nFormat\nC or C++:\nvoid acc_map_data(h_void *data_arg, d_void *data_dev,\nsize_t bytes);\nFortran:\nsubroutine acc_map_data(data_arg, data_dev, bytes)\ntype(*),dimension( *) :: data_arg\ntype(c_ptr), value :: data_dev\ninteger(c_size_t), value :: bytes\nDescription\nA call to the acc_map_data routine is similar to a call to acc_create , except that instead of\nallocating new device memory to start a data lifetime, the device address to use fo r the data lifetime\nis speci\ufb01ed as an argument data_arg is a host address, data_dev is the corresponding device\naddress, and bytes is the length in bytes data_dev may be the result of a call to acc_malloc ,\nor may come from some other device-speci\ufb01c API routine The associated data section is as for\nacc_copyin \nThe behavior of the acc_map_data routine is:\n\tIf the data section is in shared memory, the behavior is unde\ufb01ned\n\tIf any of the data referred to by data_dev is already mapped to any host memory address,\nthe behavior is unde\ufb01ned\n\tOtherwise, after this call, when data_arg appears in a data clause, the data_dev address\nwill be used The dynamic reference count for the data referred to by data_arg is set to\none, but no data movement will occur\nMemory mapped by acc_map_data may not have the associated dynamic reference count decre-\nmented to zero, except by a call to acc_unmap_data  See Section 267 Reference Counters\nErrors\n\tAnacc_invalid_null_pointer error is issued if either data_arg ordata_dev is\na null pointer\n\n\tAnacc_invalid_argument error is issued if bytes is zero\n\tAnacc_error_present error is issued if any part of the data section is already present\nin the current device memory\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc map data,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc unmap data. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc unmap data in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc unmap data, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3222 acc unmap data\nSummary\nTheacc_unmap_data routine unmaps device data from the speci\ufb01ed host data\nFormat\nC or C++:\nvoid acc_unmap_data(h_void *data_arg);\nFortran:\nsubroutine acc_unmap_data(data_arg)\ntype(*),dimension( *) :: data_arg\nDescription\nA call to the acc_unmap_data routine is similar to a call to acc_delete , except the device\nmemory is not deallocated data_arg is a host address\nThe behavior of the acc_unmap_data routine is:\n\tIfdata_arg was not previously mapped to some device address via a call to acc_map_data ,\nthe behavior is unde\ufb01ned\n\tOtherwise, the data lifetime for data_arg is ended The dynamic reference count for\ndata_arg is set to zero, but no data movement will occur and the corresponding dev ice\nmemory is not deallocated See Section 267 Reference Counters\nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer\n\tAnacc_error_present error is issued if the structured reference count for the any part\nof the data is not zero\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc unmap data,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc unmap data. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc unmap data in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc unmap data, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3222 acc unmap data\nSummary\nTheacc_unmap_data routine unmaps device data from the speci\ufb01ed host data\nFormat\nC or C++:\nvoid acc_unmap_data(h_void *data_arg);\nFortran:\nsubroutine acc_unmap_data(data_arg)\ntype(*),dimension( *) :: data_arg\nDescription\nA call to the acc_unmap_data routine is similar to a call to acc_delete , except the device\nmemory is not deallocated data_arg is a host address\nThe behavior of the acc_unmap_data routine is:\n\tIfdata_arg was not previously mapped to some device address via a call to acc_map_data ,\nthe behavior is unde\ufb01ned\n\tOtherwise, the data lifetime for data_arg is ended The dynamic reference count for\ndata_arg is set to zero, but no data movement will occur and the corresponding dev ice\nmemory is not deallocated See Section 267 Reference Counters\nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer\n\tAnacc_error_present error is issued if the structured reference count for the any part\nof the data is not zero\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc unmap data,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc unmap data. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc unmap data in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc unmap data, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3222 acc unmap data\nSummary\nTheacc_unmap_data routine unmaps device data from the speci\ufb01ed host data\nFormat\nC or C++:\nvoid acc_unmap_data(h_void *data_arg);\nFortran:\nsubroutine acc_unmap_data(data_arg)\ntype(*),dimension( *) :: data_arg\nDescription\nA call to the acc_unmap_data routine is similar to a call to acc_delete , except the device\nmemory is not deallocated data_arg is a host address\nThe behavior of the acc_unmap_data routine is:\n\tIfdata_arg was not previously mapped to some device address via a call to acc_map_data ,\nthe behavior is unde\ufb01ned\n\tOtherwise, the data lifetime for data_arg is ended The dynamic reference count for\ndata_arg is set to zero, but no data movement will occur and the corresponding dev ice\nmemory is not deallocated See Section 267 Reference Counters\nErrors\n\tAnacc_invalid_null_pointer error is issued if data_arg is a null pointer\n\tAnacc_error_present error is issued if the structured reference count for the any part\nof the data is not zero\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc unmap data,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc deviceptr. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc deviceptr in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc deviceptr, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3223 acc deviceptr\nSummary\nTheacc_deviceptr routine returns the device pointer associated with a speci\ufb01c host address \nFormat\nC or C++:\nd_void*acc_deviceptr(h_void *data_arg);\nFortran:\ntype(c_ptr) function acc_deviceptr(data_arg)\ntype(*),dimension( *) :: data_arg\n\nDescription\nTheacc_deviceptr routine returns the device pointer associated with a host address data_arg\nis the address of a host variable or array that may have an active lifetime on the current device\nThe behavior of the acc_deviceptr routine for the data referred to by data_arg is:\n\tIf the data is in shared memory or data_arg is a null pointer, acc_deviceptr returns\nthe incoming address\n\tIf the data is not present in the current device memory, acc_deviceptr returns a null\npointer\n\tOtherwise, acc_deviceptr returns the address in the current device memory that corre-\nsponds to the address data_arg\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc deviceptr,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc deviceptr. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc deviceptr in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc deviceptr, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3223 acc deviceptr\nSummary\nTheacc_deviceptr routine returns the device pointer associated with a speci\ufb01c host address \nFormat\nC or C++:\nd_void*acc_deviceptr(h_void *data_arg);\nFortran:\ntype(c_ptr) function acc_deviceptr(data_arg)\ntype(*),dimension( *) :: data_arg\n\nDescription\nTheacc_deviceptr routine returns the device pointer associated with a host address data_arg\nis the address of a host variable or array that may have an active lifetime on the current device\nThe behavior of the acc_deviceptr routine for the data referred to by data_arg is:\n\tIf the data is in shared memory or data_arg is a null pointer, acc_deviceptr returns\nthe incoming address\n\tIf the data is not present in the current device memory, acc_deviceptr returns a null\npointer\n\tOtherwise, acc_deviceptr returns the address in the current device memory that corre-\nsponds to the address data_arg\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc deviceptr,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc deviceptr. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc deviceptr in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc deviceptr, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3223 acc deviceptr\nSummary\nTheacc_deviceptr routine returns the device pointer associated with a speci\ufb01c host address \nFormat\nC or C++:\nd_void*acc_deviceptr(h_void *data_arg);\nFortran:\ntype(c_ptr) function acc_deviceptr(data_arg)\ntype(*),dimension( *) :: data_arg\n\nDescription\nTheacc_deviceptr routine returns the device pointer associated with a host address data_arg\nis the address of a host variable or array that may have an active lifetime on the current device\nThe behavior of the acc_deviceptr routine for the data referred to by data_arg is:\n\tIf the data is in shared memory or data_arg is a null pointer, acc_deviceptr returns\nthe incoming address\n\tIf the data is not present in the current device memory, acc_deviceptr returns a null\npointer\n\tOtherwise, acc_deviceptr returns the address in the current device memory that corre-\nsponds to the address data_arg\n\nTemplate:\n\n#ifndef T1\n!T1:acc deviceptr,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc hostptr. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc hostptr in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc hostptr, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3224 acc hostptr\nSummary\nTheacc_hostptr routine returns the host pointer associated with a speci\ufb01c device address \nFormat\nC or C++:\nh_void*acc_hostptr(d_void *data_dev);\nFortran:\ntype(c_ptr) function acc_hostptr(data_dev)\ntype(c_ptr), value :: data_dev\nDescription\nTheacc_hostptr routine returns the host pointer associated with a device address data_dev\nis the address of a device variable or array, such as that returned fro macc_deviceptr ,acc_create\noracc_copyin \nThe behavior of the acc_hostptr routine for the data referred to by data_dev is:\n\tIf the data is in shared memory or data_dev is a null pointer, acc_hostptr returns the\nincoming address\n\tIf the data corresponds to a host address which is present in the curre nt device memory,\nacc_hostptr returns the host address\n\tOtherwise, acc_hostptr returns a null pointer\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc hostptr,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc hostptr. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc hostptr in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc hostptr, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3224 acc hostptr\nSummary\nTheacc_hostptr routine returns the host pointer associated with a speci\ufb01c device address \nFormat\nC or C++:\nh_void*acc_hostptr(d_void *data_dev);\nFortran:\ntype(c_ptr) function acc_hostptr(data_dev)\ntype(c_ptr), value :: data_dev\nDescription\nTheacc_hostptr routine returns the host pointer associated with a device address data_dev\nis the address of a device variable or array, such as that returned fro macc_deviceptr ,acc_create\noracc_copyin \nThe behavior of the acc_hostptr routine for the data referred to by data_dev is:\n\tIf the data is in shared memory or data_dev is a null pointer, acc_hostptr returns the\nincoming address\n\tIf the data corresponds to a host address which is present in the curre nt device memory,\nacc_hostptr returns the host address\n\tOtherwise, acc_hostptr returns a null pointer\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc hostptr,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc hostptr. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc hostptr in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc hostptr, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3224 acc hostptr\nSummary\nTheacc_hostptr routine returns the host pointer associated with a speci\ufb01c device address \nFormat\nC or C++:\nh_void*acc_hostptr(d_void *data_dev);\nFortran:\ntype(c_ptr) function acc_hostptr(data_dev)\ntype(c_ptr), value :: data_dev\nDescription\nTheacc_hostptr routine returns the host pointer associated with a device address data_dev\nis the address of a device variable or array, such as that returned fro macc_deviceptr ,acc_create\noracc_copyin \nThe behavior of the acc_hostptr routine for the data referred to by data_dev is:\n\tIf the data is in shared memory or data_dev is a null pointer, acc_hostptr returns the\nincoming address\n\tIf the data corresponds to a host address which is present in the curre nt device memory,\nacc_hostptr returns the host address\n\tOtherwise, acc_hostptr returns a null pointer\n\nTemplate:\n\n#ifndef T1\n!T1:acc hostptr,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc is present. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc is present in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc is present, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3225 acc ispresent\nSummary\nTheacc_is_present routine tests whether a variable or array region is accessible from the\ncurrent device\nFormat\nC or C++:\nint acc_is_present(h_void *data_arg, size_t bytes);\n\nFortran:\nlogical function acc_is_present(data_arg)\nlogical function acc_is_present(data_arg, bytes)\ntype(*), dimension() :: data_arg\ninteger :: bytes\nDescription\nTheacc_is_present routine tests whether the speci\ufb01ed host data is accessible from the curren t\ndevice In C/C++, data_arg is a pointer to the data, and bytes speci\ufb01es the data size in bytes In\nFortran, two forms are supported In the \ufb01rst, data_arg is a variable or contiguous array section\nIn the second, data_arg is a variable or array element and bytes is the length in bytes A\nbytes value of zero is treated as a value of one if data_arg is not a null pointer\nThe behavior of the acc_is_present routines for the data referred to by data_arg is:\n\tIf the data is in shared memory, a call to acc_is_present will evaluate to true\n\tIf the data is present in the current device memory, a call to acc_is_present will evaluate\ntotrue\n\tOtherwise, a call to acc_is_present will evaluate to false \nErrors\n\tAnacc_error_invalid_argument error is issued if bytes is negative (in Fortran)\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc is present,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc is present. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc is present in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc is present, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3225 acc ispresent\nSummary\nTheacc_is_present routine tests whether a variable or array region is accessible from the\ncurrent device\nFormat\nC or C++:\nint acc_is_present(h_void *data_arg, size_t bytes);\n\nFortran:\nlogical function acc_is_present(data_arg)\nlogical function acc_is_present(data_arg, bytes)\ntype(*), dimension() :: data_arg\ninteger :: bytes\nDescription\nTheacc_is_present routine tests whether the speci\ufb01ed host data is accessible from the curren t\ndevice In C/C++, data_arg is a pointer to the data, and bytes speci\ufb01es the data size in bytes In\nFortran, two forms are supported In the \ufb01rst, data_arg is a variable or contiguous array section\nIn the second, data_arg is a variable or array element and bytes is the length in bytes A\nbytes value of zero is treated as a value of one if data_arg is not a null pointer\nThe behavior of the acc_is_present routines for the data referred to by data_arg is:\n\tIf the data is in shared memory, a call to acc_is_present will evaluate to true\n\tIf the data is present in the current device memory, a call to acc_is_present will evaluate\ntotrue\n\tOtherwise, a call to acc_is_present will evaluate to false \nErrors\n\tAnacc_error_invalid_argument error is issued if bytes is negative (in Fortran)\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc is present,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc is present. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc is present in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc is present, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3225 acc ispresent\nSummary\nTheacc_is_present routine tests whether a variable or array region is accessible from the\ncurrent device\nFormat\nC or C++:\nint acc_is_present(h_void *data_arg, size_t bytes);\n\nFortran:\nlogical function acc_is_present(data_arg)\nlogical function acc_is_present(data_arg, bytes)\ntype(*), dimension() :: data_arg\ninteger :: bytes\nDescription\nTheacc_is_present routine tests whether the speci\ufb01ed host data is accessible from the curren t\ndevice In C/C++, data_arg is a pointer to the data, and bytes speci\ufb01es the data size in bytes In\nFortran, two forms are supported In the \ufb01rst, data_arg is a variable or contiguous array section\nIn the second, data_arg is a variable or array element and bytes is the length in bytes A\nbytes value of zero is treated as a value of one if data_arg is not a null pointer\nThe behavior of the acc_is_present routines for the data referred to by data_arg is:\n\tIf the data is in shared memory, a call to acc_is_present will evaluate to true\n\tIf the data is present in the current device memory, a call to acc_is_present will evaluate\ntotrue\n\tOtherwise, a call to acc_is_present will evaluate to false \nErrors\n\tAnacc_error_invalid_argument error is issued if bytes is negative (in Fortran)\n\tAnacc_error_invalid_data_section error is issued if data_arg is an array sec-\ntion that is not contiguous (in Fortran)\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc is present,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc memcpy to device. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc memcpy to device in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc memcpy to device, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3226 acc memcpy todevice\nSummary\nTheacc_memcpy_to_device routine copies data from local memory to device memory\nFormat\nC or C++:\nvoid acc_memcpy_to_device(d_void *data_dev_dest,\nh_void*data_host_src, size_t bytes);\nvoid acc_memcpy_to_device_async(d_void *data_dev_dest,\nh_void*data_host_src, size_t bytes,\nint async_arg);\nFortran:\nsubroutine acc_memcpy_to_device(data_dev_dest,\ndata_host_src, bytes)\nsubroutine acc_memcpy_to_device_async(data_dev_dest,\ndata_host_src, bytes, async_arg)\ntype(c_ptr), value :: data_dev_dest\ntype(*),dimension( *) :: data_host_src\ninteger(c_size_t), value :: bytes\ninteger(acc_handle_kind), value :: async_arg\n\nDescription\nTheacc_memcpy_to_device routine copies bytes bytes of data from the local address in\ndata_host_src to the device address in data_dev_dest data_dev_dest must be an\naddress accessible from the current device, such as an address re turned from acc_malloc or\nacc_deviceptr , or an address in shared memory\nThe behavior of the acc_memcpy_to_device routines is:\n\tIfbytes is zero, no action is taken\n\tIfdata_dev_dest anddata_host_src both refer to shared memory and have the same\nvalue, no action is taken\n\tIfdata_dev_dest anddata_host_src both refer to shared memory and the memory\nregions overlap, the behavior is unde\ufb01ned\n\tIf the data referred to by data_dev_dest is not accessible by the current device, the be-\nhavior is unde\ufb01ned\n\tIf the data referred to by data_host_src is not accessible by the local thread, the behavior\nis unde\ufb01ned\n\tOtherwise, bytes bytes of data at data_host_src in local memory are copied to\ndata_dev_dest in the current device memory\nThe_async version of this routine will perform the data transfers asynchronously o n the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The synchro nous versions will not return\nuntil the data has been completely transferred\nErrors\n\tAnacc_error_invalid_null_pointer error is issued if data_dev_dest or\ndata_host_src is a null pointer and bytes is nonzero\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc memcpy to device,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc memcpy to device. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc memcpy to device in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc memcpy to device, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3226 acc memcpy todevice\nSummary\nTheacc_memcpy_to_device routine copies data from local memory to device memory\nFormat\nC or C++:\nvoid acc_memcpy_to_device(d_void *data_dev_dest,\nh_void*data_host_src, size_t bytes);\nvoid acc_memcpy_to_device_async(d_void *data_dev_dest,\nh_void*data_host_src, size_t bytes,\nint async_arg);\nFortran:\nsubroutine acc_memcpy_to_device(data_dev_dest,\ndata_host_src, bytes)\nsubroutine acc_memcpy_to_device_async(data_dev_dest,\ndata_host_src, bytes, async_arg)\ntype(c_ptr), value :: data_dev_dest\ntype(*),dimension( *) :: data_host_src\ninteger(c_size_t), value :: bytes\ninteger(acc_handle_kind), value :: async_arg\n\nDescription\nTheacc_memcpy_to_device routine copies bytes bytes of data from the local address in\ndata_host_src to the device address in data_dev_dest data_dev_dest must be an\naddress accessible from the current device, such as an address re turned from acc_malloc or\nacc_deviceptr , or an address in shared memory\nThe behavior of the acc_memcpy_to_device routines is:\n\tIfbytes is zero, no action is taken\n\tIfdata_dev_dest anddata_host_src both refer to shared memory and have the same\nvalue, no action is taken\n\tIfdata_dev_dest anddata_host_src both refer to shared memory and the memory\nregions overlap, the behavior is unde\ufb01ned\n\tIf the data referred to by data_dev_dest is not accessible by the current device, the be-\nhavior is unde\ufb01ned\n\tIf the data referred to by data_host_src is not accessible by the local thread, the behavior\nis unde\ufb01ned\n\tOtherwise, bytes bytes of data at data_host_src in local memory are copied to\ndata_dev_dest in the current device memory\nThe_async version of this routine will perform the data transfers asynchronously o n the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The synchro nous versions will not return\nuntil the data has been completely transferred\nErrors\n\tAnacc_error_invalid_null_pointer error is issued if data_dev_dest or\ndata_host_src is a null pointer and bytes is nonzero\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc memcpy to device,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc memcpy to device. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc memcpy to device in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc memcpy to device, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3226 acc memcpy todevice\nSummary\nTheacc_memcpy_to_device routine copies data from local memory to device memory\nFormat\nC or C++:\nvoid acc_memcpy_to_device(d_void *data_dev_dest,\nh_void*data_host_src, size_t bytes);\nvoid acc_memcpy_to_device_async(d_void *data_dev_dest,\nh_void*data_host_src, size_t bytes,\nint async_arg);\nFortran:\nsubroutine acc_memcpy_to_device(data_dev_dest,\ndata_host_src, bytes)\nsubroutine acc_memcpy_to_device_async(data_dev_dest,\ndata_host_src, bytes, async_arg)\ntype(c_ptr), value :: data_dev_dest\ntype(*),dimension( *) :: data_host_src\ninteger(c_size_t), value :: bytes\ninteger(acc_handle_kind), value :: async_arg\n\nDescription\nTheacc_memcpy_to_device routine copies bytes bytes of data from the local address in\ndata_host_src to the device address in data_dev_dest data_dev_dest must be an\naddress accessible from the current device, such as an address re turned from acc_malloc or\nacc_deviceptr , or an address in shared memory\nThe behavior of the acc_memcpy_to_device routines is:\n\tIfbytes is zero, no action is taken\n\tIfdata_dev_dest anddata_host_src both refer to shared memory and have the same\nvalue, no action is taken\n\tIfdata_dev_dest anddata_host_src both refer to shared memory and the memory\nregions overlap, the behavior is unde\ufb01ned\n\tIf the data referred to by data_dev_dest is not accessible by the current device, the be-\nhavior is unde\ufb01ned\n\tIf the data referred to by data_host_src is not accessible by the local thread, the behavior\nis unde\ufb01ned\n\tOtherwise, bytes bytes of data at data_host_src in local memory are copied to\ndata_dev_dest in the current device memory\nThe_async version of this routine will perform the data transfers asynchronously o n the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The synchro nous versions will not return\nuntil the data has been completely transferred\nErrors\n\tAnacc_error_invalid_null_pointer error is issued if data_dev_dest or\ndata_host_src is a null pointer and bytes is nonzero\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc memcpy to device,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc memcpy from device. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc memcpy from device in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc memcpy from device, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3227 acc memcpy from device\nSummary\nTheacc_memcpy_from_device routine copies data from device memory to local memory\nFormat\nC or C++:\nvoid acc_memcpy_from_device(h_void *data_host_dest,\nd_void*data_dev_src, size_t bytes);\nvoid acc_memcpy_from_device_async(h_void *data_host_dest,\nd_void*data_dev_src, size_t bytes,\nint async_arg);\nFortran:\nsubroutine acc_memcpy_from_device(data_host_dest,\n\ndata_dev_src, bytes)\nsubroutine acc_memcpy_from_device_async(data_host_de st,\ndata_dev_src, bytes, async_arg)\ntype(*),dimension( *) :: data_host_dest\ntype(c_ptr), value :: data_dev_src\ninteger(c_size_t), value :: bytes\ninteger(acc_handle_kind), value :: async_arg\nDescription\nTheacc_memcpy_from_device routine copies bytes bytes of data from the device address\nindata_dev_src to the local address in data_host_dest data_dev_src must be an\naddress accessible from the current device, such as an address re turned from acc_malloc or\nacc_deviceptr , or an address in shared memory\nThe behavior of the acc_memcpy_from_device routines is:\n\tIfbytes is zero, no action is taken\n\tIfdata_host_dest anddata_dev_src both refer to shared memory and have the same\nvalue, no action is taken\n\tIfdata_host_dest anddata_dev_src both refer to shared memory and the memory\nregions overlap, the behavior is unde\ufb01ned\n\tIf the data referred to by data_dev_src is not accessible by the current device, the behav-\nior is unde\ufb01ned\n\tIf the data referred to by data_host_dest is not accessible by the local thread, the behav-\nior is unde\ufb01ned\n\tOtherwise, bytes bytes of data at data_dev_src in the current device memory are copied\ntodata_host_dest in local memory\nThe_async version of this routine will perform the data transfers asynchronously o n the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The synchro nous versions will not return\nuntil the data has been completely transferred\nErrors\n\tAnacc_error_invalid_null_pointer error is issued if data_host_dest or\ndata_dev_src is a null pointer and bytes is nonzero\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc memcpy from device,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc memcpy from device. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc memcpy from device in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc memcpy from device, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3227 acc memcpy from device\nSummary\nTheacc_memcpy_from_device routine copies data from device memory to local memory\nFormat\nC or C++:\nvoid acc_memcpy_from_device(h_void *data_host_dest,\nd_void*data_dev_src, size_t bytes);\nvoid acc_memcpy_from_device_async(h_void *data_host_dest,\nd_void*data_dev_src, size_t bytes,\nint async_arg);\nFortran:\nsubroutine acc_memcpy_from_device(data_host_dest,\n\ndata_dev_src, bytes)\nsubroutine acc_memcpy_from_device_async(data_host_de st,\ndata_dev_src, bytes, async_arg)\ntype(*),dimension( *) :: data_host_dest\ntype(c_ptr), value :: data_dev_src\ninteger(c_size_t), value :: bytes\ninteger(acc_handle_kind), value :: async_arg\nDescription\nTheacc_memcpy_from_device routine copies bytes bytes of data from the device address\nindata_dev_src to the local address in data_host_dest data_dev_src must be an\naddress accessible from the current device, such as an address re turned from acc_malloc or\nacc_deviceptr , or an address in shared memory\nThe behavior of the acc_memcpy_from_device routines is:\n\tIfbytes is zero, no action is taken\n\tIfdata_host_dest anddata_dev_src both refer to shared memory and have the same\nvalue, no action is taken\n\tIfdata_host_dest anddata_dev_src both refer to shared memory and the memory\nregions overlap, the behavior is unde\ufb01ned\n\tIf the data referred to by data_dev_src is not accessible by the current device, the behav-\nior is unde\ufb01ned\n\tIf the data referred to by data_host_dest is not accessible by the local thread, the behav-\nior is unde\ufb01ned\n\tOtherwise, bytes bytes of data at data_dev_src in the current device memory are copied\ntodata_host_dest in local memory\nThe_async version of this routine will perform the data transfers asynchronously o n the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The synchro nous versions will not return\nuntil the data has been completely transferred\nErrors\n\tAnacc_error_invalid_null_pointer error is issued if data_host_dest or\ndata_dev_src is a null pointer and bytes is nonzero\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc memcpy from device,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc memcpy from device. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc memcpy from device in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc memcpy from device, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3227 acc memcpy from device\nSummary\nTheacc_memcpy_from_device routine copies data from device memory to local memory\nFormat\nC or C++:\nvoid acc_memcpy_from_device(h_void *data_host_dest,\nd_void*data_dev_src, size_t bytes);\nvoid acc_memcpy_from_device_async(h_void *data_host_dest,\nd_void*data_dev_src, size_t bytes,\nint async_arg);\nFortran:\nsubroutine acc_memcpy_from_device(data_host_dest,\n\ndata_dev_src, bytes)\nsubroutine acc_memcpy_from_device_async(data_host_de st,\ndata_dev_src, bytes, async_arg)\ntype(*),dimension( *) :: data_host_dest\ntype(c_ptr), value :: data_dev_src\ninteger(c_size_t), value :: bytes\ninteger(acc_handle_kind), value :: async_arg\nDescription\nTheacc_memcpy_from_device routine copies bytes bytes of data from the device address\nindata_dev_src to the local address in data_host_dest data_dev_src must be an\naddress accessible from the current device, such as an address re turned from acc_malloc or\nacc_deviceptr , or an address in shared memory\nThe behavior of the acc_memcpy_from_device routines is:\n\tIfbytes is zero, no action is taken\n\tIfdata_host_dest anddata_dev_src both refer to shared memory and have the same\nvalue, no action is taken\n\tIfdata_host_dest anddata_dev_src both refer to shared memory and the memory\nregions overlap, the behavior is unde\ufb01ned\n\tIf the data referred to by data_dev_src is not accessible by the current device, the behav-\nior is unde\ufb01ned\n\tIf the data referred to by data_host_dest is not accessible by the local thread, the behav-\nior is unde\ufb01ned\n\tOtherwise, bytes bytes of data at data_dev_src in the current device memory are copied\ntodata_host_dest in local memory\nThe_async version of this routine will perform the data transfers asynchronously o n the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The synchro nous versions will not return\nuntil the data has been completely transferred\nErrors\n\tAnacc_error_invalid_null_pointer error is issued if data_host_dest or\ndata_dev_src is a null pointer and bytes is nonzero\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc memcpy from device,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc memcpy device. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc memcpy device in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc memcpy device, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3228 acc memcpy device\nSummary\nTheacc_memcpy_device routine copies data from one memory location to another memory\nlocation on the current device\n\nFormat\nC or C++:\nvoid acc_memcpy_device(d_void *data_dev_dest,\nd_void*data_dev_src, size_t bytes);\nvoid acc_memcpy_device_async(d_void *data_dev_dest,\nd_void*data_dev_src, size_t bytes,\nint async_arg);\nFortran:\nsubroutine acc_memcpy_device(data_dev_dest,\ndata_dev_src, bytes);\nsubroutine acc_memcpy_device_async(data_dev_dest,\ndata_dev_src, bytes,\nasync_arg);\ntype(c_ptr), value :: data_dev_dest\ntype(c_ptr), value :: data_dev_src\ninteger(c_size_t), value :: bytes\ninteger(acc_handle_kind), value :: async_arg\nDescription\nTheacc_memcpy_device routine copies bytes bytes of data from the device address in\ndata_dev_src to the device address in data_dev_dest  Both addresses must be addresses in\nthe current device memory, such as would be returned from acc_malloc oracc_deviceptr \nThe behavior of the acc_memcpy_device routines is:\n\tIfbytes is zero, no action is taken\n\tIfdata_dev_dest anddata_dev_src have the same value, no action is taken\n\tIf the memory regions referred to by data_dev_dest anddata_dev_src overlap, the\nbehavior is unde\ufb01ned\n\tIf the data referred to by data_dev_src ordata_dev_dest is not accessible by the\ncurrent device, the behavior is unde\ufb01ned\n\tOtherwise, bytes bytes of data at data_dev_src in the current device memory are copied\ntodata_dev_dest in the current device memory\nThe_async version of this routine will perform the data transfers asynchronously o n the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The synchro nous versions will not return\nuntil the data has been completely transferred\nErrors\n\tAnacc_error_invalid_null_pointer error is issued if data_dev_dest or\ndata_dev_src is a null pointer and bytes is nonzero\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc memcpy device,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc memcpy device. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc memcpy device in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc memcpy device, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3228 acc memcpy device\nSummary\nTheacc_memcpy_device routine copies data from one memory location to another memory\nlocation on the current device\n\nFormat\nC or C++:\nvoid acc_memcpy_device(d_void *data_dev_dest,\nd_void*data_dev_src, size_t bytes);\nvoid acc_memcpy_device_async(d_void *data_dev_dest,\nd_void*data_dev_src, size_t bytes,\nint async_arg);\nFortran:\nsubroutine acc_memcpy_device(data_dev_dest,\ndata_dev_src, bytes);\nsubroutine acc_memcpy_device_async(data_dev_dest,\ndata_dev_src, bytes,\nasync_arg);\ntype(c_ptr), value :: data_dev_dest\ntype(c_ptr), value :: data_dev_src\ninteger(c_size_t), value :: bytes\ninteger(acc_handle_kind), value :: async_arg\nDescription\nTheacc_memcpy_device routine copies bytes bytes of data from the device address in\ndata_dev_src to the device address in data_dev_dest  Both addresses must be addresses in\nthe current device memory, such as would be returned from acc_malloc oracc_deviceptr \nThe behavior of the acc_memcpy_device routines is:\n\tIfbytes is zero, no action is taken\n\tIfdata_dev_dest anddata_dev_src have the same value, no action is taken\n\tIf the memory regions referred to by data_dev_dest anddata_dev_src overlap, the\nbehavior is unde\ufb01ned\n\tIf the data referred to by data_dev_src ordata_dev_dest is not accessible by the\ncurrent device, the behavior is unde\ufb01ned\n\tOtherwise, bytes bytes of data at data_dev_src in the current device memory are copied\ntodata_dev_dest in the current device memory\nThe_async version of this routine will perform the data transfers asynchronously o n the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The synchro nous versions will not return\nuntil the data has been completely transferred\nErrors\n\tAnacc_error_invalid_null_pointer error is issued if data_dev_dest or\ndata_dev_src is a null pointer and bytes is nonzero\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc memcpy device,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc memcpy device. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc memcpy device in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc memcpy device, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3228 acc memcpy device\nSummary\nTheacc_memcpy_device routine copies data from one memory location to another memory\nlocation on the current device\n\nFormat\nC or C++:\nvoid acc_memcpy_device(d_void *data_dev_dest,\nd_void*data_dev_src, size_t bytes);\nvoid acc_memcpy_device_async(d_void *data_dev_dest,\nd_void*data_dev_src, size_t bytes,\nint async_arg);\nFortran:\nsubroutine acc_memcpy_device(data_dev_dest,\ndata_dev_src, bytes);\nsubroutine acc_memcpy_device_async(data_dev_dest,\ndata_dev_src, bytes,\nasync_arg);\ntype(c_ptr), value :: data_dev_dest\ntype(c_ptr), value :: data_dev_src\ninteger(c_size_t), value :: bytes\ninteger(acc_handle_kind), value :: async_arg\nDescription\nTheacc_memcpy_device routine copies bytes bytes of data from the device address in\ndata_dev_src to the device address in data_dev_dest  Both addresses must be addresses in\nthe current device memory, such as would be returned from acc_malloc oracc_deviceptr \nThe behavior of the acc_memcpy_device routines is:\n\tIfbytes is zero, no action is taken\n\tIfdata_dev_dest anddata_dev_src have the same value, no action is taken\n\tIf the memory regions referred to by data_dev_dest anddata_dev_src overlap, the\nbehavior is unde\ufb01ned\n\tIf the data referred to by data_dev_src ordata_dev_dest is not accessible by the\ncurrent device, the behavior is unde\ufb01ned\n\tOtherwise, bytes bytes of data at data_dev_src in the current device memory are copied\ntodata_dev_dest in the current device memory\nThe_async version of this routine will perform the data transfers asynchronously o n the async\nqueue associated with async_arg  The routine may return before the data has been transferred;\nsee Section 216 Asynchronous Behavior for more details The synchro nous versions will not return\nuntil the data has been completely transferred\nErrors\n\tAnacc_error_invalid_null_pointer error is issued if data_dev_dest or\ndata_dev_src is a null pointer and bytes is nonzero\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc memcpy device,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc attach. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc attach in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc attach, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3229 acc attach and acc detach\nSummary\nTheacc_attach routines update a pointer in device memory to point to the corresponding devic e\ncopy of the host pointer target The acc_detach routines restore a pointer in device memory to\npoint to the host pointer target\nFormat\nC or C++:\nvoid acc_attach(h_void **ptr_addr);\nvoid acc_attach_async(h_void **ptr_addr, int async_arg);\n\nvoid acc_detach(h_void **ptr_addr);\nvoid acc_detach_async(h_void **ptr_addr, int async_arg);\nvoid acc_detach_finalize(h_void **ptr_addr);\nvoid acc_detach_finalize_async(h_void **ptr_addr,\nint async_arg);\nFortran:\nsubroutine acc_attach(ptr_addr)\nsubroutine acc_attach_async(ptr_addr, async_arg)\ntype(*),dimension() :: ptr_addr\ninteger(acc_handle_kind),value :: async_arg\n\nsubroutine acc_detach(ptr_addr)\nsubroutine acc_detach_async(ptr_addr, async_arg)\nsubroutine acc_detach_finalize(ptr_addr)\nsubroutine acc_detach_finalize_async(ptr_addr,\nasync_arg)\ntype(*),dimension() :: ptr_addr\ninteger(acc_handle_kind),value :: async_arg\nDescription\nA call to an acc_attach routine is functionally equivalent to an enter data attach direc-\ntive, as described in Section 2712 A call to an acc_detach routine is functionally equivalent to\nanexitdatadetach directive, and a call to an acc_detach_finalize routine is function-\nally equivalent to an exit data finalize detach directive, as described in Section 2713\nptr_addr must be the address of a host pointer async_arg must be an async-argument as\nde\ufb01ned in Section 216\nThe behavior of these routines is:\n\tIfptr_addr refers to shared memory, no action is taken\n\tIf the pointer referred to by ptr_addr is not present in the current device memory, no action\nis taken\n\tOtherwise:\n\t\tTheacc_attach routines perform an attach action on the pointer referred to by\nptr_addr ; see Section 272\n\n\t\tTheacc_detach routines perform a detach action on the pointer referred to by ptr_addr ;\nSee Section 272\n\t\tTheacc_detach_finalize routines perform an immediate detach action on the\npointer referred to by ptr_addr ; see Section 272\nThese routines may issue a data transfer from local memory to device memory The_async ver-\nsions of these routines will perform the data transfers asynchronously on the async queue associated\nwithasync_arg  These routines may return before the data has been transferred; see Section 2\nfor more details The synchronous versions will not return until the data h as been completely trans-\nferred\nErrors\n\tAnacc_error_invalid_null_pointer error is issued if ptr_addr is a null pointer\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc attach,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc attach. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc attach in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc attach, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3229 acc attach and acc detach\nSummary\nTheacc_attach routines update a pointer in device memory to point to the corresponding devic e\ncopy of the host pointer target The acc_detach routines restore a pointer in device memory to\npoint to the host pointer target\nFormat\nC or C++:\nvoid acc_attach(h_void **ptr_addr);\nvoid acc_attach_async(h_void **ptr_addr, int async_arg);\n\nvoid acc_detach(h_void **ptr_addr);\nvoid acc_detach_async(h_void **ptr_addr, int async_arg);\nvoid acc_detach_finalize(h_void **ptr_addr);\nvoid acc_detach_finalize_async(h_void **ptr_addr,\nint async_arg);\nFortran:\nsubroutine acc_attach(ptr_addr)\nsubroutine acc_attach_async(ptr_addr, async_arg)\ntype(*),dimension() :: ptr_addr\ninteger(acc_handle_kind),value :: async_arg\n\nsubroutine acc_detach(ptr_addr)\nsubroutine acc_detach_async(ptr_addr, async_arg)\nsubroutine acc_detach_finalize(ptr_addr)\nsubroutine acc_detach_finalize_async(ptr_addr,\nasync_arg)\ntype(*),dimension() :: ptr_addr\ninteger(acc_handle_kind),value :: async_arg\nDescription\nA call to an acc_attach routine is functionally equivalent to an enter data attach direc-\ntive, as described in Section 2712 A call to an acc_detach routine is functionally equivalent to\nanexitdatadetach directive, and a call to an acc_detach_finalize routine is function-\nally equivalent to an exit data finalize detach directive, as described in Section 2713\nptr_addr must be the address of a host pointer async_arg must be an async-argument as\nde\ufb01ned in Section 216\nThe behavior of these routines is:\n\tIfptr_addr refers to shared memory, no action is taken\n\tIf the pointer referred to by ptr_addr is not present in the current device memory, no action\nis taken\n\tOtherwise:\n\t\tTheacc_attach routines perform an attach action on the pointer referred to by\nptr_addr ; see Section 272\n\n\t\tTheacc_detach routines perform a detach action on the pointer referred to by ptr_addr ;\nSee Section 272\n\t\tTheacc_detach_finalize routines perform an immediate detach action on the\npointer referred to by ptr_addr ; see Section 272\nThese routines may issue a data transfer from local memory to device memory The_async ver-\nsions of these routines will perform the data transfers asynchronously on the async queue associated\nwithasync_arg  These routines may return before the data has been transferred; see Section 2\nfor more details The synchronous versions will not return until the data h as been completely trans-\nferred\nErrors\n\tAnacc_error_invalid_null_pointer error is issued if ptr_addr is a null pointer\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc attach,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc attach. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc attach in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc attach, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3229 acc attach and acc detach\nSummary\nTheacc_attach routines update a pointer in device memory to point to the corresponding devic e\ncopy of the host pointer target The acc_detach routines restore a pointer in device memory to\npoint to the host pointer target\nFormat\nC or C++:\nvoid acc_attach(h_void **ptr_addr);\nvoid acc_attach_async(h_void **ptr_addr, int async_arg);\n\nvoid acc_detach(h_void **ptr_addr);\nvoid acc_detach_async(h_void **ptr_addr, int async_arg);\nvoid acc_detach_finalize(h_void **ptr_addr);\nvoid acc_detach_finalize_async(h_void **ptr_addr,\nint async_arg);\nFortran:\nsubroutine acc_attach(ptr_addr)\nsubroutine acc_attach_async(ptr_addr, async_arg)\ntype(*),dimension() :: ptr_addr\ninteger(acc_handle_kind),value :: async_arg\n\nsubroutine acc_detach(ptr_addr)\nsubroutine acc_detach_async(ptr_addr, async_arg)\nsubroutine acc_detach_finalize(ptr_addr)\nsubroutine acc_detach_finalize_async(ptr_addr,\nasync_arg)\ntype(*),dimension() :: ptr_addr\ninteger(acc_handle_kind),value :: async_arg\nDescription\nA call to an acc_attach routine is functionally equivalent to an enter data attach direc-\ntive, as described in Section 2712 A call to an acc_detach routine is functionally equivalent to\nanexitdatadetach directive, and a call to an acc_detach_finalize routine is function-\nally equivalent to an exit data finalize detach directive, as described in Section 2713\nptr_addr must be the address of a host pointer async_arg must be an async-argument as\nde\ufb01ned in Section 216\nThe behavior of these routines is:\n\tIfptr_addr refers to shared memory, no action is taken\n\tIf the pointer referred to by ptr_addr is not present in the current device memory, no action\nis taken\n\tOtherwise:\n\t\tTheacc_attach routines perform an attach action on the pointer referred to by\nptr_addr ; see Section 272\n\n\t\tTheacc_detach routines perform a detach action on the pointer referred to by ptr_addr ;\nSee Section 272\n\t\tTheacc_detach_finalize routines perform an immediate detach action on the\npointer referred to by ptr_addr ; see Section 272\nThese routines may issue a data transfer from local memory to device memory The_async ver-\nsions of these routines will perform the data transfers asynchronously on the async queue associated\nwithasync_arg  These routines may return before the data has been transferred; see Section 2\nfor more details The synchronous versions will not return until the data h as been completely trans-\nferred\nErrors\n\tAnacc_error_invalid_null_pointer error is issued if ptr_addr is a null pointer\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc attach,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc detach. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc detach in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc detach, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3229 acc attach and acc detach\nSummary\nTheacc_attach routines update a pointer in device memory to point to the corresponding devic e\ncopy of the host pointer target The acc_detach routines restore a pointer in device memory to\npoint to the host pointer target\nFormat\nC or C++:\nvoid acc_attach(h_void **ptr_addr);\nvoid acc_attach_async(h_void **ptr_addr, int async_arg);\n\nvoid acc_detach(h_void **ptr_addr);\nvoid acc_detach_async(h_void **ptr_addr, int async_arg);\nvoid acc_detach_finalize(h_void **ptr_addr);\nvoid acc_detach_finalize_async(h_void **ptr_addr,\nint async_arg);\nFortran:\nsubroutine acc_attach(ptr_addr)\nsubroutine acc_attach_async(ptr_addr, async_arg)\ntype(*),dimension() :: ptr_addr\ninteger(acc_handle_kind),value :: async_arg\n\nsubroutine acc_detach(ptr_addr)\nsubroutine acc_detach_async(ptr_addr, async_arg)\nsubroutine acc_detach_finalize(ptr_addr)\nsubroutine acc_detach_finalize_async(ptr_addr,\nasync_arg)\ntype(*),dimension() :: ptr_addr\ninteger(acc_handle_kind),value :: async_arg\nDescription\nA call to an acc_attach routine is functionally equivalent to an enter data attach direc-\ntive, as described in Section 2712 A call to an acc_detach routine is functionally equivalent to\nanexitdatadetach directive, and a call to an acc_detach_finalize routine is function-\nally equivalent to an exit data finalize detach directive, as described in Section 2713\nptr_addr must be the address of a host pointer async_arg must be an async-argument as\nde\ufb01ned in Section 216\nThe behavior of these routines is:\n\tIfptr_addr refers to shared memory, no action is taken\n\tIf the pointer referred to by ptr_addr is not present in the current device memory, no action\nis taken\n\tOtherwise:\n\t\tTheacc_attach routines perform an attach action on the pointer referred to by\nptr_addr ; see Section 272\n\n\t\tTheacc_detach routines perform a detach action on the pointer referred to by ptr_addr ;\nSee Section 272\n\t\tTheacc_detach_finalize routines perform an immediate detach action on the\npointer referred to by ptr_addr ; see Section 272\nThese routines may issue a data transfer from local memory to device memory The_async ver-\nsions of these routines will perform the data transfers asynchronously on the async queue associated\nwithasync_arg  These routines may return before the data has been transferred; see Section 2\nfor more details The synchronous versions will not return until the data h as been completely trans-\nferred\nErrors\n\tAnacc_error_invalid_null_pointer error is issued if ptr_addr is a null pointer\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc detach,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc detach. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc detach in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc detach, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3229 acc attach and acc detach\nSummary\nTheacc_attach routines update a pointer in device memory to point to the corresponding devic e\ncopy of the host pointer target The acc_detach routines restore a pointer in device memory to\npoint to the host pointer target\nFormat\nC or C++:\nvoid acc_attach(h_void **ptr_addr);\nvoid acc_attach_async(h_void **ptr_addr, int async_arg);\n\nvoid acc_detach(h_void **ptr_addr);\nvoid acc_detach_async(h_void **ptr_addr, int async_arg);\nvoid acc_detach_finalize(h_void **ptr_addr);\nvoid acc_detach_finalize_async(h_void **ptr_addr,\nint async_arg);\nFortran:\nsubroutine acc_attach(ptr_addr)\nsubroutine acc_attach_async(ptr_addr, async_arg)\ntype(*),dimension() :: ptr_addr\ninteger(acc_handle_kind),value :: async_arg\n\nsubroutine acc_detach(ptr_addr)\nsubroutine acc_detach_async(ptr_addr, async_arg)\nsubroutine acc_detach_finalize(ptr_addr)\nsubroutine acc_detach_finalize_async(ptr_addr,\nasync_arg)\ntype(*),dimension() :: ptr_addr\ninteger(acc_handle_kind),value :: async_arg\nDescription\nA call to an acc_attach routine is functionally equivalent to an enter data attach direc-\ntive, as described in Section 2712 A call to an acc_detach routine is functionally equivalent to\nanexitdatadetach directive, and a call to an acc_detach_finalize routine is function-\nally equivalent to an exit data finalize detach directive, as described in Section 2713\nptr_addr must be the address of a host pointer async_arg must be an async-argument as\nde\ufb01ned in Section 216\nThe behavior of these routines is:\n\tIfptr_addr refers to shared memory, no action is taken\n\tIf the pointer referred to by ptr_addr is not present in the current device memory, no action\nis taken\n\tOtherwise:\n\t\tTheacc_attach routines perform an attach action on the pointer referred to by\nptr_addr ; see Section 272\n\n\t\tTheacc_detach routines perform a detach action on the pointer referred to by ptr_addr ;\nSee Section 272\n\t\tTheacc_detach_finalize routines perform an immediate detach action on the\npointer referred to by ptr_addr ; see Section 272\nThese routines may issue a data transfer from local memory to device memory The_async ver-\nsions of these routines will perform the data transfers asynchronously on the async queue associated\nwithasync_arg  These routines may return before the data has been transferred; see Section 2\nfor more details The synchronous versions will not return until the data h as been completely trans-\nferred\nErrors\n\tAnacc_error_invalid_null_pointer error is issued if ptr_addr is a null pointer\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc detach,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc detach. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc detach in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc detach, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3229 acc attach and acc detach\nSummary\nTheacc_attach routines update a pointer in device memory to point to the corresponding devic e\ncopy of the host pointer target The acc_detach routines restore a pointer in device memory to\npoint to the host pointer target\nFormat\nC or C++:\nvoid acc_attach(h_void **ptr_addr);\nvoid acc_attach_async(h_void **ptr_addr, int async_arg);\n\nvoid acc_detach(h_void **ptr_addr);\nvoid acc_detach_async(h_void **ptr_addr, int async_arg);\nvoid acc_detach_finalize(h_void **ptr_addr);\nvoid acc_detach_finalize_async(h_void **ptr_addr,\nint async_arg);\nFortran:\nsubroutine acc_attach(ptr_addr)\nsubroutine acc_attach_async(ptr_addr, async_arg)\ntype(*),dimension() :: ptr_addr\ninteger(acc_handle_kind),value :: async_arg\n\nsubroutine acc_detach(ptr_addr)\nsubroutine acc_detach_async(ptr_addr, async_arg)\nsubroutine acc_detach_finalize(ptr_addr)\nsubroutine acc_detach_finalize_async(ptr_addr,\nasync_arg)\ntype(*),dimension() :: ptr_addr\ninteger(acc_handle_kind),value :: async_arg\nDescription\nA call to an acc_attach routine is functionally equivalent to an enter data attach direc-\ntive, as described in Section 2712 A call to an acc_detach routine is functionally equivalent to\nanexitdatadetach directive, and a call to an acc_detach_finalize routine is function-\nally equivalent to an exit data finalize detach directive, as described in Section 2713\nptr_addr must be the address of a host pointer async_arg must be an async-argument as\nde\ufb01ned in Section 216\nThe behavior of these routines is:\n\tIfptr_addr refers to shared memory, no action is taken\n\tIf the pointer referred to by ptr_addr is not present in the current device memory, no action\nis taken\n\tOtherwise:\n\t\tTheacc_attach routines perform an attach action on the pointer referred to by\nptr_addr ; see Section 272\n\n\t\tTheacc_detach routines perform a detach action on the pointer referred to by ptr_addr ;\nSee Section 272\n\t\tTheacc_detach_finalize routines perform an immediate detach action on the\npointer referred to by ptr_addr ; see Section 272\nThese routines may issue a data transfer from local memory to device memory The_async ver-\nsions of these routines will perform the data transfers asynchronously on the async queue associated\nwithasync_arg  These routines may return before the data has been transferred; see Section 2\nfor more details The synchronous versions will not return until the data h as been completely trans-\nferred\nErrors\n\tAnacc_error_invalid_null_pointer error is issued if ptr_addr is a null pointer\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc detach,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of acc memcpy d2d. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc memcpy d2d in C. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc memcpy d2d, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3230 acc memcpy d2d\nSummary\nTheacc_memcpy_d2d routines copy the contents of an array on one device to an array on the\nsame or a different device without updating the value on the host\nFormat\nC or C++:\nvoid acc_memcpy_d2d(h_void *data_arg_dest,\nh_void*data_arg_src, size_t bytes,\nint dev_num_dest, int dev_num_src);\nvoid acc_memcpy_d2d_async(h_void *data_arg_dest,\nh_void*data_arg_src, size_t bytes,\nint dev_num_dest, int dev_num_src,\nint async_arg_src);\n\nFortran:\nsubroutine acc_memcpy_d2d(data_arg_dest, data_arg_src ,&\nbytes, dev_num_dest, dev_num_src)\nsubroutine acc_memcpy_d2d_async(data_arg_dest, data_a rg_src,&\nbytes, dev_num_dest, dev_num_src,&\nasync_arg_src)\ntype(*), dimension() :: data_arg_dest\ntype(*), dimension() :: data_arg_src\ninteger :: bytes\ninteger :: dev_num_dest\ninteger :: dev_num_src\ninteger :: async_arg_src\n\n\nDescription\nTheacc_memcpy_d2d routines are passed the address of destination and source host data as well\nas integer device numbers for the destination and source devices, which mu st both be of the current\ndevice type\nThe behavior of the acc_memcpy_d2d routines is:\n\tIfbytes is zero, no action is taken\n\tIf both pointers have the same value and either the two device numbers are the same or the\naddresses are in shared memory, then no action is taken\n\tOtherwise, bytes bytes of data at the device address corresponding to data_arg_src on\ndevicedev_num_src are copied to the device address corresponding to data_arg_dest\non devicedev_num_dest \nForacc_memcpy_d2d_async the value of async_arg_src is the number of an async queue\non the source device This routine will perform the data transfers async hronously on the async queue\nassociated with async_arg_src for devicedev_num_src ; see Section 216 Asynchronous Behavior\nfor more details\nErrors\n\tAnacc_error_device_unavailable error is issued if dev_num_dest ordev_num_src\nis not a valid device number\n\tAnacc_error_invalid_null_pointer error is issued if either data_arg_dest\nordata_arg_src is a null pointer and bytes is nonzero\n\tAnacc_error_not_present error is issued if the data at either address is not in shared\nmemory and is not present in the respective device memory\n\tAnacc_error_partly_present error is issued if part of the data is already present in\nthe current device memory but all of the data is not\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc memcpy d2d,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in C++ to verify compiler implementation of the OpenACC specification of acc memcpy d2d. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc memcpy d2d in C++. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc memcpy d2d, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3230 acc memcpy d2d\nSummary\nTheacc_memcpy_d2d routines copy the contents of an array on one device to an array on the\nsame or a different device without updating the value on the host\nFormat\nC or C++:\nvoid acc_memcpy_d2d(h_void *data_arg_dest,\nh_void*data_arg_src, size_t bytes,\nint dev_num_dest, int dev_num_src);\nvoid acc_memcpy_d2d_async(h_void *data_arg_dest,\nh_void*data_arg_src, size_t bytes,\nint dev_num_dest, int dev_num_src,\nint async_arg_src);\n\nFortran:\nsubroutine acc_memcpy_d2d(data_arg_dest, data_arg_src ,&\nbytes, dev_num_dest, dev_num_src)\nsubroutine acc_memcpy_d2d_async(data_arg_dest, data_a rg_src,&\nbytes, dev_num_dest, dev_num_src,&\nasync_arg_src)\ntype(*), dimension() :: data_arg_dest\ntype(*), dimension() :: data_arg_src\ninteger :: bytes\ninteger :: dev_num_dest\ninteger :: dev_num_src\ninteger :: async_arg_src\n\n\nDescription\nTheacc_memcpy_d2d routines are passed the address of destination and source host data as well\nas integer device numbers for the destination and source devices, which mu st both be of the current\ndevice type\nThe behavior of the acc_memcpy_d2d routines is:\n\tIfbytes is zero, no action is taken\n\tIf both pointers have the same value and either the two device numbers are the same or the\naddresses are in shared memory, then no action is taken\n\tOtherwise, bytes bytes of data at the device address corresponding to data_arg_src on\ndevicedev_num_src are copied to the device address corresponding to data_arg_dest\non devicedev_num_dest \nForacc_memcpy_d2d_async the value of async_arg_src is the number of an async queue\non the source device This routine will perform the data transfers async hronously on the async queue\nassociated with async_arg_src for devicedev_num_src ; see Section 216 Asynchronous Behavior\nfor more details\nErrors\n\tAnacc_error_device_unavailable error is issued if dev_num_dest ordev_num_src\nis not a valid device number\n\tAnacc_error_invalid_null_pointer error is issued if either data_arg_dest\nordata_arg_src is a null pointer and bytes is nonzero\n\tAnacc_error_not_present error is issued if the data at either address is not in shared\nmemory and is not present in the respective device memory\n\tAnacc_error_partly_present error is issued if part of the data is already present in\nthe current device memory but all of the data is not\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:acc memcpy d2d,V:2.7-3.3\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    if(){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}\n"}
{"idx": 1, "Instruction": "Write a code in Fortran to verify compiler implementation of the OpenACC specification of acc memcpy d2d. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test acc memcpy d2d in Fortran. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, acc memcpy d2d, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 3230 acc memcpy d2d\nSummary\nTheacc_memcpy_d2d routines copy the contents of an array on one device to an array on the\nsame or a different device without updating the value on the host\nFormat\nC or C++:\nvoid acc_memcpy_d2d(h_void *data_arg_dest,\nh_void*data_arg_src, size_t bytes,\nint dev_num_dest, int dev_num_src);\nvoid acc_memcpy_d2d_async(h_void *data_arg_dest,\nh_void*data_arg_src, size_t bytes,\nint dev_num_dest, int dev_num_src,\nint async_arg_src);\n\nFortran:\nsubroutine acc_memcpy_d2d(data_arg_dest, data_arg_src ,&\nbytes, dev_num_dest, dev_num_src)\nsubroutine acc_memcpy_d2d_async(data_arg_dest, data_a rg_src,&\nbytes, dev_num_dest, dev_num_src,&\nasync_arg_src)\ntype(*), dimension() :: data_arg_dest\ntype(*), dimension() :: data_arg_src\ninteger :: bytes\ninteger :: dev_num_dest\ninteger :: dev_num_src\ninteger :: async_arg_src\n\n\nDescription\nTheacc_memcpy_d2d routines are passed the address of destination and source host data as well\nas integer device numbers for the destination and source devices, which mu st both be of the current\ndevice type\nThe behavior of the acc_memcpy_d2d routines is:\n\tIfbytes is zero, no action is taken\n\tIf both pointers have the same value and either the two device numbers are the same or the\naddresses are in shared memory, then no action is taken\n\tOtherwise, bytes bytes of data at the device address corresponding to data_arg_src on\ndevicedev_num_src are copied to the device address corresponding to data_arg_dest\non devicedev_num_dest \nForacc_memcpy_d2d_async the value of async_arg_src is the number of an async queue\non the source device This routine will perform the data transfers async hronously on the async queue\nassociated with async_arg_src for devicedev_num_src ; see Section 216 Asynchronous Behavior\nfor more details\nErrors\n\tAnacc_error_device_unavailable error is issued if dev_num_dest ordev_num_src\nis not a valid device number\n\tAnacc_error_invalid_null_pointer error is issued if either data_arg_dest\nordata_arg_src is a null pointer and bytes is nonzero\n\tAnacc_error_not_present error is issued if the data at either address is not in shared\nmemory and is not present in the respective device memory\n\tAnacc_error_partly_present error is issued if part of the data is already present in\nthe current device memory but all of the data is not\n\tAnacc_error_invalid_async error is issued if async_arg is not a valid async-\nargument value\nSee Section 522\n\nTemplate:\n\n#ifndef T1\n!T1:acc memcpy d2d,V:2.7-2.3\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        \n        INTEGER :: errors = 0\n\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n\n      PROGRAM main\n        IMPLICIT NONE\n        INTEGER :: failcode, testrun\n        LOGICAL :: failed\n        INCLUDE \"acc_testsuite.Fh\"\n#ifndef T1\n        LOGICAL :: test1\n#endif\n        failed = .FALSE.\n        failcode = 0\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n        CALL EXIT (failcode)\n      END PROGRAM\n\n"}
