{"prompt": "Create a test for the feature routine bind prototype lambda string lambda", "completion": "#include \"acc_testsuite.h\"  //test 1 host lambda auto host_array_array = [](real_t * a, long long n){     #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; };  //test 2 host lambda auto host_object_array = [](data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned += a->data[x];     }     return returned; };  //test 3 host lambda auto host_array_object = [](real_t * a, long long n){    #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; };  //test 4 host lambda auto host_object_object = [](data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned += a->data[x];     }     return returned; };  #pragma acc routine(host_array_array) vector bind(\"device_array_array\") #pragma acc routine(host_object_array) vector bind(\"device_object_array\") #pragma acc routine(host_array_object) vector bind(\"device_array_object\") #pragma acc routine(host_object_object) vector bind(\"device_object_object\")  //test 1 device lambda auto device_array_array = [](real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; };  //test 2 device lambda auto device_object_array = [](data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned -= a->data[x];     }     return returned; };  //test 3 device lambda auto device_array_object = [](real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; };  //test 4 device lambda auto  device_object_object= [](data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; };  #ifndef T1 //T1:routine,V:2.7-3.3 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){        \ta[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_array_array(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_array(a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_array(a, n) - b[x]) > PRECISION)){             err += 1;         }     }     delete[] a;     delete[] b;      return err; } #endif #ifndef T2 //T2:routine,V:2.7-3.3 int test2(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a, a.data[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_object_array(&a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_array(&a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_array(&a, n) - b[x]) > PRECISION)){             err += 1;         }     }      delete[] b;      return err; } #endif #ifndef T3 //T3:routine,V:2.7-3.3 int test3(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b, b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_array_object(a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_object(a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_object(a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      delete[] a;      return err; } #endif #ifndef T4 //T4:routine,V:2.7-3.3 int test4(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a, a.data[0:n], b ,b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_object_object(&a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_object(&a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_object(&a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed = 0; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }      if(failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }      if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }      if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test4();     }      if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction and vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = new char[10 * n];     char * b = new char[10];     char * has_false = new char[10];     real_t false_margin = pow(exp(1), log(.5)/n);     char temp = 1;      for (int x = 0; x < 10; ++x){         has_false[x] = 0;     }     for (int x = 0; x < 10 * n; ++x){         if(rand() / (real_t)(RAND_MAX) < false_margin){             a[x] = 1;         }         else{             a[x] = 0;             has_false[x/n] = 1;         }     }     #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc parallel loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop vector reduction(&&:temp)             for (int y = 0; y < n; ++y){                 temp = temp && a[x * n + y];             }             b[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         if (has_false[x] == b[x]){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     char * a = new char[25 * n];     char * b = new char[25];     char * has_false = new char[25];     real_t false_margin = pow(exp(1), log(.5)/n);     char device[5];     char host[5];      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5 * n; ++y){             if (rand() / (real_t)(RAND_MAX) < false_margin) {                 a[x] = 1;             }             else {                 a[x] = 0;                 has_false[x * 5 + y % 5];             }         }     }      #pragma acc data copyin(a[0:25*n]) copy(b[0:25])     {         #pragma acc parallel loop private(device)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 device[y] = 1;             }             #pragma acc loop vector reduction(&&:device)             for (int y = 0; y < 5 * n; ++y) {                 device[y%5] = device[y%5] && a[x * 5 * n + y];             }             for (int y = 0; y < 5; ++y){                 b[x * 5 + y] = device[y];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             host[y] = 1;         }         for (int y = 0; y < 5 * n; ++y) {             host[y%5] = host[y%5] && a[x * 5 * n + y];         }         for (int y = 0; y < 5; ++y) {             if (b[x * 5 + y] != host[y]) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update min expr list x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic x or expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = totals(x) .OR. a(x, y)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .OR. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc copyout finalize async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];     real_t *e = new real_t[n];     real_t *f = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0;     }      #pragma acc enter data create(c[0:n], f[0:n])     #pragma acc enter data create(c[0:n], f[0:n])      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n]) present(c[0:n], f[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         acc_copyout_finalize_async(c, n * sizeof(real_t), 1);         acc_copyout_finalize_async(f, n * sizeof(real_t), 2);         #pragma acc wait     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }         if (fabs(f[x] - (d[x] + e[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,async,construct-independent,internal-control-values,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int def_async_var = acc_get_default_async();      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data create(c[0:n])     #pragma acc enter data create(c[0:n])          #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         acc_copyout_finalize_async(c, n * sizeof(real_t), def_async_var);         #pragma acc wait     }      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:runtime,data,executable-data,async,construct-independent,internal-control-values,set,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int def_async_var = acc_get_default_async();      acc_set_default_async(def_async_var + 1);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data create(c[0:n])     #pragma acc enter data create(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(c[0:n]) async         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         acc_copyout_async(c, n * sizeof(real_t), def_async_var + 1);         #pragma acc wait     }      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T4 //T4:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test4(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data create(c[0:n])     #pragma acc enter data create(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(c[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         acc_copyout_finalize_async(c, n * sizeof(real_t), 1);         #pragma acc enter data copyin(c[0:n]) async(1)         #pragma acc parallel present(c[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] += a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {             err += 1;         }     }           return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature exit data", "completion": "#ifndef T1 !T1:data,executable-data,devonly,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest         devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         a_copy = a          IF (devtest(1) .eq. 1) THEN           !$acc enter data copyin(a(1:LOOPCOUNT))           !$acc parallel present(a(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               a(x) = a(x) + 1             END DO           !$acc end parallel           !$acc exit data delete(a(1:LOOPCOUNT))            DO x = 1, LOOPCOUNT             IF (abs(a(x) - a_copy(x)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:data,executable-data,devonly,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest         devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         a_copy = a         !$acc enter data copyin(a(1:LOOPCOUNT))         !$acc parallel present(a(1:LOOPCOUNT))           !$acc loop           DO x = 1, LOOPCOUNT             a(x) = a(x) + 1           END DO         !$acc end parallel         !$acc exit data copyout(a(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(a(x) - (a_copy(x) + 1)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels vector length", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc kernels vector_length(16)         {             #pragma acc loop vector             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc on device", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     acc_device_t device_type = acc_get_device_type();      if (device_type != acc_device_none){         #pragma acc data copy(err)         {             #pragma acc parallel             {                 if (acc_on_device(device_type) == 0){                     err += 1;                 }             }         }     }     else{         #pragma acc parallel         {             if (acc_on_device(acc_device_host) == 0){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature set device num", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:set,devonly,runtime,construct-independent,V:2.5-2.7 int test1(){     int err = 0;      if (acc_get_device_type() != acc_device_none){         real_t **host_copy = (real_t **)malloc(acc_get_num_devices(acc_get_device_type()) * sizeof(real_t *));         for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){             host_copy[x] = (real_t *)malloc(n * sizeof(real_t));         }         real_t *a = (real_t *)malloc(n * sizeof(real_t));         for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){             for (int y = 0; y < n; ++y){                 a[y] = rand() / (real_t)(RAND_MAX / 10);                 host_copy[x][y] = a[y];             }             #pragma acc set device_num(x)             #pragma acc enter data copyin(a[0:n])         }         for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){             #pragma acc set device_num(x)             #pragma acc data present(a[0:n])             {                 #pragma acc parallel                 {                     #pragma acc loop                     for (int y = 0; y < n; ++y){                         a[y] = a[y] + 1;                     }                 }             }         }         for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){             #pragma acc set device_num(x)             #pragma acc exit data copyout(a[0:n])             for (int y = 0; y < n; ++y){                 if (fabs(a[y] - (host_copy[x][y] + 1)) > PRECISION){                     err += 1;                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction min loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * minimum = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 0;      for (int x = 0; x < 10 * n; ++x){         a[x] = 1 + rand() / (real_t)(RAND_MAX/10);         b[x] = 1 + rand() / (real_t)(RAND_MAX/10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], minimum[0:10])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1000;             #pragma acc loop reduction(min:temp)             for (int y = 0; y < n; ++y){                 temp = fmin(a[x * n + y] * b[x * n + y], temp);             }             minimum[x] = temp;             #pragma acc loop             for (int y = 0; y < n; ++y){                 c[x * n + y] = (a[x * n + y] * b[x * n + y]) / minimum[x];             }         }     }      for (int x = 0; x < 10; ++x){         temp = 1000;         for (int y = 0; y < n; ++y){             temp = fmin(temp, a[x * n + y] * b[x * n + y]);         }         if (fabs(temp - minimum[x]) > PRECISION){             err += 1;         }         for (int y = 0; y < n; ++y){             if (fabs(c[x * n + y] - (a[x * n + y] * b[x * n + y] / minimum[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(25 * n * sizeof(real_t));     real_t minimums[25];     real_t host_minimums[25];     real_t reduced[5];      for (int x = 0; x < n; ++x){         a[x] = 1 + rand() / (real_t)(RAND_MAX / 10);         b[x] = 1 + rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(minimums[0:25], c[0:25*n])     {         #pragma acc parallel loop gang private(reduced)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 reduced[y] = 1000;             }             #pragma acc loop reduction(min:reduced)             for (int y = 0; y < 5 * n; ++y) {                 reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);             }             for (int y = 0; y < 5; ++y) {                 minimums[x * 5 + y] = reduced[y];             }             #pragma acc loop             for (int y = 0; y < 5 * n; ++y) {                 c[x * 5 * n + y] = (a[x * 5 * n + y] * b[x * 5 * n + y]) / minimums[x * 5 + (y % 5)];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             reduced[y] = 1000;         }         for (int y = 0; y < 5 * n; ++y) {             reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);         }         for (int y = 0; y < 5; ++y) {             host_minimums[x * 5 + y] = reduced[y];             if (fabs(host_minimums[x * 5 + y] - minimums[x * 5 + y]) > PRECISION) {                 err += 1;             }         }         for (int y = 0; y < 5 * n; ++y) {             if (fabs(c[x * 5 * n + y] - ((a[x * 5 * n + y] * b[x * 5 * n + y]) / minimums[x * 5 + (y % 5)])) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update ixor x expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .lt. .5) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           totals(x) = 0           totals_comparison(x) = 0         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature shutdown device type nvidia", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:shutdown,runtime,syntactic,V:2.5-3.2 int test1(){     int err = 0;      #pragma acc shutdown device_type(nvidia)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc copyout async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));     real_t *e = (real_t *)malloc(n * sizeof(real_t));     real_t *f = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0;     }      #pragma acc enter data create(c[0:n], f[0:n])      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])     {         #pragma acc parallel async(1) present(c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel async(2) present(f[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         acc_copyout_async(c, n * sizeof(real_t), 1);         acc_copyout_async(f, n * sizeof(real_t), 2);         #pragma acc wait     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }         if (fabs(f[x] - (d[x] + e[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,async,data,executable-data,internal-control-values,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int def_async_var = acc_get_default_async();      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data create(c[0:n])      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(c[0:n]) async         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         acc_copyout_async(c, n * sizeof(real_t), def_async_var);         #pragma acc wait     }      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:runtime,async,data,executable-data,internal-control-values,construct-independent,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int def_async_var = acc_get_default_async();      acc_set_default_async(def_async_var + 1);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }          #pragma acc enter data create(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(c[0:n]) async         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         acc_copyout_async(c, n * sizeof(real_t), def_async_var + 1);         #pragma acc wait     }      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T4 //T4:runtime,async,data,executable-data,construct-independent,V:2.5-2.7 int test4(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data create(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(c[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         #pragma acc enter data copyin(c[0:n])         acc_copyout_async(c, n * sizeof(real_t), 1);         #pragma acc parallel present(c[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] += a[x] + b[x];             }         }         acc_copyout_async(c, n * sizeof(real_t), 1);     }          for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc set device num", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,devonly,construct-independent,set,V:2.0-2.7 int test1(){     int err = 0;      if (acc_get_device_type() != acc_device_none){         real_t **host_copy = (real_t **)malloc(acc_get_num_devices(acc_get_device_type()) * sizeof(real_t *));         for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){             host_copy[x] = new real_t[n];         }         real_t *a = new real_t[n];         for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){             for (int y = 0; y < n; ++y){                 a[y] = rand() / (real_t)(RAND_MAX / 10);                 host_copy[x][y] = a[y];             }             acc_set_device_num(x, acc_get_device_type());             #pragma acc enter data copyin(a[0:n])         }         for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){             acc_set_device_num(x, acc_get_device_type());             #pragma acc data present(a[0:n])             {                 #pragma acc parallel                 {                     #pragma acc loop                     for (int y = 0; y < n; ++y){                         a[y] = a[y] + 1;                     }                 }             }         }         for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){             acc_set_device_num(x, acc_get_device_type());             #pragma acc exit data copyout(a[0:n])             for (int y = 0; y < n; ++y){                 if (fabs(a[y] - (host_copy[x][y] + 1)) > PRECISION){                     err += 1;                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update ixor expr x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .lt. .5) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           totals(x) = 0           totals_comparison(x) = 0         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature init device type", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:init,runtime,V:2.5-3.2 int test1(){     int err = 0;     srand(SEED);      #pragma acc init device_type(host)      return err; } #endif #ifndef T2 //T1:init,runtime,V:2.5-3.2 int test2(){     int err = 0;     srand(SEED);      #pragma acc init device_type(multicore)      return err; } #endif #ifndef T3 //T1:init,runtime,V:2.5-3.2 int test3(){     int err = 0;     srand(SEED);      #pragma acc init device_type(default)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }     if (failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }     if (failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }     if (failed){         failcode += (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr neqv x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = a(x, y) .NEQV. totals(x)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop vector blocking", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,V:1.0-2.7 int test1(){   int err = 0;   srand(SEED);   real_t * a = (real_t *)malloc(n * sizeof(real_t));   real_t * b = (real_t *)malloc(n * sizeof(real_t));   real_t * c = (real_t *)malloc(n * sizeof(real_t));   real_t multiplyer = 1;    for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = 0.0;   }    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])   {     #pragma acc kernels     {       #pragma acc loop vector       for (int x = 0; x < n; ++x){         c[x] = (a[x] + b[x]) * multiplyer;       }       multiplyer += 1;       #pragma acc loop vector       for (int x = 0; x < n; ++x){         c[x] += (a[x] + b[x]) * multiplyer;       }     }   }    for (int x = 0; x < n; ++x){     if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){       err + 1;       break;     }   }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction add general type check pt1", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test1() {     int err = 0;     srand(SEED);     _Bool* a = (_Bool*)malloc(n * sizeof(_Bool));     _Bool* b = (_Bool*)malloc(n * sizeof(_Bool));     _Bool total = 1;     _Bool host_total = 1;      for (int x = 0; x < n; ++x) {         if ((rand()/((real_t) RAND_MAX)) > .5) {             a[x] = 1;         }         else {             a[x] = 0;         }         if ((rand()/((real_t) RAND_MAX)) > .5) {             b[x] = 1;         }         else {             b[x] = 0;         }     }          #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }           for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (total != host_total) {         err += 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(n * sizeof(char));     char * b = (char *)malloc(n * sizeof(char));     char total = 10;     char host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(UCHAR_MAX / 10);         b[x] = rand() / (real_t)(UCHAR_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (host_total != total) {         err += 1;     }      return err; } #endif  #ifndef T3 //T3:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test3(){     int err = 0;     srand(SEED);     signed char * a = (signed char *)malloc(n * sizeof(signed char));     signed char * b = (signed char *)malloc(n * sizeof(signed char));     signed char total = 10;     signed char host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (host_total != total) {         err += 1;     }      return err; } #endif  #ifndef T4 //T4:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test4(){     int err = 0;     srand(SEED);     unsigned char * a = (unsigned char *)malloc(n * sizeof(unsigned char));     unsigned char * b = (unsigned char *)malloc(n * sizeof(unsigned char));     unsigned char total = 10;     unsigned char host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (total != host_total) {         err += 1;     }      return err; } #endif  #ifndef T5 //T5:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test5(){     int err = 0;     srand(SEED);     short int * a = (short int *)malloc(n * sizeof(short int));     short int * b = (short int *)malloc(n * sizeof(short int));     short int total = 10;     short int host_total = 10;          for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (total != host_total) {         err += 1;     }      return err; } #endif  #ifndef T6 //T6:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test6(){     int err = 0;     srand(SEED);     int * a = (int *)malloc(n * sizeof(int));     int * b = (int *)malloc(n * sizeof(int));     int total = 10;     int host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (total != host_total) {         err += 1;     }      return err; } #endif  #ifndef T7 //T7:parallel,reduction,combined-constructs,loop,nonvalidating,V:1.0-2.7 int test7(){     int err = 0;     srand(SEED);     long int * a = (long int *)malloc(n * sizeof(long int));     long int * b = (long int *)malloc(n * sizeof(long int));     long int total = 10;     long int host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      return err; } #endif  #ifndef T8 //T8:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test8(){     int err = 0;     srand(SEED);     long long int * a = (long long int *)malloc(n * sizeof(long long int));     long long int * b = (long long int *)malloc(n * sizeof(long long int));     long long int total = 10;     long long int host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (host_total != total) {         err += 1;     }      return err; } #endif  int main() {     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x) {         failed = failed + test1();     }     if (failed != 0) {         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif #ifndef T6     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test6();     }     if (failed != 0){         failcode = failcode + (1 << 5);     } #endif #ifndef T7     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test7();     }     if (failed != 0){         failcode = failcode + (1 << 6);     } #endif #ifndef T8     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test8();     }     if (failed != 0){         failcode = failcode + (1 << 7);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign bitor equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev | a[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         for (int y = 0; y < 8; ++y){             totals[x] =  1<<y;             totals_comparison[x] = 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         b[x] = totals[x/10];                         totals[x/10] |= a[x];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] |= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature shutdown device type", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:shutdown,runtime,syntactic,V:2.5-3.2 int test1(){     int err = 0;      #pragma acc shutdown device_type(host)      return err; } #endif #ifndef T2 //T2:shutdown,runtime,syntactic,V:2.5-3.2 int test2(){     int err = 0;      #pragma acc shutdown device_type(multicore)      return err; } #endif #ifndef T3 //T3:shutdown,runtime,syntactic,V:2.5-3.2 int test3(){     int err = 0;      #pragma acc shutdown device_type(default)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction min vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * min = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 100;     real_t temp_min;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(min[0:10])     {         #pragma acc serial  \t{     \t#pragma acc loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 100;             #pragma acc loop vector reduction(min:temp)             for (int y = 0; y < n; ++y){                 temp = fmin(a[x * n + y] * b[x * n + y], temp);             }             min[x] = temp;         } \t}     }     for (int x = 0; x < 10; ++x){         temp_min = 100;         for (int y = 0; y < n; ++y){             if (temp_min > a[x * n + y] * b[x * n + y]){                 temp_min = a[x * n + y] * b[x * n + y];             }         }         if (fabs(temp_min - min[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature set device type num nvidia", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:set,runtime,syntactic,V:2.5-3.2 int test1(){         int err = 0;         int device_num;          device_num = acc_get_device_num(acc_get_device_type());         #pragma acc set device_type(nvidia) device_num(device_num)          return err; } #endif  int main(){     \tint failcode = 0;     \tint failed; #ifndef T1     \tfailed = 0;     \tfor (int x = 0; x < NUM_TEST_CALLS; ++x){         \tfailed = failed + test1();     \t}     \tif (failed != 0){         \tfailcode = failcode + (1 << 0);     \t} #endif     \treturn failcode; } "}
{"prompt": "Create a test for the feature acc memcpy to device", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *hostdata = (real_t *)malloc(3 * n * sizeof(real_t));     real_t *devdata;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 1;     }      devdata = acc_create(hostdata, 3 * n * sizeof(real_t));      acc_memcpy_to_device(devdata, a, n * sizeof(real_t));     acc_memcpy_to_device(&(devdata[n]), b, n * sizeof(real_t));     acc_memcpy_to_device(&(devdata[2*n]), c, n * sizeof(real_t));      #pragma acc data deviceptr(devdata)     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[2*n + x] += devdata[x] + devdata[n + x];             }         }     }     #pragma acc exit data copyout(hostdata[0:3*n])     for (int x = 0; x < n; ++x){         if (fabs(hostdata[2 * n + x] - (1 + hostdata[n + x] + hostdata[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel wait devnum", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,wait,async,V:2.0-3.2 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n])     { \t#pragma acc parallel loop present(a[0:n], b[0:n]) async(1)         for (int x = 0; x < n; ++x){ \t    b[x] = a[x];         } \t#pragma acc update host(b[0:n]) wait(1)     }     for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }     if (failed){         failcode +=  (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop gang", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])     {         #pragma acc serial loop gang         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update preincrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic update                         ++distribution[(int) (a[x]*b[y]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             distribution_comparison[(int) (a[x]*b[y]/10)]++;         }     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature shutdown device num", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:shutdown,runtime,syntactic,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     int device_num;      device_num = acc_get_device_num(acc_get_device_type());     #pragma acc shutdown device_num(device_num)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature init device type num nvidia", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:init,runtime,V:2.5-3.2 int test1(){     int err = 0;     srand(SEED);     int device_num = acc_get_device_num(acc_get_device_type());      #pragma acc init device_type(nvidia) device_num(device_num)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }     if (failed){         failcode += (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign expr divided x", "completion": "#include \"acc_testsuite.h\" bool is_possible_2(real_t* a, real_t* b, int length, real_t prev, real_t destination){     if (length == 0 && abs(prev - destination) < PRECISION){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         for (int y = 0; y < x; ++y){             passed_a[y] = a[y];             passed_b[y] = b[y];         }         for (int y = x + 1; y < length; ++y){             passed_a[y - 1] = a[y];             passed_b[y - 1] = b[y];         }         if (is_possible_2(passed_a, passed_b, length - 1, (a[x] + b[x]) / prev, destination)){             free(passed_a);             free(passed_b);             return true;         }     }     free(passed_a);     free(passed_b);     return false; }  bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_c = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(c[x] - prev) < 100*PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];                 passed_c[y] = c[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];                 passed_c[y - 1] = c[y];             }             if (is_possible(passed_a, passed_b, passed_c, length - 1, (a[x] + b[x]) / prev)){                 free(passed_a);                 free(passed_b);                 free(passed_c);                 return true;             }         }     }     free(passed_a);     free(passed_b);     free(passed_c);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t* passed_a = (real_t *)malloc(10 * sizeof(real_t));     real_t* passed_b = (real_t *)malloc(10 * sizeof(real_t));     real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));     real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));     real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x/10];                     totals[x/10] = (a[x] + b[x]) / totals[x/10];                 }             }         }     }      for (int x = 0; x < n; x = x + 10){         for (int y = 0; y < 10 && (x + y) < n; ++y){             passed_a[y] = a[x + y];             passed_b[y] = b[x + y];         }         if (!(is_possible_2(passed_a, passed_b, 10, 1, totals[x/10]))){             err += 1;             break;         }     }      for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];             temp_c[temp_iterator] = c[ab_iterator];             temp_iterator++;         }         if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc copyout finalize", "completion": "#ifndef T1 !T1:runtime,data,executable-data,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data create(c(1:LOOPCOUNT))         !$acc enter data create(c(1:LOOPCOUNT))          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_copyout_finalize(c(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif          CALL EXIT (failcode)         END PROGRAM  "}
{"prompt": "Create a test for the feature kernels loop reduction multiply vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     int multiplicitive_n = 128;     srand(SEED);     real_t * a = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * sizeof(real_t));     real_t temp;      for (int x = 0; x < 10 * multiplicitive_n; ++x){         a[x] = rand() / (real_t) RAND_MAX;         b[x] = rand() / (real_t) RAND_MAX;     }      #pragma acc data copyin(a[0:10*multiplicitive_n], b[0:10*multiplicitive_n]) copyout(c[0:10])     {         #pragma acc kernels loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 1.0;             #pragma acc loop vector reduction(*:temp)             for (int y = 0; y < multiplicitive_n; ++y){                 temp *= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];             }             c[x] = temp;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < multiplicitive_n; ++y){             c[x] /= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];         }     }      for (int x = 0; x < 10; ++x){         if (fabs(c[x] - 1) > PRECISION * (4 * multiplicitive_n - 1)){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel independent atomic read", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.7-3.2 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(a[0:n], b[0:n])     {         #pragma acc parallel         { \t    #pragma acc loop independent             for (int x = 0; x < n; ++x){                 #pragma acc atomic read                     b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1    failed = 0;    for (int x = 0; x < NUM_TEST_CALLS; ++x){        failed = failed + test1();    }    if (failed != 0){        failcode = failcode + (1 << 0);    } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature enter data copyin no lower bound", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,syntactic,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[:n], b[:n]) create(c[0:n])     #pragma acc parallel present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture bitand equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; x++){         if (b[x] == (a[x] & prev)){             for (int y = 0; y < x; y++){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; y++){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int iterator;     int iterator2;     int init = 0;      for (int x = 0; x < n; x++){         a[x] = 0;         for (int y = 0; y < 8; y++){                          if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; x++){ \t    totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; y++){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; x++){         b[x] = 0;         for (int y = 0; y < 8; y++){             b[x] += 1<<y;         }     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; x++){                 #pragma acc atomic capture                     b[x] = totals[x%(n/10 + 1)] &= a[x];             }         }     }     for (int x = 0; x < n; x++){         totals_comparison[x%(n/10 + 1)] &= a[x];     }     for (int x = 0; x < (n/10 + 1); x++){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }      for (int x = 0; x < 8; x++){         init += 1<<x;     }     for (int x = 0; x < (n/10 + 1); x++){         for (iterator = x, iterator2 = 0; iterator < n; iterator += n/10 + 1, iterator2++){             temp_a[iterator2] = a[iterator];             temp_b[iterator2] = b[iterator];         }         if (!is_possible(temp_a, temp_b, iterator2, init)){             err += 1;         }     }     return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; x++){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature set device type num", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:set,runtime,syntactic,V:2.5-3.2 int test1(){ \tint err = 0; \tint device_num;  \tdevice_num = acc_get_device_num(acc_get_device_type()); \t#pragma acc set device_type(host) device_num(device_num)  \treturn err; } #endif  #ifndef T2 //T2:set,runtime,syntactic,V:2.5-3.2 int test2(){ int err = 0;         int device_num;          device_num = acc_get_device_num(acc_get_device_type());         #pragma acc set device_type(multicore) device_num(device_num)          return err;\t } #endif  #ifndef T3 //T2:set,runtime,syntactic,V:2.5-3.2 int test3(){ int err = 0;         int device_num;          device_num = acc_get_device_num(acc_get_device_type());         #pragma acc set device_type(default) device_num(device_num)          return err; } #endif  int main(){ \tint failcode = 0;     \tint failed; #ifndef T1     \tfailed = 0;     \tfor (int x = 0; x < NUM_TEST_CALLS; ++x){         \tfailed = failed + test1();     \t}     \tif (failed != 0){         \tfailcode = failcode + (1 << 0);     \t} #endif #ifndef T2     \tfailed = 0;     \tfor (int x = 0; x < NUM_TEST_CALLS; ++x){         \tfailed = failed + test2();     \t}     \tif (failed != 0){         \tfailcode = failcode + (1 << 1);     \t} #endif  #ifndef T3     \tfailed = 0;     \tfor (int x = 0; x < NUM_TEST_CALLS; ++x){         \tfailed = failed + test3();     \t}     \tif (failed != 0){         \tfailcode = failcode + (1 << 2);     \t} #endif      \treturn failcode; } "}
{"prompt": "Create a test for the feature parallel loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = 0;     }      #pragma acc data copy(a[0:n])     {         #pragma acc parallel loop         for (int x = 0; x < n; ++x){             a[x] = 1.0;         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - 1.0) > PRECISION){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,loop,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){       a[x] = 0.0;       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = rand() / (real_t)(RAND_MAX / 10);     }     #pragma acc data copy(a[0:n], b[0:n], c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = b[x];             }             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] += c[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] + c[x])) > PRECISION * 2){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic plus equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] += a[x] * b[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] += a[x] * b[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > (n/10 + 1) * PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc delete finalize async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,reference-counting,syntactic,construct-independent,async,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];     real_t *e = new real_t[n];     real_t *f = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0;     }      #pragma acc enter data copyin(a[0:n], b[0:n], d[0:n], e[0:n])     #pragma acc enter data copyin(a[0:n], b[0:n], d[0:n], e[0:n])      #pragma acc data present(a[0:n], b[0:n], d[0:n], e[0:n]) copyout(c[0:n], f[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         acc_delete_finalize_async(a, n * sizeof(real_t), 1);         acc_delete_finalize_async(b, n * sizeof(real_t), 1);         acc_delete_finalize_async(d, n * sizeof(real_t), 2);         acc_delete_finalize_async(e, n * sizeof(real_t), 2);         #pragma acc wait     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }         if (fabs(f[x] - (d[x] + e[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,reference-counting,devonly,async,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];     real_t *e = new real_t[n];     real_t *f = new real_t[n];     int* devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0;         }          #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])         #pragma acc enter data copyin(c[0:n])         #pragma acc data present(a[0:n], b[0:n], c[0:n])         {             #pragma acc parallel async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] * b[x];                 }             }         }         acc_delete_finalize_async(c, n * sizeof(real_t), 1);         #pragma acc enter data copyin(c[0:n]) async(1)         #pragma acc data present(a[0:n], b[0:n], c[0:n])         {             #pragma acc parallel async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] += a[x] + b[x];                 }             }         }         #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update x or expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = totals(x) .OR. a(x, y)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .OR. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature wait if", "completion": "#include \"acc_testsuite.h\" /*  *if implimented on wait, but not init, set, nor shutdown */  #ifndef T1 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));     real_t *e = (real_t *)malloc(n * sizeof(real_t));     real_t *f = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){ \ta[x] = rand() / (real_t)(RAND_MAX / 10); \tb[x] = rand() / (real_t)(RAND_MAX / 10); \tc[x] = 0.0; \td[x] = rand() / (real_t)(RAND_MAX / 10); \te[x] = rand() / (real_t)(RAND_MAX / 10); \tf[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n]) create(c[0:n], f[0:n])     { \t#pragma acc parallel async(1) \t{ \t    #pragma acc loop \t    for (int x = 0; x < n; ++x){ \t\tc[x] = a[x] + b[x]; \t    } \t} \t#pragma acc parallel async(2) \t{ \t    #pragma acc loop \t    for (int x = 0; x < n; ++x){ \t\tf[x] = d[x] + e[x]; \t    } \t} \t#pragma acc update host(c[0:n], f[0:n]) wait(1, 2) if(true)     }          for (int x = 0; x < n; ++x){ \tif (abs(c[x] - (a[x] + b[x])) > PRECISION){ \t    err++; \t} \tif (abs(f[x] - (d[x] + e[x])) > PRECISION){ \t    err++; \t}     }      return err; } #endif #ifndef T2 int test2(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));     real_t *e = (real_t *)malloc(n * sizeof(real_t));     real_t *f = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n]) create(c[0:n], f[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         #pragma acc update host(c[0:n], f[0:n]) wait(1) if(true) \t#pragma acc update host(c[0:n], f[0:n]) wait(2) if(true)     }      for (int x = 0; x < n; ++x){         if (abs(c[x] - (a[x] + b[x])) > PRECISION){             err++;         }         if (abs(f[x] - (d[x] + e[x])) > PRECISION){             err++;         }     }      return err; } #endif #ifndef T3 int test3(){     int err = 0;     srand(time(NULL));     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));     real_t *e = (real_t *)malloc(n * sizeof(real_t));     real_t *f = (real_t *)malloc(n * sizeof(real_t));          for (int x = 0; x < n; ++x){ \ta[x] = rand() / (real_t)(RAND_MAX / 10); \tb[x] = rand() / (real_t)(RAND_MAX / 10); \tc[x] = 0.0; \td[x] = rand() / (real_t)(RAND_MAX / 10); \te[x] = rand() / (real_t)(RAND_MAX / 10); \tf[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n]) create(c[0:n], f[0:n])     { \t#pragma acc parallel async(1) \t{ \t    #pragma acc loop \t    for (int x = 0; x < n; ++x){ \t        c[x] = a[x] + b[x]; \t    }  \t} \t#pragma acc parallel async(2) \t{ \t    #pragma acc loop \t    for (int x = 0; x < n; ++x){ \t\tf[x] = d[x] + e[x]; \t    } \t} \t#pragma acc update host(c[0:n], f[0:n]) wait(1, 2) if(false)     }              for (int x = 0; x < n; ++x){ \tif (c[x] > PRECISION){ \t    err++; \t} \tif (f[x] > PRECISION){ \t    err++; \t}     }     return err; } #endif #ifndef T4 int test4(){     int err = 0;     srand(time(NULL));     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));     real_t *e = (real_t *)malloc(n * sizeof(real_t));     real_t *f = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n]) create(c[0:n], f[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         #pragma acc update host(c[0:n], f[0:n]) wait(1) if(false) \t#pragma acc update host(c[0:n], f[0:n]) wait(2) if(false)     }      for (int x = 0; x < n; ++x){         if (c[x] > PRECISION){             err++;         }         if (f[x] > PRECISION){             err++;         }     }     return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }     if (failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test2();     }     if (failed){ \tfailcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }     if (failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test4();     }     if (failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured expr plus x assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] + prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t *passed_ab = new real_t[10];     real_t *passed_c = new real_t[10];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x%(n/10 + 1)] = (a[x] * b[x]) + totals[x%(n/10 + 1)];                     c[x] = totals[x%(n/10 + 1)];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] += a[x] * b[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){             passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel scalar default firstprivate", "completion": "#ifndef T1 !T1:parallel,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(1):: random         INTEGER :: errors = 0         REAL(8) :: scalar         REAL(8) :: scalar_copy          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(random)         scalar = random(1)         scalar_copy = scalar         CALL RANDOM_NUMBER(a)         b = 0          !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = a(x) + scalar             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           IF (abs(b(x) - (a(x) + scalar_copy)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO         IF (abs(scalar_copy - scalar) .gt. PRECISION) THEN           errors = errors + 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature declare function scope deviceptr", "completion": "#include \"acc_testsuite.h\" void declare_deviceptr(real_t *a, real_t *b, real_t *c, real_t *d){     #pragma acc declare deviceptr(c)     #pragma acc parallel present(a[0:n], b[0:n], d[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = c[x] + a[x] + b[x];         }         #pragma acc loop         for (int x = 0; x < n; ++x){             d[x] = c[x] * a[x];         }     } }  #ifndef T1 //T1:declare,runtime,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t ** b = (real_t **)malloc(n * sizeof(real_t *));     real_t ** c = (real_t **)malloc(n * sizeof(real_t *));     real_t ** d = (real_t **)malloc(n * sizeof(real_t *));     real_t ** devpointer_c = (real_t **)malloc(n * sizeof(real_t *));     int *devtest = (int *)malloc(sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];         b[x] = new real_t[n];         c[x] = new real_t[n];         d[x] = new real_t[n];         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 1;             d[x][y] = 0;         }     }      #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copy(c[0:n][0:n]) copyout(d[0:n][0:n])     {         for (int x = 0; x < n; ++x){             devpointer_c[x] = reinterpret_cast<real_t *>(acc_copyin(c[x], n * sizeof(real_t)));             declare_deviceptr(a[x], b[x], devpointer_c[x], d[x]);         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){                 err += 1;             }             if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:declare,runtime,construct-independent,devonly,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t ** b = (real_t **)malloc(n * sizeof(real_t *));     real_t ** c = (real_t **)malloc(n * sizeof(real_t *));     real_t ** d = (real_t **)malloc(n * sizeof(real_t *));     real_t ** devpointer_c = (real_t **)malloc(n * sizeof(real_t *));     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 a[x][y] = rand() / (real_t)(RAND_MAX / 10);                 b[x][y] = rand() / (real_t)(RAND_MAX / 10);                 c[x][y] = 3;             }         }          #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])         {             for (int x = 0; x < n; ++x){                 #pragma acc data copyout(d[x:1][0:n])                 {                     devpointer_c[x] = reinterpret_cast<real_t *>(acc_copyin(c[x], n * sizeof(real_t)));                     declare_deviceptr(a[x], b[x], devpointer_c[x], d[x]);                 }                 for (int y = 0; y < n; ++y){                     if (fabs(c[x][y] - 3) > PRECISION){                         err += 1;                     }                 }                 for (int y = 0; y < n; ++y){                     if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 10){                         err += 1;                     }                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature init if", "completion": "#include \"acc_testsuite.h\"  /*  * if clause not implimented on init yet */  #ifndef T1 //T1:,V:2.7-3.0 int test1(){ \tint err = 0; \tsrand(SEED); \t \tint device_num = acc_get_device_num(acc_get_device_type());  \t#pragma acc init if(device_num == device_num) \t//#pragma acc init if(true)  \treturn err; } #endif  #ifndef T2 //T2:,V:2.7-3.0 int test2(){ \tint err = 0; \tsrand(SEED);  \tint device_num = acc_get_device_num(acc_get_device_type());  \t#pragma acc init if(device_num != device_num) \t//#pragma acc init if(false)  \treturn err; } #endif  int main(){ \tint failcode = 0; \tint failed; #ifndef T1 \tfailed = 0; \tfor (int x = 0; x < NUM_TEST_CALLS; ++x){ \t\tfailed = failed + test1(); \t} \tif (failed != 0){ \t\tfailcode = failcode + (1 << 0); \t} #endif #ifndef T2 \tfailed = 0; \tfor (int x = 0; x < NUM_TEST_CALLS; ++x){ \t\tfailed = failed + test2(); \t} \tif (failed != 0){ \t\tfailcode = failcode + (1 << 1); \t} #endif \treturn failcode; } "}
{"prompt": "Create a test for the feature kernels loop tile", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,tile,reduction,combined-constructs,V:2.0-2.7 int test1(){   int err = 0;   srand(SEED);   real_t * a = new real_t[n];   real_t * b = new real_t[n];   real_t * c = new real_t[n];   real_t * d2 = new real_t[n * n];   real_t * d3 = new real_t[n * n * n];   real_t temp = 0.0;    for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = rand() / (real_t)(RAND_MAX / 10);   }   #pragma acc data copy(a[0:n], b[0:n], c[0:n], d2[0:n*n])   {       #pragma acc kernels loop tile(*, *) reduction(+:temp)       for (int x = 0; x < n; ++x){           for (int y = 0; y < n; ++y){               temp = 0;               for (int z = 0; z < n; ++z){                   temp += a[x] + b[y] + c[z];               }               d2[x * n + y] = temp;           }       }   }   for (int x = 0; x < n; ++x){       for (int y = 0; y < n; ++y){           temp = 0.0;           for (int z = 0; z < n; ++z){               temp += a[x] + b[y] + c[z];           }           if (fabs(temp - d2[x * n + y]) > PRECISION * n){               err += 1;           }       }   }      return err; } #endif  #ifndef T2 //T2:kernels,loop,tile,combined-constructs,V:2.0-2.7 int test2(){   int err = 0;   srand(SEED);   real_t * a = new real_t[n];   real_t * b = new real_t[n];   real_t * c = new real_t[n];   real_t * d2 = new real_t[n * n];   real_t * d3 = new real_t[n * n * n];   real_t temp = 0.0;    for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = rand() / (real_t)(RAND_MAX / 10);   }    #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d3[0:n*n*n])   {       #pragma acc kernels loop tile(n/10, n, n*2)       for (int x = 0; x < n; ++x){           for (int y = 0; y < n; ++y){               for (int z = 0; z < n; ++z){                   d3[(n * n * x) + (n * y) + z] = a[x] + b[x] + c[x];               }           }       }   }    for (int x = 0; x < n; ++x){       for (int y = 0; y < n; ++y){           for (int z = 0; z < n; ++z){               if (fabs(d3[(n * n * x) + (n * y) + z] - a[x] - b[x] - c[x]) > PRECISION * 2){                   err = 1;               }           }       }   }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc update self async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];      int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = 0;     }        #pragma acc data create(c[0:n], d[0:n]) copyin(a[0:n], b[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 d[x] = a[x] * b[x];             }         }         acc_update_self_async(c, n * sizeof(real_t), 1);         acc_update_self_async(d, n * sizeof(real_t), 2);         #pragma acc wait     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }         if (fabs(d[x] - (a[x] * b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7 int test2(){ \tint err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];      int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0;         }          #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])         {             #pragma acc parallel async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     a[x] = a[x] * a[x];                 }             }             acc_update_self_async(a, n * sizeof(real_t), 1);             #pragma acc parallel async(2)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = b[x] * b[x];                 }             }             acc_update_self_async(b, n * sizeof(real_t), 2);             #pragma acc parallel async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     a[x] = a[x] + 1;                 }             }             #pragma acc parallel async(2)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = b[x] + 1;                 }             }             #pragma acc parallel async(1) wait(2)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] * b[x];                 }             }             #pragma acc wait(1)         }           for (int x = 0; x < n; ++x){             if (fabs(c[x] - ((a[x] + 1) * (b[x] + 1))) > 4 * PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,async,wait,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * restrict a = (real_t *)malloc(n * sizeof(real_t));     real_t * restrict b = (real_t *)malloc(n * sizeof(real_t));     real_t * restrict c = (real_t *)malloc(n * sizeof(real_t));     real_t * restrict d = (real_t *)malloc(n * sizeof(real_t));     real_t * restrict e = (real_t *)malloc(n * sizeof(real_t));     real_t * restrict f = (real_t *)malloc(n * sizeof(real_t));     real_t * restrict g = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);       \tb[x] = rand() / (real_t)(RAND_MAX / 10);       \tc[x] = 0.0;       \td[x] = rand() / (real_t)(RAND_MAX / 10);       \te[x] = rand() / (real_t)(RAND_MAX / 10);       \tf[x] = 0.0;       \tg[x] = 0.0;     }     #pragma acc enter data create(g[0:n], c[0:n], f[0:n])     #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])     {         #pragma acc kernels async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc kernels async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         #pragma acc kernels wait(1, 2) async(3)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 g[x] = c[x] + f[x];             }         }     }     #pragma acc wait(1, 2)     #pragma acc update host(c[0:n], f[0:n])     #pragma acc exit data copyout(g[0:n]) async(3)     for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;       \t}         if (fabs(f[x] - (d[x] + e[x])) > PRECISION){             err += 1;         }     }     #pragma acc wait(3)     for (int x = 0; x < n; ++x){         if (fabs(g[x] - (c[x] + f[x])) > PRECISION){             err += 1;         }     }     #pragma acc exit data delete(c[0:n], f[0:n])      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop seq", "completion": "#ifndef T1 !T1:serial,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   REAL(8),DIMENSION(LOOPCOUNT):: a, b   REAL(8):: temp   INTEGER:: errors, x    errors = 0   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   b = 0    !$acc data copyin(a(1:LOOPCOUNT)) copy(b(1:LOOPCOUNT))     !$acc serial loop seq     DO x = 2, LOOPCOUNT       b(x) = b(x - 1) + a(x)     END DO   !$acc end data    temp = 0   DO x = 2, LOOPCOUNT     temp = temp + a(x)     IF (abs(b(x) - temp) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic x bitor expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] |= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured postincrement assign", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *c = new int[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];     bool found = false;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     distribution[(int) (a[x]*b[x]/10)]++;                     c[x] = distribution[(int) (a[x]*b[x]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]++;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < distribution_comparison[x]; ++y){             for (int z = 0; z < n; ++z){                 if (c[z] == y + 1 && (int) (a[z]*b[z]/10) == x){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data create no lower bound", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,data-region,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * d = (real_t *)malloc(n * sizeof(real_t));     real_t * e = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[:n]) copyout(e[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }             #pragma acc loop             for (int x = 0; x < n; ++x){                 e[x] = c[x] + d[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial wait", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,executable-data,async,wait,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      #pragma acc enter data create(a[0:n])     #pragma acc update device(a[0:n]) async(1)     #pragma acc serial present(a[0:n]) wait(1)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             a[x] += 1;         }     }     #pragma acc exit data copyout(a[0:n])     for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] + 1)) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitxor general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     unsigned int b = 0;     unsigned int host_b = 0;      for (int x = 0; x < n; ++x){         a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);     }      #pragma acc data copyin(a[0:n])     {         #pragma acc parallel loop reduction(^:b)         for (int x = 0; x < n; ++x){             b = b ^ a[x];         }     }      for (int x = 0; x < n; ++x){         host_b = host_b ^ a[x];     }     if (b != host_b){         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int b[10];     unsigned int host_b[10];      for (int x = 0; x < 10 * n; ++x){         a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);     }      for (int x = 0; x < 10; ++x) {         b[x] = 0;         host_b[x] = 0;     }      #pragma acc data copyin(a[0:10*n])     {         #pragma acc parallel loop reduction(^:b)         for (int x = 0; x < 10 * n; ++x) {             b[x % 10] = b[x % 10] ^ a[x];         }     }      for (int x = 0; x < 10 * n; ++x) {         host_b[x % 10] = host_b[x % 10] ^ a[x];     }      for (int x = 0; x < 10; ++x) {         if (host_b[x] != b[x]) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture expr plus x", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] + prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(int)(n/10 + 1)];     real_t *totals_comparison = new real_t[(int)(n/10 + 1)];     real_t *passed_ab = new real_t[10];     real_t *passed_c = new real_t[10];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:11]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = totals[x%((int)(n/10 + 1))] = (a[x] + b[x]) + totals[x%((int)(n/10 + 1))];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%((int)(n/10 + 1))] += (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction bitand vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int c = 0;     unsigned int b_host;      for (int x = 0; x < 10 * n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX < false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc kernels loop private(c)         for (int x = 0; x < 10; ++x){             c = a[x * n];             #pragma acc loop vector reduction(&:c)             for (int y = 1; y < n; ++y){                 c = c & a[x * n + y];             }             b[x] = c;         }     }     for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host & a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic postdecrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     distribution[(int) (a[x] * b[x] / 10)]--;             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]--;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitand general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     n = 10;     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int b = 0;     unsigned int host_b;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX < false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }     for (int x = 0; x < 16; ++x){         temp = 1;         for (int y = 0; y < x; ++y){             temp *= 2;         }         b += temp;     }     #pragma acc data copyin(a[0:n])     {         #pragma acc serial loop reduction(&:b)         for (int x = 0; x < n; ++x){             b = b & a[x];         }     }      host_b = a[0];     for (int x = 1; x < n; ++x){         host_b = host_b & a[x];     }     if (b != host_b){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update max expr list x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update expr and x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) < .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = a(x, y) .AND. totals(x)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .AND. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial reduction", "completion": "#ifndef T1 !T1:serial,reduction,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   REAL(8),DIMENSION(LOOPCOUNT):: a   REAL(8):: reduction   INTEGER:: errors, x    errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)    !$acc serial copyin(a(1:LOOPCOUNT)) reduction(+:reduction)     !$acc loop     DO x = 1, LOOPCOUNT       reduction = reduction + a(x)     END DO   !$acc end serial    DO x = 1, LOOPCOUNT     reduction = reduction - a(x)   END DO    IF (abs(reduction) .gt. PRECISION) THEN     errors = errors + 1   END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture minus equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (prev - a[x])) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));     real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0; \ttotals_host[x] = 0;      }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = totals[x%10] -= (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitxor vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));     unsigned int temp = 0;     unsigned int b_host;      for (int x = 0; x < 10 * n; ++x){         a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(^:temp)             for (int y = 0; y < n; ++y){                 temp = temp ^ a[x * n + y];             }             b[x] = temp;         }     }      for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host ^ a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,async,wait,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * d = (real_t *)malloc(n * sizeof(real_t));     real_t * e = (real_t *)malloc(n * sizeof(real_t));     real_t * f = (real_t *)malloc(n * sizeof(real_t));     real_t * g = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;         g[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], c[0:n], f[0:n], g[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         #pragma acc parallel wait(1, 2) async(3)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 g[x] = c[x] + f[x];             }         }         #pragma acc update host(c[0:n]) async(1)         #pragma acc update host(f[0:n]) async(2)         #pragma acc update host(g[0:n]) async(3)          #pragma acc wait(1)         for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x])) > PRECISION){                 err += 1;             }         }         #pragma acc wait(2)         for (int x = 0; x < n; ++x){             if (fabs(f[x] - (d[x] + e[x])) > PRECISION){                 err += 1;             }         }         #pragma acc wait(3)         for (int x = 0; x < n; ++x){             if (fabs(g[x] - (a[x] + b[x] + d[x] + e[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction add general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      real_t total = 10; //Should be innitialized to 0 anyway.     #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc kernels loop reduction(+:total)         for (int x = 0; x < n; ++x){             total += a[x] + b[x];         }     }     for (int x = 0; x < n; ++x){         total -= a[x] + b[x];     }     if (fabs(total - 10) > PRECISION * (2 * n - 1)){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitxor loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));     unsigned int temp = 0;      for (int x = 0; x < 10*n; ++x){         b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b_copy[x] = b[x];         a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);     }     for (int x = 0; x < 10; ++x){         c[x] = 0;     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(^:temp)             for (int y = 0; y < n; ++y){                 temp = temp ^ a[x * n + y];             }             c[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 b[x * n + y] = b[x * n + y] + c[x];             }         }     }      for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = temp ^ a[x * n + y];         }         if (temp != c[x]){             err += 1;         }         for (int y = 0; y < n; ++y){             if (b[x * n + y] != b_copy[x * n + y] + c[x]){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine bind", "completion": "#include \"acc_testsuite.h\" real_t host_function_identifier_named(real_t* a, long long n); real_t host_function_string_named(real_t* a, long long n);  #pragma acc routine(host_function_identifier_named) vector bind(device_function_identifier_named) #pragma acc routine(host_function_string_named) vector bind(\"device_function_string_named\")  #pragma acc routine vector bind(device_function_identifier_unnamed) real_t host_function_identifier_unnamed(real_t* a, long long n){     real_t returned = 0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  real_t device_function_identifier_unnamed(real_t *a, long long n){     real_t returned = 0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  #pragma acc routine vector bind(\"device_function_string_unnamed\") real_t host_function_string_unnamed(real_t* a, long long n){     real_t returned = 0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  real_t device_function_string_unnamed(real_t* a, long long n){     real_t returned = 0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  real_t host_function_identifier_named(real_t* a, long long n){     real_t returned = 0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  real_t device_function_identifier_named(real_t* a, long long n){     real_t returned = 0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  real_t host_function_string_named(real_t* a, long long n){     real_t returned = 0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  real_t device_function_string_named(real_t* a, long long n){     real_t returned = 0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  #ifndef T1 //T1:routine,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t **a = (real_t **)malloc(n * sizeof(real_t *));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int on_host = (acc_get_device_type() == acc_device_none);     for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_function_identifier_unnamed(a[x], n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_function_identifier_unnamed(a[x], n) + b[x]) > PRECISION)){             err += 1;             return 1;         }         else if ((on_host) && (fabs(host_function_identifier_unnamed(a[x], n) - b[x]) > PRECISION)){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:routine,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t **a = (real_t **)malloc(n * sizeof(real_t *));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int on_host = (acc_get_device_type() == acc_device_none);     for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }     }      #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_function_string_unnamed(a[x], n);             }         }     }      for (int x = 0; x < n; ++x){         if (!on_host && fabs(host_function_string_unnamed(a[x], n) + b[x]) > PRECISION){             err += 1;         }         else if (on_host && fabs(host_function_string_unnamed(a[x], n) - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:routine,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t **a = (real_t **)malloc(n * sizeof(real_t *));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int on_host = (acc_get_device_type() == acc_device_none);     for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }     }      #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_function_identifier_named(a[x], n);             }         }     }      for (int x = 0; x < n; ++x){         if (!on_host && fabs(host_function_identifier_named(a[x], n) + b[x]) > PRECISION){             err += 1;         }         else if (on_host && fabs(host_function_identifier_named(a[x], n) - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T4 //T4:routine,construct-independent,V:2.0-2.7 int test4(){     int err = 0;     srand(SEED);     real_t **a = (real_t **)malloc(n * sizeof(real_t *));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int on_host = (acc_get_device_type() == acc_device_none);     for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }     }      #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_function_string_named(a[x], n);             }         }     }      for (int x = 0; x < n; ++x){         if (!on_host && fabs(host_function_string_named(a[x], n) + b[x]) > PRECISION){             err += 1;         }         else if (on_host && fabs(host_function_string_named(a[x], n) - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction multiply loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10 * n];     real_t * totals = new real_t[10];     real_t temp;      for (int x = 0; x < n; ++x){         a[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;         b[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;         c[x] = 0.0;     }       #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10*n]) copy(totals[0:10])     {         #pragma acc serial  \t{    \t#pragma acc loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop worker reduction(*:temp)             for (int y = 0; y < n; ++y){                 temp *= a[x * n + y] + b[x * n + y];             }             totals[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 c[x * n + y] = (a[x * n + y] + b[x * n + y]) / totals[x];             }         } \t}     }      for (int x = 0; x < 10; ++x){         temp = 1;         for (int y = 0; y < n; ++y){             temp *= a[x * n + y] + b[x * n + y];         }         if (fabs(temp - totals[x]) > (temp / 2 + totals[x] / 2) * PRECISION){             err += 1;         }         for (int y = 0; y < n; ++y){             if (fabs(c[x * n + y] - ((a[x * n + y] + b[x * n + y]) / totals[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial default present", "completion": "#ifndef T1 !T1:serial,default,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT):: a   INTEGER:: x   errors = 0    a = 0    !$acc enter data copyin(a(1:LOOPCOUNT))   !$acc serial default(present)     !$acc loop     DO x = 1, LOOPCOUNT       a(x) = 1     END DO   !$acc end serial   !$acc exit data copyout(a(1:LOOPCOUNT))    DO x = 1, LOOPCOUNT     IF (abs(a(x) - 1) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop vector blocking", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,V:1.0-2.7 int test1(){   int err = 0;   srand(SEED);   real_t * a = (real_t *)malloc(n * sizeof(real_t));   real_t * b = (real_t *)malloc(n * sizeof(real_t));   real_t * c = (real_t *)malloc(n * sizeof(real_t));   real_t multiplyer = 1;    for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = 0.0;   }    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])   {     #pragma acc parallel     {       #pragma acc loop vector       for (int x = 0; x < n; ++x){         c[x] = (a[x] + b[x]) * multiplyer;       }       multiplyer += 1;       #pragma acc loop vector       for (int x = 0; x < n; ++x){         c[x] += (a[x] + b[x]) * multiplyer;       }     }   }    for (int x = 0; x < n; ++x){     if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){       err + 1;       break;     }   }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc copyout async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];     real_t *e = new real_t[n];     real_t *f = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0;     }      #pragma acc enter data create(c[0:n], f[0:n])      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])     {         #pragma acc parallel async(1) present(c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel async(2) present(f[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         acc_copyout_async(c, n * sizeof(real_t), 1);         acc_copyout_async(f, n * sizeof(real_t), 2);         #pragma acc wait     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }         if (fabs(f[x] - (d[x] + e[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,async,data,executable-data,internal-control-values,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int def_async_var = acc_get_default_async();      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data create(c[0:n])      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(c[0:n]) async         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         acc_copyout_async(c, n * sizeof(real_t), def_async_var);         #pragma acc wait     }      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:runtime,async,data,executable-data,internal-control-values,construct-independent,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int def_async_var = acc_get_default_async();      acc_set_default_async(def_async_var + 1);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }          #pragma acc enter data create(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(c[0:n]) async         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         acc_copyout_async(c, n * sizeof(real_t), def_async_var + 1);         #pragma acc wait     }      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T4 //T4:runtime,async,data,executable-data,construct-independent,V:2.5-2.7 int test4(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data create(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(c[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         #pragma acc enter data copyin(c[0:n])         acc_copyout_async(c, n * sizeof(real_t), 1);         #pragma acc parallel present(c[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] += a[x] + b[x];             }         }         acc_copyout_async(c, n * sizeof(real_t), 1);     }          for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction max general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t max = 0.0;     int found = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:n], b[0:n]) copy(max)     {         #pragma acc serial loop reduction(max:max)         for (int x = 0; x < n; ++x){             max = fmax(a[x] * b[x], max);         }     }      for (int x = 0; x < n; ++x){         if (fabs(max - (a[x] * b[x] + PRECISION)) < 0){             err = 1;         }         if (fabs(max - (a[x] * b[x] - PRECISION)) > 0){             found = 1;         }     }     if (found = 0){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction min general", "completion": "#ifndef T1 !T1:serial,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors, x   REAL(8),DIMENSION(LOOPCOUNT):: a, b   REAL(8):: minimum, host_minimum    errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)    minimum = a(1) * b(1)   host_minimum = minimum    DO x = 2, LOOPCOUNT     host_minimum = min(host_minimum, a(x) * b(x))   END DO    !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))     !$acc serial loop reduction(min:minimum)     DO x = 1, LOOPCOUNT       minimum = min(minimum, a(x) * b(x))     END DO   !$acc end data    IF (abs(host_minimum - minimum) .gt. PRECISION) THEN     errors = errors + 1   END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc memcpy to device", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *hostdata = new real_t[3 * n];     real_t *devdata;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 1;     }      devdata = reinterpret_cast<real_t*>(acc_create(hostdata, 3 * n * sizeof(real_t)));      acc_memcpy_to_device(devdata, a, n * sizeof(real_t));     acc_memcpy_to_device(&(devdata[n]), b, n * sizeof(real_t));     acc_memcpy_to_device(&(devdata[2*n]), c, n * sizeof(real_t));      #pragma acc data deviceptr(devdata)     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[2*n + x] += devdata[x] + devdata[n + x];             }         }     }     #pragma acc exit data copyout(hostdata[0:3*n])     for (int x = 0; x < n; ++x){         if (fabs(hostdata[2 * n + x] - (1 + hostdata[n + x] + hostdata[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign bitand equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev & a[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }   #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         for (int y = 0; y < 8; ++y){             totals[x] =  1<<y;             totals_comparison[x] = 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         b[x] = totals[x/10];                         totals[x/10] &= a[x];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] &= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }      for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction min vector loop", "completion": "#ifndef T1 !T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b   REAL(8),DIMENSION(10):: minimums, host_minimums   REAL(8):: temp   INTEGER:: errors, x, y    errors = 0   minimums = 1   host_minimums = 1    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)    DO y = 1, 10     DO x = 1, LOOPCOUNT       host_minimums(y) = min(host_minimums(y), a(x, y) * b(x, y))     END DO   END DO    !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(minimums(1:10))     !$acc serial loop gang private(temp)     DO y = 1, 10       temp = 1       !$acc loop vector reduction(min:temp)       DO x = 1, LOOPCOUNT         temp = min(temp, a(x, y) * b(x, y))       END DO       minimums(y) = temp     END DO   !$acc end data    DO x = 1, 10     IF (abs(host_minimums(x) - minimums(x)) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update expr and x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) < .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = a(x, y) .AND. totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .AND. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc set default async", "completion": "#ifndef T1 !T1:runtime,async,construct-independent,internal-control-values,set,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         a_host = a         b_host = b         c = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))           CALL acc_set_default_async(1)           !$acc parallel async             !$acc loop             DO x = 1, LOOPCOUNT               a(x) = a(x) * a(x)             END DO           !$acc end parallel           CALL acc_set_default_async(2)           !$acc parallel async             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = b(x) * b(x)             END DO           !$acc end parallel           !$acc parallel async(1) wait(2)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           !$acc wait(1)         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a_host(x) * a_host(x) + b_host(x) * b_host(x))) .gt. 4 * PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature init", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:init,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);      #pragma acc init      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels default copy", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data-region,default-mapping,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t c[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc kernels         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:kernels,data-region,default-mapping,reference-counting,devonly,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t c[n];     int * devtest = (int *)malloc(sizeof(real_t));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc kernels present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 1;         }          #pragma acc enter data copyin(c[0:n])         for (int x = 0; x < n; ++x){             c[x] = 0.0;         }         #pragma acc data copyin(a[0:n], b[0:n])         {             #pragma acc kernels             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] += a[x] + b[x];                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(c[x]) > PRECISION){                 err += 1;             }         }          #pragma acc exit data copyout(c[0:n])          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels create", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data,data-region,devonly,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     int * devtest = (int *)malloc(sizeof(int));     real_t * a = new real_t[n];     real_t * b = new real_t[n];     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {       devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){           a[x] = rand() / (real_t)(RAND_MAX / 10);           b[x] = 0.0;         }          #pragma acc data copyin(a[0:n])         {             #pragma acc kernels create(b[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = a[x];                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(b[x]) > PRECISION){                 err += 1;             }         }      }      return err; } #endif  #ifndef T2 //T2:kernels,data,data-region,reference-counting,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc kernels create(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:kernels,data,data-region,V:1.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copyout(c[0:n])     {         #pragma acc kernels create(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - a[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel firstprivate", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,firstprivate,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[n];     real_t * c_copy = new real_t[n];     real_t * d = new real_t[10 * n];      for (int x = 0; x < 10*n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         d[x] = 0.0;     }     for (int x = 0; x < n; ++x){         c[x] = rand() / (real_t)(RAND_MAX / 10);         c_copy[x] = c[x];     }     #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])     {         #pragma acc parallel firstprivate(c[0:n])         {             #pragma acc loop gang             for (int x = 0; x < 10; ++x){                 #pragma acc loop worker                 for (int y = 0; y < n; ++y){                     d[x * n + y] = a[x * n + y] + b[x * n + y] + c[y];                 }             }         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (fabs(d[x * n + y] - (a[x * n + y] + b[x * n + y] + c_copy[y])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,firstprivate,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[n];     real_t * c_copy = new real_t[n];     real_t * d = new real_t[10 * n];      for (int x = 0; x < 10*n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         d[x] = 0.0;     }     for (int x = 0; x < n; ++x){         c[x] = 0.0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])     {         #pragma acc parallel firstprivate(c[0:n])         {             #pragma acc loop gang independent             for (int x = 0; x < 10; ++x){                 #pragma acc loop worker independent                 for (int y = 0; y < n; ++y){                     c[y] = a[x * n + y] - b[x * n + y];                 }                 #pragma acc loop worker independent                 for (int y = 0; y < n; ++y){                     d[x * n + y] = a[x * n + y] + b[x * n + y] + c[y];                 }             }         }     }      for (int x = 0; x < 10 * n; ++x){         if (fabs(d[x] - 2 * a[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign plus equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, a[x] + prev)){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t *passed_ab = new real_t[10];     real_t *passed_c = new real_t[10];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x%(n/10 + 1)];                     totals[x%(n/10 + 1)] += a[x] * b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] += a[x] * b[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){             passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitand loop", "completion": "#ifndef T1 !T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y, z !Iterators         INTEGER,DIMENSION(10*LOOPCOUNT):: a, b, b_copy !Data         REAL(8),DIMENSION(10*LOOPCOUNT):: randoms2         INTEGER,DIMENSION(10) :: c         REAL(8) :: false_margin         REAL(8),DIMENSION(160*LOOPCOUNT)::randoms         INTEGER :: errors = 0         INTEGER :: temp          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         CALL RANDOM_NUMBER(randoms2)         b = FLOOR(10000 * randoms2)         b_copy = b         false_margin = exp(log(.5)/LOOPCOUNT)         DO x = 1, 10 * LOOPCOUNT           DO y = 1, 16             IF (randoms((y - 1) * 10 * LOOPCOUNT + x) < false_margin) THEN               temp = 1               DO z = 1, y                 temp = temp * 2               END DO               a(x) = a(x) + temp             END IF           END DO         END DO                  DO x = 1, 10          c(x) = a((x - 1) * LOOPCOUNT + x)         END DO                            !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10*LOOPCOUNT), c(1:10))           !$acc parallel loop gang private(temp)           DO x = 1, 10             temp = a((x - 1) * LOOPCOUNT + 1)             !$acc loop worker reduction(iand:temp)             DO y = 2, LOOPCOUNT               temp = iand(temp, a((x - 1) * LOOPCOUNT + y))             END DO             c(x) = temp             !$acc loop worker             DO y = 1, LOOPCOUNT               b((x - 1) * LOOPCOUNT + y) = b((x - 1) * LOOPCOUNT + y) + c(x)             END DO           END DO         !$acc end data         DO x = 1, 10          temp = a((x - 1) * LOOPCOUNT + 1)          DO y = 2, LOOPCOUNT            temp = iand(temp, a((x - 1) * LOOPCOUNT + y))          END DO          IF (temp .ne. c(x)) THEN            errors = errors + 1          END IF          DO y = 1, LOOPCOUNT            IF (b((x - 1) * LOOPCOUNT + y) .ne. b_copy((x - 1) * LOOPCOUNT + y) + temp) THEN              errors = errors + 1            END IF          END DO        END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop reduction bitor loop", "completion": "#ifndef T1 !T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y, z, i !Iterators         INTEGER,DIMENSION(10*LOOPCOUNT):: a, b, b_copy !Data         REAL(8),DIMENSION(10*LOOPCOUNT):: randoms2         INTEGER,DIMENSION(10) :: c         REAL(8),DIMENSION(160*LOOPCOUNT):: randoms         REAL(8) :: false_margin         INTEGER :: errors = 0         INTEGER :: temp          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         CALL RANDOM_NUMBER(randoms2)         false_margin = exp(log(.5)/n)         b = FLOOR(6*randoms2)         b_copy = b         DO x = 0, 9           DO y = 1, LOOPCOUNT             DO z = 1, 16               IF (randoms(x * 16 * LOOPCOUNT + y * 16 + z - 1) .gt. false_margin) THEN                 temp = 1                 DO i = 1, z                   temp = temp * 2                 END DO                 a(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + temp               END IF             END DO           END DO         END DO          !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10*LOOPCOUNT), c(1:10))           !$acc kernels loop gang private(temp)           DO x = 0, 9             temp = 0             !$acc loop worker reduction(ior:temp)             DO y = 1, LOOPCOUNT               temp = ior(temp, a(x * LOOPCOUNT + y))             END DO             c(x + 1) = temp             !$acc loop worker             DO y = 1, LOOPCOUNT               b(x * LOOPCOUNT + y) = b(x * LOOPCOUNT + y) + c(x + 1)             END DO           END DO         !$acc end data          DO x = 0, 9           temp = 0           DO y = 1, LOOPCOUNT             temp = ior(temp, a(x * LOOPCOUNT + y))           END DO           IF (temp .ne. c(x + 1)) THEN             errors = errors + 1           END IF           DO y = 1, LOOPCOUNT             IF (b(x * LOOPCOUNT + y) .ne. b_copy(x * LOOPCOUNT + y) + c(x + 1)) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop independent", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc kernels loop independent         for (int x = 0; x < n; ++x){             b[x] = a[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature declare function scope deviceptr", "completion": "#include \"acc_testsuite.h\" void declare_deviceptr(real_t *a, real_t *b, real_t *c, real_t *d){     #pragma acc declare deviceptr(c)     #pragma acc parallel present(a[0:n], b[0:n], d[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = c[x] + a[x] + b[x];         }         #pragma acc loop         for (int x = 0; x < n; ++x){             d[x] = c[x] * a[x];         }     } }  #ifndef T1 //T1:declare,runtime,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t ** b = (real_t **)malloc(n * sizeof(real_t *));     real_t ** c = (real_t **)malloc(n * sizeof(real_t *));     real_t ** d = (real_t **)malloc(n * sizeof(real_t *));     real_t ** devpointer_c = (real_t **)malloc(n * sizeof(real_t *));     int *devtest = (int *)malloc(sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));         b[x] = (real_t *)malloc(n * sizeof(real_t));         c[x] = (real_t *)malloc(n * sizeof(real_t));         d[x] = (real_t *)malloc(n * sizeof(real_t));         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 1;             d[x][y] = 0;         }     }      #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copy(c[0:n][0:n]) copyout(d[0:n][0:n])     {         for (int x = 0; x < n; ++x){             devpointer_c[x] = acc_deviceptr(c[x]);             declare_deviceptr(a[x], b[x], devpointer_c[x], d[x]);         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){                 err += 1;             }             if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:declare,runtime,construct-independent,devonly,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t ** b = (real_t **)malloc(n * sizeof(real_t *));     real_t ** c = (real_t **)malloc(n * sizeof(real_t *));     real_t ** d = (real_t **)malloc(n * sizeof(real_t *));     real_t ** devpointer_c = (real_t **)malloc(n * sizeof(real_t *));     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 a[x][y] = rand() / (real_t)(RAND_MAX / 10);                 b[x][y] = rand() / (real_t)(RAND_MAX / 10);                 c[x][y] = 3;             }         }          #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])         {             for (int x = 0; x < n; ++x){                 #pragma acc data copyout(d[x:1][0:n])                 {                     devpointer_c[x] = acc_copyin(c[x], n * sizeof(real_t));                     declare_deviceptr(a[x], b[x], devpointer_c[x], d[x]);                 }                 for (int y = 0; y < n; ++y){                     if (fabs(c[x][y] - 3) > PRECISION){                         err += 1;                     }                 }                 for (int y = 0; y < n; ++y){                     if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 10){                         err += 1;                     }                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x minus expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = totals(x) - a(x, y)               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) - a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update bitand equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }      }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] &= a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] &= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture preincrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *c = (int *)malloc(n * sizeof(int));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = ++distribution[(int) (a[x]*b[x]/10)];             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]++;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      bool found = false;     for (int x = 0; x < 10; ++x){         for (int y = 0; y < distribution[x]; ++y){             for (int z = 0; z < n; ++z){                 if (c[z] == y + 1 && x == (int) (a[z] * b[z] / 10)){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature declare function scope copyout", "completion": "FUNCTION copyout_test(a, b, c, LOOPCOUNT)   REAL(8),DIMENSION(LOOPCOUNT),INTENT(IN) :: a, b   REAL(8),DIMENSION(LOOPCOUNT),INTENT(INOUT) :: c   INTEGER,INTENT(IN) :: LOOPCOUNT   INTEGER :: x    !$acc declare copyout(c(1:LOOPCOUNT))   !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))     !$acc loop     DO x = 1, LOOPCOUNT       c(x) = a(x) + b(x)     END DO   !$acc end parallel END FUNCTION copyout_test  #ifndef T1 !T1:devonly,construct-independent,declare,V:2.0-2.7       LOGICAL FUNCTION test1()   USE OPENACC   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c   INTEGER,DIMENSION(1) :: devtest   INTEGER :: x, y    devtest(1) = 1   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = 0   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 1    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))     DO x = 1, LOOPCOUNT       CALL copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)     END DO   !$acc end data    DO x = 1, LOOPCOUNT     DO y = 1, LOOPCOUNT       IF (abs(c(x, y) - (a(x, y) + b(x, y))) .gt. PRECISION) THEN         errors = errors + 1       END IF     END DO   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:devonly,construct-independent,declare,V:2.0-2.7       LOGICAL FUNCTION test2()   USE OPENACC   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c   INTEGER,DIMENSION(1) :: devtest   INTEGER :: x, y    devtest(1) = 1   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = 0   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 2    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))     DO x = 1, LOOPCOUNT       !$acc data copy(c(1:LOOPCOUNT, x:x))         CALL copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)       !$acc end data     END DO   !$acc end data    DO x = 1, LOOPCOUNT     DO y = 1, LOOPCOUNT       IF (abs(c(x, y) - (a(x, y) + b(x, y))) .gt. PRECISION) THEN         errors = errors + 1       END IF     END DO   END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:devonly,construct-independent,declare,V:2.0-2.7       LOGICAL FUNCTION test3()   USE OPENACC   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c   INTEGER,DIMENSION(1) :: devtest   INTEGER :: x, y    devtest(1) = 1   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = 0   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    IF (devtest(1) .eq. 1) THEN     CALL RANDOM_NUMBER(a)     CALL RANDOM_NUMBER(b)     c = 3      !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))       DO x = 1, LOOPCOUNT         !$acc data copyin(c(1:LOOPCOUNT, x:x))           CALL copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)         !$acc end data         DO y = 1, LOOPCOUNT           IF (abs(c(y, x) - 3) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO       END DO     !$acc end data   END IF          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc get device num", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,devonly,internal-control-values,syntactic,V:1.0-2.7 int test1(){     int err = 0;      if (acc_get_device_type() != acc_device_none){         for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){             acc_set_device_num(x, acc_get_device_type());             if (acc_get_device_num(acc_get_device_type()) != x){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature declare function scope create", "completion": "FUNCTION create_test(a, b, c, d, LOOPCOUNT)   REAL(8),DIMENSION(LOOPCOUNT),INTENT(IN) :: a, b   REAL(8),DIMENSION(LOOPCOUNT),INTENT(INOUT) :: c, d   INTEGER,INTENT(IN) :: LOOPCOUNT   INTEGER :: x    !$acc declare create(c(1:LOOPCOUNT))   !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT))     !$acc loop     DO x = 1, LOOPCOUNT       c(x) = a(x) + b(x)     END DO     !$acc loop     DO x = 1, LOOPCOUNT       d(x) = c(x) * a(x)     END DO   !$acc end parallel END FUNCTION function_test  FUNCTION create_as_present(a, b, c, d, LOOPCOUNT)   REAL(8),DIMENSION(LOOPCOUNT),INTENT(IN) :: a, b   REAL(8),DIMENSION(LOOPCOUNT),INTENT(INOUT) :: c, d   INTEGER,INTENT(IN) :: LOOPCOUNT   INTEGER :: x    !$acc declare create(c(1:LOOPCOUNT))   !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT))     !$acc loop     DO x = 1, LOOPCOUNT       c(x) = c(x) + a(x) + b(x)     END DO     !$acc loop     DO x = 1, LOOPCOUNT       d(x) = c(x) * a(x)     END DO   !$acc end parallel END FUNCTION function_test_dev_only  #ifndef T1 !T1:devonly,construct-independent,declare,V:2.0-2.7       LOGICAL FUNCTION test1()   USE OPENACC   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d   INTEGER,DIMENSION(1) :: devtest   INTEGER :: x, y    devtest(1) = 1   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = 0   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 1   d = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT)) copyout(d(1:LOOPCOUNT, 1:LOOPCOUNT))     DO x = 1, LOOPCOUNT       CALL create_test(a(x), b(x), c(x), d(x), LOOPCOUNT)     END DO   !$acc end data    DO x = 1, LOOPCOUNT     DO y = 1, LOOPCOUNT       IF (abs(d(x, y) - (a(x, y) * (a(x, y) + b(x, y)))) .gt. PRECISION) THEN         errors = errors + 1       END IF     END DO   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:devonly,construct-independent,declare,V:2.0-2.7       LOGICAL FUNCTION test2()   USE OPENACC   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d   INTEGER,DIMENSION(1) :: devtest   INTEGER :: x, y    devtest(1) = 1   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = 0   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 2   d = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT)) copy(c(1:LOOPCOUNT, 1:LOOPCOUNT)) copyout(d(1:LOOPCOUNT, 1:LOOPCOUNT))     DO x = 1, LOOPCOUNT       CALL create_as_present(a(x), b(x), c(x), d(x), LOOPCOUNT)     END DO   !$acc end data    DO x = 1, LOOPCOUNT     DO y = 1, LOOPCOUNT       IF (abs(c(x, y) - (2 + a(x, y) + b(x, y))) .gt. PRECISION) THEN         errors = errors + 1       END IF       IF (abs(d(x, y) - (a(x, y) * c(x, y))) .gt. PRECISION * 2) THEN         errors = errors + 1       END IF     END DO   END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:devonly,construct-independent,declare,V:2.0-2.7       LOGICAL FUNCTION test3()   USE OPENACC   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d   INTEGER,DIMENSION(1) :: devtest   INTEGER :: x, y    devtest(1) = 1   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = 0   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    IF (devtest(1) .eq. 1) THEN     CALL RANDOM_NUMBER(a)     CALL RANDOM_NUMBER(b)     c = 3      !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))       DO x = 1, LOOPCOUNT         !$acc data copyin(c(x:x, 1:LOOPCOUNT)) copyout(d(x:x, 1:LOOPCOUNT))           CALL create_as_present(a(x), b(x), c(x), d(x), LOOPCOUNT)         !$acc end data         DO y = 1, LOOPCOUNT           IF (abs(c(x, y) - 3) .gt. PRECISION) THEN             errors = errors + 1           END IF           IF (abs(d(x, y) - (a(x, y) * (3 + a(x, y) + b(x, y)))) .gt. PRECISION * 2) THEN             errors = errors + 1           END IF         END DO       END DO     !$acc end data   END IF          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc hostptr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *a_ptr;      a_ptr = acc_create(a, n * sizeof(real_t));      if (a != acc_hostptr(acc_deviceptr(a))){         err += 1;     }      acc_delete(a, n * sizeof(real_t));      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction and loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     char * a = new char[10 * n];     char * a_copy = new char[10 * n];     char * has_false = new char[10];     real_t false_margin = pow(exp(1), log(.5)/n);     char temp = 1;      for (int x = 0; x < 10; ++x){         has_false[x] = 0;     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (rand() / (real_t)(RAND_MAX) < false_margin){                 a[x * n + y] = 1;                 a_copy[x * n + y] = 1;             }             else {                 a[x * n + y] = 0;                 a_copy[x * n + y] = 0;                 has_false[x] = 1;             }         }     }      #pragma acc data copy(a[0:10*n])     {         #pragma acc serial \t{    \t#pragma acc loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop worker reduction(&&:temp)             for (int y = 0; y < n; ++y){                 temp = temp && a[x * n + y];             }             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 if(temp == 1){                     if  (a[x * n + y] == 1){                         a[x * n + y] = 0;                     }                     else {                         a[x * n + y] = 1;                     }                 }             }         } \t}     }       for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){                 err = 1;             }             else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){                 err = 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture assign max expr list x", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, c, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8), INTENT(IN) :: init         REAL(8),DIMENSION(length), INTENT(IN) :: a         REAL(8),DIMENSION(length), INTENT(IN) :: b         REAL(8),DIMENSION(length), INTENT(IN) :: c         REAL(8),DIMENSION(length - 1) :: passed_a         REAL(8),DIMENSION(length - 1) :: passed_b         REAL(8),DIMENSION(length - 1) :: passed_c         REAL(8) :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (abs(c(x) - init) .lt. ((10 - length) * PRECISION)) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = max(a(x), b(x), init)             IF (IS_POSSIBLE(passed_a, passed_b, passed_c, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c         REAL(8):: init         LOGICAL IS_POSSIBLE         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   c(x, y) = totals(x)                   totals(x) = max(a(x, y), b(x, y), totals(x))                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = max(totals_comparison(x), a(x, y), b(x, y))           END DO         END DO         DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)             passed_c(y) = c(x, y)           END DO           init = 0           IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif         PROGRAM main       IMPLICIT NONE       INTEGER :: failcode, testrun       LOGICAL :: failed       INCLUDE \"acc_testsuite.Fh\"       !Conditionally define test functions #ifndef T1       LOGICAL :: test1 #endif       failcode = 0       failed = .FALSE.  #ifndef T1       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test1()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 0         failed = .FALSE.       END IF #endif       CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic x bitxor expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .5){                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] =  totals[x%(n/10 + 1)] ^ a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] ^= a[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update x times expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = totals(x) * a(x, y)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) * a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture expr multiply x", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] * prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t *passed_ab = new real_t[10];     real_t *passed_c = new real_t[10];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc get num devices", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,V:1.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: errors         errors = 0          IF (acc_get_device_type() .ne. acc_device_none) THEN           IF (acc_get_num_devices(acc_get_device_type()) .eq. 0) THEN             errors = errors + 1           END IF         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature parallel loop reduction or vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(10 * n * sizeof(char));     char * b = (char *)malloc(10 * sizeof(char));     real_t false_margin = pow(exp(1), log(.5)/n);     char temp = 0;     char found;      for (int x = 0; x < 10 * n; ++x){         if(rand() / (real_t)(RAND_MAX) > false_margin){             a[x] = 1;         }         else{             a[x] = 0;         }     }     #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc parallel loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(||:temp)             for (int y = 0; y < n; ++y){                 temp = temp || a[x * n + y];             }             b[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         found = 0;         for (int y = 0; y < n; ++y){             if (a[x * n + y] &! 0){                 found = 1;             }         }         if (found != b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic bitand equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] &= a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] &= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature exit data copyout reference counts", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int * devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){           a[x] = rand() / (real_t)(RAND_MAX / 10);           b[x] = rand() / (real_t)(RAND_MAX / 10);           c[x] = 0.0;         }          #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])         #pragma acc data copyin(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] += a[x] + b[x];                 }             }             #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])         }         for (int x = 0; x < n; ++x){             if (fabs(c[x]) > PRECISION){                 err += 1;             }         }      }      return err; } #endif  #ifndef T2 //T2:data,executable-data,reference-counting,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])     #pragma acc data copyin(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }     #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 2;             break;         }     }      return err; } #endif  #ifndef T3 //T3:data,executable-data,reference-counting,construct-independent,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])     #pragma acc enter data create(c[0:n])     #pragma acc parallel     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] += a[x] + b[x];         }     }     #pragma acc exit data delete(c[0:n])     #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 4;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc update self", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc data create(c[0:n]) copyin(a[0:n], b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         acc_update_self(c, n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = a[x] * a[x];             }         }         acc_update_self(a, n * sizeof(real_t));         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = b[x] * b[x];             }         }         acc_update_self(b, n * sizeof(real_t));         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }       for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial default copy", "completion": "#ifndef T1 !T1:devonly,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT):: a, b, c   INTEGER,DIMENSION(1):: devtest   INTEGER:: x   errors = 0    devtest(1) = 1   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = 0   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 0    !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))     !$acc serial       !$acc loop       DO x = 1, LOOPCOUNT         c(x) = c(x) + b(x) + a(x)       END DO     !$acc end serial   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:devonly,V:2.6-2.7       LOGICAL FUNCTION test2()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT):: a, b, c   INTEGER,DIMENSION(1):: devtest   INTEGER:: x   errors = 0    devtest(1) = 1   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = 0   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    IF (devtest(1) .eq. 1) THEN     CALL RANDOM_NUMBER(a)     CALL RANDOM_NUMBER(b)     c = 1      !$acc enter data copyin(c(1:LOOPCOUNT))     DO x = 1, LOOPCOUNT       c(x) = 0     END DO      !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))       !$acc serial         !$acc loop         DO x = 1, LOOPCOUNT           c(x) = c(x) + a(x) + b(x)         END DO       !$acc end serial     !$acc end data      DO x = 1, LOOPCOUNT       if (abs(c(x)) .gt. PRECISION) THEN         errors = errors + 1       END IF     END DO      !$acc exit data copyout(c(1:LOOPCOUNT))      DO x = 1, LOOPCOUNT       IF (abs(c(x) - (a(x) + b(x) + 1)) .gt. PRECISION) THEN         errors = errors + 1       END IF     END DO   END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction max general", "completion": "#ifndef T1 !T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8) :: maximum, temp         INTEGER :: errors = 0          !Initilization         maximum = 0         temp = 0         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc parallel loop reduction(max:maximum)           DO x = 1, LOOPCOUNT             maximum = max(maximum, a(x) * b(x))           END DO         !$acc end data          DO x = 1, LOOPCOUNT           temp = max(temp, a(x) * b(x))         END DO         IF (abs(temp - maximum) .gt. PRECISION) THEN           errors = errors + 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels if", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,if,V:1.0-3.2 int test1(){     int err = 0;     srand(SEED);     int data_on_device = 0;     real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             b[x] = a[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - a[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:kernels,if,V:2.0-3.2 int test2(){     int err = 0;     srand(SEED);     int data_on_device = 0;     int * devtest = (int *)malloc(sizeof(int));     real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc enter data copyin(a[0:n]) create(b[0:n])     data_on_device = 1;      #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             b[x] = a[x];         }     }     #pragma acc exit data copyout(b[0:n]) delete(a[0:n])      for (int x = 0; x < n; ++x){         if (fabs(b[x] - a[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:kernels,if,devonly,V:2.0-3.2 int test3(){     int err = 0;     srand(SEED);     int data_on_device = 0;     int * devtest = (int *)malloc(sizeof(int));     real_t * a = new real_t[n];     real_t * b = new real_t[n];     devtest[0] = 1;      #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     { \tdevtest[0] = 0;      }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0;         }          #pragma acc enter data copyin(a[0:n]) create(b[0:n])         for (int x = 0; x < n; ++x){             a[x] = -1;         }          #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }         for (int x = 0; x < n; ++x){             if (fabs(a[x] + 1) > PRECISION){                 err += 1;             }             if (fabs(b[x] + 1) > PRECISION){                 err += 1;             }         }         #pragma acc exit data copyout(a[0:n], b[0:n])         data_on_device = 0;         for (int x = 0; x < n; ++x){             if (fabs(a[x] - b[x]) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T4 //T4:kernels,if,devonly,V:2.0-3.2 int test4(){     int err = 0;     srand(SEED);     int data_on_device = 0;     int * devtest = (int *)malloc(sizeof(int));     real_t * a = new real_t[n];     real_t * b = new real_t[n];     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {       devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0;         }          #pragma acc enter data copyin(a[0:n], b[0:n])         #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }         for (int x = 0; x < n; ++x){             if (fabs(a[x] - b[x]) > PRECISION) {                 err += 1;             }         }         #pragma acc exit data copyout(a[0:n], b[0:n])         for (int x = 0; x < n; ++x){             if (fabs(b[x]) > PRECISION && b[x] != a[x]){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction or vector loop", "completion": "#ifndef T1 !T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   LOGICAL,DIMENSION(LOOPCOUNT, 10):: a   LOGICAL,DIMENSION(10):: b   LOGICAL:: temp   REAL(8):: false_margin   REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms   INTEGER:: errors   INTEGER:: x, y    errors = 0   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)    DO y = 1, 10     DO x = 1, LOOPCOUNT       IF (randoms(x, y) .gt. false_margin) THEN         a(x, y) = .TRUE.       ELSE         a(x, y) = .FALSE.       END IF     END DO   END DO    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(b(1:10))     !$acc serial loop private(temp)     DO y = 1, 10       temp = .FALSE.       !$acc loop vector reduction(.OR.:temp)       DO x = 1, LOOPCOUNT         temp = temp .OR. a(x, y)       END DO       b(y) = temp     END DO   !$acc end data    DO y = 1, 10     temp = .FALSE.     DO x = 1, LOOPCOUNT       temp = temp .OR. a(x, y)     END DO     IF (temp .neqv. b(y)) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update max x expr list end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction add loop", "completion": "#ifndef T1 !T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c, d   REAL(8):: avg, temp   INTEGER:: x, y   avg = 0   errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)    !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) create(c(1:LOOPCOUNT, 1:10)) copyout(d(1:LOOPCOUNT, 1:10))     !$acc serial loop gang private(avg)     DO y = 1, 10       avg = 0       !$acc loop worker reduction(+:avg)       DO x = 1, LOOPCOUNT         c(x, y) = a(x, y) + b(x, y)         avg = avg + c(x, y)       END DO       avg = avg / LOOPCOUNT       !$acc loop worker       DO x = 1, LOOPCOUNT         d(x, y) = c(x, y) - avg       END DO     END DO   !$acc end data    DO y = 1, 10     temp = 0     DO x = 1, LOOPCOUNT       temp = temp + (a(x, y) + b(x, y))     END DO     temp = temp / LOOPCOUNT     DO x = 1, LOOPCOUNT       IF (abs(d(x, y) - ((a(x, y) + b(x, y)) - temp)) .gt. PRECISION) THEN         errors = errors + 1       END IF     END DO   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc memcpy from device", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *hostdata = (real_t *)malloc(3 * n * sizeof(real_t));     real_t *devdata;      for (int x = 0; x < n; ++x){         hostdata[x] = rand() / (real_t)(RAND_MAX / 10);         hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);         hostdata[2*n + x] = 1;     }      devdata = acc_copyin(hostdata, 3 * n * sizeof(real_t));      #pragma acc data deviceptr(devdata)     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[2*n + x] += devdata[x] + devdata[n + x];             }         }     }      acc_memcpy_from_device(a, devdata, n * sizeof(real_t));     acc_memcpy_from_device(b, &(devdata[n]), n * sizeof(real_t));     acc_memcpy_from_device(c, &(devdata[2*n]), n * sizeof(real_t));       for (int x = 0; x < n; ++x){         if (fabs(a[x] - hostdata[x]) > PRECISION){             err += 1;         }         if (fabs(b[x] - hostdata[n + x]) > PRECISION){             err += 1;         }         if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){             err += 1;         }     }      #pragma acc exit data delete(hostdata[0:3*n])      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop gang", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])     {         #pragma acc parallel loop gang         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured expr bitand x assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == (prev & a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] = a[x] & totals[x/10];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] &= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr or x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = a(x, y) .OR. totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .OR. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction add general type check pt1", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test1() {     int err = 0;     srand(SEED);     bool* a = new bool[n];     bool* b = new bool[n];     bool total = 1;     bool host_total = 1;      for (int x = 0; x < n; ++x) {         if ((rand()/((real_t) RAND_MAX)) > .5) {             a[x] = 1;         }         else {             a[x] = 0;         }         if ((rand()/((real_t) RAND_MAX)) > .5) {             b[x] = 1;         }         else {             b[x] = 0;         }     }          #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }           for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (total != host_total) {         err += 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     char * a = new char[n];     char * b = new char[n];     char total = 10;     char host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(UCHAR_MAX / 10);         b[x] = rand() / (real_t)(UCHAR_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (host_total != total) {         err += 1;     }      return err; } #endif  #ifndef T3 //T3:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test3(){     int err = 0;     srand(SEED);     signed char * a = (signed char *)malloc(n * sizeof(signed char));     signed char * b = (signed char *)malloc(n * sizeof(signed char));     signed char total = 10;     signed char host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (host_total != total) {         err += 1;     }      return err; } #endif  #ifndef T4 //T4:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test4(){     int err = 0;     srand(SEED);     unsigned char * a = (unsigned char *)malloc(n * sizeof(unsigned char));     unsigned char * b = (unsigned char *)malloc(n * sizeof(unsigned char));     unsigned char total = 10;     unsigned char host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (total != host_total) {         err += 1;     }      return err; } #endif  #ifndef T5 //T5:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test5(){     int err = 0;     srand(SEED);     short int * a = (short int *)malloc(n * sizeof(short int));     short int * b = (short int *)malloc(n * sizeof(short int));     short int total = 10;     short int host_total = 10;          for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (total != host_total) {         err += 1;     }      return err; } #endif  #ifndef T6 //T6:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test6(){     int err = 0;     srand(SEED);     int * a = new int[n];     int * b = new int[n];     int total = 10;     int host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (total != host_total) {         err += 1;     }      return err; } #endif  #ifndef T7 //T7:parallel,reduction,combined-constructs,loop,nonvalidating,V:1.0-2.7 int test7(){     int err = 0;     srand(SEED);     long int * a = (long int *)malloc(n * sizeof(long int));     long int * b = (long int *)malloc(n * sizeof(long int));     long int total = 10;     long int host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      return err; } #endif  #ifndef T8 //T8:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test8(){     int err = 0;     srand(SEED);     long long int * a = (long long int *)malloc(n * sizeof(long long int));     long long int * b = (long long int *)malloc(n * sizeof(long long int));     long long int total = 10;     long long int host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (host_total != total) {         err += 1;     }      return err; } #endif  int main() {     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x) {         failed = failed + test1();     }     if (failed != 0) {         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif #ifndef T6     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test6();     }     if (failed != 0){         failcode = failcode + (1 << 5);     } #endif #ifndef T7     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test7();     }     if (failed != 0){         failcode = failcode + (1 << 6);     } #endif #ifndef T8     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test8();     }     if (failed != 0){         failcode = failcode + (1 << 7);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture bitand equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; x++){         if (b[x] == (a[x] & prev)){             for (int y = 0; y < x; y++){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; y++){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int iterator;     int iterator2;     int init = 0;      for (int x = 0; x < n; x++){         a[x] = 0;         for (int y = 0; y < 8; y++){                          if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; x++){ \t    totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; y++){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; x++){         b[x] = 0;         for (int y = 0; y < 8; y++){             b[x] += 1<<y;         }     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; x++){                 #pragma acc atomic capture                     b[x] = totals[x%(n/10 + 1)] &= a[x];             }         }     }     for (int x = 0; x < n; x++){         totals_comparison[x%(n/10 + 1)] &= a[x];     }     for (int x = 0; x < (n/10 + 1); x++){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }      for (int x = 0; x < 8; x++){         init += 1<<x;     }     for (int x = 0; x < (n/10 + 1); x++){         for (iterator = x, iterator2 = 0; iterator < n; iterator += n/10 + 1, iterator2++){             temp_a[iterator2] = a[iterator];             temp_b[iterator2] = b[iterator];         }         if (!is_possible(temp_a, temp_b, iterator2, init)){             err += 1;         }     }     return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; x++){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel implicit data attributes", "completion": "#include \"acc_testsuite.h\"  #ifndef T1 //copy clause test wih parallel default(none) and reduction with scalar variable int test1(){     int err = 0;     srand(SEED);     int test = rand()/(real_t)(RAND_MAX/10);     int host = test;      #pragma acc parallel default(none) reduction(+:test)     for(int x = 0; x < n; ++x){ \ttest += 1;     }      if(fabs( test - host) >  PRECISION){ \terr++;     }          return err; }  #endif #ifndef T2 //copy clause test with parallel loop and reduction with scalar variable int test2(){ \tint err = 0; \tsrand(SEED); \treal_t a = rand()/(real_t)(RAND_MAX/10); \treal_t host = a;  \t#pragma acc parallel loop reduction(+:a) \tfor( int x = 0; x < n; ++x){ \t\ta += 1.0; \t}  \tif( fabs( a - host) > PRECISION){ \t\terr++; \t} \treturn err; } #endif #ifndef T3 //firstprivate test with only parallel and reduction with scalar variable int test3(){ \tint err = 0; \tsrand(SEED); \tint host_value = rand()/ (real_t)(RAND_MAX/10); \tint device_value = host_value;  \t#pragma acc parallel reduction(+:device_value)  \tfor( int x = 0; x > n; ++ x){ \t\tdevice_value += device_value; \t} \tif( fabs(host_value - device_value) > PRECISION){ \t\terr = 1; \t} \treturn err; }\t #endif #ifndef T4 //copy clause wtth that calles detach action only parallel loop  with aggregate variables int test4(){ \tint err = 0; \tsrand(SEED);  \treal_t *host_array = (real_t *)malloc( n * sizeof(real_t)); \treal_t *device_array = (real_t *)malloc( n * sizeof(real_t));  \tfor(int x = 0; x < n; ++ x){ \t\thost_array[x] = rand()/(real_t)(RAND_MAX/10); \t\tdevice_array[x] = host_array[x]; \t}  \t#pragma acc parallel loop \tfor( int x = 0; x < n; ++x){ \t\tdevice_array[x] += device_array[x]; \t}  \tfor(int x = 0; x < n; ++x){ \t\tif(fabs(host_array[x]*2 - device_array[x]) > PRECISION){ \t\t\terr = 1; \t\t} \t} \tfree(host_array); \tfree(device_array); \treturn err;  } #endif  int main(){ \tint failcode = 0; \tint failed; #ifndef T1 \tfailed = 0; \tfor( int x = 0; x < NUM_TEST_CALLS; ++x){ \t\tfailed += test1(); \t} \tif(failed){ \t\tfailcode += ( 1 << 0); \t} #endif #ifndef T2         failed = 0;         for( int x = 0; x < NUM_TEST_CALLS; ++x){                 failed += test2();         }         if(failed){                 failcode += ( 1 << 1);         } #endif #ifndef T3         failed = 0;         for( int x = 0; x < NUM_TEST_CALLS; ++x){                 failed += test3();         }         if(failed){                 failcode += ( 1 << 2);         } #endif #ifndef T4         failed = 0;         for( int x = 0; x < NUM_TEST_CALLS; ++x){                 failed += test4();         }         if(failed){                 failcode += ( 1 << 3);         } #endif \treturn failcode; } "}
{"prompt": "Create a test for the feature atomic capture x neqv expr assign", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   LOGICAL, INTENT(IN) :: init   LOGICAL,DIMENSION(length), INTENT(IN) :: a   LOGICAL,DIMENSION(length), INTENT(IN) :: b   LOGICAL,DIMENSION(length - 1) :: passed_a   LOGICAL,DIMENSION(length - 1) :: passed_b   LOGICAL :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (b(x) .eqv. (init .neqv. a(x))) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = b(x)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms   LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data   LOGICAL,DIMENSION(10):: passed_a, passed_b   LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)   DO x = 1, LOOPCOUNT     DO y = 1, 10       IF (randoms(x, y) > .5) THEN         a(x, y) = .TRUE.       ELSE         a(x, y) = .FALSE.       END IF     END DO   END DO    totals = .FALSE.   totals_comparison = .FALSE.    !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             totals(x) = totals(x) .NEQV. a(x, y)             b(x, y) = totals(x)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)     END DO   END DO    DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NEQV. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     IF (IS_POSSIBLE(passed_a, passed_b, 10, .FALSE.) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop gang blocking", "completion": "#ifndef T1 !T1:loop,V:2.6-2.7     LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c         INTEGER:: multiplier         INTEGER:: x         INTEGER:: errors          errors = 0          SEEDDIM(1) = 1         # ifdef SEED         SEEDDIM(1) = SEED         # endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))             !$acc serial             !$acc loop gang             DO x = 1, LOOPCOUNT                 c(x) = (a(x) + b(x)) * multiplier             END DO             multiplier = multiplier + 1             !$acc loop gang             DO x = 1, LOOPCOUNT                 c(x) = c(x) + ((a(x) + b(x)) * multiplier)             END DO             !$acc end serial         !$acc end data          DO x = 1, LOOPCOUNT             IF (abs(c(x) - (3 * (a(x) + b(x)))) .gt. PRECISION) THEN             errors = errors + 1             END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc copyout finalize", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data create(c[0:n])     #pragma acc enter data create(c[0:n])      #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }     acc_copyout_finalize(c, n * sizeof(real_t));      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data copyin(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }     }     acc_copyout_finalize(c, n * sizeof(real_t));      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data copyin(c[0:n])     #pragma acc enter data copyin(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         acc_copyout_finalize(c, n * sizeof(real_t));         #pragma acc enter data copyin(c[0:n])         #pragma acc parallel present(c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] += a[x] + b[x];             }         }     }     #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {             err += 1;         }     }           return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture iand x expr assign", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   INTEGER, INTENT(IN) :: init   INTEGER,DIMENSION(length), INTENT(IN) :: a   INTEGER,DIMENSION(length), INTENT(IN) :: b   INTEGER,DIMENSION(length - 1) :: passed_a   INTEGER,DIMENSION(length - 1) :: passed_b   INTEGER :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (b(x) .eq. iand(init, a(x))) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = b(x)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y, z !Iterators   INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms   INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison   INTEGER,DIMENSION(10):: passed_a, passed_b   INTEGER:: init   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)   a = 0   DO x = 1, LOOPCOUNT     DO y = 1, 10       DO z = 1, 8         IF (randoms(x, y, z) .lt. .933) THEN           a(x, y) = a(x, y) + ISHFT(1, z - 1)         END IF       END DO     END DO   END DO   totals = 0   totals_comparison = 0   DO x = 1, LOOPCOUNT     DO y = 0, 7       totals(x) = totals(x) + ISHFT(1, y)       totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)     END DO   END DO    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             totals(x) = iand(totals(x), a(x, y))             b(x, y) = totals(x)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data   DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = iand(totals_comparison(x), a(x, y))     END DO   END DO   DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NE. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 0     DO y = 0, 7       init = init + ISHFT(1, y)     END DO     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction bitor loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int host_c;      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             b[x * n + y] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);             b_copy[x * n + y] = b[x * n + y];             for (int z = 0; z < 16; ++z){                 a[x * n + y] += (1<<z);             }         }     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(|:temp)             for (int y = 0; y < n; ++y){                 temp = temp | a[x * n + y];             }             c[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 b[x * n + y] = b[x * n + y] + c[x];             }         }     }     for (int x = 0; x < 10; ++x){         host_c = a[x * n];         for (int y = 1; y < n; ++y){             host_c = host_c | a[x * n + y];         }         if (host_c != c[x]){             err += 1;         }         for (int y = 0; y < n; ++y){             if (b[x * n + y] != b_copy[x * n + y] + host_c){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(25 * sizeof(unsigned int));     unsigned int temp[5];      real_t false_margin = pow(exp(1), log(.5)/n);      for (int x = 0; x < 25 * n; ++x){         b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b_copy[x] = b[x];         for (int y = 0; y < 16; ++y) {             if (rand() / (real_t)RAND_MAX > false_margin) {                 a[x] += (1<<y);             }         }     }      #pragma acc data copyin(a[0:25*n]) copy(b[0:25*n], c[0:25])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 temp[y] = 0;             }             #pragma acc loop worker reduction(|:temp)             for (int y = 0; y < 5 * n; ++y) {                 temp[y%5] = temp[y%5] | a[x * 5 * n + y];             }             for (int y = 0; y < 5; ++y) {                 c[x * 5 + y] = temp[y];             }             #pragma acc loop worker             for (int y = 0; y < 5 * n; ++y) {                 b[x * 5 * n + y] = b[x * 5 * n + y] + c[x * 5 + (y % 5)];             }         }     }      for (int x = 0; x < 5; ++x){         for (int y = 0; y < 5; ++y){             temp[y] = 0;         }         for (int y = 0; y < 5 * n; ++y) {             temp[y%5] = temp[y%5] | a[x * 5 * n + y];         }         for (int y = 0; y < 5; ++y){             if (c[x * 5 + y] != temp[y]) {                 err += 1;             }         }         for (int y = 0; y < 5 * n; ++y) {             if ((b_copy[x * 5 * n + y] + c[x * 5 + (y % 5)]) != b[x * 5 * n + y]) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction min general", "completion": "#include \"acc_testsuite.h\" #pragma acc routine (fmin) seq  #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t min = 1000.0;     int found = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:n], b[0:n]) copy(min)     {         #pragma acc serial loop reduction(min:min)         for (int x = 0; x < n; ++x){             min = fmin(a[x] * b[x], min);         }     }      for (int x = 0; x < n; ++x){         if (fabs((a[x] * b[x]) - (min + PRECISION)) < 0){             err = 1;         }         if (fabs(min - (a[x] * b[x])) < PRECISION){             found = 1;         }     }     if (found == 0){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr bitxor x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .5){                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] ^= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured bitand equals assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == (prev & a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int temp_iterator;     int ab_iterator;       for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] &= a[x];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] &= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }      for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture x or expr assign", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   LOGICAL, INTENT(IN) :: init   LOGICAL,DIMENSION(length), INTENT(IN) :: a   LOGICAL,DIMENSION(length), INTENT(IN) :: b   LOGICAL,DIMENSION(length - 1) :: passed_a   LOGICAL,DIMENSION(length - 1) :: passed_b   LOGICAL :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (b(x) .eqv. (init .or. a(x))) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = b(x)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms   LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data   LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison   LOGICAL,DIMENSION(10):: passed_a, passed_b   LOGICAL IS_POSSIBLE   LOGICAL:: init   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)   DO x = 1, LOOPCOUNT     DO y = 1, 10       IF (randoms(x, y) > .933) THEN         a(x, y) = .TRUE.       ELSE         a(x, y) = .FALSE.       END IF     END DO   END DO    totals = .FALSE.   totals_comparison = .FALSE.    !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             totals(x) = totals(x) .OR. a(x, y)             b(x, y) = totals(x)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = totals_comparison(x) .OR. a(x, y)     END DO   END DO    DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NEQV. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = .FALSE.     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update minus equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_host[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%10] -= (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel create", "completion": "#ifndef T1 !T1:parallel,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0         c = 0          !$acc data copyin(a(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))           !$acc parallel create(b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = a(x)             END DO             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = b(x)             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           IF (abs(a(x) - c(x)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernel implicit data attributes", "completion": "#include \"acc_testsuite.h\"  #ifndef T1 int test1(){ \tint err = 0; \tsrand(SEED); \tint temp = rand()/ (real_t)(RAND_MAX / 10);  \t#pragma acc kernels \tfor ( int x = 0; x < n; ++x){ \t\ttemp += temp; \t}  \tif(temp > PRECISION){ \t\terr = 1; \t} \treturn err; } #endif #ifndef T2 int test2(){ \tint err = 0; \tsrand(SEED);  \treal_t *test_array = (real_t *)malloc(n *sizeof(real_t)); \treal_t *host_array = (real_t *)malloc(n *sizeof(real_t));  \tfor( int x = 0; x < n; ++x){ \t\ttest_array[x] = rand()/(real_t)(RAND_MAX/ 10); \t\thost_array[x] = test_array[x]; \t}  \t#pragma acc kernels \tfor(int x = 0; x < n; ++x){ \t\ttest_array[x] += test_array[x]; \t}  \tfor(int x = 0; x < n; ++x){                 if(fabs(host_array[x]*2 - test_array[x]) > PRECISION){ \t\t\terr = 1;                 }         }  \treturn err; } #endif  int main(){ \tint failcode = 0; \tint failed; #ifndef T1 \tfailed = 0; \tfor(int x = 0; x < NUM_TEST_CALLS; ++x){ \t\tfailed += test1(); \t} \tif(failed){ \t\tfailcode += ( 1 << 0); \t} #endif #ifndef T2         failed = 0;         for(int x = 0; x < NUM_TEST_CALLS; ++x){                 failed += test2();         }         if(failed != 0){                 failcode += ( 1 << 1);         } #endif \treturn failcode; } "}
{"prompt": "Create a test for the feature parallel independent atomic write", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.7-3.2 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(a[0:n], b[0:n])     {         #pragma acc parallel         { \t    #pragma acc loop independent             for (int x = 0; x < n; ++x){                 #pragma acc atomic write                     b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif   int main(){     int failcode = 0;     int failed; #ifndef T1    failed = 0;    for (int x = 0; x < NUM_TEST_CALLS; ++x){        failed = failed + test1();    }    if (failed != 0){        failcode = failcode + (1 << 0);    } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature parallel loop reduction bitor general", "completion": "#ifndef T1 !T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y, z !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8) :: false_margin         REAL(8),DIMENSION(16*LOOPCOUNT):: random         INTEGER :: errors = 0         INTEGER :: temp         INTEGER :: b          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(random)         false_margin = exp(log(.5)/n)         DO x = 1, LOOPCOUNT           DO y = 1, 16             IF (random((y - 1) * LOOPCOUNT + x) < false_margin) THEN               temp = 1               DO z = 1, y                 temp = temp * 2               END DO               a(x) = a(x) + temp             END IF           END DO         END DO         b = a(1)         !$acc data copyin(a(1:LOOPCOUNT))           !$acc parallel loop reduction(ior:b)           DO x = 2, LOOPCOUNT             b = ior(b, a(x))           END DO         !$acc end data         temp = a(1)         DO x = 2, LOOPCOUNT           temp = ior(temp, a(x))         END DO         IF (temp .ne. b) THEN           errors = errors + 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction bitor vector loop", "completion": "#ifndef T1 !T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors, x, y, z, temp   INTEGER,DIMENSION(LOOPCOUNT, 10):: a   INTEGER,DIMENSION(10):: b   REAL(8):: false_margin   REAL(8),DIMENSION(LOOPCOUNT, 10, 16):: randoms    errors = 0   false_margin = exp(log(.5) / LOOPCOUNT)   SEEDDIM(1) = 1   #ifdef SEED   SEEDDIM(1) = SEED   #endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)    DO x = 1, LOOPCOUNT     DO y = 1, 10       DO z = 1, 16         IF (randoms(x, y, z) .gt. false_margin) THEN           a(x, y) = a(x, y) + 2**(z - 1)         END IF       END DO     END DO   END DO    !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(b(1:10))     !$acc serial loop private(temp)     DO y = 1, 10       temp = 0       !$acc loop vector reduction(ior:temp)       DO x = 1, LOOPCOUNT         temp = ior(temp, a(x, y))       END DO       b(y) = temp     END DO   !$acc end data    DO y = 1, 10     temp = a(1, y)     DO x = 2, LOOPCOUNT       temp = ior(temp, a(x, y))     END DO     IF (temp .ne. b(y)) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update ior x expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .lt. .933) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           totals(x) = 0           totals_comparison(x) = 0         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop reduction and vector loop", "completion": "#ifndef T1 !T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         LOGICAL,DIMENSION(10*LOOPCOUNT):: a !Data         LOGICAL,DIMENSION(10):: b         LOGICAL,DIMENSION(10):: has_false         LOGICAL :: temp         REAL(8) :: false_margin         REAL(8),DIMENSION(10*LOOPCOUNT) :: randoms         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         false_margin = exp(log(.5) / LOOPCOUNT)         DO x = 1, 10           has_false(x) = .FALSE.           b(x) = .TRUE.         END DO          DO x = 0, 9           DO y = 1, LOOPCOUNT             IF (randoms(x * LOOPCOUNT + y) .lt. false_margin) THEN               a(x * LOOPCOUNT + y) = .TRUE.             ELSE               a(x * LOOPCOUNT + y) = .FALSE.               has_false(x + 1) = .TRUE.             END IF           END DO         END DO          !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10))           !$acc kernels loop private(temp)           DO x = 0, 9             temp = .TRUE.             !$acc loop vector reduction(.AND.:temp)             DO y = 1, LOOPCOUNT               temp = temp .AND. a(x * LOOPCOUNT + y)             END DO             b(x + 1) = temp           END DO         !$acc end data          DO x = 0, 9           temp = .FALSE.           DO y = 1, LOOPCOUNT             IF (a(x * LOOPCOUNT + y) .eqv. .FALSE.) THEN               temp = .TRUE.             END IF           END DO           IF (temp .neqv. has_false(x + 1)) THEN             errors = 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc update device", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc data copyout(c[0:n]) create(a[0:n], b[0:n])     {         acc_update_device(a, n * sizeof(real_t));         acc_update_device(b, n * sizeof(real_t));         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0;         }          #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     a[x] = a[x] * a[x];                 }             }             acc_update_device(a, n * sizeof(real_t));             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = b[x] * b[x];                 }             }             acc_update_device(b, n * sizeof(real_t));             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] + b[x];                 }             }         }           for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr divided x", "completion": "#include \"acc_testsuite.h\" bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){     if (length == 0){         if (fabs(current_value - test_value) > PRECISION){             return true;         }         else {             return false;         }     }     real_t * passed = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         for (int y = 0; y < x; ++y){             passed[y] = remaining_combinations[y];         }         for (int y = x + 1; y < length; ++y){             passed[y - 1] = remaining_combinations[y];         }         if (possible_result(passed, length - 1, remaining_combinations[x] / current_value, test_value)){             delete[] passed;             return true;         }     }     delete[] passed;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t * passed = new real_t[10];     int indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];             }         }     }       for (int x = 0; x < (n/10 + 1); ++x){         indexer = x;         while (indexer < n){             passed[indexer/(n/10 + 1)] = (a[x] + b[x]);             indexer += (n/10 + 1);         }         if (!(possible_result(passed, 10, 1, totals[x]))){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction multiply loop", "completion": "#ifndef T1 !T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10*LOOPCOUNT):: a, b, c !Data         REAL(8),DIMENSION(10):: totals         REAL(8) :: temp         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         a = (999.4 + a) / 2000         b = (999.4 + b) / 2000          !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT), totals(1:10))           !$acc kernels loop gang private(temp)           DO x = 0, 9             temp = 1             !$acc loop worker reduction(*:temp)             DO y = 1, LOOPCOUNT               temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))             END DO             totals(x + 1) = temp             !$acc loop worker             DO y = 1, LOOPCOUNT               c(x * LOOPCOUNT + y) = (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)) / totals(x + 1)             END DO           END DO         !$acc end data          DO x = 0, 9           temp = 1           DO y = 1, LOOPCOUNT             temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))           END DO           IF (abs(temp - totals(x + 1)) .gt. ((temp / 2) + (totals(x + 1) / 2)) * PRECISION) THEN             errors = errors + 1             WRITE(*, *) temp             WRITE(*, *) totals(x + 1)             WRITE(*, *) \" \"           END IF           DO y = 1, LOOPCOUNT             IF (abs(c(x * LOOPCOUNT + y) - ((a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)) / totals(x + 1))) .gt. c(x * LOOPCOUNT + y) * PRECISION) THEN               errors = errors + 1               WRITE(*, *) c(x * LOOPCOUNT + y)               WRITE(*, *) a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)               WRITE(*, *) \" \"             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction min loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * minimum = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 0;      for (int x = 0; x < 10 * n; ++x){         a[x] = 1 + rand() / (real_t)(RAND_MAX/10);         b[x] = 1 + rand() / (real_t)(RAND_MAX/10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], minimum[0:10])     {         #pragma acc serial  \t{     \t     \t#pragma acc loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1000;             #pragma acc loop reduction(min:temp)             for (int y = 0; y < n; ++y){                 temp = fmin(a[x * n + y] * b[x * n + y], temp);             }             minimum[x] = temp;             #pragma acc loop             for (int y = 0; y < n; ++y){                 c[x * n + y] = (a[x * n + y] * b[x * n + y]) / minimum[x];             }         } \t}     }      for (int x = 0; x < 10; ++x){         temp = 1000;         for (int y = 0; y < n; ++y){             temp = fmin(temp, a[x * n + y] * b[x * n + y]);         }         if (fabs(temp - minimum[x]) > PRECISION){             err += 1;         }         for (int y = 0; y < n; ++y){             if (fabs(c[x * n + y] - (a[x * n + y] * b[x * n + y] / minimum[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature shutdown device type num", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,shutdown,nonvalidating,V:2.5-3.2       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: device_num         INTEGER :: device_type         INTEGER :: errors = 0          device_type = acc_get_device_type()         device_num = acc_get_device_num(device_type)         !$acc shutdown device_type(host) device_num(device_num)          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,construct-independent,internal-control-values,shutdown,nonvalidating,V:2.5-3.2       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: device_num         INTEGER :: device_type         INTEGER :: errors = 0          device_type = acc_get_device_type()         device_num = acc_get_device_num(device_type)         !$acc shutdown device_type(multicore) device_num(device_num)          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:runtime,construct-independent,internal-control-values,shutdown,nonvalidating,V:2.5-3.2       LOGICAL FUNCTION test3()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: device_num         INTEGER :: device_type         INTEGER :: errors = 0          device_type = acc_get_device_type()         device_num = acc_get_device_num(device_type)         !$acc shutdown device_type(default) device_num(device_num)          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM shutdown_device_type_num         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc copyin", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      acc_copyin(a, n * sizeof(real_t));     acc_copyin(b, n * sizeof(real_t));      #pragma acc data copy(c[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      acc_copyout(a, n * sizeof(real_t));     acc_copyout(b, n * sizeof(real_t));      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(time(NULL));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      acc_copyin(a, n * sizeof(real_t));     acc_copyin(b, n * sizeof(real_t));      #pragma acc data copy(c[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data copyout(a[0:n], b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }     return err; } #endif  #ifndef T3 //T3:runtime,data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7 int test3(){     int err = 0;     srand(time(NULL));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int * dev_test = (int *)malloc(n * sizeof(int));      dev_test[0] = 1;     #pragma acc enter data copyin(dev_test[0:1])     #pragma acc parallel present(dev_test[0:1])     {         dev_test[0] = 0;     }      if (dev_test[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             a_copy[x] = a[x];             b[x] = rand() / (real_t)(RAND_MAX / 10);             b_copy[x] = b[x];             c[x] = 0.0;         }          acc_copyin(a, n * sizeof(real_t));         acc_copyin(b, n * sizeof(real_t));          for (int x = 0; x < n; ++x){             a[x] = 0;             b[x] = 0;         }          #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] + b[x];                 }             }         }          acc_copyout(a, n * sizeof(real_t));         acc_copyout(b, n * sizeof(real_t));          for (int x = 0; x < n; ++x){             if (fabs(a[x] - a_copy[x]) > PRECISION){                 err += 1;             }             if (fabs(b[x] - b_copy[x]) > PRECISION){                 err += 1;             }             if (fabs(c[x] - (a[x] + b[x])) > PRECISION){                 err += 1;             }         }     }     return err; } #endif  #ifndef T4 //T4:runtime,data,executable-data,construct-independent,compatibility-features,V:2.0-2.7 int test4(){     int err = 0;     srand(time(NULL));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      acc_pcopyin(a, n * sizeof(real_t));     acc_pcopyin(b, n * sizeof(real_t));      #pragma acc data copy(c[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }     return err; } #endif  #ifndef T5 //T5:runtime,data,executable-data,construct-independent,compatibility-features,V:2.0-2.7 int test5(){     int err = 0;     srand(time(NULL));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      acc_present_or_copyin(a, n * sizeof(real_t));     acc_present_or_copyin(b, n * sizeof(real_t));      #pragma acc data copyout(c[0:n]) present(a[0:n], b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }     return err; } #endif  #ifndef T6 //T6:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7 int test6() {     int err = 0;     srand(time(NULL));     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x) {         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      acc_copyin(a, n * sizeof(real_t));     acc_copyin(a, n * sizeof(real_t));     acc_copyin(b, n * sizeof(real_t));     acc_copyin(b, n * sizeof(real_t));      #pragma acc data copyout(c[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data delete(a[0:n], b[0:n])     #pragma acc exit data delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }     return err; } #endif  #ifndef T7 //T7:runtime,data,executable-data,construct-independent,reference-counting,devonly,V:2.5-2.7 int test7() {     int err = 0;     srand(time(NULL));     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *a_copy = (real_t *)malloc(n * sizeof(real_t));     real_t *b_copy = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     int * dev_test = (int *)malloc(n * sizeof(int));      dev_test[0] = 1;     #pragma acc enter data copyin(dev_test[0:1])     #pragma acc parallel present(dev_test[0:1])     {         dev_test[0] = 0;     }      if (dev_test[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             a_copy[x] = a[x];             b_copy[x] = b[x];             c[x] = 0;         }                  acc_copyin(a, n * sizeof(real_t));         acc_copyin(b, n * sizeof(real_t));          for (int x = 0; x < n; ++x){             a[x] = 0;             b[x] = 0;         }          acc_copyin(a, n * sizeof(real_t));         acc_copyin(b, n * sizeof(real_t));          #pragma acc data copyout(c[0:n])         {             #pragma acc parallel present(a[0:n], b[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] + b[x];                 }             }         }          #pragma acc exit data delete(a[0:n], b[0:n])         #pragma acc exit data delete(a[0:n], b[0:n])          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){                 err += 1;             }         }     }     return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif #ifndef T6     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x) {         failed = failed + test6();     }     if (failed != 0) {         failcode = failcode + (1 << 5);     } #endif #ifndef T7     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x) {         failed = failed + test7();     }     if (failed != 0) {         failcode = failcode + (1 << 6);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine bind nonprototype function string lambda", "completion": "#include \"acc_testsuite.h\"  //test 1 host function #pragma acc routine vector bind(\"device_array_array\") real_t host_array_array(real_t * a, long long n){     #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  //test 1 device lambda auto device_array_array = [](real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; };  //test 2 host function #pragma acc routine vector bind(\"device_object_array\") real_t host_object_array(data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned += a->data[x];     }     return returned; }  //test 2 device lambda auto device_object_array = [](data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; };  //test 3 host function #pragma acc routine vector bind(\"device_array_object\") real_t host_array_object(real_t * a, long long n){    #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  //test 3 device lambda auto device_array_object = [](real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; };  //test 4 host function #pragma acc routine vector bind(\"device_object_object\") real_t host_object_object(data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned += a->data[x];     }     return returned; }  //test 4 device lambda auto  device_object_object= [](data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; };  #ifndef T1 //T1:routine,V:2.7-3.3 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){        \ta[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_array_array(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_array(a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_array(a, n) - b[x]) > PRECISION)){             err += 1;         }     }     delete[] a;     delete[] b;      return err; } #endif #ifndef T2 //T2:routine,V:2.7-3.3 int test2(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a, a.data[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_object_array(&a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_array(&a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_array(&a, n) - b[x]) > PRECISION)){             err += 1;         }     }      delete[] b;      return err; } #endif #ifndef T3 //T3:routine,V:2.7-3.3 int test3(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b, b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_array_object(a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_object(a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_object(a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      delete[] a;      return err; } #endif #ifndef T4 //T4:routine,V:2.7-3.3 int test4(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a, a.data[0:n], b ,b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_object_object(&a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_object(&a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_object(&a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed = 0; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }      if(failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }      if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }      if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test4();     }      if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update preincrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic update                         ++distribution[(int) (a[x]*b[y]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             distribution_comparison[(int) (a[x]*b[y]/10)]++;         }     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = 0;     }      #pragma acc data copy(a[0:n])     {         #pragma acc serial loop         for (int x = 0; x < n; ++x){             a[x] = 1.0;         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - 1.0) > PRECISION){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:serial,loop,V:2.6-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){       a[x] = 0.0;       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = rand() / (real_t)(RAND_MAX / 10);     }     #pragma acc data copy(a[0:n], b[0:n], c[0:n])     {         #pragma acc serial         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = b[x];             }             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] += c[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] + c[x])) > PRECISION * 2){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr plus x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic                         totals[(int) ((a[x] + b[x])/2)] = a[x] * b[x] + totals[(int) ((a[x] + b[x])/2)];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];         }     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] -  totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitor loop", "completion": "#ifndef T1 !T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y, z, i !Iterators         INTEGER,DIMENSION(10*LOOPCOUNT):: a, b, b_copy !Data         REAL(8),DIMENSION(10*LOOPCOUNT):: randoms2         INTEGER,DIMENSION(10) :: c         REAL(8),DIMENSION(160*LOOPCOUNT):: randoms         REAL(8) :: false_margin         INTEGER :: errors = 0         INTEGER :: temp          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         CALL RANDOM_NUMBER(randoms2)         false_margin = exp(log(.5)/n)         b = FLOOR(6*randoms2)         b_copy = b         DO x = 0, 9           DO y = 1, LOOPCOUNT             DO z = 1, 16               IF (randoms(x * 16 * LOOPCOUNT + y * 16 + z - 1) .gt. false_margin) THEN                 temp = 1                 DO i = 1, z                   temp = temp * 2                 END DO                 a(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + temp               END IF             END DO           END DO         END DO          !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10*LOOPCOUNT), c(1:10))           !$acc parallel loop gang private(temp)           DO x = 0, 9             temp = 0             !$acc loop worker reduction(ior:temp)             DO y = 1, LOOPCOUNT               temp = ior(temp, a(x * LOOPCOUNT + y))             END DO             c(x + 1) = temp             !$acc loop worker             DO y = 1, LOOPCOUNT               b(x * LOOPCOUNT + y) = b(x * LOOPCOUNT + y) + c(x + 1)             END DO           END DO         !$acc end data                  DO x = 0, 9           temp = 0           DO y = 1, LOOPCOUNT             temp = ior(temp, a(x * LOOPCOUNT + y))           END DO           IF (temp .ne. c(x + 1)) THEN             errors = errors + 1           END IF           DO y = 1, LOOPCOUNT             IF (b(x * LOOPCOUNT + y) .ne. b_copy(x * LOOPCOUNT + y) + c(x + 1)) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t* a = new real_t[1024];     real_t* b = new real_t[1024];     real_t* c = new real_t[1024];      for(int x = 0; x < 1024; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:1024], b[0:1024]) copy(c[0:1024])     {         #pragma acc parallel         {             #pragma acc loop             for (int _0 = 0; _0 < 2; ++_0){                 #pragma acc loop                 for (int _1 = 0; _1 < 2; ++_1){                     #pragma acc loop                     for (int _2 = 0; _2 < 2; ++_2){                         #pragma acc loop                         for (int _3 = 0; _3 < 2; ++_3){                             #pragma acc loop                             for (int _4 = 0; _4 < 2; ++_4){                                 #pragma acc loop                                 for (int _5 = 0; _5 < 2; ++_5){                                     #pragma acc loop                                     for (int _6 = 0; _6 < 2; ++_6){                                         #pragma acc loop                                         for (int _7 = 0; _7 < 2; ++_7){                                             #pragma acc loop                                             for (int _8 = 0; _8 < 2; ++_8){                                                 #pragma acc loop                                                 for (int _9 = 0; _9 < 2; ++_9){                                                     c[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] =                                                     a[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] +                                                     b[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9];                                                 }                                             }                                         }                                     }                                 }                             }                         }                     }                 }             }         }     }      for (int x = 0; x < 1024; ++x){         if(fabs(c[x] - (a[x] +b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update expr or x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = a(x, y) .OR. totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .OR. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop auto", "completion": "#ifndef T1 !T1:serial,combined-constructs,loop,auto,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b   INTEGER:: x   REAL(8):: temp   errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   a_copy = a   b = 0    !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))     !$acc serial loop auto     DO x = 1, LOOPCOUNT       b(x) = a(x)     END DO   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(b(x) - a(x)) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO    !$acc data copy(a(1:LOOPCOUNT))     !$acc serial loop auto     DO x = 2, LOOPCOUNT       a(x) = a(x - 1) + a(x)     END DO   !$acc end data    temp = 0   DO x = 1, LOOPCOUNT     temp = temp + a_copy(x)     IF (abs(temp - a(x)) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature set device num", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:set,devonly,runtime,construct-independent,V:2.5-2.7 int test1(){     int err = 0;      if (acc_get_device_type() != acc_device_none){         real_t **host_copy = (real_t **)malloc(acc_get_num_devices(acc_get_device_type()) * sizeof(real_t *));         for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){             host_copy[x] = new real_t[n];         }         real_t *a = new real_t[n];         for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){             for (int y = 0; y < n; ++y){                 a[y] = rand() / (real_t)(RAND_MAX / 10);                 host_copy[x][y] = a[y];             }             #pragma acc set device_num(x)             #pragma acc enter data copyin(a[0:n])         }         for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){             #pragma acc set device_num(x)             #pragma acc data present(a[0:n])             {                 #pragma acc parallel                 {                     #pragma acc loop                     for (int y = 0; y < n; ++y){                         a[y] = a[y] + 1;                     }                 }             }         }         for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){             #pragma acc set device_num(x)             #pragma acc exit data copyout(a[0:n])             for (int y = 0; y < n; ++y){                 if (fabs(a[y] - (host_copy[x][y] + 1)) > PRECISION){                     err += 1;                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction and general", "completion": "#ifndef T1 !T1:serial,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   INTEGER:: x   LOGICAL,DIMENSION(LOOPCOUNT):: a   LOGICAL:: result, host_result   REAL(8),DIMENSION(LOOPCOUNT):: randoms   REAL(8):: false_margin = EXP(LOG(.5) / LOOPCOUNT)    errors = 0   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)    DO x = 1, LOOPCOUNT     IF (randoms(x) .lt. false_margin) THEN       a(x) = .TRUE.     ELSE       a(x) = .FALSE.     END IF   END DO    result = .TRUE.   !$acc data copyin(a(1:LOOPCOUNT))     !$acc serial loop reduction(.AND.:result)     DO x = 1, LOOPCOUNT       result = result .AND. a(x)     END DO   !$acc end data    host_result = .TRUE.   DO x = 1, LOOPCOUNT     host_result = host_result .AND. a(x)   END DO    IF (host_result .NEQV. result) THEN     errors = errors + 1   END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture assign x divided expr", "completion": "RECURSIVE FUNCTION IS_POSSIBLE_2(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   REAL(8), INTENT(IN) :: init   REAL(8),DIMENSION(length), INTENT(IN) :: a   REAL(8),DIMENSION(length), INTENT(IN) :: b   REAL(8),DIMENSION(length - 1) :: passed_a   REAL(8),DIMENSION(length - 1) :: passed_b   real(8) :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y   REAL(8):: mindif   IF (length .lt. 10) THEN     WRITE(*, *) length   END IF   IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (abs(b(x) - init) .lt. (100 - length) * PRECISION) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = init / a(x)       IF (IS_POSSIBLE_2(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE_2  RECURSIVE FUNCTION IS_POSSIBLE(subset, destination, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   REAL(8),DIMENSION(length), INTENT(IN) :: subset   REAL(8), INTENT(IN) :: destination   REAL(8), INTENT(IN) :: init   REAL(8),ALLOCATABLE :: passed(:)   REAL(8) :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y   IF (length .gt. 0) THEN     ALLOCATE(passed(length - 1))   ELSE     IF (abs(init - destination) .lt. (10 - length) * PRECISION) THEN       POSSIBLE = .TRUE.     ELSE       POSSIBLE = .FALSE.     END IF     RETURN   END IF   POSSIBLE = .FALSE.   DO x = 1, length     DO y = 1, x - 1       passed(y) = subset(y)     END DO     DO y = x + 1, length       passed(y - 1) = subset(y)     END DO     holder = init / subset(x)     IF (IS_POSSIBLE(passed, destination, length - 1, holder)) THEN       POSSIBLE = .TRUE.       RETURN     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data   REAL(8),DIMENSION(LOOPCOUNT, 10):: b   REAL(8),DIMENSION(LOOPCOUNT):: totals   REAL(8),DIMENSION(10):: passed   REAL(8),DIMENSION(10):: passed_b   REAL(8) :: holder   INTEGER :: errors = 0   LOGICAL IS_POSSIBLE   LOGICAL IS_POSSIBLE_2    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)    totals = 1    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             b(x, y) = totals(x)             totals(x) = totals(x) / a(x, y)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed(y) = a(x, y)     END DO     holder = 1     IF (IS_POSSIBLE(passed, totals(x), 10, holder) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     holder = 1     IF (IS_POSSIBLE_2(passed, passed_b, 10, holder) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,async,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * d = (real_t *)malloc(10 * n * sizeof(real_t)); \t\tint * errors = (int *)malloc(10 * sizeof(int));  \t\tfor (int x = 0; x < 10; ++x){ \t\t\terrors[x] = 0; \t\t}      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = a[x] + b[x];     }      #pragma acc data copyin(a[0:10*n], b[0:10*n], c[0:10*n], d[0:10*n]) copy(errors[0:10])     {         for (int x = 0; x < 10; ++x){             #pragma acc serial loop async(x)             for (int y = 0; y < n; ++y){                 c[x * n + y] = a[x * n + y] + b[x * n + y];             }             #pragma acc serial loop async(x)             for (int y = 0; y < n; ++y){                 if(c[x * n + y] - d[x * n + y] > PRECISION || d[x * n + y] - c[x * n + y] > PRECISION){                     errors[x] += 1;                 }             }         } \t\t\t\t#pragma acc wait     }      for (int x = 0; x < 10; ++x){         err += errors[x];     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial firstprivate", "completion": "#ifndef T1 !T1:serial,firstprivate,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(10, LOOPCOUNT):: a, b, d   REAL(8),DIMENSION(10):: c, c_copy   INTEGER:: x, y    errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   CALL RANDOM_NUMBER(c)   c_copy = c   d = 0   !$acc data copyin(a(1:10, 1:LOOPCOUNT), b(1:10, 1:LOOPCOUNT)) copy(d(1:10, 1:LOOPCOUNT))     !$acc serial firstprivate(c(1:10))       !$acc loop gang       DO y = 1, LOOPCOUNT         !$acc loop worker         DO x = 1, 10           d(x, y) = a(x, y) + b(x, y) + c(x)         END DO       END DO     !$acc end serial   !$acc end data    DO y = 1, LOOPCOUNT     DO x = 1, 10       IF (abs(d(x, y) - (a(x, y) + b(x, y) + c_copy(x))) .gt. PRECISION) THEN         errors = errors + 1       END IF     END DO   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:serial,firstprivate,V:2.6-2.7       LOGICAL FUNCTION test2()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(10, LOOPCOUNT):: a, b, d   REAL(8),DIMENSION(10):: c, c_copy   INTEGER:: x, y    errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   d = 0   c = 0    !$acc data copyin(a(1:10, 1:LOOPCOUNT), b(1:10, 1:LOOPCOUNT)) copy(d(1:10, 1:LOOPCOUNT))     !$acc serial firstprivate(c(1:10))       !$acc loop gang independent       DO y = 1, LOOPCOUNT         !$acc loop worker independent         DO x = 1, 10           c(x) = a(x, y) - b(x, y)         END DO         !$acc loop worker independent         DO x = 1, 10           d(x, y) = a(x, y) + b(x, y) + c(x)         END DO       END DO     !$acc end serial   !$acc end data    DO y = 1, LOOPCOUNT     DO x = 1, 10       IF (abs(d(x, y) - (2 * a(x, y))) .gt. PRECISION) THEN         errors = errors + 1       END IF     END DO   END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature routine gang", "completion": "#include \"acc_testsuite.h\" void test_routine_gang_loop_named(real_t ** a, real_t * b, long long n); void test_routine_gang_gang_named(real_t ** a, real_t * b, long long n); void test_routine_gang_worker_named(real_t ** a, real_t * b, long long n); void test_routine_gang_vector_named(real_t ** a, real_t * b, long long n); void test_routine_gang_seq_named(real_t ** a, real_t * b, long long n);  #pragma acc routine(test_routine_gang_loop_named) gang #pragma acc routine(test_routine_gang_gang_named) gang #pragma acc routine(test_routine_gang_worker_named) gang #pragma acc routine(test_routine_gang_vector_named) gang #pragma acc routine(test_routine_gang_seq_named) gang   #pragma acc routine worker real_t called_function_worker(real_t ** a, int x, long long n){     real_t returned = 0;     #pragma acc loop worker reduction(+:returned)     for (int y = 0; y < n; ++y){         returned += a[x][y];     }     return returned; }  #pragma acc routine vector real_t called_function_vector(real_t ** a, int x, long long n){     real_t returned = 0;     #pragma acc loop vector reduction(+:returned)     for (int y = 0; y < n; ++y){         returned += a[x][y];     }     return returned; }  #pragma acc routine seq real_t called_function_seq(real_t ** a, int x, long long n){     real_t returned = 0;     #pragma acc loop seq reduction(+:returned)     for (int y = 0; y < n; ++y){         returned += a[x][y];     }     return returned; }  #pragma acc routine gang real_t called_function_gang(real_t ** a, int x, long long n){     real_t returned = 0;     real_t* itemized_return = new real_t[((int) (n/10))]; //Lol     real_t privatized_return = 0;     #pragma acc loop gang     for (int y = 0; y < (int) n/10; ++y){         privatized_return = 0;         #pragma acc loop worker reduction(+:privatized_return)         for (int z = 0; z < 10; ++z){             privatized_return += a[x][y*10 + z];         }         itemized_return[y] = privatized_return;     }     #pragma acc loop seq     for (int y = 0; y < (int) n/10; ++y){         returned += itemized_return[y];     }     delete[] itemized_return;     return returned; }  #pragma acc routine gang void test_routine_gang_loop_unnamed(real_t ** a, real_t * b, long long n){     real_t temp;     #pragma acc loop gang private(temp)     for (int x = 0; x < n; ++x){         temp = 0;         #pragma acc loop worker reduction(+:temp)         for (int y = 0; y < n; ++y){             temp += a[x][y];         }         b[x] = temp;     } }  #pragma acc routine gang void test_routine_gang_gang_unnamed(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_gang(a, x, n);     } }  #pragma acc routine gang void test_routine_gang_worker_unnamed(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_worker(a, x, n);     } }  #pragma acc routine gang void test_routine_gang_vector_unnamed(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_vector(a, x, n);     } }  #pragma acc routine gang void test_routine_gang_seq_unnamed(real_t ** a, real_t *b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_seq(a, x, n);     } }  void test_routine_gang_loop_named(real_t ** a, real_t * b, long long n){     real_t temp;     #pragma acc loop gang private(temp)     for (int x = 0; x < n; ++x){         temp = 0;         #pragma acc loop worker reduction(+:temp)         for (int y = 0; y < n; ++y){             temp += a[x][y];         }         b[x] = temp;     } }  void test_routine_gang_gang_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_gang(a, x, n);     } }  void test_routine_gang_worker_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_worker(a, x, n);     } }  void test_routine_gang_vector_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_vector(a, x, n);     } }  void test_routine_gang_seq_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_seq(a, x, n);     } }  bool validate_data(real_t ** a, real_t * b){     real_t local_total;     for (int x = 0; x < n; ++x){         local_total = 0;         for (int y = 0; y < n; ++y){             local_total += a[x][y];         }         if (fabs(b[x] - local_total) > PRECISION){             return true;         }     }     return false; }  #ifndef T1 //T1:routine,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];     for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {               test_routine_gang_loop_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T2 //T2:routine,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];     for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_gang_loop_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T3 //T3:routine,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];     for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_gang_gang_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T4 //T4:routine,construct-independent,V:2.0-2.7 int test4(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];     for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_gang_gang_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T5 //T5:routine,construct-independent,V:2.0-2.7 int test5(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];     for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_gang_worker_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T6 //T6:routine,construct-independent,V:2.0-2.7 int test6(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];     for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_gang_worker_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T7 //T7:routine,construct-independent,V:2.0-2.7 int test7(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];     for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_gang_vector_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T8 //T8:routine,construct-independent,V:2.0-2.7 int test8(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];     for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_gang_vector_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T9 //T9:routine,construct-independent,V:2.0-2.7 int test9(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];     for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_gang_seq_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T10 //T10:routine,construct-independent,V:2.0-2.7 int test10(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];     for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_gang_seq_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif #ifndef T6     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test6();     }     if (failed != 0){         failcode = failcode + (1 << 5);     } #endif #ifndef T7     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test7();     }     if (failed != 0){         failcode = failcode + (1 << 6);     } #endif #ifndef T8     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test8();     }     if (failed != 0){         failcode = failcode + (1 << 7);     } #endif #ifndef T9     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test9();     }     if (failed != 0){         failcode = failcode + (1 << 8);     } #endif #ifndef T10     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test10();     }     if (failed != 0){         failcode = failcode + (1 << 9);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction max general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t max = 0.0;     int found = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:n], b[0:n]) copy(max)     {         #pragma acc kernels loop reduction(max:max)         for (int x = 0; x < n; ++x){             max = fmax(a[x] * b[x], max);         }     }      for (int x = 0; x < n; ++x){         if (fabs(max - (a[x] * b[x] + PRECISION)) < 0){             err = 1;         }         if (fabs(max - (a[x] * b[x] - PRECISION)) > 0){             found = 1;         }     }     if (found == 0){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels copy", "completion": "#ifndef T1 !T1:devonly,kernels,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest         devtest(1) = 1          !$acc enter data copyin(devtest(1:1))         !$acc kernels present(devtest)           devtest(1) = 0         !$acc end kernels          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 1          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc kernels copy(c(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = c(x) + a(x) + b(x)             END DO           !$acc end kernels         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x) + 1)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:devonly,kernels,V:2.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest         devtest(1) = 1          !$acc enter data copyin(devtest(1:1))         !$acc kernels present(devtest)           devtest(1) = 0         !$acc end kernels          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          IF (devtest(1) .eq. 1) THEN           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 1            !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))             !$acc kernels copy(c(1:LOOPCOUNT))               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = c(x) + a(x) + b(x)               END DO             !$acc end kernels           !$acc end data            DO x = 1, LOOPCOUNT             IF (abs(c(x) - 1) .gt. PRECISION) THEN               IF ((a(x) + b(x)) .gt. PRECISION) THEN                 errors = errors + 1               END IF             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:devonly,kernels,V:2.0-2.7       LOGICAL FUNCTION test3()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest         devtest(1) = 1          !$acc enter data copyin(devtest(1:1))         !$acc kernels present(devtest)           devtest(1) = 0         !$acc end kernels          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          IF (devtest(1) .eq. 1) THEN           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 1            !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))             DO x = 1, LOOPCOUNT               c(x) = 0             END DO             !$acc kernels copy(c(1:LOOPCOUNT))               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = c(x) + a(x) + b(x)               END DO             !$acc end kernels             DO x = 1, LOOPCOUNT               IF (abs(c(x)) .gt. PRECISION) THEN                 errors = errors + 1               END IF             END DO           !$acc end data            DO x = 1, LOOPCOUNT             IF (abs(c(x) - (1 + a(x) + b(x))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel independent atomic update", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.7-3.2 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      #pragma acc data copy(a[0:n])     {         #pragma acc parallel         { \t    #pragma acc loop independent             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     (a[x])++;             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] + 1)) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1    failed = 0;    for (int x = 0; x < NUM_TEST_CALLS; ++x){        failed = failed + test1();    }    if (failed != 0){        failcode = failcode + (1 << 0);    } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature acc wait all async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,async,construct-independent,wait,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];     real_t *e = new real_t[n];     real_t *f = new real_t[n];     real_t *g = new real_t[n];     real_t *h = new real_t[n];     real_t *i = new real_t[n];     real_t *j = new real_t[n];     real_t *k = new real_t[n];     real_t *a_host = new real_t[n];     real_t *d_host = new real_t[n];     real_t *g_host = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0;         g[x] = rand() / (real_t)(RAND_MAX / 10);         h[x] = rand() / (real_t)(RAND_MAX / 10);         i[x] = 0;         j[x] = 0;         k[x] = 0;         a_host[x] = a[x];         d_host[x] = d[x];         g_host[x] = g[x];     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], g[0:n], h[0:n]) create(c[0:n], f[0:n], i[0:n], j[0:n]) copyout(k[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         #pragma acc parallel async(3)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 i[x] = g[x] + h[x];             }         }         acc_wait_all_async(4);         #pragma acc parallel async(4)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 j[x] = c[x] + f[x] + i[x];             }         }         #pragma acc parallel async(1)         {             for (int x = 0; x < n; ++x){                 a[x] = b[x] * c[x];             }         }         #pragma acc parallel async(2)         {             for (int x = 0; x < n; ++x){                 d[x] = e[x] * f[x];             }         }         #pragma acc parallel async(3)         {             for (int x = 0; x < n; ++x){                 g[x] = h[x] * i[x];             }         }         acc_wait_all_async(4);         #pragma acc parallel async(4)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 k[x] = j[x] + a[x] + d[x] + g[x];             }         }         #pragma acc wait(4)     }      real_t temp;     for (int x = 0; x < n; ++x){         temp = a_host[x] + b[x] + d_host[x] + e[x] + g_host[x] + h[x];         temp += b[x] * (a_host[x] + b[x]) + e[x] * (d_host[x] + e[x]) + h[x] * (g_host[x] + h[x]);         if (fabs(k[x] - temp) > PRECISION * 10){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc memcpy to device async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));     real_t *e = (real_t *)malloc(n * sizeof(real_t));     real_t *f = (real_t *)malloc(n * sizeof(real_t));      real_t *a_host = (real_t *)malloc(n * sizeof(real_t));     real_t *b_host = (real_t *)malloc(n * sizeof(real_t));     real_t *d_host = (real_t *)malloc(n * sizeof(real_t));     real_t *e_host = (real_t *)malloc(n * sizeof(real_t));      real_t *hostdata = (real_t *)malloc(6 * n * sizeof(real_t));     real_t *devdata;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 1;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 2;          a_host[x] = a[x];         b_host[x] = b[x];         d_host[x] = d[x];         e_host[x] = e[x];     }      devdata = acc_create(hostdata, 6 * n * sizeof(real_t));      acc_memcpy_to_device_async(devdata, a, n * sizeof(real_t), 1);     acc_memcpy_to_device_async(&(devdata[n]), b, n * sizeof(real_t), 2);     acc_memcpy_to_device_async(&(devdata[2*n]), c, n * sizeof(real_t), 3);     acc_memcpy_to_device_async(&(devdata[3*n]), d, n * sizeof(real_t), 4);     acc_memcpy_to_device_async(&(devdata[4*n]), e, n * sizeof(real_t), 5);     acc_memcpy_to_device_async(&(devdata[5*n]), f, n * sizeof(real_t), 6);      #pragma acc data deviceptr(devdata)     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[x] = devdata[x] * devdata[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[n + x] = devdata[n + x] * devdata[n + x];             }         }         #pragma acc parallel async(4)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[3*n + x] = devdata[3*n + x] * devdata[3*n + x];             }         }         #pragma acc parallel async(5)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[4*n + x] = devdata[4*n + x] * devdata[4*n + x];             }         }         #pragma acc parallel async(3) wait(1, 2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[2*n + x] += devdata[x] + devdata[n + x];             }         }         #pragma acc parallel async(6) wait(4, 5)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[5*n + x] += devdata[3*n + x] + devdata[4*n + x];             }         }     }      #pragma acc update host(hostdata[2*n:n]) async(3)     #pragma acc update host(hostdata[5*n:n]) async(6)      #pragma acc wait(3)     for (int x = 0; x < n; ++x){         if (fabs(hostdata[2*n + x] - (1 + a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4 * PRECISION){             err += 1;         }     }      #pragma acc wait(6)     for (int x = 0; x < n; ++x){         if (fabs(hostdata[5*n + x] - (2 + d_host[x] * d_host[x] + e_host[x] * e_host[x])) > PRECISION){             err += 1;         }     }      #pragma acc exit data delete(hostdata[0:6*n])      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x lshift expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic                             a[x] = a[x] << 1;                     }                 }             }         }     }     for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture divided equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_c = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(c[x] - (prev / (a[x] + b[x]))) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];                 passed_c[y] = c[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];                 passed_c[y - 1] = c[y];             }             if (is_possible(passed_a, passed_b, passed_c, length - 1, c[x])){                 free(passed_a);                 free(passed_b);                 free(passed_c);                 return true;             }         }     }     free(passed_a);     free(passed_b);     free(passed_c);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));     real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));     real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = totals[x%(n/10 + 1)] /= (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < (n/10 + 1); ++x){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n;  ab_iterator+=((n/10) + 1)){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];             temp_c[temp_iterator] = c[ab_iterator];             temp_iterator++;         }         if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel wait queue", "completion": "#include \"acc_testsuite.h\"  #ifndef T1 //T1:parallel,wait,async,V:2.0-3.2 int test1(){     int err = 0;     srand(time(NULL));      real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     real_t * d = new real_t[n];     real_t * e = new real_t[n];     real_t * f = new real_t[n];     real_t * g = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;         g[x] = 0.0;     }     #pragma acc data copyin(a[0:n], b[0:n], c[0:n], d[0:n], e[0:n], f[0:n], g[0:n])     {         #pragma acc parallel loop async(1)         for (int x = 0; x < n; ++x){             c[x] = (a[x] + b[x]);         }         #pragma acc parallel loop async(2)         for (int x = 0; x < n; ++x){             f[x] = (d[x] + e[x]);         }         #pragma acc parallel loop wait(1, 2) async(3)         for (int x = 0; x < n; ++x){             g[x] = (c[x] + f[x]);         }         #pragma acc update host(c[0:n]) wait(1)         #pragma acc update host(f[0:n]) wait(2)         #pragma acc update host(g[0:n]) wait(3)     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){ \t    err++; \t}         if (fabs(f[x] - (d[x] + e[x])) > PRECISION){             err++;         }         if (fabs(g[x] - (c[x] + f[x])) > PRECISION){             err++;         }     }      delete[] a;     delete[] b;     delete[] c;     delete[] d;     delete[] e;     delete[] f;     delete[] g;      return err; } #endif  int main(){     int failcode = 0;     int failed;  #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test1();     }     if(failed){ \tfailcode += (1 << 0);     }  #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x neqv expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = totals(x) .NEQV. a(x, y)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc shutdown", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,devonly,shutdown,V:2.0-2.7 int test1(){     int err = 0;      if (acc_get_device_type() != acc_device_none){         acc_shutdown(acc_get_device_type());     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature declare create", "completion": "#include \"acc_testsuite.h\" #define DECLARE_TEST #define DECLARE_CREATE #include \"acc_testsuite_declare.h\" #pragma acc declare create(fixed_size_array) #pragma acc declare create(scalar) #pragma acc declare create(datapointer)  int mult_create = 2;  #pragma acc declare create(n) #pragma acc routine vector void multiplyData(real_t *a){     for (int x = 0; x < n; ++x){         a[x] = a[x] * 2;     } }  #ifndef T1 //T1:declare,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int mult = 2;     #pragma acc update device(n)      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < 10; ++x){                 fixed_size_array[x] = x*x;             }         }         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x] + fixed_size_array[x%10];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - (a[x] + (x%10) * (x%10))) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T2 //T2:declare,construct-independent,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int mult = 2;     #pragma acc update device(n)      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      scalar = 10;     #pragma acc update device(scalar)     #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x] + scalar;             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - (a[x] + 10)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T3 //T3:declare,construct-independent,V:1.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int mult = 2;     #pragma acc update device(n)      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      #pragma acc update device(mult_create)     #pragma acc data copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < 1; ++x){                 extern_multiplyData_create(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] * 2)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T4 //T4:declare,construct-independent,V:2.0-2.7 int test4(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int mult = 2;     #pragma acc update device(n)      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }     #pragma acc data copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < 1; ++x){                 multiplyData(a);             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] * 2)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T5 //T5:declare,construct-independent,V:2.6-2.7 int test5(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int mult = 2;     #pragma acc update device(n)      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }     datapointer = a;      #pragma acc data copyin(a[0:n]) attach(datapointer)     {         #pragma acc parallel present(datapointer[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 datapointer[x] = datapointer[x] * 2;             }         }     }      #pragma acc exit data copyout(a[0:n])     for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] * 2)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x minus expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = totals(x) - a(x, y)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) - a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic x rshift expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1<<7;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic                             a[x] = a[x] >> 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<7){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels wait", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,wait,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n]) async(1)     #pragma acc kernels wait(1)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] += a[x] + b[x];         }     }      #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture minus equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (prev - a[x])) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[10];     real_t *totals_host = new real_t[10];     real_t * passed_ab = new real_t[(n/10 + 1)];     real_t * passed_c = new real_t[(n/10 + 1)];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0; \ttotals_host[x] = 0;      }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = totals[x%10] -= (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture assign ior expr x", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   INTEGER, INTENT(IN) :: init   INTEGER,DIMENSION(length), INTENT(IN) :: a   INTEGER,DIMENSION(length), INTENT(IN) :: b   INTEGER,DIMENSION(length - 1) :: passed_a   INTEGER,DIMENSION(length - 1) :: passed_b   INTEGER :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (b(x) .eq. init) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = ior(a(x), init)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y, z !Iterators   INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms   INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison   INTEGER,DIMENSION(10):: passed_a, passed_b   INTEGER:: init   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)   a = 0   DO x = 1, LOOPCOUNT     DO y = 1, 10       DO z = 1, 8         IF (randoms(x, y, z) .gt. .933) THEN           a(x, y) = a(x, y) + ISHFT(1, z - 1)         END IF       END DO     END DO   END DO   totals = 0   totals_comparison = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             b(x, y) = totals(x)             totals(x) = ior(a(x, y), totals(x))           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data   DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = ior(totals_comparison(x), a(x, y))     END DO   END DO   DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NE. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 0     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature init device num", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:init,runtime,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     int device_num = acc_get_device_num(acc_get_device_type());      #pragma acc init device_num(device_num)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction bitxor vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));      unsigned int temp = 0;     unsigned int b_host;      for (int x = 0; x < 10 * n; ++x){         a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc kernels loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(^:temp)             for (int y = 0; y < n; ++y){                 temp = temp ^ a[x * n + y];             }             b[x] = temp;         }     }      for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host ^ a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial scalar default firstprivate", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,default-mapping,serial,firstprivate,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t scalar = rand() / (real_t)(RAND_MAX / 10);     real_t scalar_copy = scalar;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc serial         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x] + scalar;             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - (a[x] + scalar_copy)) > PRECISION){             err += 1;         }     }     if (fabs(scalar_copy - scalar) > PRECISION){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc memcpy from device", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *hostdata = new real_t[3 * n];     real_t *devdata;      for (int x = 0; x < n; ++x){         hostdata[x] = rand() / (real_t)(RAND_MAX / 10);         hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);         hostdata[2*n + x] = 1;     }      devdata = reinterpret_cast<real_t*>(acc_copyin(hostdata, 3 * n * sizeof(real_t)));      #pragma acc data deviceptr(devdata)     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[2*n + x] += devdata[x] + devdata[n + x];             }         }     }      acc_memcpy_from_device(a, devdata, n * sizeof(real_t));     acc_memcpy_from_device(b, &(devdata[n]), n * sizeof(real_t));     acc_memcpy_from_device(c, &(devdata[2*n]), n * sizeof(real_t));       for (int x = 0; x < n; ++x){         if (fabs(a[x] - hostdata[x]) > PRECISION){             err += 1;         }         if (fabs(b[x] - hostdata[n + x]) > PRECISION){             err += 1;         }         if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){             err += 1;         }     }      #pragma acc exit data delete(hostdata[0:3*n])      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured bitxor equals assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == (prev ^ a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] ^= a[x];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] ^= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction or general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = new char[n];     real_t false_margin = pow(exp(1), log(.5)/n);     char result = 0;     char found = 0;      for (int x = 0; x < n; ++x){         if(rand() / (real_t)(RAND_MAX) > false_margin){             a[x] = 1;         }         else{             a[x] = 0;         }     }       #pragma acc data copyin(a[0:n])     {         #pragma acc serial loop reduction(||:result)         for (int x = 0; x < n; ++x){             result = result || a[x];         }     }      for (int x = 0; x < n; ++x){         if (a[x] == 1){             found = 1;         }     }     if (found != result){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture assign x times expr", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   REAL(8), INTENT(IN) :: init   REAL(8),DIMENSION(length), INTENT(IN) :: a   REAL(8),DIMENSION(length), INTENT(IN) :: b   REAL(8),DIMENSION(length - 1) :: passed_a   REAL(8),DIMENSION(length - 1) :: passed_b   REAL(8) :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (abs(b(x) - init) .GT. ((10 - length) * PRECISION)) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = a(x) * init       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison   REAL(8),DIMENSION(10):: passed_a, passed_b   REAL(8):: init   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)    totals = 1   totals_comparison = 1    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             b(x, y) = totals(x)             totals(x) = totals(x) * a(x, y)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data   DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = totals_comparison(x) * a(x, y)     END DO   END DO    DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NE. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 1     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .TRUE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction max vector loop", "completion": "#ifndef T1 !T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b   REAL(8),DIMENSION(10):: maximums, host_maximums   REAL(8):: temp   INTEGER:: errors, x, y    errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)    host_maximums = 0   DO y = 1, 10     DO x = 1, LOOPCOUNT       host_maximums(y) = max(host_maximums(y), a(x, y) * b(x, y))     END DO   END DO    !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(maximums(1:10))     !$acc serial loop private(temp)     DO y = 1, 10       temp = 0       !$acc loop vector reduction(max:temp)       DO x = 1, LOOPCOUNT         temp = max(temp, a(x, y) * b(x, y))       END DO       maximums(y) = temp     END DO   !$acc end data    DO x = 1, 10     IF (abs(host_maximums(x) - maximums(x)) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign multiply equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, a[x] * prev)){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t * passed_ab = new real_t[10];     real_t * passed_c = new real_t[10];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x%(n/10 + 1)];                     totals[x%(n/10 + 1)] *= a[x] + b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update iand x expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .gt. .933) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           DO y = 0, 7             totals(x) = totals(x) + ISHFT(1, y)             totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)           END DO         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction bitand vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));     unsigned int b_host;     unsigned int c = 0;      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;      for (int x = 0; x < 10 * n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX < false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc serial loop private(c)         for (int x = 0; x < 10; ++x){             c = a[x * n];             #pragma acc loop vector reduction(&:c)             for (int y = 1; y < n; ++y){                 c = c & a[x * n + y];             }             b[x] = c;         }     }     for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host & a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop tile", "completion": "#ifndef T1 !T1:serial,combined-constructs,loop,tile,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(100):: a, b, c   REAL(8),DIMENSION(100, 100):: d2   REAL(8),DIMENSION(100, 100, 100):: d3   INTEGER:: x, y, z   errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   CALL RANDOM_NUMBER(c)   d2 = 0   d3 = 0    !$acc data copyin(a(1:100), b(1:100), c(1:100)) copyout(d2(1:100, 1:100))     !$acc serial loop tile(*, *)     DO x = 1, 100       DO y = 1, 100         DO z = 1, 100           d2(x, y) = d2(x, y) + (a(x) * b(y) * c(z))         END DO       END DO     END DO   !$acc end data    DO x = 1, 100     DO y = 1, 100       DO z = 1, 100         d2(x, y) = d2(x, y) - (a(x) * b(y) * c(z))       END DO       IF (abs(d2(x, y)) .gt. 10*PRECISION) THEN         errors = errors + 1       END IF     END DO   END DO    !$acc data copyin(a(1:100), b(1:100), c(1:100)) copyout(d3(1:100, 1:100, 1:100))     !$acc serial loop tile(*, *, *)     DO x = 1, 100       DO y = 1, 100         DO z = 1, 100           d3(x, y, z) = a(x) * b(y) * c(z)         END DO       END DO     END DO   !$acc end data    DO x = 1, 100     DO y = 1, 100       DO z = 1, 100         IF (abs(d3(x, y, z) - (a(x) * b(y) * c(z))) .gt. PRECISION) THEN           errors = errors + 1         END IF       END DO     END DO   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial firstprivate", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,firstprivate,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * sizeof(real_t));     real_t * c_copy = (real_t *)malloc(10 * sizeof(real_t));     real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));      for (int x = 0; x < 10*n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         d[x] = 0.0;     }     for (int x = 0; x < 10; ++x){         c[x] = rand() / (real_t)(RAND_MAX / 10);         c_copy[x] = c[x];     }     #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])     {         #pragma acc serial firstprivate(c[0:n])         {             #pragma acc loop gang             for (int x = 0; x < n; ++x){                 #pragma acc loop worker                 for (int y = 0; y < 10; ++y){                     d[x * 10 + y] = a[x * 10 + y] + b[x * 10 + y] + c[y];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 10; ++y){             if (fabs(d[x * 10 + y] - (a[x * 10 + y] + b[x * 10 + y] + c_copy[y])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:serial,firstprivate,V:2.6-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * sizeof(real_t));     real_t * c_copy = (real_t *)malloc(10 * sizeof(real_t));     real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));      for (int x = 0; x < 10*n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         d[x] = 0.0;     }     for (int x = 0; x < 10; ++x){         c[x] = 0.0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])     {         #pragma acc serial firstprivate(c[0:n])         {             #pragma acc loop gang independent             for (int x = 0; x < n; ++x){                 #pragma acc loop worker independent                 for (int y = 0; y < 10; ++y){                     c[y] = a[x * 10 + y] - b[x * 10 + y];                 }                 #pragma acc loop worker independent                 for (int y = 0; y < 10; ++y){                     d[x * 10 + y] = a[x * 10 + y] + b[x * 10 + y] + c[y];                 }             }         }     }      for (int x = 0; x < 10 * n; ++x){         if (fabs(d[x] - 2 * a[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial private", "completion": "#ifndef T1 !T1:serial,private,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b   REAL(8),DIMENSION(LOOPCOUNT):: c   REAL(8),DIMENSION(10):: d   REAL(8):: temp   INTEGER:: x, y   INTEGER:: errors    errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 0   d = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(d(1:10))     !$acc serial private(c(1:LOOPCOUNT))       !$acc loop gang       DO y = 1, 10         !$acc loop worker         DO x = 1, LOOPCOUNT           c(x) = a(x, y) + b(x, y)         END DO         !$acc loop seq         DO x = 1, LOOPCOUNT           d(y) = d(y) + c(x)         END DO       END DO     !$acc end serial   !$acc end data    DO y = 1, 10     temp = 0     DO x = 1, LOOPCOUNT       temp = temp + (a(x, y) + b(x, y))     END DO     IF (abs(d(x) - temp) .gt. (2 * PRECISION * LOOPCOUNT)) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc wait async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,async,construct-independent,wait,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));     real_t *e = (real_t *)malloc(n * sizeof(real_t));     real_t *f = (real_t *)malloc(n * sizeof(real_t));     real_t *g = (real_t *)malloc(n * sizeof(real_t));     real_t *h = (real_t *)malloc(n * sizeof(real_t));     real_t *i = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0;         g[x] = rand() / (real_t)(RAND_MAX / 10);         h[x] = 0;         i[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], g[0:n]) create(c[0:n], f[0:n], h[0:n]) copyout(i[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         acc_wait_async(1, 2);         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 h[x] = c[x] + g[x];             }         }         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         acc_wait_async(1, 2);         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 i[x] = h[x] + f[x];             }         }         #pragma acc wait(2)     }      for (int x = 0; x < n; ++x){         if (fabs(i[x] - (a[x] + b[x] + g[x] + d[x] + e[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic min x expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial create zero", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,data-region,V:3.0-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 1;     }      #pragma acc data copyin(a[0:n])      {         #pragma acc serial create(zero: b[0:n]) copyout(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] += a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction multiply vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     int multiplicitive_n = 128;     srand(SEED);     real_t * a = new real_t[10 * multiplicitive_n];     real_t * b = new real_t[10 * multiplicitive_n];     real_t * c = new real_t[10];     real_t temp;      for (int x = 0; x < 10 * multiplicitive_n; ++x){         a[x] = rand() / (real_t) RAND_MAX;         b[x] = rand() / (real_t) RAND_MAX;     }      #pragma acc data copyin(a[0:10*multiplicitive_n], b[0:10*multiplicitive_n]) copyout(c[0:10])     {         #pragma acc kernels loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 1.0;             #pragma acc loop vector reduction(*:temp)             for (int y = 0; y < multiplicitive_n; ++y){                 temp *= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];             }             c[x] = temp;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < multiplicitive_n; ++y){             c[x] /= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];         }     }      for (int x = 0; x < 10; ++x){         if (fabs(c[x] - 1) > PRECISION * (4 * multiplicitive_n - 1)){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,async,wait,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     real_t * d = new real_t[n];     real_t * e = new real_t[n];     real_t * f = new real_t[n];     real_t * g = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;         g[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], c[0:n], f[0:n], g[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         #pragma acc parallel wait(1, 2) async(3)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 g[x] = c[x] + f[x];             }         }         #pragma acc update host(c[0:n]) async(1)         #pragma acc update host(f[0:n]) async(2)         #pragma acc update host(g[0:n]) async(3)          #pragma acc wait(1)         for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x])) > PRECISION){                 err += 1;             }         }         #pragma acc wait(2)         for (int x = 0; x < n; ++x){             if (fabs(f[x] - (d[x] + e[x])) > PRECISION){                 err += 1;             }         }         #pragma acc wait(3)         for (int x = 0; x < n; ++x){             if (fabs(g[x] - (a[x] + b[x] + d[x] + e[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update expr minus x", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(subset, destination, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8),DIMENSION(length), INTENT(IN) :: subset         REAL(8), INTENT(IN) :: destination         REAL(8), INTENT(IN) :: init         REAL(8),ALLOCATABLE :: passed(:)         LOGICAL :: POSSIBLE         INTEGER :: x, y         IF (length .gt. 0) THEN           ALLOCATE(passed(length - 1))         ELSE           IF (abs(init - destination) .gt. PRECISION) THEN             POSSIBLE = .TRUE.           ELSE             POSSIBLE = .FALSE.           END IF           RETURN         END IF         POSSIBLE = .FALSE.         DO x = 1, length           DO y = 1, x - 1             passed(y) = subset(y)           END DO           DO y = x + 1, length             passed(y - 1) = subset(y)           END DO           IF (IS_POSSIBLE(passed, destination, length - 1, subset(x) - init)) THEN             POSSIBLE = .TRUE.             RETURN           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         LOGICAL IS_POSSIBLE         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals         INTEGER :: errors = 0         REAL(8),DIMENSION(10):: passed          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = a(x, y) - totals(x)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed(y) = a(x, y)           END DO           IF (IS_POSSIBLE(passed, totals(x), 10, 0) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc update self async with len", "completion": "#ifndef T1 !T1:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d !Data         INTEGER,DIMENSION(1):: devtest         REAL(8) :: RAND         INTEGER :: errors = 0          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         d = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT), d(1:LOOPCOUNT))           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           !$acc parallel async(2)             !$acc loop             DO x = 1, LOOPCOUNT               d(x) = a(x) * b(x)             END DO           !$acc end parallel           CALL acc_update_self_async(c(1), LOOPCOUNT*8, 1)           CALL acc_update_self_async(d(1), LOOPCOUNT*8, 2)           !$acc wait         !$acc end data         DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF           IF (abs(d(x) - (a(x) * b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d !Data         INTEGER,DIMENSION(1):: devtest         REAL(8) :: RAND         INTEGER :: errors = 0          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          IF (devtest(1) .eq. 1) THEN           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 0            !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc parallel async(1)               !$acc loop               DO x = 1, LOOPCOUNT                 a(x) = a(x) * a(x)               END DO             !$acc end parallel             CALL acc_update_self_async(a(1), LOOPCOUNT*8, 1)             !$acc parallel async(2)               !$acc loop               DO x = 1, LOOPCOUNT                 b(x) = b(x) * b(x)               END DO             !$acc end parallel             CALL acc_update_self_async(b(1), LOOPCOUNT*8, 2)             !$acc parallel async(1)               !$acc loop               DO x = 1, LOOPCOUNT                 a(x) = a(x) + 1               END DO             !$acc end parallel             !$acc parallel async(2)               !$acc loop               DO x = 1, LOOPCOUNT                 b(x) = b(x) + 1               END DO             !$acc end parallel             !$acc parallel async(1) wait(2)               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) * b(x)               END DO             !$acc end parallel             !$acc wait(1)           !$acc end data            DO x = 1, LOOPCOUNT             IF (abs(c(x) - ((a(x) + 1) * (b(x) + 1))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update x and expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) < .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = totals(x) .AND. a(x, y)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .AND. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture ixor x expr assign", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   INTEGER, INTENT(IN) :: init   INTEGER,DIMENSION(length), INTENT(IN) :: a   INTEGER,DIMENSION(length), INTENT(IN) :: b   INTEGER,DIMENSION(length - 1) :: passed_a   INTEGER,DIMENSION(length - 1) :: passed_b   INTEGER :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (b(x) .eq. ieor(init, a(x))) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = b(x)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y, z !Iterators   INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms   INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison   INTEGER,DIMENSION(10):: passed_a, passed_b   INTEGER:: init   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)   a = 0   DO x = 1, LOOPCOUNT     DO y = 1, 10       DO z = 1, 8         IF (randoms(x, y, z) .gt. .5) THEN           a(x, y) = a(x, y) + ISHFT(1, z - 1)         END IF       END DO     END DO   END DO   totals = 0   totals_comparison = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             totals(x) = ieor(totals(x), a(x, y))             b(x, y) = totals(x)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data   DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = ieor(totals_comparison(x), a(x, y))     END DO   END DO   DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NE. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 0     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop reduction bitand loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;      for (int x = 0; x < 10 * n; ++x){         b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b_copy[x] = b[x];         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX < false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }     #pragma acc data copyin(a[0:10 * n]) copy(b[0:10 * n], c[0:10])     {         #pragma acc kernels loop gang private(temp)         for (int y = 0; y < 10; ++y){             temp = a[y * n];             #pragma acc loop worker reduction(&:temp)             for (int x = 1; x < n; ++x){                 temp = temp & a[y * n + x];             }             c[y] = temp;             #pragma acc loop worker             for (int x = 0; x < n; ++x){                 b[y * n + x] = b[y * n + x] + c[y];             }         }     }     unsigned int* host_c = (unsigned int *)malloc(10 * sizeof(unsigned int));     for (int x = 0; x < 10; ++x){         host_c[x] = a[x * n];         for (int y = 1; y < n; ++y){             host_c[x] = host_c[x] & a[x * n + y];         }         if (host_c[x] != c[x]){           err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (b[x * n + y] != b_copy[x * n + y] + c[x]){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr eqv x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = a(x, y) .EQV. totals(x)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel default copy", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,data,data-region,default-mapping,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t c[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,data,data-region,default-mapping,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t c[n];     int * devtest = (int *)malloc(sizeof(real_t));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 1;         }          #pragma acc enter data copyin(c[0:n])         for (int x = 0; x < n; ++x){             c[x] = 0.0;         }         #pragma acc data copyin(a[0:n], b[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] += a[x] + b[x];                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(c[x]) > PRECISION){                 err += 1;             }         }          #pragma acc exit data copyout(c[0:n])          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction bitxor vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));      unsigned int temp = 0;     unsigned int b_host;      for (int x = 0; x < 10 * n; ++x){         a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc kernels loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(^:temp)             for (int y = 0; y < n; ++y){                 temp = temp ^ a[x * n + y];             }             b[x] = temp;         }     }      for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host ^ a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update predecrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic update                         --distribution[(int) (a[x]*b[y]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             distribution_comparison[(int) (a[x]*b[y]/10)]--;         }     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction multiply vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     int multiplicitive_n = 128;     srand(SEED);     real_t * a = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * sizeof(real_t));     real_t temp;      for (int x = 0; x < 10 * multiplicitive_n; ++x){         a[x] = rand() / (real_t) RAND_MAX;         b[x] = rand() / (real_t) RAND_MAX;     }      #pragma acc data copyin(a[0:10*multiplicitive_n], b[0:10*multiplicitive_n]) copyout(c[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 1.0;             #pragma acc loop vector reduction(*:temp)             for (int y = 0; y < multiplicitive_n; ++y){                 temp *= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];             }             c[x] = temp;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < multiplicitive_n; ++y){             c[x] /= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];         }     }      for (int x = 0; x < 10; ++x){         if (fabs(c[x] - 1) > PRECISION * (4 * multiplicitive_n - 1)){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel wait queue", "completion": "#include \"acc_testsuite.h\"  #ifndef T1 //T1:parallel,wait,async,V:2.0-3.2 int test1(){     int err = 0;     srand(time(NULL));      real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * d = (real_t *)malloc(n * sizeof(real_t));     real_t * e = (real_t *)malloc(n * sizeof(real_t));     real_t * f = (real_t *)malloc(n * sizeof(real_t));     real_t * g = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;         g[x] = 0.0;     }     #pragma acc data copyin(a[0:n], b[0:n], c[0:n], d[0:n], e[0:n], f[0:n], g[0:n])     {         #pragma acc parallel loop async(1)         for (int x = 0; x < n; ++x){             c[x] = (a[x] + b[x]);         }         #pragma acc parallel loop async(2)         for (int x = 0; x < n; ++x){             f[x] = (d[x] + e[x]);         }         #pragma acc parallel loop wait(1, 2) async(3)         for (int x = 0; x < n; ++x){             g[x] = (c[x] + f[x]);         }         #pragma acc update host(c[0:n]) wait(1)         #pragma acc update host(f[0:n]) wait(2)         #pragma acc update host(g[0:n]) wait(3)     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){ \t    err++; \t}         if (fabs(f[x] - (d[x] + e[x])) > PRECISION){             err++;         }         if (fabs(g[x] - (c[x] + f[x])) > PRECISION){             err++;         }     }      free(a);     free(b);     free(c);     free(d);     free(e);     free(f);     free(g);      return err; } #endif  int main(){     int failcode = 0;     int failed;  #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test1();     }     if(failed){ \tfailcode += (1 << 0);     }  #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel firstprivate", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,firstprivate,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * c_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));      for (int x = 0; x < 10*n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         d[x] = 0.0;     }     for (int x = 0; x < n; ++x){         c[x] = rand() / (real_t)(RAND_MAX / 10);         c_copy[x] = c[x];     }     #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])     {         #pragma acc parallel firstprivate(c[0:n])         {             #pragma acc loop gang             for (int x = 0; x < 10; ++x){                 #pragma acc loop worker                 for (int y = 0; y < n; ++y){                     d[x * n + y] = a[x * n + y] + b[x * n + y] + c[y];                 }             }         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (fabs(d[x * n + y] - (a[x * n + y] + b[x * n + y] + c_copy[y])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,firstprivate,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * c_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));      for (int x = 0; x < 10*n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         d[x] = 0.0;     }     for (int x = 0; x < n; ++x){         c[x] = 0.0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])     {         #pragma acc parallel firstprivate(c[0:n])         {             #pragma acc loop gang independent             for (int x = 0; x < 10; ++x){                 #pragma acc loop worker independent                 for (int y = 0; y < n; ++y){                     c[y] = a[x * n + y] - b[x * n + y];                 }                 #pragma acc loop worker independent                 for (int y = 0; y < n; ++y){                     d[x * n + y] = a[x * n + y] + b[x * n + y] + c[y];                 }             }         }     }      for (int x = 0; x < 10 * n; ++x){         if (fabs(d[x] - 2 * a[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction and loop", "completion": "#ifndef T1 !T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         LOGICAL,DIMENSION(10*LOOPCOUNT):: a, a_copy !Data         LOGICAL,DIMENSION(10) :: results, has_false         LOGICAL :: host_results = .TRUE.         LOGICAL :: temp = .TRUE.         REAL(8),DIMENSION(10*LOOPCOUNT):: randoms         REAL(8) :: false_margin = exp(log(.5) / LOOPCOUNT)         INTEGER :: errors = 0         !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, 10           results(x) = .TRUE.           has_false(x) = .FALSE.         END DO         DO x = 1, 10*LOOPCOUNT           IF (randoms(x) .lt. false_margin) THEN             a(x) = .TRUE.             a_copy(x) = .TRUE.           ELSE             a(x) = .FALSE.             a_copy(x) = .FALSE.             has_false(x / LOOPCOUNT) = .TRUE.           END IF         END DO          !$acc data copy(a(1:10*LOOPCOUNT), results(1:10))           !$acc kernels loop gang           DO x = 0, 9             temp = .TRUE.             !$acc loop worker reduction(.AND.:temp)             DO y = 1, LOOPCOUNT               temp = temp .AND. a(x * LOOPCOUNT + y)             END DO             results(x + 1) = temp             !$acc loop worker             DO y = 1, LOOPCOUNT               IF (temp .eqv. .TRUE.) THEN                 IF (a(x * LOOPCOUNT + y) .eqv. .TRUE.) THEN                   a(x * LOOPCOUNT + y) = .FALSE.                 ELSE                   a(x * LOOPCOUNT + y) = .TRUE.                 END IF               END IF             END DO           END DO         !$acc end data         DO x = 0, 9           temp = .TRUE.           DO y = 1, LOOPCOUNT             temp = temp .AND. a_copy(x * LOOPCOUNT + y)           END DO           IF (temp .neqv. results(x + 1)) THEN             errors = errors + 1           END IF           DO y = 1, LOOPCOUNT             IF (temp .eqv. .TRUE.) THEN               IF (a(x * LOOPCOUNT + y) .eqv. a_copy(x * LOOPCOUNT + y)) THEN                 errors = errors + 1               END IF             ELSE               IF (a(x * LOOPCOUNT + y) .neqv. a_copy(x * LOOPCOUNT + y)) THEN                 errors = errors + 1               END IF             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels copyout", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data,data-region,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n])     {         #pragma acc kernels copyout(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - a[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     int * devtest = (int *)malloc(sizeof(int));     real_t * a = new real_t[n];     real_t * b = new real_t[n];     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc kernels present(devtest[0:1])     {       devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0;         }          #pragma acc data copyin(a[0:n], b[0:n])         {             #pragma acc kernels copyout(b[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = a[x];                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(b[x]) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction multiply general", "completion": "#ifndef T1 !T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0         REAL(8) :: temp = 1         REAL(8) :: multiplied_total = 1          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         a = (999.4 + a)/1000         b = (999.4 + b)/1000          !$acc data copyin(a(1:LOOPCOUNT))           !$acc parallel loop reduction(*:multiplied_total)           DO x = 1, LOOPCOUNT             multiplied_total = multiplied_total * (a(x) + b(x))           END DO         !$acc end data          DO x = 1, LOOPCOUNT           temp = temp * (a(x) + b(x))         END DO         IF (abs(temp - multiplied_total) .gt. ((temp / 2) + (multiplied_total / 2)) * PRECISION) THEN           WRITE(*, *) temp           WRITE(*, *) multiplied_total           errors = errors + 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured plus equals assign", "completion": "#include \"acc_testsuite.h\"  bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] + prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x%(n/10 + 1)] += a[x] * b[x];                     c[x] = totals[x%(n/10 + 1)];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] += a[x] * b[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){             passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign bitxor equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev ^ a[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         for (int y = 0; y < 8; ++y){             totals[x] =  1<<y;             totals_comparison[x] = 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         b[x] = totals[x/10];                         totals[x/10] ^= a[x];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] ^= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update max expr list x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic x plus expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic                         totals[(int) ((a[x] + b[x])/2)] = totals[(int) ((a[x] + b[x])/2)] + a[x] * b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];         }     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop vector blocking", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,V:1.0-2.7 int test1(){   int err = 0;   srand(SEED);   real_t * a = new real_t[n];   real_t * b = new real_t[n];   real_t * c = new real_t[n];   real_t multiplyer = 1;    for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = 0.0;   }    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])   {     #pragma acc parallel     {       #pragma acc loop vector       for (int x = 0; x < n; ++x){         c[x] = (a[x] + b[x]) * multiplyer;       }       multiplyer += 1;       #pragma acc loop vector       for (int x = 0; x < n; ++x){         c[x] += (a[x] + b[x]) * multiplyer;       }     }   }    for (int x = 0; x < n; ++x){     if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){       err + 1;       break;     }   }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial copyout zero", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,data-region,V:3.0-3.1 int test1(){     int err = 0;     srand(SEED);      real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n])     {         #pragma acc serial copyout(zero: b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] += a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T2 //T2:serial,data,data-region,reference-counting,devonly,V:3.0-3.1 int test2(){     int err = 0;     srand(SEED);      real_t * a = new real_t[n];     real_t * b = new real_t[n];     int* hasDevice = (int *) malloc(sizeof(int));     hasDevice[0] = 1;     #pragma acc enter data copyin(hasDevice[0:1])     #pragma acc serial present(hasDevice[0:1])     {       hasDevice[0] = 0;     }      if (hasDevice[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0;         }         #pragma acc data copyin(a[0:n], b[0:n])         {             #pragma acc serial copyout(b[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] += a[x];                 }             }         }         for (int x = 0; x < n; ++x){             if (fabs(b[x]) > PRECISION){                 err += 1;                 break;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc async test all", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:async,runtime,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     real_t **a = (real_t **)malloc(10 * sizeof(real_t*));     real_t **b = (real_t **)malloc(10 * sizeof(real_t*));     real_t **c = (real_t **)malloc(10 * sizeof(real_t*));     real_t **d = (real_t **)malloc(10 * sizeof(real_t*));     real_t **e = (real_t **)malloc(10 * sizeof(real_t*));      for (int x = 0; x < 10; ++x){         a[x] = new real_t[n];         b[x] = new real_t[n];         c[x] = new real_t[n];         d[x] = new real_t[n];         e[x] = new real_t[n];         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 0;             d[x][y] = rand() / (real_t)(RAND_MAX / 10);             e[x][y] = 0;         }     }      #pragma acc enter data create(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n], d[0:10][0:n], e[0:10][0:n])     for (int x = 0; x < 10; ++x){         #pragma acc update device(a[x:1][0:n], b[x:1][0:n], d[x:1][0:n]) async(x)         #pragma acc parallel present(a[x:1][0:n], b[x:1][0:n], c[x:1][0:n]) async(x)         {             #pragma acc loop             for (int y = 0; y < n; ++y){                 c[x][y] = a[x][y] + b[x][y];             }         }         #pragma acc parallel present(c[x:1][0:n], d[x:1][0:n], e[x:1][0:n]) async(x)         {             #pragma acc loop             for (int y = 0; y < n; ++y){                 e[x][y] = c[x][y] + d[x][y];             }         }         #pragma acc update host(e[x:1][0:n]) async(x)     }         while(!acc_async_test_all());     for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (fabs(e[x][y] - (a[x][y] + b[x][y] + d[x][y])) > PRECISION){                 err += 1;             }         }     }     #pragma acc exit data delete(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n], d[0:10][0:n], e[0:10][0:n])     for (int x = 0; x < 10; ++x){         free(a[x]);         free(b[x]);         free(c[x]);         free(d[x]);         free(e[x]);     }     delete[] a;     delete[] b;     delete[] c;     delete[] d;     delete[] e;          return err; } #endif  #ifndef T2 //T2:async,runtime,construct-independent,V:1.0-2.7 int test2(){     int err = 0;     real_t *a = new real_t[10 * n];     real_t *b = new real_t[10 * n];     real_t *c = new real_t[10 * n];     real_t *d = new real_t[10 * n];     real_t *e = new real_t[10 * n];      for (int x = 0; x < 10*n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = 0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n], d[0:10*n]) copyout(c[0:10*n], e[0:10*n])     {         for (int x = 0; x < 10; ++x){             #pragma acc parallel present(a[0:10*n], b[0:10*n], c[0:10*n]) async(x)             {                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     c[x * n + y] = a[x * n + y] + b[x * n + y];                 }             }             #pragma acc parallel present(c[0:10*n], d[0:10*n], e[0:10*n]) async(x)             {                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     e[x * n + y] = c[x * n + y] + d[x * n + y];                 }             }         }         while(!acc_async_test_all());     }      for (int x = 0; x < 10*n; ++x){         if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){             err += 1;         }     }          delete[] a;     delete[] b;     delete[] c;     delete[] d;     delete[] e;          return err; } #endif  #ifndef T3 //T3:async,runtime,construct-independent,V:2.5-2.7 int test3(){     int err = 0;     real_t **a = (real_t **)malloc(10 * sizeof(real_t *));     real_t **b = (real_t **)malloc(10 * sizeof(real_t *));     real_t **c = (real_t **)malloc(10 * sizeof(real_t *));     real_t **d = (real_t **)malloc(10 * sizeof(real_t *));     real_t **e = (real_t **)malloc(10 * sizeof(real_t *));      for (int x = 0; x < 10; ++x){         a[x] = new real_t[n];         b[x] = new real_t[n];         c[x] = new real_t[n];         d[x] = new real_t[n];         e[x] = new real_t[n];         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 0;             d[x][y] = rand() / (real_t)(RAND_MAX / 10);             e[x][y] = 0;         }     }      #pragma acc data copyin(a[0:10][0:n], b[0:10][0:n], d[0:10][0:n]) copyout(c[0:10][0:n], e[0:10][0:n])     {         for (int x = 0; x < 10; ++x){             acc_set_default_async(x);             #pragma acc parallel present(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n]) async             {                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     c[x][y] = a[x][y] + b[x][y];                 }             }             #pragma acc parallel present(c[0:10][0:n], d[0:10][0:n], e[0:10][0:n]) async             {                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     e[x][y] = c[x][y] + d[x][y];                 }             }         }         while (!acc_async_test_all());     }      int count = 0;     int total = 0;     for (int x = 0; x < 10; ++x) {         for (int y = 0; y < n; ++y) {             if (fabs(e[x][y]) < PRECISION) {                 count += 1;             }             total += 1;         }     }     printf(\"%d out of %d\\n\", count, total);      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (fabs(e[x][y] - (a[x][y] + b[x][y] + d[x][y])) > PRECISION){                 err += 1;             }         }     }          for (int x = 0; x < 10; ++x){         free(a[x]);         free(b[x]);         free(c[x]);         free(d[x]);         free(e[x]);     }     delete[] a;     delete[] b;     delete[] c;     delete[] d;     delete[] e;          return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels copyout", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data,data-region,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n])     {         #pragma acc kernels copyout(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - a[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     int * devtest = (int *)malloc(sizeof(int));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc kernels present(devtest[0:1])     {       devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0;         }          #pragma acc data copyin(a[0:n], b[0:n])         {             #pragma acc kernels copyout(b[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = a[x];                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(b[x]) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction add loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t* b = (real_t*)malloc(10 * n * sizeof(real_t));     real_t* c = (real_t*)malloc(10 * n * sizeof(real_t));     real_t* d = (real_t*)malloc(10 * n * sizeof(real_t));     real_t avg = 0.0;     real_t rolling_total = 0;      for (int x = 0; x < 10 * n; ++x) {         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) create(c[0:10*n]) copyout(d[0:10*n])     {         #pragma acc parallel loop gang private(avg)         for (int x = 0; x < 10; ++x) {             avg = 0;             #pragma acc loop worker reduction(+:avg)             for (int y = 0; y < n; ++y) {                 avg += c[x * n + y] = a[x * n + y] + b[x * n + y];             }             avg = avg / n;             #pragma acc loop worker             for (int y = 0; y < n; ++y) {                 d[x * n + y] = c[x * n + y] - avg;             }         }     }       for (int x = 0; x < 10; ++x) {         rolling_total = 0;         for (int y = 0; y < n; ++y) {             rolling_total += a[x * n + y] + b[x * n + y];         }         rolling_total = rolling_total / n;         for (int y = 0; y < n; ++y) {             if (fabs(d[x * n + y] - ((a[x * n + y] + b[x * n + y]) - rolling_total)) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,loop,reduction,combined-constructs,V:2.7-2.7 int test2() {     int err = 0;     srand(SEED);     real_t* a = (real_t*)malloc(25 * n * sizeof(real_t));     real_t* b = (real_t*)malloc(25 * n * sizeof(real_t));     real_t* c = (real_t*)malloc(25 * n * sizeof(real_t));     real_t* d = (real_t*)malloc(25 * n * sizeof(real_t));     real_t avgs[5];     real_t host_avgs[5];      for (int x = 0; x < 25 * n; ++x) {         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = 0;     }      #pragma acc data copyin(a[0:25*n], b[0:25*n]) copyout(c[0:25*n], d[0:25*n])     {         #pragma acc parallel loop gang private(avgs)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 avgs[y] = 0;             }             #pragma acc loop worker reduction(+:avgs)             for (int y = 0; y < 5 * n; ++y) {                 avgs[y % 5] += c[x * 5 * n + y] = a[x * 5 * n + y] + b[x * 5 * n + y];             }             for (int y = 0; y < 5; ++y) {                 avgs[y] = avgs[y] / n;             }             #pragma acc loop worker             for (int y = 0; y < 5 * n; ++y) {                 d[x * 5 * n + y] = c[x * 5 * n + y] - avgs[y % 5];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             host_avgs[y] = 0;         }         for (int y = 0; y < 5 * n; ++y) {             host_avgs[y % 5] += a[x * 5 * n + y] + b[x * 5 * n + y];             if (fabs(c[x * 5 * n + y] - (a[x * n * 5 + y] + b[x * n * 5 + y])) > PRECISION) {                 err += 1;             }         }         for (int y = 0; y < 5; ++y) {             host_avgs[y] = host_avgs[y] / n;         }         for (int y = 0; y < 5 * n; ++y) {             if (fabs(d[x * 5 * n + y] - (c[x * 5 * n + y] - host_avgs[y % 5])) > PRECISION){                 err += 1;                          }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop gang", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])     {         #pragma acc parallel loop gang         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature set device type", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:set,runtime,syntactic,V:2.5-3.2 int test1(){     int err = 0;      int device_type = acc_get_device_type();      #pragma acc set device_type(host)     if (acc_get_device_type() != device_type){         err += 1;     }      return err; } #endif #ifndef T2 //T2:set,runtime,syntactic,V:2.5-3.2 int test2(){     int err = 0;      int device_type = acc_get_device_type();      #pragma acc set device_type(multicore)     if (acc_get_device_type() != device_type){         err += 1;     }      return err; } #endif #ifndef T3 //T3:set,runtime,syntactic,V:2.5-3.2 int test3(){     int err = 0;      int device_type = acc_get_device_type();      #pragma acc set device_type(default)     if (acc_get_device_type() != device_type){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitand general", "completion": "#ifndef T1 !T1:serial,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER,DIMENSION(N):: a   INTEGER:: b, host_b   REAL(8):: false_margin   REAL(8),DIMENSION(LOOPCOUNT, 16):: randoms   INTEGER:: x, y   INTEGER:: errors    errors = 0   false_margin = exp(log(.5)/LOOPCOUNT)    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)    DO x = 1, LOOPCOUNT     DO y = 1, 16       IF (randoms(x, y) .lt. false_margin) THEN         a(x) = a(x) + 2**(y - 1)       END IF     END DO   END DO    b = a(1)   host_b = a(1)   DO x = 2, LOOPCOUNT     host_b = iand(host_b, a(x))   END DO    !$acc data copyin(a(1:LOOPCOUNT))     !$acc serial loop reduction(iand: b)     DO x = 1, LOOPCOUNT       b = iand(b, a(x))     END DO   !$acc end data    IF (b .ne. host_b) THEN     errors = errors + 1   END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop worker", "completion": "#ifndef T1 !T1:serial,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   REAL(8),DIMENSION(LOOPCOUNT):: a, b, c   INTEGER:: x   INTEGER:: errors    errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 0    !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))     !$acc serial loop worker     DO x = 1, LOOPCOUNT       c(x) = a(x) + b(x)     END DO   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign rshift equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if ((a >> x) % 2 == 1){                 if (is_possible(passed_a, passed_b, length - 1,prev >> 1)){                     free(passed_b);                     return true;                 }             }             else{                 if (is_possible(passed_a, passed_b, length - 1, prev)){                     free(passed_b);                     return true;                 }             }         }     }     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1<<8;      for (int x = 0; x < n; ++x){         a[x] = 1<<8;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                         {                             c[x * 7 + y] = a[x];                             a[x] >>= 1;                         }                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<8){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction add loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,combined-constructs,reduction,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10 * n];     real_t * d = new real_t[10 * n];     real_t avg = 0.0;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) create(c[0:10*n]) copyout(d[0:10*n])     {         #pragma acc kernels loop gang private(avg)         for (int x = 0; x < 10; ++x){             avg = 0;             #pragma acc loop worker reduction(+:avg)             for (int y = 0; y < n; ++y){                 avg += c[x * n + y] = a[x * n + y] + b[x * n + y];             }             avg = avg / n;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 d[x * n + y] = c[x * n + y] - avg;             }         }     }      real_t rolling_total = 0;      for (int x = 0; x < 10; ++x){         rolling_total = 0;         for (int y = 0; y < n; ++y){             rolling_total += a[x * n + y] + b[x * n + y];         }         rolling_total = rolling_total / n;         for (int y = 0; y < n; ++y){             if (fabs(d[x * n + y] - ((a[x * n + y] + b[x * n + y]) - rolling_total)) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel while loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,syntactic,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t avg = 0.0;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         avg += a[x]/(n * 10);     }      #pragma acc data copy(a[0:10*n])     {         #pragma acc parallel         {             real_t avg = 0.0;             #pragma acc loop             for (int y = 0; y < 10; ++y){                 avg = 0.0;                 while (avg - 1000 < PRECISION * n){                     avg = 0.0;                     #pragma acc loop reduction(+:avg)                     for (int x = 0; x < n; ++x){                         a[n * y + x] *= 1.5;                         avg += a[n * y + x] / n;                     }                 }             }         }     }      avg = 0.0;     for (int x = 0; x < n; ++x){         avg += a[x]/n;     }      if (avg < 1000 || avg > 1600){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature exit data finalize", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,reference-counting,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int * devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])     #pragma acc enter data create(a[0:n], b[0:n], c[0:n])     #pragma acc parallel present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc exit data copyout(a[0:n], b[0:n], c[0:n])     if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             if (fabs(c[x]) > PRECISION) {                 err += 1;             }         }     }     #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])     for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:data,executable-data,reference-counting,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])     #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])     #pragma acc parallel present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n]) finalize     for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign x bitand expr", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev & a[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         b[x] = totals[x/10];                         totals[x/10] = totals[x/10] & a[x];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] &= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial present", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,present,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n])     #pragma acc serial present(a[0:n], b[0:n]) copy(c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc exit data delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data present no lower bound", "completion": "#ifndef T1 !T1:data,data_region,construct-independent,present,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0           !$acc enter data copyin(c(1:LOOPCOUNT))         !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data         !$acc exit data copyout(c(1:LOOPCOUNT))         DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture x divided expr assign", "completion": "RECURSIVE FUNCTION IS_POSSIBLE_2(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   REAL(8), INTENT(IN) :: init   REAL(8),DIMENSION(length), INTENT(IN) :: a   REAL(8),DIMENSION(length), INTENT(IN) :: b   REAL(8),DIMENSION(length - 1) :: passed_a   REAL(8),DIMENSION(length - 1) :: passed_b   real(8) :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y   REAL(8):: mindif   IF (length .lt. 10) THEN     WRITE(*, *) length   END IF   IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (abs(b(x) - (init / a(x))) .lt. (100 - length) * PRECISION) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = b(x)       IF (IS_POSSIBLE_2(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE_2  RECURSIVE FUNCTION IS_POSSIBLE(subset, destination, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   REAL(8),DIMENSION(length), INTENT(IN) :: subset   REAL(8), INTENT(IN) :: destination   REAL(8), INTENT(IN) :: init   REAL(8),ALLOCATABLE :: passed(:)   REAL(8) :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y   IF (length .gt. 0) THEN     ALLOCATE(passed(length - 1))   ELSE     IF (abs(init - destination) .lt. (10 - length) * PRECISION) THEN       POSSIBLE = .TRUE.     ELSE       POSSIBLE = .FALSE.     END IF     RETURN   END IF   POSSIBLE = .FALSE.   DO x = 1, length     DO y = 1, x - 1       passed(y) = subset(y)     END DO     DO y = x + 1, length       passed(y - 1) = subset(y)     END DO     holder = init / subset(x)     IF (IS_POSSIBLE(passed, destination, length - 1, holder)) THEN       POSSIBLE = .TRUE.       RETURN     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data   REAL(8),DIMENSION(LOOPCOUNT, 10):: b   REAL(8),DIMENSION(LOOPCOUNT):: totals   REAL(8),DIMENSION(10):: passed   REAL(8),DIMENSION(10):: passed_b   REAL(8) :: holder   INTEGER :: errors = 0   LOGICAL IS_POSSIBLE   LOGICAL IS_POSSIBLE_2    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)    totals = 1    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             totals(x) = totals(x) / a(x, y)             b(x, y) = totals(x)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed(y) = a(x, y)     END DO     holder = 1     IF (IS_POSSIBLE(passed, totals(x), 10, holder) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     holder = 1     IF (IS_POSSIBLE_2(passed, passed_b, 10, holder) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature reference count zero", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:reference-counting,data,V:3.2-3.3 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }       #pragma acc data copy(a[0:n], b[0:n], c[0:n])     {         #pragma acc parallel loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature serial async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,async,wait,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     real_t * d = new real_t[n];     real_t * e = new real_t[n];     real_t * f = new real_t[n];     real_t * g = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;         g[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], c[0:n], f[0:n], g[0:n])     {         #pragma acc serial async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc serial async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         #pragma acc serial wait(1, 2) async(3)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 g[x] = c[x] + f[x];             }         }         #pragma acc update host(c[0:n]) async(1)         #pragma acc update host(f[0:n]) async(2)         #pragma acc update host(g[0:n]) async(3)          #pragma acc wait(1)         for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x])) > PRECISION){                 err += 1;             }         }         #pragma acc wait(2)         for (int x = 0; x < n; ++x){             if (fabs(f[x] - (d[x] + e[x])) > PRECISION){                 err += 1;             }         }         #pragma acc wait(3)         for (int x = 0; x < n; ++x){             if (fabs(g[x] - (a[x] + b[x] + d[x] + e[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitor general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     unsigned int b = 0;     unsigned int host_b;     real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX > false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }      #pragma acc data copyin(a[0:n])     {         #pragma acc serial loop reduction(|:b)         for (int x = 0; x < n; ++x){             b = b | a[x];         }     }      host_b = a[0];     for (int x = 1; x < n; ++x){         host_b = host_b | a[x];     }     if (b != host_b){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic max expr list x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO         IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update x bitor expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] |= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial create", "completion": "#ifndef T1 !T1:serial,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT):: a, b, c   INTEGER:: x   errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   b = 0   c = 0    !$acc data copyin(a(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))     !$acc serial create(b(1:LOOPCOUNT))       !$acc loop       DO x = 1, LOOPCOUNT         b(x) = a(x)       END DO       !$acc loop       DO x = 1, LOOPCOUNT         c(x) = b(x)       END DO     !$acc end serial   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(a(x) - c(x)) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction multiply vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     int multiplicitive_n = 128;     srand(SEED);     real_t * a = new real_t[10 * multiplicitive_n];     real_t * b = new real_t[10 * multiplicitive_n];     real_t * c = new real_t[10];     real_t temp;      for (int x = 0; x < 10 * multiplicitive_n; ++x){         a[x] = rand() / (real_t) RAND_MAX;         b[x] = rand() / (real_t) RAND_MAX;     }      #pragma acc data copyin(a[0:10*multiplicitive_n], b[0:10*multiplicitive_n]) copyout(c[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 1.0;             #pragma acc loop vector reduction(*:temp)             for (int y = 0; y < multiplicitive_n; ++y){                 temp *= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];             }             c[x] = temp;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < multiplicitive_n; ++y){             c[x] /= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];         }     }      for (int x = 0; x < 10; ++x){         if (fabs(c[x] - 1) > PRECISION * (4 * multiplicitive_n - 1)){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,async,wait,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * d = (real_t *)malloc(n * sizeof(real_t));     real_t * e = (real_t *)malloc(n * sizeof(real_t));     real_t * f = (real_t *)malloc(n * sizeof(real_t));     real_t * g = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;         g[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], c[0:n], f[0:n], g[0:n])     {         #pragma acc serial async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc serial async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         #pragma acc serial wait(1, 2) async(3)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 g[x] = c[x] + f[x];             }         }         #pragma acc update host(c[0:n]) async(1)         #pragma acc update host(f[0:n]) async(2)         #pragma acc update host(g[0:n]) async(3)          #pragma acc wait(1)         for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x])) > PRECISION){                 err += 1;             }         }         #pragma acc wait(2)         for (int x = 0; x < n; ++x){             if (fabs(f[x] - (d[x] + e[x])) > PRECISION){                 err += 1;             }         }         #pragma acc wait(3)         for (int x = 0; x < n; ++x){             if (fabs(g[x] - (a[x] + b[x] + d[x] + e[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature declare create", "completion": "!$acc declare create(fixed_size_array) !$acc declare create(scalar) !$acc declare create(LOOPCOUNT)  !$acc routine vector FUNCTION multiplyData(a)   REAL(8),DIMENSION(LOOPCOUNT), INTENT(INOUT) :: a   !$acc loop vector   DO x = 1, LOOPCOUNT     a(x) = a(x) * 2   END DO END FUNCTION multiplyData  #ifndef T1 !T1:construct-independent,declare,update,V:2.0-2.7       LOGICAL FUNCTION test1()   USE OPENACC   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT) :: a, b    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   b = 0   !$acc update device(n)   !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT)) present(fixed_size_array)     !$acc parallel       !$acc loop       DO x = 1, 10         fixed_size_array(x) = x * x       END DO     !$acc end parallel     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         b(x) = a(x) + fixed_size_array(MOD(x, 10))       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(b(x) - (a(x) + (MOD(x, 10) * MOD(x, 10)))) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:construct-independent,declare,update,V:2.0-2.7       LOGICAL FUNCTION test2()   USE OPENACC   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT) :: a, b    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   b = 0   scalar = 10   !$acc update device(scalar)   !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT)) present(scalar)     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         b(x) = a(x) + scalar       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(b(x) - (a(x) + scalar)) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:construct-independent,declare,V:2.0-2.7       LOGICAL FUNCTION test3()   USE OPENACC   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT) :: a, b    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   b = a   !$acc update   !$acc data copy(a(1:LOOPCOUNT))     !$acc parallel       !$acc loop       DO x = 1, 1         CALL externMultiplyData(a, LOOPCOUNT)       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(a(x) - (b(x) * 2)) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif #ifndef T4 !T4:construct-independent,declare,V:2.0-2.7       LOGICAL FUNCTION test4()   USE OPENACC   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT) :: a, b    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   b = a    !$acc data copy(a(1:LOOPCOUNT))     !$acc parallel       !$acc loop       DO x = 1, 1         CALL multiplyData(a)       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(a(x) - (b(x) * 2)) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test4 = .FALSE.         ELSE           test4 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif #ifndef T4         LOGICAL :: test4 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif #ifndef T4         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test4()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 3           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction add loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));     real_t avg = 0.0;     real_t rolling_total = 0;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) create(c[0:10*n]) copyout(d[0:10*n])     {         #pragma acc serial  \t{     \t#pragma acc loop gang private(avg)         for (int x = 0; x < 10; ++x){             avg = 0;             #pragma acc loop worker reduction(+:avg)             for (int y = 0; y < n; ++y){                 avg += c[x * n + y] = a[x * n + y] + b[x * n + y];             }             avg = avg / n;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 d[x * n + y] = c[x * n + y] - avg;             }         } \t}     }       for (int x = 0; x < 10; ++x){         rolling_total = 0;         for (int y = 0; y < n; ++y){             rolling_total += a[x * n + y] + b[x * n + y];         }         rolling_total = rolling_total / n;         for (int y = 0; y < n; ++y){             if (fabs(d[x * n + y] - ((a[x * n + y] + b[x * n + y]) - rolling_total)) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction add general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc serial loop reduction(+:total)         for (int x = 0; x < n; ++x){             total += a[x] + b[x];         }     }     for (int x = 0; x < n; ++x){         total -= a[x] + b[x];     }     if (fabs(total - 10) > PRECISION * (2 * n - 1)){ //199 = # of mathematical operations necessary         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured minus equals assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (prev - a[x])) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[10];     real_t *totals_host = new real_t[10];     real_t * passed_ab = new real_t[(n/10 + 1)];     real_t * passed_c = new real_t[(n/10 + 1)];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0; \ttotals_host[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x%10] -= (a[x] + b[x]);                     c[x] = totals[x%10];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc get property", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,devonly,syntactic,V:2.6-2.7 int test1(){     int err = 0;      if (acc_get_device_type() != acc_device_none){         const char* returned_string1;         const char* returned_string2;         const char* returned_string3;         int returned_int;         returned_int = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_memory);         returned_int = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);         returned_string1 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_name);         returned_string2 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_vendor);         returned_string3 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_driver);     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update iand expr x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .gt. .933) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           DO y = 0, 7             totals(x) = totals(x) + ISHFT(1, y)             totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)           END DO         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update x minus expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_host[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%10] = totals[x%10] - (a[x] + b[x]);             }         }     }       for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured bitor equals assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == (prev | a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] |= a[x];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] |= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitand loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));     unsigned int* host_c = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;      for (int x = 0; x < 10 * n; ++x){         b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b_copy[x] = b[x];         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX < false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }     #pragma acc data copyin(a[0:10 * n]) copy(b[0:10 * n], c[0:10])     {         #pragma acc serial \t{    \t\t#pragma acc loop gang private(temp)         \tfor (int y = 0; y < 10; ++y){             \t\ttemp = a[y * n];             \t\t#pragma acc loop worker reduction(&:temp)            \t\tfor (int x = 1; x < n; ++x){                \t\ttemp = temp & a[y * n + x];             \t\t}             \t \t\t\tc[y] = temp;             \t \t\t\t#pragma acc loop worker             \t\tfor (int x = 0; x < n; ++x){ \t       \t\t\tb[y * n + x] = b[y * n + x] + c[y];             \t\t}         \t}     \t}     }     for (int x = 0; x < 10; ++x){         host_c[x] = a[x * n];         for (int y = 1; y < n; ++y){             host_c[x] = host_c[x] & a[x * n + y];         }         if (host_c[x] != c[x]){           err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (b[x * n + y] != b_copy[x * n + y] + c[x]){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc copyin", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      acc_copyin(a, n * sizeof(real_t));     acc_copyin(b, n * sizeof(real_t));      #pragma acc data copy(c[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      acc_copyout(a, n * sizeof(real_t));     acc_copyout(b, n * sizeof(real_t));      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(time(NULL));     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      acc_copyin(a, n * sizeof(real_t));     acc_copyin(b, n * sizeof(real_t));      #pragma acc data copy(c[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data copyout(a[0:n], b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }     return err; } #endif  #ifndef T3 //T3:runtime,data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7 int test3(){     int err = 0;     srand(time(NULL));     real_t * a = new real_t[n];     real_t * a_copy = new real_t[n];     real_t * b = new real_t[n];     real_t * b_copy = new real_t[n];     real_t * c = new real_t[n];     int * dev_test = new int[n];      dev_test[0] = 1;     #pragma acc enter data copyin(dev_test[0:1])     #pragma acc parallel present(dev_test[0:1])     {         dev_test[0] = 0;     }      if (dev_test[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             a_copy[x] = a[x];             b[x] = rand() / (real_t)(RAND_MAX / 10);             b_copy[x] = b[x];             c[x] = 0.0;         }          acc_copyin(a, n * sizeof(real_t));         acc_copyin(b, n * sizeof(real_t));          for (int x = 0; x < n; ++x){             a[x] = 0;             b[x] = 0;         }          #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] + b[x];                 }             }         }          acc_copyout(a, n * sizeof(real_t));         acc_copyout(b, n * sizeof(real_t));          for (int x = 0; x < n; ++x){             if (fabs(a[x] - a_copy[x]) > PRECISION){                 err += 1;             }             if (fabs(b[x] - b_copy[x]) > PRECISION){                 err += 1;             }             if (fabs(c[x] - (a[x] + b[x])) > PRECISION){                 err += 1;             }         }     }     return err; } #endif  #ifndef T4 //T4:runtime,data,executable-data,construct-independent,compatibility-features,V:2.0-2.7 int test4(){     int err = 0;     srand(time(NULL));     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      acc_pcopyin(a, n * sizeof(real_t));     acc_pcopyin(b, n * sizeof(real_t));      #pragma acc data copy(c[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }     return err; } #endif  #ifndef T5 //T5:runtime,data,executable-data,construct-independent,compatibility-features,V:2.0-2.7 int test5(){     int err = 0;     srand(time(NULL));     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      acc_present_or_copyin(a, n * sizeof(real_t));     acc_present_or_copyin(b, n * sizeof(real_t));      #pragma acc data copyout(c[0:n]) present(a[0:n], b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }     return err; } #endif  #ifndef T6 //T6:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7 int test6() {     int err = 0;     srand(time(NULL));     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];      for (int x = 0; x < n; ++x) {         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      acc_copyin(a, n * sizeof(real_t));     acc_copyin(a, n * sizeof(real_t));     acc_copyin(b, n * sizeof(real_t));     acc_copyin(b, n * sizeof(real_t));      #pragma acc data copyout(c[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data delete(a[0:n], b[0:n])     #pragma acc exit data delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }     return err; } #endif  #ifndef T7 //T7:runtime,data,executable-data,construct-independent,reference-counting,devonly,V:2.5-2.7 int test7() {     int err = 0;     srand(time(NULL));     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *a_copy = new real_t[n];     real_t *b_copy = new real_t[n];     real_t *c = new real_t[n];     int * dev_test = new int[n];      dev_test[0] = 1;     #pragma acc enter data copyin(dev_test[0:1])     #pragma acc parallel present(dev_test[0:1])     {         dev_test[0] = 0;     }      if (dev_test[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             a_copy[x] = a[x];             b_copy[x] = b[x];             c[x] = 0;         }                  acc_copyin(a, n * sizeof(real_t));         acc_copyin(b, n * sizeof(real_t));          for (int x = 0; x < n; ++x){             a[x] = 0;             b[x] = 0;         }          acc_copyin(a, n * sizeof(real_t));         acc_copyin(b, n * sizeof(real_t));          #pragma acc data copyout(c[0:n])         {             #pragma acc parallel present(a[0:n], b[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] + b[x];                 }             }         }          #pragma acc exit data delete(a[0:n], b[0:n])         #pragma acc exit data delete(a[0:n], b[0:n])          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){                 err += 1;             }         }     }     return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif #ifndef T6     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x) {         failed = failed + test6();     }     if (failed != 0) {         failcode = failcode + (1 << 5);     } #endif #ifndef T7     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x) {         failed = failed + test7();     }     if (failed != 0) {         failcode = failcode + (1 << 6);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature init device type nvidia", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:init,runtime,V:2.5-3.2 int test1(){     int err = 0;     srand(SEED);      #pragma acc init device_type(nvidia)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }     if (failed){         failcode += (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture x eqv expr assign", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   LOGICAL, INTENT(IN) :: init   LOGICAL,DIMENSION(length), INTENT(IN) :: a   LOGICAL,DIMENSION(length), INTENT(IN) :: b   LOGICAL,DIMENSION(length - 1) :: passed_a   LOGICAL,DIMENSION(length - 1) :: passed_b   LOGICAL :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (b(x) .eqv. (init .eqv. a(x))) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = b(x)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms   LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data   LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison   LOGICAL,DIMENSION(10):: passed_a, passed_b   LOGICAL:: init   INTEGER :: errors = 0   LOGICAL IS_POSSIBLE    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)   DO x = 1, LOOPCOUNT     DO y = 1, 10       IF (randoms(x, y) > .5) THEN         a(x, y) = .TRUE.       ELSE         a(x, y) = .FALSE.       END IF     END DO   END DO    totals = .FALSE.   totals_comparison = .FALSE.    !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             totals(x) = totals(x) .EQV. a(x, y)             b(x, y) = totals(x)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)     END DO   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = .FALSE.     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN       errors = errors + 1     END IF   END DO    DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NEQV. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture assign x eqv expr", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   LOGICAL, INTENT(IN) :: init   LOGICAL,DIMENSION(length), INTENT(IN) :: a   LOGICAL,DIMENSION(length), INTENT(IN) :: b   LOGICAL,DIMENSION(length - 1) :: passed_a   LOGICAL,DIMENSION(length - 1) :: passed_b   LOGICAL :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (b(x) .eqv. init) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = a(x) .eqv. init       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms   LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data   LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison   LOGICAL,DIMENSION(10):: passed_a, passed_b   LOGICAL:: init   INTEGER :: errors = 0   LOGICAL IS_POSSIBLE    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)   DO x = 1, LOOPCOUNT     DO y = 1, 10       IF (randoms(x, y) > .5) THEN         a(x, y) = .TRUE.       ELSE         a(x, y) = .FALSE.       END IF     END DO   END DO    totals = .FALSE.   totals_comparison = .FALSE.    !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             b(x, y) = totals(x)             totals(x) = totals(x) .EQV. a(x, y)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)     END DO   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = .FALSE.     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN       errors = errors + 1     END IF   END DO    DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NEQV. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update expr plus x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[10];     real_t *totals_comparison = new real_t[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic update                         totals[(int) ((a[x] + b[x])/2)] = a[x] * b[x] + totals[(int) ((a[x] + b[x])/2)];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];         }     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > 10 * PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine bind nonprototype lambda string function", "completion": "#include \"acc_testsuite.h\"  //test 1 host lambnda #pragma acc routine vector bind(\"device_array_array\") auto  host_array_array = [](real_t * a, long long n){     #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; };  //test 1 device function real_t device_array_array(real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  //test 2 host lambda #pragma acc routine vector bind(\"device_object_array\") auto host_object_array = [](data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned += a->data[x];     }     return returned; };  //test 2 device function real_t device_object_array(data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; }  //test 3 host lambda #pragma acc routine vector bind(\"device_array_object\") auto host_array_object = [](real_t * a, long long n){    #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; };  //test 3 device function real_t device_array_object(real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  //test 4 host lambda #pragma acc routine vector bind(\"device_object_object\") auto host_object_object = [](data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned += a->data[x];     }     return returned; };  //test 4 device function real_t device_object_object(data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; }  #ifndef T1 //T1:routine,V:2.7-3.3 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){        \ta[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_array_array(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_array(a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_array(a, n) - b[x]) > PRECISION)){             err += 1;         }     }     delete[] a;     delete[] b;      return err; } #endif #ifndef T2 //T2:routine,V:2.7-3.3 int test2(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a, a.data[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_object_array(&a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_array(&a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_array(&a, n) - b[x]) > PRECISION)){             err += 1;         }     }      delete[] b;      return err; } #endif #ifndef T3 //T3:routine,V:2.7-3.3 int test3(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b, b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_array_object(a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_object(a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_object(a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      delete[] a;      return err; } #endif #ifndef T4 //T4:routine,V:2.7-3.3 int test4(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a, a.data[0:n], b ,b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_object_object(&a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_object(&a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_object(&a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed = 0; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }      if(failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }      if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }      if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test4();     }      if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction and loop", "completion": "#include \"acc_testsuite.h\"  #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = new char[10 * n];     char * a_copy = new char[10 * n];     char * has_false = new char[10];     real_t false_margin = pow(exp(1), log(.5)/n);     char temp = 1;      for (int x = 0; x < 10; ++x){         has_false[x] = 0;     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (rand() / (real_t)(RAND_MAX) < false_margin){                 a[x * n + y] = 1;                 a_copy[x * n + y] = 1;             }             else {                 a[x * n + y] = 0;                 a_copy[x * n + y] = 0;                 has_false[x] = 1;             }         }     }      #pragma acc data copy(a[0:10*n])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop worker reduction(&&:temp)             for (int y = 0; y < n; ++y){                 temp = temp && a[x * n + y];             }             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 a[x * n + y] = a[x * n + y] ^ temp;             }         }     }       for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){                 err = 1;             }             else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){                 err = 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     char * a = new char[n * 25];     char * a_copy = new char[n * 25];     char * has_false = new char[25];     real_t false_margin = pow(exp(1), log(.5)/n);     char device[5];     char host[5];      for (int x = 0; x < 5; ++x) {         device[x] = 1;         host[x] = 1;         for (int y = 0; y < 5; ++y) {             has_false[x * 5 + y] = 0;         }     }      for (int x = 0; x < 25 * n; ++x){         if (rand() / (real_t)(RAND_MAX) < false_margin) {             a[x] = 1;             a_copy[x] = 1;         }         else {             a[x] = 0;             a_copy[x] = 0;             has_false[x % 25] = 1;         }     }      #pragma acc data copy(a[0:25*n])     {         #pragma acc parallel loop gang private(device)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 device[y] = 1;             }             #pragma acc loop worker reduction(&&:device)             for (int y = 0; y < 5 * n; ++y) {                 device[y%5] = device[y%5] && a[x * 5 * n + y];             }             #pragma acc loop worker             for (int y = 0; y < 5 * n; ++y) {                 a[x * 5 * n + y] = a[x * 5 * n + y] ^ device[y%5];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             host[y] = 1;         }         for (int y = 0; y < 5 * n; ++y) {             host[y%5] = host[y%5] && a_copy[x * 5 * n + y];         }         for (int y = 0; y < 5 * n; ++y) {             if (a[x * 5 * n + y] != (a_copy[x * 5 * n + y] ^ host[y % 5])) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update x divided expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] / (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update x plus expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = totals(x) + a(x, y)               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) + a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured predecrement assign", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *c = (int *)malloc(n * sizeof(int));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));     bool found = false;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     --distribution[(int) (a[x]*b[x]/10)];                     c[x] = distribution[(int) (a[x]*b[x]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]--;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y > distribution[x]; --y){             for (int z = 0; z < n; ++z){                 if (c[z] == y - 1 && x == (int) (a[z] * b[z] / 10)){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data create", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,data-region,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc data create(b[0:n])     {         #pragma acc data copyin(a[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = a[x];                 }             }         }         #pragma acc data copyout(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - a[x]) > PRECISION) {             err += 1;             break;         }     }      return err; } #endif  #ifndef T2 //T2:data,data-region,construct-independent,compatibility-features,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc data present_or_create(b[0:n])     {         #pragma acc data copyin(a[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = a[x];                 }             }         }         #pragma acc data copyout(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - a[x]) > PRECISION) {             err += 2;             break;         }     }      return err; } #endif  #ifndef T3 //T3:data,data-region,construct-independent,compatibility-features,V:1.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc data pcreate(b[0:n])     {         #pragma acc data copyin(a[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = a[x];                 }             }         }         #pragma acc data copyout(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - a[x]) > PRECISION){             err += 4;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update x bitand expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0; \tfor (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] & a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] &= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc update self with len", "completion": "#ifndef T1 !T1:runtime,data,executable-data,construct-independent,update,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           CALL acc_update_self(c(1), LOOPCOUNT*8)         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,data,executable-data,construct-independent,update,V:2.0-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               a(x) = a(x) * a(x)             END DO           !$acc end parallel           CALL acc_update_self(a(1), LOOPCOUNT*8)           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = b(x) * b(x)             END DO           !$acc end parallel           CALL acc_update_self(b(1), LOOPCOUNT*8)           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction or loop", "completion": "#ifndef T1 !T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, a_copy   LOGICAL,DIMENSION(10):: results   LOGICAL:: temp   REAL(8):: false_margin   REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms   INTEGER:: errors   INTEGER:: x, y    errors = 0   SEEDDIM(1) = 1   #ifdef SEED   SEEDDIM(1) = SEED   #endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)    DO y = 1, 10     DO x = 1, LOOPCOUNT       IF (randoms(x, y) .gt. false_margin) THEN         a(x, y) = .TRUE.       ELSE         a(x, y) = .FALSE.       END IF     END DO   END DO    a_copy = a    !$acc data copy(a(1:LOOPCOUNT, 1:10))     !$acc serial loop gang private(temp)     DO y = 1, 10       temp = .FALSE.       !$acc loop worker reduction(.OR.:temp)       DO x = 1, LOOPCOUNT         temp = temp .OR. a(x, y)       END DO       results(y) = temp       !$acc loop worker       DO x = 1, LOOPCOUNT         IF (results(y)) THEN           IF (a(x, y)) THEN             a(x, y) = .FALSE.           ELSE             a(x, y) = .TRUE.           END IF         END IF       END DO     END DO   !$acc end data    DO y = 1, 10     temp = .FALSE.     DO x = 1, LOOPCOUNT       temp = temp .OR. a(x, y)     END DO     IF (temp .neqv. results(y)) THEN       errors = errors + 1     END IF     DO x = 1, LOOPCOUNT       IF (temp) THEN         IF (a(x, y) .eqv. a_copy(x, y)) THEN           errors = errors + 1         END IF       ELSE         IF (a(x, y) .neqv. a_copy(x, y)) THEN           errors = errors + 1         END IF       END IF     END DO   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM serial_loop_reduction_or_loop         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature shutdown", "completion": "#ifndef T1 !T1:construct-independent,shutdown,nonvalidating,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: errors = 0          !$acc shutdown          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update expr plus x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = a(x, y) + totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) + a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel private", "completion": "#ifndef T1 !T1:parallel,private,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT):: c         REAL(8),DIMENSION(10)::d         REAL(8) :: temp         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         d = 0          !$acc enter data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT), d(1:10))          !$acc parallel num_gangs(10) private(c(1:LOOPCOUNT))           !$acc loop gang           DO x = 1, 10             !$acc loop worker             DO y = 1, LOOPCOUNT               c(y) = a((x - 1) * LOOPCOUNT + y) + b((x - 1) * LOOPCOUNT + y)             END DO             !$acc loop seq             DO y = 1, LOOPCOUNT               d(x) = d(x) + c(y)             END DO           END DO         !$acc end parallel         !$acc exit data copyout(d(1:10)) delete(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT))          DO x = 0, 9           temp = 0           DO y = 1, LOOPCOUNT             temp = temp + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)           END DO           IF (abs(temp - d(x + 1)) .gt. 2 * PRECISION * LOOPCOUNT) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop reduction bitor vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int b_host;      for (int x = 0; x < 10 * n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX > false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }     temp = 0;     #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc kernels loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(|:temp)             for (int y = 0; y < n; ++y){                 temp = temp | a[x * n + y];             }             b[x] = temp;         }     }      for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host | a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x bitand expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] & a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] &= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc get device type", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:,V:1.0-3.2 int test1(){ \tint err = 0;  \tint device_type = acc_get_device_type();  \tif (acc_get_device_type() != device_type){ \t\terr += 1; \t}  \treturn err; } #endif  int main(){     \tint failcode = 0;     \tint failed; #ifndef T1     \tfailed = 0;     \tfor (int x = 0; x < NUM_TEST_CALLS; ++x){         \tfailed = failed + test1();     \t}     \tif (failed != 0){         \tfailcode = failcode + (1 << 0);     \t} #endif     \treturn failcode; } "}
{"prompt": "Create a test for the feature atomic max x expr list end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction multiply vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1() {     int err = 0;     int multiplicitive_n = 128;     srand(SEED);     real_t* a = new real_t[10 * multiplicitive_n];     real_t* b = new real_t[10 * multiplicitive_n];     real_t* c = new real_t[10];     real_t temp;      for (int x = 0; x < 10 * multiplicitive_n; ++x) {         a[x] = rand() / (real_t)RAND_MAX;         b[x] = rand() / (real_t)RAND_MAX;     }  #pragma acc data copyin(a[0:10*multiplicitive_n], b[0:10*multiplicitive_n]) copyout(c[0:10])     { #pragma acc parallel loop private(temp)         for (int x = 0; x < 10; ++x) {             temp = 1.0; #pragma acc loop vector reduction(*:temp)             for (int y = 0; y < multiplicitive_n; ++y) {                 temp *= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];             }             c[x] = temp;         }     }      for (int x = 0; x < 10; ++x) {         for (int y = 0; y < multiplicitive_n; ++y) {             c[x] /= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];         }     }      for (int x = 0; x < 10; ++x) {         if (fabs(c[x] - 1) > PRECISION* (4 * multiplicitive_n - 1)) {             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2() {     int err = 0;     int m_n = 128;     srand(SEED);     real_t* a = new real_t[25 * m_n];     real_t* b = new real_t[25 * m_n];     real_t* c = new real_t[25 * m_n];     real_t* totals = new real_t[25];     real_t reduced[5];      for (int x = 0; x < n; ++x) {         a[x] = .05 + rand() / (real_t)(RAND_MAX / 10);         b[x] = .05 + rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc data copyin(a[0:25*m_n], b[0:25*m_n]) copyout(c[0:25*m_n], totals[0:25])     {         #pragma acc parallel loop gang private(reduced)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 reduced[y] = 1.0;             }             #pragma acc loop worker reduction(*:reduced)             for (int y = 0; y < 5 * m_n; ++y) {                 reduced[y % 5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];             }             for (int y = 0; y < 5; ++y) {                 totals[x * 5 + y] = reduced[y];             }             #pragma acc loop worker             for (int y = 0; y < 5 * m_n; ++y) {                 c[x * 5 * m_n + y] = (a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[(x * 5) + (y % 5)];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             reduced[y] = 1;         }         for (int y = 0; y < 5 * m_n; ++y) {             reduced[y % 5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];         }         for (int y = 0; y < 5; ++y) {             if (fabs(totals[x * 5 + y] - reduced[y]) > PRECISION) {                 err += 1;             }         }         for (int y = 0; y < 5 * m_n; ++y) {             if (fabs(c[x * 5 * m_n + y] - ((a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[x * 5 + (y % 5)])) > PRECISION){                 err += 1;             }            }     }      return err; } #endif  #ifndef T3 //T3: int test3(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr eqv x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = a(x, y) .EQV. totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature shutdown if", "completion": "#include \"acc_testsuite.h\" /*  *if clause not implimented as of now */  #ifndef T1 //T1:,V:2.7-3.0 int test1(){ \tint err = 0; \tsrand(SEED); \tint device_num;  \tdevice_num = acc_get_device_num(acc_get_device_type()); \t#pragma acc shutdown if(device_num == device_num)  \treturn err; } #endif  #ifndef T2 //T2:,V:2.7-3.0 int test2(){ \tint err = 0; \tsrand(SEED); \tint device_num;  \tdevice_num = acc_get_device_num(acc_get_device_type()); \t#pragma acc shutdown if(device_num != device_num)  \treturn err; } #endif  int main(){ \tint failcode = 0; \tint failed; #ifndef T1 \tfailed = 0; \tfor (int x = 0; x < NUM_TEST_CALLS; ++x){ \t\tfailed = failed + test1(); \t} \tif (failed != 0){ \t\tfailcode = failcode + (1 << 0); \t} #endif #ifndef T2         failed = 0;         for (int x = 0; x < NUM_TEST_CALLS; ++x){                 failed = failed + test2();         }         if (failed != 0){                 failcode = failcode + (1 << 1);         } #endif \treturn failcode; } "}
{"prompt": "Create a test for the feature data copyout no lower bound", "completion": "#ifndef T1 !T1:data,data_region,construct-independent,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction add loop", "completion": "#ifndef T1 !T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10*LOOPCOUNT):: a, b, c, d !Data         REAL(8) :: avg         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         avg = 0         !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) create(c(1:10*LOOPCOUNT)) copyout(d(1:10*LOOPCOUNT))           !$acc parallel loop gang private(avg)           DO x = 0, 9             avg = 0             !$acc loop worker reduction(+:avg)             DO y = 1, LOOPCOUNT               avg = avg + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)               c(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)             END DO             avg = avg / LOOPCOUNT             !$acc loop worker             DO y = 1, LOOPCOUNT               d(x * LOOPCOUNT + y) = c(x * LOOPCOUNT + y) / avg             END DO           END DO         !$acc end data         DO x = 0, 9           avg = 0           DO y = 1, LOOPCOUNT             avg = avg + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)           END DO           avg = avg / LOOPCOUNT           DO y = 1, LOOPCOUNT             IF (abs(d(x * LOOPCOUNT + y) - ((a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)) / avg)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature exit data copyout no lower bound", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,syntactic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])     #pragma acc parallel present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature exit data delete no lower bound", "completion": "#ifndef T1 !T1:data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         LOGICAL,DIMENSION(1):: has_device          has_device(1) = .TRUE.         !$acc enter data copyin(has_device(1:1))         !$acc parallel present(has_device(1:1))           has_device(1) = .FALSE.         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))         !$acc data copyout(c(1:LOOPCOUNT)) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data         !$acc exit data delete(a(:LOOPCOUNT), b(:LOOPCOUNT))         DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         LOGICAL,DIMENSION(1):: has_device          has_device(1) = .TRUE.         !$acc enter data copyin(has_device(1:1))         !$acc parallel present(has_device(1:1))           has_device(1) = .FALSE.         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          IF (has_device(1) .eqv. .TRUE.) THEN           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 0                      !$acc enter data copyin(c(1:LOOPCOUNT))           !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) + b(x)               END DO             !$acc end parallel           !$acc end data           !$acc exit data delete(c(:LOOPCOUNT))            DO x = 1, LOOPCOUNT             IF (abs(c(x)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop worker", "completion": "#ifndef T1 !T1:parallel,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))           !$acc parallel loop worker           DO x = 1, LOOPCOUNT             c(x) = a(x) + b(x)           END DO         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic expr multiply x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction or loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(10 * n * sizeof(char));     char * a_copy = (char *)malloc(10 * n * sizeof(char));     char * results = (char *)malloc(10 * sizeof(char));     char temp = 0;     real_t false_margin = pow(exp(1), log(.5)/n);      for (int x = 0; x < 10 * n; ++x){         if (rand() / (real_t)(RAND_MAX) > false_margin){             a[x] = 1;             a_copy[x] = 1;         }         else{             a[x] = 0;             a_copy[x] = 0;         }     }     #pragma acc data copy(a[0:10*n]) copyout(results[0:10])     {         #pragma acc serial  \t{ \t#pragma loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(||:temp)             for (int y = 0; y < n; ++y){                 temp = temp || a[x * n + y];             }             results[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 if(results[x] == 1){                     if (a[x * n + y] == 1){                         a[x * n + y] = 0;                     }                     else{                         a[x * n + y] = 1;                     }                 }             }         } \t}     }     for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = temp || a_copy[x * n + y];         }         if (temp != results[x]) {             err += 1;         }         for (int y = 0; y < n; ++y){             if (temp == 1){                 if (a[x * n + y] == a_copy[x * n + y]){                     err += 1;                 }             }             else {                 if (a[x * n + y] != a_copy[x * n + y]){                     err += 1;                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction and vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(10 * n * sizeof(char));     char * b = (char *)malloc(10 * sizeof(char));     char * has_false = (char *)malloc(10 * sizeof(char));     real_t false_margin = pow(exp(1), log(.5)/n);      for (int x = 0; x < 10; ++x){         has_false[x] = 0;     }     for (int x = 0; x < 10 * n; ++x){         if(rand() / (real_t)(RAND_MAX) < false_margin){             a[x] = 1;         }         else{             a[x] = 0;             has_false[x/n] = 1;         }     }     char temp = 1;     #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc kernels loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop vector reduction(&&:temp)             for (int y = 0; y < n; ++y){                 temp = temp && a[x * n + y];             }             b[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         if (has_false[x] == b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitor loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));     unsigned int host_c;      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             b[x * n + y] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);             b_copy[x * n + y] = b[x * n + y];             for (int z = 0; z < 16; ++z){                 if (rand() / (real_t) RAND_MAX > false_margin){                     temp = 1;                     for (int i = 0; i < z; ++i){                         temp = temp * 2;                     }                     a[x * n + y] += temp;                 }             }         }     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(|:temp)             for (int y = 0; y < n; ++y){                 temp = temp | a[x * n + y];             }             c[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 b[x * n + y] = b[x * n + y] + c[x];             }         }     }     for (int x = 0; x < 10; ++x){         host_c = a[x * n];         for (int y = 1; y < n; ++y){             host_c = host_c | a[x * n + y];         }         if (host_c != c[x]){             err += 1;         }         for (int y = 0; y < n; ++y){             if (b[x * n + y] != b_copy[x * n + y] + host_c){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic lshift equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic                             a[x] <<= 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels num gangs", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * restrict a = new real_t[n];     real_t * restrict b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc kernels loop num_gangs(16)         for (int x = 0; x < n; ++x){             b[x] = a[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc update device", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc data copyout(c[0:n]) create(a[0:n], b[0:n])     {         acc_update_device(a, n * sizeof(real_t));         acc_update_device(b, n * sizeof(real_t));         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0;         }          #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     a[x] = a[x] * a[x];                 }             }             acc_update_device(a, n * sizeof(real_t));             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = b[x] * b[x];                 }             }             acc_update_device(b, n * sizeof(real_t));             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] + b[x];                 }             }         }           for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature init device type", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:init,runtime,V:2.5-3.2 int test1(){     int err = 0;     srand(SEED);      #pragma acc init device_type(host)      return err; } #endif #ifndef T2 //T1:init,runtime,V:2.5-3.2 int test2(){     int err = 0;     srand(SEED);      #pragma acc init device_type(multicore)      return err; } #endif #ifndef T3 //T1:init,runtime,V:2.5-3.2 int test3(){     int err = 0;     srand(SEED);      #pragma acc init device_type(default)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }     if (failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }     if (failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }     if (failed){         failcode += (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture assign min expr list x", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, c, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8), INTENT(IN) :: init         REAL(8),DIMENSION(length), INTENT(IN) :: a         REAL(8),DIMENSION(length), INTENT(IN) :: b         REAL(8),DIMENSION(length), INTENT(IN) :: c         REAL(8),DIMENSION(length - 1) :: passed_a         REAL(8),DIMENSION(length - 1) :: passed_b         REAL(8),DIMENSION(length - 1) :: passed_c         REAL(8) :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (abs(c(x) - init) .gt. (10 - length) * PRECISION) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = min(a(x), b(x), init)             IF (IS_POSSIBLE(passed_a, passed_b, passed_c, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c         REAL(8):: init         LOGICAL IS_POSSIBLE         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   c(x, y) = totals(x)                   totals(x) = min(a(x, y), b(x, y), totals(x))                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = min(totals_comparison(x), a(x, y), b(x, y))           END DO         END DO         DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)             passed_c(y) = c(x, y)           END DO           init = 0           IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update multiply equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] *= a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc malloc", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,V:1.0-2.7 int test1(){     int err = 0;     size_t initial_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);     int *a = (int *)acc_malloc(n * sizeof(int));      if (initial_memory == 0){         return err;     }     size_t final_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);     if (final_memory + n * sizeof(int) > initial_memory){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels num workers", "completion": "#ifndef T1 !T1:kernels,V:2.5-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0          !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))           !$acc kernels loop num_workers(16)           DO x = 1, LOOPCOUNT             b(x) = a(x)           END DO           !$acc end kernels         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(a(x) - b(x)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign assign", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *b_copy = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         b_copy[x] = b[x];     }      #pragma acc data copyin(a[0:n]) copy(b[0:n]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = b[x];                     b[x] = a[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         if (abs(c[x] - b_copy[x]) > PRECISION){             err++;         }         if (abs(b[x] - a[x]) > PRECISION){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture assign max expr x", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   REAL(8), INTENT(IN) :: init   REAL(8),DIMENSION(length), INTENT(IN) :: a   REAL(8),DIMENSION(length), INTENT(IN) :: b   REAL(8),DIMENSION(length - 1) :: passed_a   REAL(8),DIMENSION(length - 1) :: passed_b   REAL(8) :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (abs(b(x) - init) .lt. (10 - length) * PRECISION) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = max(a(x), init)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison   REAL(8),DIMENSION(10):: passed_a, passed_b   REAL(8):: init   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)    totals = 0   totals_comparison = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             b(x, y) = totals(x)             totals(x) = max(a(x, y), totals(x))           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data   DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = max(totals_comparison(x), a(x, y))     END DO   END DO   DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NE. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 0     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop independent", "completion": "#ifndef T1 !T1:kernels,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0          !$acc data copyin(a(1:LOOPCOUNT)) copy(b(1:LOOPCOUNT))           !$acc kernels loop independent           DO x = 1, LOOPCOUNT             b(x) = b(x) + a(x)           END DO         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(a(x) - b(x)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc delete async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,async,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];     real_t *e = new real_t[n];     real_t *f = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0;     }      #pragma acc enter data copyin(a[0:n], b[0:n], d[0:n], e[0:n])      #pragma acc data present(a[0:n], b[0:n], d[0:n], e[0:n]) copyout(c[0:n], f[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         acc_delete_async(a, n * sizeof(real_t), 1);         acc_delete_async(b, n * sizeof(real_t), 1);         acc_delete_async(d, n * sizeof(real_t), 2);         acc_delete_async(e, n * sizeof(real_t), 2);         #pragma acc wait     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }         if (fabs(f[x] - (d[x] + e[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];     real_t *e = new real_t[n];     real_t *f = new real_t[n];     int* devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0;         }          #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])         #pragma acc data present(a[0:n], b[0:n], c[0:n])         {             #pragma acc parallel async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] * b[x];                 }             }         }         acc_delete_async(c, n * sizeof(real_t), 1);         #pragma acc enter data copyin(c[0:n]) async(1)         #pragma acc data present(a[0:n], b[0:n], c[0:n])         {             #pragma acc parallel async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] += a[x] + b[x];                 }             }         }         #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x divided expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] / (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update x eqv expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = totals(x) .EQV. a(x, y)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature data with structs", "completion": "#include \"acc_testsuite.h\" typedef struct multi_item {     real_t a;     real_t b;     real_t c; } multi_item;  #ifndef T1 //T1:data,data-region,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     multi_item * a = (multi_item *)malloc(n * sizeof(multi_item));      for (int x = 0; x < n; ++x){         a[x].a = rand() / (real_t)(RAND_MAX / 10);         a[x].b = rand() / (real_t)(RAND_MAX / 10);         a[x].c = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x].c = a[x].a + a[x].b;             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x].c - (a[x].a + a[x].b)) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction or loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = new char[10 * n];     char * a_copy = new char[10 * n];     char * results = new char[10];     char temp = 0;     real_t false_margin = pow(exp(1), log(.5)/n);      for (int x = 0; x < 10 * n; ++x){         if (rand() / (real_t)(RAND_MAX) > false_margin){             a[x] = 1;             a_copy[x] = 1;         }         else{             a[x] = 0;             a_copy[x] = 0;         }     }     #pragma acc data copy(a[0:10*n]) copyout(results[0:10])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(||:temp)             for (int y = 0; y < n; ++y){                 temp = temp || a[x * n + y];             }             results[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 if(results[x] == 1){                     if (a[x * n + y] == 1){                         a[x * n + y] = 0;                     }                     else{                         a[x * n + y] = 1;                     }                 }             }         }     }     for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = temp || a_copy[x * n + y];         }         if (temp != results[x]) {             err += 1;         }         for (int y = 0; y < n; ++y){             if (temp == 1){                 if (a[x * n + y] == a_copy[x * n + y]){                     err += 1;                 }             }             else {                 if (a[x * n + y] != a_copy[x * n + y]){                     err += 1;                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction bitxor general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     unsigned int b = 0;      for (int x = 0; x < n; ++x){         a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);     }     unsigned int host_b = a[0];      #pragma acc data copyin(a[0:n])     {         #pragma acc kernels loop reduction(^:b)         for (int x = 0; x < n; ++x){             b = b ^ a[x];         }     }       for (int x = 1; x < n; ++x){         host_b = host_b ^ a[x];     }     if (b != host_b){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc copyout finalize with len", "completion": "#ifndef T1 !T1:runtime,data,executable-data,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data create(c(1:LOOPCOUNT))         !$acc enter data create(c(1:LOOPCOUNT))          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_copyout_finalize(c(1), LOOPCOUNT*8)          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif          CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature atomic ior expr x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .lt. .933) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           totals(x) = 0           totals_comparison(x) = 0         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured lshift equals assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if ((b[x] == (prev << 1) && (a>>x)%2 == 1) || ((a>>x)%2==0 && b[x] == prev)){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1;      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                         {                             a[x] <<= 1;                             c[x * 7 + y] = a[x];                         }                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data copyout reference counts", "completion": "#ifndef T1 !T1:data,data_region,devonly,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1)::devtest          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          IF (devtest(1) .eq. 1) THEN           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 0           !$acc data copyin(c(1:LOOPCOUNT))             !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))               !$acc parallel                 !$acc loop                 DO x = 1, LOOPCOUNT                   c(x) = c(x) + a(x) + b(x)                 END DO               !$acc end parallel             !$acc end data           !$acc end data            DO x = 1, LOOPCOUNT             IF (abs(c(x)) .gt. PRECISION) THEN               errors = errors + 1               EXIT             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:data,data_region,devonly,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1)::devtest          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data copyin(c(1:LOOPCOUNT))         !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = c(x) + a(x) + b(x)             END DO           !$acc end parallel         !$acc end data         IF (devtest(1) .eq. 1) THEN           DO x = 1, LOOPCOUNT             IF (abs(c(x)) .gt. PRECISION) THEN               errors = errors + 2               EXIT             END IF           END DO         END IF         !$acc exit data copyout(c(1:LOOPCOUNT))         DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 4             EXIT           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:data,data_region,devonly,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test3()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1)::devtest          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data copyin(c(1:LOOPCOUNT))         !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = c(x) + a(x) + b(x)             END DO           !$acc end parallel           !$acc exit data delete(c(1:LOOPCOUNT))         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 8             EXIT           END IF         END DO          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture assign expr minus x", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE_2(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8), INTENT(IN) :: init         REAL(8),DIMENSION(length), INTENT(IN) :: a         REAL(8),DIMENSION(length), INTENT(IN) :: b         REAL(8),DIMENSION(length - 1) :: passed_a         REAL(8),DIMENSION(length - 1) :: passed_b         REAL(8) :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (abs(b(x) - init) .GT. ((10 - length) * PRECISION)) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = a(x) - init             IF (IS_POSSIBLE_2(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE_2        RECURSIVE FUNCTION IS_POSSIBLE(subset, destination, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8),DIMENSION(length), INTENT(IN) :: subset         REAL(8), INTENT(IN) :: destination         REAL(8), INTENT(IN) :: init         REAL(8),ALLOCATABLE :: passed(:)         LOGICAL :: POSSIBLE         INTEGER :: x, y         IF (length .gt. 0) THEN           ALLOCATE(passed(length - 1))         ELSE           IF (abs(init - destination) .gt. PRECISION) THEN             POSSIBLE = .TRUE.           ELSE             POSSIBLE = .FALSE.           END IF           RETURN         END IF         POSSIBLE = .FALSE.         DO x = 1, length           DO y = 1, x - 1             passed(y) = subset(y)           END DO           DO y = x + 1, length             passed(y - 1) = subset(y)           END DO           IF (IS_POSSIBLE(passed, destination, length - 1, subset(x) - init)) THEN             POSSIBLE = .TRUE.             RETURN           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         LOGICAL IS_POSSIBLE         LOGICAL IS_POSSIBLE_2         REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals         REAL(8),DIMENSION(10):: passed_a, passed_b         REAL(8):: init         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   b(x, y) = totals(x)                   totals(x) = a(x, y) - totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)           END DO           IF (IS_POSSIBLE(passed_a, totals(x), 10, 0) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           init = 0           IF (IS_POSSIBLE_2(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction add vector loop", "completion": "#ifndef T1 !T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b   REAL(8),DIMENSION(10):: c   REAL(8):: temp   INTEGER:: x, y    errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)    !$acc data copyin(a(1:LOOPCOUNT,1:10), b(1:LOOPCOUNT,1:10)) copyout(c(1:10))     !$acc serial loop private(temp)     DO y = 1, 10       temp = 0       !$acc loop vector reduction(+:temp)       DO x = 1, LOOPCOUNT         temp = temp + (a(x, y) + b(x, y))       END DO       c(y) = temp     END DO   !$acc end data    DO y = 1, 10     DO x = 1, LOOPCOUNT       c(y) = c(y) - (a(x, y) + b(x, y))     END DO     IF (abs(c(y)) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel create zero", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //#T1:parallel,data,data_region,V:3.0-3.2 int Test1(){     int err=0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];      for( int x = 0; x < n; x++){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n]     {         #pragma acc parallel create(zero: b[0:n])         {             #pragma acc loop             {                 for(int x = 0; x < n; x++){                     b[x] += a[x];                 }             }         }     }     for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; }"}
{"prompt": "Create a test for the feature parallel loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = 0;     }      #pragma acc data copy(a[0:n])     {         #pragma acc parallel loop         for (int x = 0; x < n; ++x){             a[x] = 1.0;         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - 1.0) > PRECISION){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,loop,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){       a[x] = 0.0;       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = rand() / (real_t)(RAND_MAX / 10);     }     #pragma acc data copy(a[0:n], b[0:n], c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = b[x];             }             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] += c[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] + c[x])) > PRECISION * 2){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture min expr x assign", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8), INTENT(IN) :: init         REAL(8),DIMENSION(length), INTENT(IN) :: a         REAL(8),DIMENSION(length), INTENT(IN) :: b         REAL(8),DIMENSION(length - 1) :: passed_a         REAL(8),DIMENSION(length - 1) :: passed_b         REAL(8) :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (abs(b(x) - min(init, a(x))) .gt. (10 - length) * PRECISION) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = b(x)             IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         REAL(8),DIMENSION(10):: passed_a, passed_b         REAL(8):: init         LOGICAL IS_POSSIBLE         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   totals(x) = min(a(x, y), totals(x))                   b(x, y) = totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = min(totals_comparison(x), a(x, y))           END DO         END DO         DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           init = 0           IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel present", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,present,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n])     #pragma acc parallel present(a[0:n], b[0:n]) copy(c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc exit data delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop worker blocking", "completion": "#ifndef T1 !T1:parallel,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         REAL(8) :: multiplyer         INTEGER :: errors = 0          multiplyer = 1         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop worker             DO x = 1, LOOPCOUNT               c(x) = (a(x) + b(x)) * multiplyer             END DO             multiplyer = multiplyer + 1             !$acc loop worker             DO x = 1, LOOPCOUNT               c(x) = c(x) + (a(x) + b(x)) * multiplyer             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (3 * (a(x) + b(x)))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update min expr x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc copyout finalize async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));     real_t *e = (real_t *)malloc(n * sizeof(real_t));     real_t *f = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0;     }      #pragma acc enter data create(c[0:n], f[0:n])     #pragma acc enter data create(c[0:n], f[0:n])      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n]) present(c[0:n], f[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         acc_copyout_finalize_async(c, n * sizeof(real_t), 1);         acc_copyout_finalize_async(f, n * sizeof(real_t), 2);         #pragma acc wait     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }         if (fabs(f[x] - (d[x] + e[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,async,construct-independent,internal-control-values,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int def_async_var = acc_get_default_async();      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data create(c[0:n])     #pragma acc enter data create(c[0:n])          #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         acc_copyout_finalize_async(c, n * sizeof(real_t), def_async_var);         #pragma acc wait     }      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:runtime,data,executable-data,async,construct-independent,internal-control-values,set,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int def_async_var = acc_get_default_async();      acc_set_default_async(def_async_var + 1);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data create(c[0:n])     #pragma acc enter data create(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(c[0:n]) async         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         acc_copyout_async(c, n * sizeof(real_t), def_async_var + 1);         #pragma acc wait     }      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T4 //T4:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test4(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data create(c[0:n])     #pragma acc enter data create(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(c[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         acc_copyout_finalize_async(c, n * sizeof(real_t), 1);         #pragma acc enter data copyin(c[0:n]) async(1)         #pragma acc parallel present(c[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] += a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {             err += 1;         }     }           return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitxor vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));      unsigned int temp = 0;     unsigned int b_host;      for (int x = 0; x < 10 * n; ++x){         a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc parallel loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(^:temp)             for (int y = 0; y < n; ++y){                 temp = temp ^ a[x * n + y];             }             b[x] = temp;         }     }      for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host ^ a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));      unsigned int temp[5];      for (int x = 0; x < 25 * n; ++x){         a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);     }      #pragma acc data copyin(a[0:25*n]) copy(b[0:25])     {         #pragma acc parallel loop private(temp)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y){                 temp[y] = 0;             }             #pragma acc loop vector reduction(^:temp)             for (int y = 0; y < 5 * n; ++y) {                 temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];             }             for (int y = 0; y < 5; ++y) {                 b[x * 5 + y] = temp[y];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             temp[y] = 0;         }         for (int y = 0; y < 5 * n; ++y) {             temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];         }         for (int y = 0; y < 5; ++y) {             if (b[x * 5 + y] != temp[y]) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction multiply general", "completion": "#ifndef T1 !T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0         REAL(8) :: temp = 1         REAL(8) :: multiplied_total = 1          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         a = (999.4 + a)/1000         b = (999.4 + b)/1000          !$acc data copyin(a(1:LOOPCOUNT))           !$acc kernels loop reduction(*:multiplied_total)           DO x = 1, LOOPCOUNT             multiplied_total = multiplied_total * (a(x) + b(x))           END DO         !$acc end data          DO x = 1, LOOPCOUNT           temp = temp * (a(x) + b(x))         END DO         IF (abs(temp - multiplied_total) .gt. ((temp / 2) + (multiplied_total / 2)) * PRECISION) THEN           WRITE(*, *) temp           WRITE(*, *) multiplied_total           errors = errors + 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update bitor equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] |= a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] |= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture expr bitor x", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == (a[x]|prev)){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *passed_a = new int[10];     int *passed_b = new int[10];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){ \ta[x] = 0;         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0; \ttotals_comparison[x] = 0;      }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1], b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     b[x] = totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] |= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }     for (int x = 0; x < (n/10 + 1); ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_a[passed_indexer] = a[absolute_indexer];             passed_b[passed_indexer] = b[absolute_indexer];         }         if (!is_possible(passed_a, passed_b, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x neqv expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = totals(x) .NEQV. a(x, y)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update bitand equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }      }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] &= a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] &= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update x times expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = totals(x) * a(x, y)               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) * a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature declare copyin mod", "completion": "MODULE DECLARE_COPYIN_MOD   INTEGER,DIMENSION(10):: fixed_size_array   !$acc declare copyin(fixed_size_array) END MODULE DECLARE_COPYIN_MOD  "}
{"prompt": "Create a test for the feature parallel copy", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,data,data-region,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * a_host = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         a_host[x] = a[x];     }      #pragma acc parallel copy(a[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             a[x] = 2 * a[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (2 * a_host[x])) > PRECISION){             err = 1;         }     }      return err; } #endif #ifndef T2 //T2:parallel,data,data-region,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t device = rand() / (real_t)(RAND_MAX / 10);     real_t host = device;     #pragma acc parallel loop copy(device) reduction(+:device)     for(int x = 0; x < n; ++x){         device += 1.0;     }      if(fabs(host - (device - n) ) > PRECISION){             err++;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }     if(failed){         failcode +=  (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }     if(failed){         failcode +=  (1 << 1);     } #endif      return failcode; }"}
{"prompt": "Create a test for the feature acc delete with len", "completion": "#ifndef T1 !T1:runtime,data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors         errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          !$acc data copyout(c(1:LOOPCOUNT))           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_delete(a(1), LOOPCOUNT*8)         CALL acc_delete(b(1), LOOPCOUNT*8)          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors         errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_copyin(a(1:LOOPCOUNT))         CALL acc_copyin(b(1:LOOPCOUNT))          !$acc data copyout(c(1:LOOPCOUNT))           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_delete(a(1), LOOPCOUNT*8)         CALL acc_delete(b(1), LOOPCOUNT*8)          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failcode = 0         failed = .FALSE. #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2**1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature parallel copyout zero", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,data,data-region,V:3.0-3.2 int test1(){     int err = 0;     srand(SEED);      real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n])      {       #pragma acc parallel copyout(zero: b[0:n])       {         #pragma acc loop         {           for (int x = 0; x < n; ++x){             b[x] += a[x];           }         }       }     }      for (int x = 0; x < n; ++x){         if(fabs(a[x] - b[x]) > PRECISION){                 err += 1;                 break;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,data,data-region,devonly,V:3.0-3.1 int test2(){     //for development; logic test     int err = 0;     srand(SEED);      real_t * a = new real_t[n];     real_t * b = new real_t[n];      int* hasDevice = (int *) malloc(sizeof(int));     hasDevice[0] = 1;     #pragma acc enter data copyin(hasDevice[0:1])     #pragma acc parallel present(hasDevice[0:1])     {       hasDevice[0] = 0;     }      if (hasDevice[0] == 1){       for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 1;       }        #pragma acc data copyin(a[0:n])       {         #pragma acc parallel copyout(zero: b[0:n])         {           #pragma acc loop           {             for (int x = 0; x < n; ++x){               b[x] += a[x];             }           }         }       }        for (int x = 0; x < n; ++x){           if(fabs(a[x] - b[x]) > PRECISION){                   err += 1;                   break;           }       }     }      return err; } #endif  #ifndef T3 //T3:parallel,data,data-region,V:3.0-3.1 int test3(){     int err = 0;     srand(SEED);      real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 1;     }      #pragma acc data copyin(a[0:n]) copy(b[0:n])     {       #pragma acc parallel copyout(zero: b[0:n])       {         #pragma acc loop         {           for (int x = 0; x < n; ++x){             b[x] += a[x];           }         }       }     }      for (int x = 0; x < n; ++x){         if(fabs(a[x] - b[x] + 1) > PRECISION){                 err += 1;                 break;         }     }      return err; } #endif  int main(){     int failcode = 0;      int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update min x expr list", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature declare function scope copyout", "completion": "#include \"acc_testsuite.h\" void copyout_test(real_t *a, real_t *b, real_t *c){     #pragma acc declare copyout(c[0:n])     #pragma acc parallel present(a[0:n], b[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     } }  #ifndef T1 //T1:declare,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));         b[x] = (real_t *)malloc(n * sizeof(real_t));         c[x] = (real_t *)malloc(n * sizeof(real_t));         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 1;         }     }     #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])     {         for (int x = 0; x < n; ++x){             copyout_test(a[x], b[x], c[x]);         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:declare,construct-independent,reference-counting,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 2;         }     }      #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])     {         for (int x = 0; x < n; ++x){             #pragma acc data copy(c[x:1][0:n])             {                 copyout_test(a[x], b[x], c[x]);             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T3 //T3:declare,construct-independent,devonly,reference-counting,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 a[x][y] = rand() / (real_t)(RAND_MAX / 10);                 b[x][y] = rand() / (real_t)(RAND_MAX / 10);                 c[x][y] = 3;             }         }          #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])         {             for (int x = 0; x < n; ++x){                 #pragma acc data copyin(c[x:1][0:n])                 {                     copyout_test(a[x], b[x], c[x]);                     for (int y = 0; y < n; ++y){                         if (fabs(c[x][y] - 3) > PRECISION){                             err += 1;                         }                     }                 }                 for (int y = 0; y < n; ++y){                     if (fabs(c[x][y] - 3) > PRECISION){                         err += 1;                     }                 }             }         }     }      return err; } #endif  #ifndef T4 //T4:declare,construct-independent,devonly,reference-counting,V:2.5-2.7 int test4(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 a[x][y] = rand() / (real_t)(RAND_MAX / 10);                 b[x][y] = rand() / (real_t)(RAND_MAX / 10);                 c[x][y] = 4;             }         }          #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])         {             for (int x = 0; x < n; ++x){                 #pragma acc data copy(c[x:1][0:n])                 {                     copyout_test(a[x], b[x], c[x]);                     for (int y = 0; y < n; ++y){                         if (fabs(c[x][y] - 4) > PRECISION){                             err += 1;                         }                     }                 }                 for (int y = 0; y < n; ++y){                     if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){                         err += 1;                     }                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture expr lshift x", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int* a, unsigned int* b, int length, int prev){     if (length == 0){         return true;     }     unsigned int *passed_a = (unsigned int *)malloc((length - 1) * sizeof(int));     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == (a[x]<<prev)){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(3 * n * sizeof(int));     int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};     int result;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 3; ++y){             a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));         }         b[x] = 0;     }      #pragma acc data copyin(a[0:3 * n]) copy(b[0:n]) copyout(c[0:3*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 3; ++y){                     #pragma acc atomic capture                         c[x * 3 + y] = b[x] = a[x * 3 + y] << b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 6; ++y){             result = 0;             for (int z = 0; z < 3; ++z){                 result = a[x * 3 + orders[y * 3 + z]] << result;             }             if (result == b[x]){                 break;             }         }         if (result != b[x]){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!(is_possible(&(a[x*3]), &(c[x*3]), 3, 0))){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic rshift equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1<<7;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic                             a[x] >>= 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<7){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature copy copyout", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1: , V:1.0-2.7 int test1(){     int err = 0;     real_t test = 0;     #pragma acc parallel loop copy(test) copyout(test) reduction(+:test)     for( int x = 0; x <n; ++x){         test += 1;     }      if(fabs(test - n) > PRECISION){         err++;     }      return err; } #endif  #ifndef T2 //T2: , V:1.0-2.7 int test2(){     int err = 0;     real_t *test = new real_t[n];      for(int x = 0; x < n; ++x){         test[x] = 1.0;     }     #pragma acc parallel loop copy(test[0:n]) copyout(test[0:n])    for(int x = 0; x < n; ++x){         test[x] += 1.0;    }     for(int x = 0; x < n; ++x){         if(fabs(test[x] - 2.0) > PRECISION){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for( int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test1();     }     if(failed){ \tfailcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for( int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }     if(failed){         failcode += (1 << 1);     } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature parallel create", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,data,data-region,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copy(c[0:n])     {         #pragma acc parallel create(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - c[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature declare function scope copyin", "completion": "#include \"acc_testsuite.h\" void function_test(real_t *a, real_t *b, real_t *c){     #pragma acc declare copyin(a[0:n], b[0:n])     #pragma acc parallel present(c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = c[x] + a[x] + b[x];         }     } }  void function_test_dev_only(real_t * a, real_t * b, real_t *c){     #pragma acc declare copyin(a[0:n], b[0:n])     #pragma acc parallel present(c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = c[x] + a[x] + b[x];             a[x] = -1;             b[x] = -1;         }     } }  #ifndef T1 //T1:declare,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));         b[x] = (real_t *)malloc(n * sizeof(real_t));         c[x] = (real_t *)malloc(n * sizeof(real_t));         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 1;         }     }      #pragma acc data copy(c[0:n][0:n])     {         for (int x = 0; x < n; ++x){             function_test(a[x], b[x], c[x]);         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:declare,construct-independent,devonly,reference-counting,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     int * devtest = (int *)malloc(sizeof(int));     real_t ** a_host = (real_t **)malloc(n * sizeof(real_t *));     real_t ** b_host = (real_t **)malloc(n * sizeof(real_t *));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a_host[x] = (real_t *)malloc(n * sizeof(real_t));             b_host[x] = (real_t *)malloc(n * sizeof(real_t));             for (int y = 0; y < n; ++y){                 a[x][y] = rand() / (real_t)(RAND_MAX / 10);                 a_host[x][y] = a[x][y];                 b[x][y] = rand() / (real_t)(RAND_MAX / 10);                 b_host[x][y] = b[x][y];                 c[x][y] = 0;             }         }          #pragma acc data copy(a[0:n][0:n], b[0:n][0:n], c[0:n][0:n])         {             for (int x = 0; x < n; ++x){                 function_test_dev_only(a[x], b[x], c[x]);             }         }          for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 if (fabs(a[x][y] + 1) > PRECISION){                     err += 1;                 }                 if (fabs(b[x][y] + 1) > PRECISION){                     err += 1;                 }                 if (fabs(c[x][y] - (a_host[x][y] + b_host[x][y])) > PRECISION){                     err += 1;                 }             }         }     }      return err; } #endif  #ifndef T3 //T3:declare,construct-independent,devonly,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     int * devtest = (int *)malloc(sizeof(int));     real_t ** a_host = (real_t **)malloc(n * sizeof(real_t *));     real_t ** b_host = (real_t **)malloc(n * sizeof(real_t *));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 a[x][y] = rand() / (real_t)(RAND_MAX / 10);                 a_host[x][y] = a[x][y];                 b[x][y] = rand() / (real_t)(RAND_MAX / 10);                 b_host[x][y] = b[x][y];                 c[x][y] = 1;             }         }          #pragma acc data copy(c[0:n][0:n])         {             for (int x = 0; x < n; ++x){                 function_test_dev_only(a[x], b[x], c[x]);             }         }          for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 if (fabs(a[x][y] - a_host[x][y]) > PRECISION){                     err += 1;                 }                 if (fabs(b[x][y] - b_host[x][y]) > PRECISION){                     err += 1;                 }                 if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){                     err += 1;                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign postincrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *c = new int[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];     bool found = false;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = distribution[(int) (a[x]*b[x]/10)];                     distribution[(int) (a[x]*b[x]/10)]++;                 }             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]++;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < distribution_comparison[x]; ++y){             for (int z = 0; z < n; ++z){                 if (c[z] == y && (int) (a[z]*b[z]/10) == x){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture iand expr x assign", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         INTEGER, INTENT(IN) :: init         INTEGER,DIMENSION(length), INTENT(IN) :: a         INTEGER,DIMENSION(length), INTENT(IN) :: b         INTEGER,DIMENSION(length - 1) :: passed_a         INTEGER,DIMENSION(length - 1) :: passed_b         INTEGER :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (b(x) .eq. iand(init, a(x))) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = b(x)             IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y, z !Iterators         INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER,DIMENSION(10):: passed_a, passed_b         INTEGER:: init         LOGICAL IS_POSSIBLE         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 10             DO z = 1, 8               IF (randoms(x, y, z) .lt. .933) THEN                 a(x, y) = a(x, y) + ISHFT(1, z - 1)               END IF             END DO           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT           DO y = 0, 7             totals(x) = totals(x) + ISHFT(1, y)             totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)           END DO         END DO          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   totals(x) = iand(a(x, y), totals(x))                   b(x, y) = totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = iand(totals_comparison(x), a(x, y))           END DO         END DO         DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           init = 0           DO y = 0, 7             init = init + ISHFT(1, y)           END DO           IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction add general type check pt2", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned short int * a = (unsigned short int*)malloc(n * sizeof(unsigned short int));     unsigned short int * b = (unsigned short int *)malloc(n * sizeof(unsigned short int));     unsigned short int total = 10;     unsigned short int host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (host_total != total) {         err += 1;     }      return err; } #endif   #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(n * sizeof(unsigned int));     unsigned int total = 10;     unsigned int host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (host_total != total) {         err += 1;     }      return err; } #endif  #ifndef T3 //T3:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test3(){     int err = 0;     srand(SEED);     unsigned long int * a = (unsigned long int *)malloc(n * sizeof(unsigned long int));     unsigned long int * b = (unsigned long int *)malloc(n * sizeof(unsigned long int));     unsigned long int total = 10;     unsigned long int host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (host_total != total) {         err += 1;     }      return err; } #endif  #ifndef T4 //T4:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test4(){     int err = 0;     srand(SEED);     unsigned long long int * a = (unsigned long long int *)malloc(n * sizeof(unsigned long long int));     unsigned long long int * b = (unsigned long long int *)malloc(n * sizeof(unsigned long long int));     unsigned long long int total = 10;     unsigned long long int host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }          if (total != host_total) {         err += 1;     }      return err; } #endif  #ifndef T5 //T5:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test5(){     int err = 0;     srand(SEED);     float * a = (float *)malloc(n * sizeof(float));     float * b = (float *)malloc(n * sizeof(float));     float total = 10;     float host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (fabsf(total - host_total) > PRECISION) {         err += 1;     }      return err; } #endif  #ifndef T6 //T6:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test6(){     int err = 0;     srand(SEED);     double * a = (double *)malloc(n * sizeof(double));     double * b = (double *)malloc(n * sizeof(double));     double total = 10;     double host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (fabs(host_total - total) > PRECISION) {         err += 1;     }      return err; } #endif  #ifndef T7 //T7:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test7(){     int err = 0;     srand(SEED);     long double * a = (long double *)malloc(n * sizeof(long double));     long double * b = (long double *)malloc(n * sizeof(long double));     long double total = 10;     long double host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }          #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x){             total += a[x] + b[x];         }     }          for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (fabsl(host_total - total) > PRECISION) {         err += 1;     }      return err; } #endif  #ifndef T8 //T8:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test8(){     int err = 0;     srand(SEED);     float _Complex * a = (float _Complex *)malloc(n * sizeof(float _Complex));     float _Complex * b = (float _Complex *)malloc(n * sizeof(float _Complex));     float _Complex total = 10 + 10 * I;     float _Complex host_total = 10 + 10 * I;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;         b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (fabsf(crealf(total) - crealf(host_total)) > PRECISION) {         err += 1;     }     if (fabsf(cimagf(total) - cimagf(host_total)) > PRECISION) {         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif #ifndef T6     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test6();     }     if (failed != 0){         failcode = failcode + (1 << 5);     } #endif #ifndef T7     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test7();     }     if (failed != 0){         failcode = failcode + (1 << 6);     } #endif #ifndef T8     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test8();     }     if (failed != 0){         failcode = failcode + (1 << 7);     } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature atomic structured bitand equals assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == (prev & a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;       for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] &= a[x];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] &= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }      for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine bind prototype lambda string function", "completion": "#include \"acc_testsuite.h\"  //test 1 host lambda auto host_array_array = [](real_t * a, long long n){     #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; };  //test 2 host lambda auto host_object_array = [](data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned += a->data[x];     }     return returned; };  //test 3 host lambda auto host_array_object = [](real_t * a, long long n){    #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; };  //test 4 host lambda auto host_object_object = [](data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned += a->data[x];     }     return returned; };  #pragma acc routine(host_array_array) vector bind(\"device_array_array\") #pragma acc routine(host_object_array) vector bind(\"device_object_array\") #pragma acc routine(host_array_object) vector bind(\"device_array_object\") #pragma acc routine(host_object_object) vector bind(\"device_object_object\")  //test 1 device function real_t device_array_array(real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  //test 2 device function real_t device_object_array(data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned -= a->data[x];     }     return returned; }  //test 3 device function real_t device_array_object(real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  //test 4 device function real_t device_object_object(data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; }  #ifndef T1 //T1:routine,V:2.7-3.3 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){        \ta[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_array_array(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_array(a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_array(a, n) - b[x]) > PRECISION)){             err += 1;         }     }     delete[] a;     delete[] b;      return err; } #endif #ifndef T2 //T2:routine,V:2.7-3.3 int test2(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a, a.data[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_object_array(&a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_array(&a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_array(&a, n) - b[x]) > PRECISION)){             err += 1;         }     }      delete[] b;      return err; } #endif #ifndef T3 //T3:routine,V:2.7-3.3 int test3(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b, b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_array_object(a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_object(a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_object(a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      delete[] a;      return err; } #endif #ifndef T4 //T4:routine,V:2.7-3.3 int test4(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a, a.data[0:n], b ,b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_object_object(&a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_object(&a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_object(&a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed = 0; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }      if(failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }      if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }      if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test4();     }      if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop gang blocking", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     real_t multiplyer = 1;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])     {       #pragma acc serial       {         #pragma acc loop gang         for (int x = 0; x < n; ++x){           c[x] = (a[x] + b[x]) * multiplyer;         }         multiplyer += 1;         #pragma acc loop gang         for (int x = 0; x < n; ++x){           c[x] += (a[x] + b[x]) * multiplyer;         }       }     }      for (int x = 0; x < n; ++x){       if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){         err + 1;         break;       }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc memcpy to device async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];     real_t *e = new real_t[n];     real_t *f = new real_t[n];      real_t *a_host = new real_t[n];     real_t *b_host = new real_t[n];     real_t *d_host = new real_t[n];     real_t *e_host = new real_t[n];      real_t *hostdata = new real_t[6 * n];     real_t *devdata;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 1;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 2;          a_host[x] = a[x];         b_host[x] = b[x];         d_host[x] = d[x];         e_host[x] = e[x];     }      devdata = reinterpret_cast<real_t*>(acc_create(hostdata, 6 * n * sizeof(real_t)));      acc_memcpy_to_device_async(devdata, a, n * sizeof(real_t), 1);     acc_memcpy_to_device_async(&(devdata[n]), b, n * sizeof(real_t), 2);     acc_memcpy_to_device_async(&(devdata[2*n]), c, n * sizeof(real_t), 3);     acc_memcpy_to_device_async(&(devdata[3*n]), d, n * sizeof(real_t), 4);     acc_memcpy_to_device_async(&(devdata[4*n]), e, n * sizeof(real_t), 5);     acc_memcpy_to_device_async(&(devdata[5*n]), f, n * sizeof(real_t), 6);      #pragma acc data deviceptr(devdata)     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[x] = devdata[x] * devdata[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[n + x] = devdata[n + x] * devdata[n + x];             }         }         #pragma acc parallel async(4)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[3*n + x] = devdata[3*n + x] * devdata[3*n + x];             }         }         #pragma acc parallel async(5)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[4*n + x] = devdata[4*n + x] * devdata[4*n + x];             }         }         #pragma acc parallel async(3) wait(1, 2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[2*n + x] += devdata[x] + devdata[n + x];             }         }         #pragma acc parallel async(6) wait(4, 5)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[5*n + x] += devdata[3*n + x] + devdata[4*n + x];             }         }     }      #pragma acc update host(hostdata[2*n:n]) async(3)     #pragma acc update host(hostdata[5*n:n]) async(6)      #pragma acc wait(3)     for (int x = 0; x < n; ++x){         if (fabs(hostdata[2*n + x] - (1 + a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4 * PRECISION){             err += 1;         }     }      #pragma acc wait(6)     for (int x = 0; x < n; ++x){         if (fabs(hostdata[5*n + x] - (2 + d_host[x] * d_host[x] + e_host[x] * e_host[x])) > PRECISION){             err += 1;         }     }      #pragma acc exit data delete(hostdata[0:6*n])      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop independent", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,combined-constructs,V:2.7-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel loop independent         for (int x = 0; x < n; ++x){             b[x] = a[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitor loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int host_c;      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             b[x * n + y] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);             b_copy[x * n + y] = b[x * n + y];             for (int z = 0; z < 16; ++z){                 a[x * n + y] += (1<<z);             }         }     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(|:temp)             for (int y = 0; y < n; ++y){                 temp = temp | a[x * n + y];             }             c[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 b[x * n + y] = b[x * n + y] + c[x];             }         }     }     for (int x = 0; x < 10; ++x){         host_c = a[x * n];         for (int y = 1; y < n; ++y){             host_c = host_c | a[x * n + y];         }         if (host_c != c[x]){             err += 1;         }         for (int y = 0; y < n; ++y){             if (b[x * n + y] != b_copy[x * n + y] + host_c){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(25 * sizeof(unsigned int));     unsigned int temp[5];      real_t false_margin = pow(exp(1), log(.5)/n);      for (int x = 0; x < 25 * n; ++x){         b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b_copy[x] = b[x];         for (int y = 0; y < 16; ++y) {             if (rand() / (real_t)RAND_MAX > false_margin) {                 a[x] += (1<<y);             }         }     }      #pragma acc data copyin(a[0:25*n]) copy(b[0:25*n], c[0:25])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 temp[y] = 0;             }             #pragma acc loop worker reduction(|:temp)             for (int y = 0; y < 5 * n; ++y) {                 temp[y%5] = temp[y%5] | a[x * 5 * n + y];             }             for (int y = 0; y < 5; ++y) {                 c[x * 5 + y] = temp[y];             }             #pragma acc loop worker             for (int y = 0; y < 5 * n; ++y) {                 b[x * 5 * n + y] = b[x * 5 * n + y] + c[x * 5 + (y % 5)];             }         }     }      for (int x = 0; x < 5; ++x){         for (int y = 0; y < 5; ++y){             temp[y] = 0;         }         for (int y = 0; y < 5 * n; ++y) {             temp[y%5] = temp[y%5] | a[x * 5 * n + y];         }         for (int y = 0; y < 5; ++y){             if (c[x * 5 + y] != temp[y]) {                 err += 1;             }         }         for (int y = 0; y < 5 * n; ++y) {             if ((b_copy[x * 5 * n + y] + c[x * 5 + (y % 5)]) != b[x * 5 * n + y]) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel", "completion": "#ifndef T1 !T1:parallel,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, i_a, i_b, i_c, i_d, i_e, i_f, i_g, i_h, i_i, i_j !Iterators         INTEGER, PARAMETER :: PRIVATE_LOOPCOUNT = 1024         REAL(8),DIMENSION(PRIVATE_LOOPCOUNT):: a, b, c !Data         INTEGER :: errors         errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(1:PRIVATE_LOOPCOUNT), b(1:PRIVATE_LOOPCOUNT)) copy(c(1:PRIVATE_LOOPCOUNT))           !$acc parallel             !$acc loop             DO i_a = 0, 1               !$acc loop               DO i_b = 0, 1                 !$acc loop                 DO i_c = 0, 1                   !$acc loop                   DO i_d = 0, 1                     !$acc loop                     DO i_e = 0, 1                       !$acc loop                       DO i_f = 0, 1                         !$acc loop                         DO i_g = 0, 1                           !$acc loop                           DO i_h = 0, 1                             !$acc loop                             DO i_i = 0, 1                               !$acc loop                               DO i_j = 0, 1                                 c(i_a*512 + i_b*256 + i_c*128 + i_d*64 + i_e*32 + i_f*16 + i_g*8 + i_h*4 + i_i*2 + i_j + 1) = &                                 a(i_a*512 + i_b*256 + i_c*128 + i_d*64 + i_e*32 + i_f*16 + i_g*8 + i_h*4 + i_i*2 + i_j + 1) + &                                 b(i_a*512 + i_b*256 + i_c*128 + i_d*64 + i_e*32 + i_f*16 + i_g*8 + i_h*4 + i_i*2 + i_j + 1)                               END DO                             END DO                           END DO                         END DO                       END DO                     END DO                   END DO                 END DO               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, PRIVATE_LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature data create zero", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,data-region,V:3.0-3.2 int test1(){     int err = 0;     srand(SEED);      real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 1;     }      #pragma acc data copyin(a[0:n]) create(zero: b[0:n]) copyout(b[0:n])     {       #pragma acc parallel       {         #pragma acc loop         {           for (int x = 0; x < n; ++x){             b[x] += a[x];           }         }       }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int testrun;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif   return failcode; }"}
{"prompt": "Create a test for the feature acc wait any", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,async,wait,V:3.2-3.3 int test1() {      int err = 0;     srand(SEED);      real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));       for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = (a[x] + 1) * 2 + (b[x] + 1) * 2;     }          real_t *list[3] = {a, b, c};      #pragma acc data copyin(list[0:3][0:n])     {         int queues[10];         for (int i = 0; i < 2; i++)         {             // Do some unbalanced operation on several queues             #pragma acc enter data copyin(list[i]) async(i)                          // Put the queue number in the queues list             queues[i] = i;              #pragma acc parallel loop async(i)             for(int k = 0; k < n; k++) {                 list[i][k]++;             }         }         int next;         // Look for queue that is ready to process         while ((next = acc_wait_any(3, queues)) >= 0)         {             // Remove this queue from consideration next time around             queues[next] = acc_async_sync;                          // Process work dependent on above             #pragma acc kernels             {                 for(int i = 0; i < n; i++)                 {                     list[next][i] = list[next][i] * 2;                 }             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop", "completion": "#ifndef T1 !T1:serial,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   REAL(8),DIMENSION(LOOPCOUNT):: a, b, c   INTEGER:: x   INTEGER:: errors    errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 0    !$acc data copy(c(1:LOOPCOUNT))     !$acc serial loop     DO x = 1, LOOPCOUNT       c(x) = 1     END DO   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(c(x) - 1) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO    !$acc data copy(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))     !$acc serial       !$acc loop       DO x = 1, LOOPCOUNT         c(x) = b(x)       END DO       !$acc loop       DO x = 1, LOOPCOUNT         c(x) = c(x) + a(x)       END DO     !$acc end serial   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction and general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = new char[n];     real_t false_margin = pow(exp(1), log(.5)/n);     char result = 1;     char found = 0;      for (int x = 0; x < n; ++x){         if(rand() / (real_t)(RAND_MAX) < false_margin){             a[x] = 1;         }         else{             a[x] = 0;         }     }      #pragma acc data copyin(a[0:n])     {         #pragma acc serial loop reduction(&&:result)         for (int x = 0; x < n; ++x){             result = result && a[x];         }     }      for (int x = 0; x < n; ++x){         if (a[x] == 0){             found = 1;             break;         }     }     if (found == result){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine bind prototype function string function", "completion": "#include \"acc_testsuite.h\"  //test 1 host function real_t host_array_array(real_t * a, long long n){     #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  //test 2 host function real_t host_object_array(data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned += a->data[x];     }     return returned; }  //test 3 host function real_t host_array_object(real_t * a, long long n){    #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  //test 4 host function real_t host_object_object(data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned += a->data[x];     }     return returned; }   #pragma acc routine(host_array_array) vector bind(\"device_array_array\") #pragma acc routine(host_object_array) vector bind(\"device_object_array\") #pragma acc routine(host_array_object) vector bind(\"device_array_object\") #pragma acc routine(host_object_object) vector bind(\"device_object_object\")  //test 1 device function real_t device_array_array(real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  //test 2 device function real_t device_object_array(data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned -= a->data[x];     }     return returned; }  //test 3 device function real_t device_array_object(real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  //test 4 device function real_t device_object_object(data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; }   #ifndef T1 //T1:routine,V:2.7-3.3 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){        \ta[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_array_array(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_array(a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_array(a, n) - b[x]) > PRECISION)){             err += 1;         }     }     delete[] a;     delete[] b;      return err; } #endif #ifndef T2 //T2:routine,V:2.7-3.3 int test2(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a, a.data[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_object_array(&a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_array(&a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_array(&a, n) - b[x]) > PRECISION)){             err += 1;         }     }      delete[] b;      return err; } #endif #ifndef T3 //T3:routine,V:2.7-3.3 int test3(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b, b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_array_object(a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_object(a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_object(a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      delete[] a;      return err; } #endif #ifndef T4 //T4:routine,V:2.7-3.3 int test4(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a, a.data[0:n], b ,b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_object_object(&a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_object(&a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_object(&a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      return err; } #endif int main(){     int failcode = 0;     int failed = 0; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }      if(failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }      if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }      if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test4();     }      if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel scalar default firstprivate", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,data,data-region,default-mapping,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t scalar = rand() / (real_t)(RAND_MAX / 10);     real_t scalar_copy = scalar;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x] + scalar;             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - (a[x] + scalar_copy)) > PRECISION){             err += 1;         }     }     if (fabs(scalar_copy - scalar) > PRECISION){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured multiply equals assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] * prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t * passed_ab = new real_t[10];     real_t * passed_c = new real_t[10];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x%(n/10 + 1)] *= a[x] + b[x];                     c[x] = totals[x%(n/10 + 1)];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop auto", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,auto,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * a_copy = new real_t[n];     real_t * b = new real_t[n];     real_t rolling_total = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {       #pragma acc serial loop auto       for (int x = 0; x < n; ++x){         b[x] = a[x];       }     }      for (int x = 0; x < n; ++x){       if (fabs(b[x] - a[x]) > PRECISION){         err = 1;       }     }      return err; } #endif  #ifndef T2 //T2:serial,loop,combined-constructs,V:2.6-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * a_copy = new real_t[n];     real_t * b = new real_t[n];     real_t rolling_total = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         a_copy[x] = a[x];     }      #pragma acc data copy(a[0:n])     {       #pragma acc serial loop auto       for (int x = 1; x < n; ++x){         a[x] = a[x - 1] + a[x];       }     }      for (int x = 0; x < n; ++x){       rolling_total += a_copy[x];       if (fabs(rolling_total - a[x]) > PRECISION){         err = 1;       }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine bind nonprototype lambda string lambda", "completion": "#include \"acc_testsuite.h\"  //test 1 host lambda #pragma acc routine vector bind(\"device_array_array\") auto host_array_array = [](real_t * a, long long n){     #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; };  //test 1 device lambda auto device_array_array = [](real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; };  //test 2 host lambda #pragma acc routine vector bind(\"device_object_array\") auto host_object_array= [](data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned += a->data[x];     }     return returned; };  //test 2 device lambda auto device_object_array = [](data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; };  //test 3 host lambda #pragma acc routine vector bind(\"device_array_object\") auto host_array_object = [](real_t * a, long long n){    #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; };  //test 3 device lambda auto device_array_object = [](real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; };  //test 4 host lambda #pragma acc routine vector bind(\"device_object_object\") auto host_object_object = [](data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned += a->data[x];     }     return returned; };  //test 4 device lambda auto device_object_object = [](data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; };  #ifndef T1 //T1:routine,V:2.7-3.3 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){        \ta[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_array_array(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_array(a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_array(a, n) - b[x]) > PRECISION)){             err += 1;         }     }     delete[] a;     delete[] b;      return err; } #endif #ifndef T2 //T2:routine,V:2.7-3.3 int test2(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a, a.data[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_object_array(&a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_array(&a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_array(&a, n) - b[x]) > PRECISION)){             err += 1;         }     }      delete[] b;      return err; } #endif #ifndef T3 //T3:routine,V:2.7-3.3 int test3(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b, b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_array_object(a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_object(a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_object(a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      delete[] a;      return err; } #endif #ifndef T4 //T4:routine,V:2.7-3.3 int test4(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a, a.data[0:n], b ,b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_object_object(&a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_object(&a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_object(&a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed = 0; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }      if(failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }      if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }      if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test4();     }      if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature set device num", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,set,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(:, :),ALLOCATABLE :: host_copy         REAL(8) :: RAND         INTEGER :: errors = 0         INTEGER :: temp          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          ALLOCATE(host_copy(acc_get_num_devices(acc_get_device_type()), LOOPCOUNT))          IF (acc_get_device_type() .ne. acc_device_none) THEN           !host_copy(acc_get_num_devices(acc_get_device_type()), LOOPCOUNT)           DO x = 1, acc_get_num_devices(acc_get_device_type())             CALL RANDOM_NUMBER(a)             host_copy(x, :) = a             !$acc set device_num(x)             !$acc enter data copyin(a(1:LOOPCOUNT))           END DO            DO x = 1, acc_get_num_devices(acc_get_device_type())             !$acc set device_num(x)             !$acc data present(a(1:LOOPCOUNT))               !$acc parallel                 !$acc loop                 DO y = 1, LOOPCOUNT                   a(y) = a(y) + 1                 END DO               !$acc end parallel             !$acc end data           END DO            DO x = 1, acc_get_num_devices(acc_get_device_type())             !$acc set device_num(x)             !$acc exit data copyout(a(1:LOOPCOUNT))             temp = errors             DO y = 1, LOOPCOUNT               IF (abs(a(y) - (host_copy(x, y) + 1)) .gt. PRECISION) THEN                 PRINT*, a(y)                 PRINT*, host_copy(x, y)                 errors = errors + 1               END IF             END DO             IF (temp .ne. errors) THEN               PRINT*, x             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction bitor vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));     unsigned int b_host;      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;      for (int x = 0; x < 10 * n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX > false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }     temp = 0;     #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(|:temp)             for (int y = 0; y < n; ++y){                 temp = temp | a[x * n + y];             }             b[x] = temp;         }     }      for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host | a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction and vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = new char[10 * n];     char * b = new char[10];     char * has_false = new char[10];     real_t false_margin = pow(exp(1), log(.5)/n);      for (int x = 0; x < 10; ++x){         has_false[x] = 0;     }     for (int x = 0; x < 10 * n; ++x){         if(rand() / (real_t)(RAND_MAX) < false_margin){             a[x] = 1;         }         else{             a[x] = 0;             has_false[x/n] = 1;         }     }     char temp = 1;     #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc kernels loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop vector reduction(&&:temp)             for (int y = 0; y < n; ++y){                 temp = temp && a[x * n + y];             }             b[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         if (has_false[x] == b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitor general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int b = 0;     unsigned int host_b;      for (int x = 0; x < n; ++x){         a[x] = 0;         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX > false_margin){                 a[x] += 1 << y;             }         }     }      #pragma acc data copyin(a[0:n])     {         #pragma acc parallel loop reduction(|:b)         for (int x = 0; x < n; ++x){             b = b | a[x];         }     }      host_b = a[0];     for (int x = 1; x < n; ++x){         host_b = host_b | a[x];     }      if (b != host_b){         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(5 * n * sizeof(unsigned int));     real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int b[5];     unsigned int host_b[5];      for (int x = 0; x < 5 * n; ++x){         a[x] = 0;         for (int y = 0; y < 16; ++y) {             if (rand() / (real_t) RAND_MAX > false_margin) {                 a[x] += 1 << y;             }         }     }      for (int x = 0; x < 5; ++x) {         b[x] = 0;         host_b[x] = 0;     }      #pragma acc data copyin(a[0:5*n])     {         #pragma acc parallel loop reduction(|:b)         for (int x = 0; x < 5 * n; ++x) {             b[x%5] = b[x%5] | a[x];         }     }      for (int x = 0; x < 5 * n; ++x){         host_b[x%5] = host_b[x%5] | a[x];     }      for (int x = 0; x < 5; ++x) {         if (host_b[x] != b[x]) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture bitxor equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == (a[x] ^ prev)){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int * temp_a = new int[10];     int * temp_b = new int[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .5){                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     b[x] = totals[x%(n/10 + 1)] ^= a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] ^= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (temp_iterator = 0, ab_iterator = x; ab_iterator < n; temp_iterator++, ab_iterator += n/10 + 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!(is_possible(temp_a, temp_b, temp_iterator, 0))){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction multiply loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10 * n];     real_t * totals = new real_t[10];     real_t temp;      for (int x = 0; x < n; ++x){         a[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;         b[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;         c[x] = 0.0;     }       #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10*n]) copy(totals[0:10])     {         #pragma acc kernels loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop worker reduction(*:temp)             for (int y = 0; y < n; ++y){                 temp *= a[x * n + y] + b[x * n + y];             }             totals[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 c[x * n + y] = (a[x * n + y] + b[x * n + y]) / totals[x];             }         }     }      for (int x = 0; x < 10; ++x){         temp = 1;         for (int y = 0; y < n; ++y){             temp *= a[x * n + y] + b[x * n + y];         }         if (fabs(temp - totals[x]) > (temp / 2 + totals[x] / 2) * PRECISION){             err += 1;         }         for (int y = 0; y < n; ++y){             if (fabs(c[x * n + y] - ((a[x * n + y] + b[x * n + y]) / totals[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured bitor equals assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == (prev | a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] |= a[x];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] |= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic bitxor equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .5){                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] ^= a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] ^= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature shutdown device type num", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:shutdown,runtime,syntactic,V:2.5-3.2 int test1(){     int err = 0;     int device_num;      device_num = acc_get_device_num(acc_get_device_type());     #pragma acc shutdown device_type(host) device_num(device_num)      return err; } #endif #ifndef T2 //T2:shutdown,runtime,syntactic,V:2.5-3.2 int test2(){     int err = 0;     int device_num;      device_num = acc_get_device_num(acc_get_device_type());     #pragma acc shutdown device_type(multicore) device_num(device_num)      return err; } #endif #ifndef T3 //T3:shutdown,runtime,syntactic,V:2.5-3.2 int test3(){     int err = 0;     int device_num;      device_num = acc_get_device_num(acc_get_device_type());     #pragma acc shutdown device_type(default) device_num(device_num)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x minus expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_host[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%10] = totals[x%10] - (a[x] + b[x]);             }         }     }       for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitand vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int c = 0;     unsigned int b_host;      for (int x = 0; x < 10 * n; ++x){         a[x] = 0;         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX < false_margin){                 a[x] += 1 << y;             }         }     }      #pragma acc data copyin(a[0:10*n]) copyout(b[0:10])     {         #pragma acc parallel loop private(c)         for (int x = 0; x < 10; ++x){             c = a[x * n];             #pragma acc loop vector reduction(&:c)             for (int y = 1; y < n; ++y){                 c = c & a[x * n + y];             }             b[x] = c;         }     }     for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host & a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));     real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int c[5];     unsigned int * b_host = (unsigned int *)malloc(5 * sizeof(unsigned int));           for (int x = 0; x < 25 * n; ++x){         a[x] = 0;         for (int y = 0; y < 16; ++y) {             if (rand() / (real_t)RAND_MAX < false_margin) {                 a[x] += 1 << y;             }         }     }      #pragma acc data copyin(a[0:25*n]) copyout(b[0:25])     {         #pragma acc parallel loop private(c)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 c[y] = a[x * 5 * n + y];             }             #pragma acc loop vector reduction(&:c)             for (int y = 0; y < 5 * n; ++y) {                 c[y%5] = c[y%5] & a[x * 5 * n + y];             }             for (int y = 0; y < 5; ++y) {                 b[x * 5 + y] = c[y];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             b_host[y] = a[x * 5 * n + y];         }         for (int y = 0; y < 5 * n; ++y) {             b_host[y%5] = b_host[y%5] & a[x * 5 * n + y];         }         for (int y = 0; y < 5; ++y) {             if (b_host[y] != b[x * 5 + y]){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine bind nonprototype function string function", "completion": "#include \"acc_testsuite.h\"  //test 1 host function #pragma acc routine vector bind(\"device_array_array\") real_t host_array_array(real_t * a, long long n){     #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  //test 1 device function real_t device_array_array(real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  //test 2 host function #pragma acc routine vector bind(\"device_object_array\") real_t host_object_array(data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned += a->data[x];     }     return returned; }  //test 2 device function real_t device_object_array(data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; }  //test 3 host function #pragma acc routine vector bind(\"device_array_object\") real_t host_array_object(real_t * a, long long n){    #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  //test 3 device function real_t device_array_object(real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  //test 4 host function #pragma acc routine vector bind(\"device_object_object\") real_t host_object_object(data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned += a->data[x];     }     return returned; }  //test 4 device function real_t device_object_object(data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; }  #ifndef T1 //T1:routine,V:2.7-3.3 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){        \ta[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_array_array(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_array(a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_array(a, n) - b[x]) > PRECISION)){             err += 1;         }     }     delete[] a;     delete[] b;      return err; } #endif #ifndef T2 //T2:routine,V:2.7-3.3 int test2(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a, a.data[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_object_array(&a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_array(&a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_array(&a, n) - b[x]) > PRECISION)){             err += 1;         }     }      delete[] b;      return err; } #endif #ifndef T3 //T3:routine,V:2.7-3.3 int test3(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b, b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_array_object(a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_object(a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_object(a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      delete[] a;      return err; } #endif #ifndef T4 //T4:routine,V:2.7-3.3 int test4(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a, a.data[0:n], b ,b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_object_object(&a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_object(&a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_object(&a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      return err; } #endif int main(){     int failcode = 0;     int failed = 0; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }      if(failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }      if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }      if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test4();     }      if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture expr bitand x", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == (a[x] & prev)){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *passed_a = new int[10];     int *passed_b = new int[10];     int passed_total = 0;     int absolute_indexer;     int passed_indexer;      for (int x = 0; x < n; ++x){ \tfor (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0; \tfor (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                      b[x] = totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] &= a[x];     }      for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < 8; ++x){         passed_total += 1<<x;     }     for (int x = 0; x < (n/10 + 1); ++x){         for (absolute_indexer = x, passed_indexer = 0; absolute_indexer < n; absolute_indexer += (n/10 + 1), passed_indexer++){             passed_a[passed_indexer] = a[absolute_indexer];             passed_b[passed_indexer] = b[absolute_indexer];         }         if (!is_possible(passed_a, passed_b, passed_indexer, passed_total)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr divided x", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(subset, destination, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8),DIMENSION(length), INTENT(IN) :: subset         REAL(8), INTENT(IN) :: destination         REAL(8), INTENT(IN) :: init         REAL(8),ALLOCATABLE :: passed(:)         LOGICAL :: POSSIBLE         INTEGER :: x, y         IF (length .gt. 0) THEN           ALLOCATE(passed(length - 1))         ELSE           IF (abs(init - destination) .gt. PRECISION) THEN             POSSIBLE = .TRUE.           ELSE             POSSIBLE = .FALSE.           END IF           RETURN         END IF         POSSIBLE = .FALSE.         DO x = 1, length           DO y = 1, x - 1             passed(y) = subset(y)           END DO           DO y = x + 1, length             passed(y - 1) = subset(y)           END DO           IF (IS_POSSIBLE(passed, destination, length - 1, subset(x) / init)) THEN             POSSIBLE = .TRUE.             RETURN           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals         REAL(8),DIMENSION(10):: passed         INTEGER :: errors = 0         LOGICAL IS_POSSIBLE          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = a(x, y) / totals(x)               END DO             END DO           !$acc end parallel         !$acc end data           DO x = 1, LOOPCOUNT           DO y = 1, 10             passed(y) = a(x, y)           END DO           IF (IS_POSSIBLE(passed, totals(x), 10, 1) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured x plus expr assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] + prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] + (a[x] * b[x]);                     c[x] = totals[x%(n/10 + 1)];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] += a[x] * b[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){             passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x minus expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[10];     real_t *totals_host = new real_t[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_host[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%10] = totals[x%10] - (a[x] + b[x]);             }         }     }       for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop gang blocking", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t multiplyer = 1;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])     {       #pragma acc serial       {         #pragma acc loop gang         for (int x = 0; x < n; ++x){           c[x] = (a[x] + b[x]) * multiplyer;         }         multiplyer += 1;         #pragma acc loop gang         for (int x = 0; x < n; ++x){           c[x] += (a[x] + b[x]) * multiplyer;         }       }     }      for (int x = 0; x < n; ++x){       if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){         err + 1;         break;       }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured expr bitxor x assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == (prev ^ a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] = a[x] ^ totals[x/10];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] ^= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels create", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data,data-region,devonly,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     int * devtest = (int *)malloc(sizeof(int));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {       devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){           a[x] = rand() / (real_t)(RAND_MAX / 10);           b[x] = 0.0;         }          #pragma acc data copyin(a[0:n])         {             #pragma acc kernels create(b[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = a[x];                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(b[x]) > PRECISION){                 err += 1;             }         }      }      return err; } #endif  #ifndef T2 //T2:kernels,data,data-region,reference-counting,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc kernels create(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:kernels,data,data-region,V:1.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copyout(c[0:n])     {         #pragma acc kernels create(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - a[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic minus equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[10];     real_t *totals_host = new real_t[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_host[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%10] -= (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction add loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,combined-constructs,reduction,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));     real_t avg = 0.0;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) create(c[0:10*n]) copyout(d[0:10*n])     {         #pragma acc kernels loop gang private(avg)         for (int x = 0; x < 10; ++x){             avg = 0;             #pragma acc loop worker reduction(+:avg)             for (int y = 0; y < n; ++y){                 avg += c[x * n + y] = a[x * n + y] + b[x * n + y];             }             avg = avg / n;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 d[x * n + y] = c[x * n + y] - avg;             }         }     }      real_t rolling_total = 0;      for (int x = 0; x < 10; ++x){         rolling_total = 0;         for (int y = 0; y < n; ++y){             rolling_total += a[x * n + y] + b[x * n + y];         }         rolling_total = rolling_total / n;         for (int y = 0; y < n; ++y){             if (fabs(d[x * n + y] - ((a[x * n + y] + b[x * n + y]) - rolling_total)) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction and loop", "completion": "#ifndef T1 !T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8):: false_margin   REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms   LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, a_copy   LOGICAL,DIMENSIOn(10):: has_false   LOGICAL:: temp   INTEGER:: x, y   errors = 0   false_margin = EXP(LOG(.5) / LOOPCOUNT)    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)    has_false = .FALSE.   a = .TRUE.   DO y = 1, 10     DO x = 1, LOOPCOUNT       IF (randoms(x, y) .gt. false_margin) THEN         a(x, y) = .FALSE.         has_false(y) = .TRUE.       END IF     END DO   END DO   a_copy = a    !$acc data copy(a(1:LOOPCOUNT, 1:10))     !$acc serial loop gang private(temp)     DO y = 1, 10       temp = .TRUE.       !$acc loop worker reduction(.AND.:temp)       DO x = 1, LOOPCOUNT         temp = temp .AND. a(x, y)       END DO       !$acc loop worker       DO x = 1, LOOPCOUNT         IF (temp) THEN           IF (a(x, y) .eq. 1) THEN             a(x, y) = .FALSE.           ELSE             a(x, y) = .TRUE.           END IF         END IF       END DO     END DO   !$acc end data    DO y = 1, 10     DO x = 1, LOOPCOUNT       IF ((has_false(y) .eqv. .TRUE.) .AND. (a(x, y) .neqv. a_copy(x, y))) THEN         errors = errors + 1       ELSEIF ((has_false(y) .eqv. .FALSE.) .AND. (a(x, y) .eqv. a_copy(x, y))) THEN         errors = errors + 1       END IF     END DO   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update expr divided x", "completion": "#include \"acc_testsuite.h\" bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){     if (length == 0){         if (fabs(current_value - test_value) > PRECISION){             return true;         }         else {             return false;         }     }     real_t * passed = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         for (int y = 0; y < x; ++y){             passed[y] = remaining_combinations[y];         }         for (int y = x + 1; y < length; ++y){             passed[y - 1] = remaining_combinations[y];         }         if (possible_result(passed, length - 1, remaining_combinations[x] / current_value, test_value)){             free(passed);             return true;         }     }     free(passed);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed = (real_t *)malloc(10 * sizeof(real_t));     int indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];             }         }     }       for (int x = 0; x < (n/10 + 1); ++x){         indexer = x;         while (indexer < n){             passed[indexer/(n/10 + 1)] = (a[x] + b[x]);             indexer += (n/10 + 1);         }         if (!(possible_result(passed, 10, 1, totals[x]))){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature declare function scope copyout", "completion": "#include \"acc_testsuite.h\" void copyout_test(real_t *a, real_t *b, real_t *c){     #pragma acc declare copyout(c[0:n])     #pragma acc parallel present(a[0:n], b[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     } }  #ifndef T1 //T1:declare,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];         b[x] = new real_t[n];         c[x] = new real_t[n];         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 1;         }     }     #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])     {         for (int x = 0; x < n; ++x){             copyout_test(a[x], b[x], c[x]);         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:declare,construct-independent,reference-counting,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 2;         }     }      #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])     {         for (int x = 0; x < n; ++x){             #pragma acc data copy(c[x:1][0:n])             {                 copyout_test(a[x], b[x], c[x]);             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T3 //T3:declare,construct-independent,devonly,reference-counting,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 a[x][y] = rand() / (real_t)(RAND_MAX / 10);                 b[x][y] = rand() / (real_t)(RAND_MAX / 10);                 c[x][y] = 3;             }         }          #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])         {             for (int x = 0; x < n; ++x){                 #pragma acc data copyin(c[x:1][0:n])                 {                     copyout_test(a[x], b[x], c[x]);                     for (int y = 0; y < n; ++y){                         if (fabs(c[x][y] - 3) > PRECISION){                             err += 1;                         }                     }                 }                 for (int y = 0; y < n; ++y){                     if (fabs(c[x][y] - 3) > PRECISION){                         err += 1;                     }                 }             }         }     }      return err; } #endif  #ifndef T4 //T4:declare,construct-independent,devonly,reference-counting,V:2.5-2.7 int test4(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 a[x][y] = rand() / (real_t)(RAND_MAX / 10);                 b[x][y] = rand() / (real_t)(RAND_MAX / 10);                 c[x][y] = 4;             }         }          #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])         {             for (int x = 0; x < n; ++x){                 #pragma acc data copy(c[x:1][0:n])                 {                     copyout_test(a[x], b[x], c[x]);                     for (int y = 0; y < n; ++y){                         if (fabs(c[x][y] - 4) > PRECISION){                             err += 1;                         }                     }                 }                 for (int y = 0; y < n; ++y){                     if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){                         err += 1;                     }                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured expr bitxor x assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == (prev ^ a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] = a[x] ^ totals[x/10];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] ^= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic min expr x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature declare function scope create", "completion": "#include \"acc_testsuite.h\" void create_test(real_t *a, real_t *b, real_t *c, real_t *d){     #pragma acc declare create(c[0:n])     #pragma acc parallel present(a[0:n], b[0:n], d[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }         #pragma acc loop         for (int x = 0; x < n; ++x){             d[x] = c[x] * a[x];         }     } }  void create_as_present(real_t *a, real_t *b, real_t *c, real_t *d){     #pragma acc declare create(c[0:n])     #pragma acc parallel present(a[0:n], b[0:n], d[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = c[x] + a[x] + b[x];         }         #pragma acc loop         for (int x = 0; x < n; ++x){             d[x] = c[x] * a[x];         }     } }  #ifndef T1 //T1:declare,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     real_t ** d = (real_t **)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];         b[x] = new real_t[n];         c[x] = new real_t[n];         d[x] = new real_t[n];         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 1;             d[x][y] = 0;         }     }     #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copyout(d[0:n][0:n])     {         for (int x = 0; x < n; ++x){             create_test(a[x], b[x], c[x], d[x]);         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             if (fabs(d[x][y] - (a[x][y] * (a[x][y] + b[x][y]))) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:declare,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     real_t ** d = (real_t **)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 2;             d[x][y] = 0;         }     }      #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copy(c[0:n][0:n]) copyout(d[0:n][0:n])     {         for (int x = 0; x < n; ++x){             create_as_present(a[x], b[x], c[x], d[x]);         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             if (fabs(c[x][y] - (2 + a[x][y] + b[x][y])) > PRECISION){                 err += 1;             }             if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){                 err += 1;             }         }     }      return err; } #endif  #ifndef T3 //T3:declare,construct-independent,devonly,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     real_t ** d = (real_t **)malloc(n * sizeof(real_t));     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 a[x][y] = rand() / (real_t)(RAND_MAX / 10);                 b[x][y] = rand() / (real_t)(RAND_MAX / 10);                 c[x][y] = 3;             }         }          #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])         {             for (int x = 0; x < n; ++x){                 #pragma acc data copyin(c[x:1][0:n]) copyout(d[x:1][0:n])                 {                     create_as_present(a[x], b[x], c[x], d[x]);                 }                 for (int y = 0; y < n; ++y){                     if (fabs(c[x][y] - 3) > PRECISION){                         err += 1;                     }                 }                 for (int y = 0; y < n; ++y){                     if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 2){                         err += 1;                     }                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x or expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = totals(x) .OR. a(x, y)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .OR. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels create", "completion": "#ifndef T1 !T1:devonly,kernels,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest         devtest(1) = 1          !$acc enter data copyin(devtest(1:1))         !$acc kernels present(devtest(1:1))           devtest(1) = 0         !$acc end kernels          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          IF (devtest(1) .eq. 1) THEN           CALL RANDOM_NUMBER(a)           b = 0           c = 0           !$acc data copyin(a(1:LOOPCOUNT))             !$acc kernels create(b(1:LOOPCOUNT))               !$acc loop               DO x = 1, LOOPCOUNT                 b(x) = a(x)               END DO             !$acc end kernels           !$acc end data           DO x = 1, LOOPCOUNT             IF (abs(b(x)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:devonly,kernels,V:2.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest         devtest(1) = 1          !$acc enter data copyin(devtest(1:1))         !$acc kernels present(devtest(1:1))           devtest(1) = 0         !$acc end kernels          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0         !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))           !$acc kernels create(b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = a(x)             END DO           !$acc end kernels         !$acc end data         DO x = 1, LOOPCOUNT           IF (abs(b(x) - a(x)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:devonly,kernels,V:2.0-2.7       LOGICAL FUNCTION test3()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest         devtest(1) = 1          !$acc enter data copyin(devtest(1:1))         !$acc kernels present(devtest(1:1))           devtest(1) = 0         !$acc end kernels          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0          !$acc data copyin(a(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))           !$acc kernels create(b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = a(x)             END DO             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = b(x)             END DO           !$acc end kernels         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - a(x)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel create zero", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //#T1:parallel,data,data_region,V:3.0-3.2 int Test1(){     int err=0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for( int x = 0; x < n; x++){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n]     {         #pragma acc parallel create(zero: b[0:n])         {             #pragma acc loop             {                 for(int x = 0; x < n; x++){                     b[x] += a[x];                 }             }         }     }     for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; }"}
{"prompt": "Create a test for the feature atomic expr bitand x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] &= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic divided equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] /= (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update expr lshift x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};     int result;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 3; ++y){             a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));         }         b[x] = 0;     }      #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 3; ++y){                     #pragma acc atomic update                         b[x] = a[x * 3 + y] << b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 6; ++y){             result = 0;             for (int z = 0; z < 3; ++z){                 result = a[x * 3 + orders[y * 3 + z]] << result;             }             if (result == b[x]){                 break;             }         }         if (result != b[x]){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels default copy", "completion": "#ifndef T1 !T1:devonly,kernels,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         LOGICAL,DIMENSION(1):: devtest         devtest(1) = .TRUE.          !$acc enter data copyin(devtest(1:1))         !$acc kernels           devtest(1) = .FALSE.         !$acc end kernels          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc kernels             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = c(x) + a(x) + b(x)             END DO           !$acc end kernels         !$acc end data         DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:devonly,kernels,V:2.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         LOGICAL,DIMENSION(1):: devtest         devtest(1) = .TRUE.          !$acc enter data copyin(devtest(1:1))         !$acc kernels           devtest(1) = .FALSE.         !$acc end kernels          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          IF (devtest(1)) THEN           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 1            !$acc enter data copyin(c(1:LOOPCOUNT))           c = 0           !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc kernels               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = c(x) + a(x) + b(x)               END DO             !$acc end kernels           !$acc end data           DO x = 1, LOOPCOUNT             IF (abs(c(x)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO           !$acc exit data copyout(c(1:LOOPCOUNT))           DO x = 1, LOOPCOUNT             IF (abs(c(x) - (a(x) + b(x) + 1)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial implicit data attributes", "completion": "#include \"acc_testsuite.h\"  #ifndef T1 //T1:serial,V:1.0-2.7 //copy cluase test with serial default(none) and reduction with scalar variables int test1(){ \tint err = 0; \tsrand(SEED); \tint temp = rand()/(real_t)(RAND_MAX / 10); \t#pragma acc serial default(none) reduction(+:temp) \tfor(int x = 0; x < n; ++x){ \t\ttemp += temp; \t} \tif(temp > PRECISION){ \t\terr = 1; \t} \treturn err; } #endif #ifndef T2 //T2:serial,V:1.0-2.7 //copy clause test with serial loop and reduction with scalar int test2(){ \tint err = 0; \tsrand(SEED); \tint temp = rand()/(real_t)(RAND_MAX / 10); \t#pragma acc serial loop reduction(+:temp) \tfor(int x = 0; x < n; ++x){ \t\ttemp += temp; \t} \tif(temp > PRECISION){ \t\terr = 1; \t} \treturn err; } #endif #ifndef T3 //T3:serial, firstprivate, V:1.0-2.7 //firstprivate test with only serial and reduction with scalar variables int test3(){ \tint err = 0; \tsrand(SEED); \tint host = rand()/(real_t)(RAND_MAX/10); \tint device = host; \t#pragma acc serial reduction(+:device) \tfor( int x = 0; x < n; ++x){ \t\tdevice += device; \t}  \tif( fabs(host - device) > PRECISION ){ \t\terr = 1; \t} \treturn err; } #endif #ifndef T4 //T4:serial, host_dataV:1.0-2.7 int test4(){ \tint err = 0; \tsrand(SEED);  \treal_t *host_array = (real_t *) malloc ( n *sizeof(real_t));         real_t *device_array = (real_t *) malloc ( n *sizeof(real_t));  \tfor( int x = 0; x < n; ++x){                 host_array[x] = rand()/ (real_t)(RAND_MAX/10);                 device_array[x] = host_array[x];         } \t \t#pragma acc serial loop \tfor ( int x = 0; x < n; ++x){ \t\tdevice_array[x] += device_array[x]; \t} \t \tfor( int x = 0; x < n; ++x){                 if(fabs(host_array[x]*2 - device_array[x]) > PRECISION){                         err = 1;                 }         }         free(host_array);         free(device_array);         return err; } #endif  int main(){ \tint failcode = 0; \tint failed; #ifndef T1 \tfailed = 0; \tfor( int x = 0; x < NUM_TEST_CALLS; ++x){ \t\tfailed += test1(); \t} \tif(failed){ \t\tfailcode += (1 << 0); \t} #endif #ifndef T2         failed = 0;         for( int x = 0; x < NUM_TEST_CALLS; ++x){                 failed += test2();         }         if(failed){                 failcode += (1 << 1); \t} #endif #ifndef T3         failed = 0;         for( int x = 0; x < NUM_TEST_CALLS; ++x){                 failed += test3();         }         if(failed){                 failcode += (1 << 2);         } #endif #ifndef T4         failed = 0;         for( int x = 0; x < NUM_TEST_CALLS; ++x){                 failed += test4();         }         if(failed){                 failcode += (1 << 3);         } #endif \treturn failcode; } "}
{"prompt": "Create a test for the feature atomic capture plus equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] + prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = totals[x%(n/10 + 1)] += a[x] * b[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] += a[x] * b[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){             passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel firstprivate", "completion": "#ifndef T1 !T1:parallel,firstprivate,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, d !Data         REAL(8),DIMENSION(LOOPCOUNT):: c, c_copy         REAL*8 :: RAND         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         CALL RANDOM_NUMBER(c)         c_copy = c         d = 0                  !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(d(1:10*LOOPCOUNT))           !$acc parallel firstprivate(c(1:LOOPCOUNT))             !$acc loop gang             DO x = 0, 9               !$acc loop worker               DO y = 1, LOOPCOUNT                 d(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y) + c(y)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 0, 9           DO y = 1, LOOPCOUNT             IF (abs(d(x * LOOPCOUNT + y) - (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y) + c(y))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:parallel,firstprivate,V:1.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, d !Data         REAL(8),DIMENSION(LOOPCOUNT):: c, c_copy         REAL*8 :: RAND         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         d = 0                  !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(d(1:10*LOOPCOUNT))           !$acc parallel firstprivate(c(1:LOOPCOUNT))             !$acc loop gang independent             DO x = 0, 9               !$acc loop worker independent               DO y = 1, LOOPCOUNT                 c(y) = a(x * LOOPCOUNT + y) - b(x * LOOPCOUNT + y)               END DO               !$acc loop worker independent               DO y = 1, LOOPCOUNT                 d(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y) + c(y)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, 10 * LOOPCOUNT           IF (abs(d(x) - (2 * a(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO                 IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc shutdown device", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:routine,shutdown,runtime,syntactic,V:3.2-3.3 int test1(){     int err = 0;      if (acc_get_device_type() != acc_device_none){         acc_shutdown_device(1, acc_get_device_type());     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature kernels loop reduction bitor loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int host_c;      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             b[x * n + y] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);             b_copy[x * n + y] = b[x * n + y];             for (int z = 0; z < 16; ++z){                 if (rand() / (real_t) RAND_MAX > false_margin){                     temp = 1;                     for (int i = 0; i < z; ++i){                         temp = temp * 2;                     }                     a[x * n + y] += temp;                 }             }         }     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])     {         #pragma acc kernels loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(|:temp)             for (int y = 0; y < n; ++y){                 temp = temp | a[x * n + y];             }             c[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 b[x * n + y] = b[x * n + y] + c[x];             }         }     }     for (int x = 0; x < 10; ++x){         host_c = a[x * n];         for (int y = 1; y < n; ++y){             host_c = host_c | a[x * n + y];         }         if (host_c != c[x]){             err += 1;         }         for (int y = 0; y < n; ++y){             if (b[x * n + y] != b_copy[x * n + y] + host_c){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitand loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));     unsigned int * host_c = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;      for (int x = 0; x < 10 * n; ++x){         a[x] = 0;         b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b_copy[x] = b[x];         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX < false_margin){                 a[x] += 1 << y;             }         }     }     #pragma acc data copyin(a[0:10 * n]) copy(b[0:10 * n], c[0:10])     {         #pragma acc parallel loop gang private(temp)         for (int y = 0; y < 10; ++y){             temp = a[y * n];             #pragma acc loop worker reduction(&:temp)             for (int x = 1; x < n; ++x){                 temp = temp & a[y * n + x];             }             c[y] = temp;             #pragma acc loop worker             for (int x = 0; x < n; ++x){                 b[y * n + x] = b[y * n + x] + c[y];             }         }     }     for (int x = 0; x < 10; ++x){         host_c[x] = a[x * n];         for (int y = 1; y < n; ++y){             host_c[x] = host_c[x] & a[x * n + y];         }         if (host_c[x] != c[x]){           err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (b[x * n + y] != b_copy[x * n + y] + c[x]){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(25 * sizeof(unsigned int));     unsigned int device[5];     unsigned int host[5];      real_t false_margin = pow(exp(1), log(.5)/n);          for (int x = 0; x < 25 * n; ++x){         a[x] = 0;         b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b_copy[x] = b[x];         for (int y = 0; y < 16; ++y) {             if (rand() / (real_t)RAND_MAX < false_margin) {                 a[x] += 1 << y;             }         }     }      #pragma acc data copyin(a[0:25*n]) copy(b[0:25*n], c[0:25])     {         #pragma acc parallel loop gang private(device)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 device[y] = a[x * 5 * n + y];             }             #pragma acc loop worker reduction(&:device)             for (int y = 0; y < 5 * n; ++y) {                 device[y%5] = device[y%5] & a[x * 5 * n + y];             }             for (int y = 0; y < 5; ++y) {                 c[x * 5 + y] = device[y];             }             #pragma acc loop worker             for (int y = 0; y < 5 * n; ++y) {                 b[x * 5 * n + y] = b[x * 5 * n + y] + c[x * 5 + (y % 5)];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             host[y] = a[x * 5 * n + y];         }         for (int y = 0; y < 5 * n; ++y) {             host[y%5] = host[y%5] & a[x * 5 * n + y];         }         for (int y = 0; y < 5; ++y) {             if (host[y] != c[x * 5 + y]) {                 err += 1;             }         }         for (int y = 0; y < 5 * n; ++y) {             if (b[x * 5 * n + y] != (host[y%5] + b_copy[x * 5 * n + y])) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic bitxor equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .5){                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] ^= a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] ^= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction or vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = new char[10 * n];     char * b = new char[10];     real_t false_margin = pow(exp(1), log(.5)/n);     char temp = 0;     char found;      for (int x = 0; x < 10 * n; ++x){         if(rand() / (real_t)(RAND_MAX) > false_margin){             a[x] = 1;         }         else{             a[x] = 0;         }     }     #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(||:temp)             for (int y = 0; y < n; ++y){                 temp = temp || a[x * n + y];             }             b[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         found = 0;         for (int y = 0; y < n; ++y){             if (a[x * n + y] &! 0){                 found = 1;             }         }         if (found != b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels if", "completion": "#ifndef T1 !T1:devonly,kernels,if,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0         LOGICAL,DIMENSION(1):: devtest         LOGICAL:: data_on_device = .FALSE.         devtest(1) = .TRUE.          !$acc enter data copyin(devtest(1:1))         !$acc kernels present(devtest(1:1))           devtest(1) = .FALSE.         !$acc end kernels          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0          !$acc kernels if(data_on_device) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc loop           DO x = 1, LOOPCOUNT             b(x) = a(x)           END DO         !$acc end kernels          DO x = 1, LOOPCOUNT           IF (abs(a(x) - b(x)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:devonly,kernels,if,V:2.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0         LOGICAL,DIMENSION(1):: devtest         LOGICAL:: data_on_device = .FALSE.         devtest(1) = .TRUE.          !$acc enter data copyin(devtest(1:1))         !$acc kernels present(devtest(1:1))           devtest(1) = .FALSE.         !$acc end kernels          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0          data_on_device = .TRUE.         !$acc enter data copyin(a(1:LOOPCOUNT)) create(b(1:LOOPCOUNT))         !$acc kernels if(data_on_device) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc loop           DO x = 1, LOOPCOUNT             b(x) = a(x)           END DO         !$acc end kernels         !$acc exit data copyout(b(1:LOOPCOUNT)) delete(a(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(b(x) - a(x)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:devonly,kernels,if,V:2.0-2.7       LOGICAL FUNCTION test3()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0         LOGICAL,DIMENSION(1):: devtest         LOGICAL:: data_on_device = .FALSE.         devtest(1) = .TRUE.          !$acc enter data copyin(devtest(1:1))         !$acc kernels present(devtest(1:1))           devtest(1) = .FALSE.         !$acc end kernels          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          IF (devtest(1) .eqv. .TRUE.) THEN           CALL RANDOM_NUMBER(a)           b = 0            !$acc enter data copyin(a(1:LOOPCOUNT)) create(b(1:LOOPCOUNT))           DO x = 1, LOOPCOUNT             a(x) = -1           END DO            !$acc kernels if(data_on_device) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = a(x)             END DO           !$acc end kernels            DO x = 1, LOOPCOUNT             IF (abs(a(x) + 1) .gt. PRECISION) THEN               errors = errors + 1             END IF             IF (abs(b(x)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO            !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           data_on_device = .FALSE.            DO x = 1, LOOPCOUNT             IF (abs(a(x) - b(x)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif #ifndef T4 !T4:devonly,kernels,if,V:2.0-2.7       LOGICAL FUNCTION test4()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0         LOGICAL,DIMENSION(1):: devtest         LOGICAL:: data_on_device = .FALSE.         devtest(1) = .TRUE.          !$acc enter data copyin(devtest(1:1))         !$acc kernels present(devtest(1:1))           devtest(1) = .FALSE.         !$acc end kernels          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          IF (devtest(1) .eq. 1) THEN           CALL RANDOM_NUMBER(a)           b = 0            !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc kernels if(data_on_device) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = a(x)             END DO           !$acc end kernels            DO x = 1, LOOPCOUNT             IF (abs(a(x) - b(x)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO            !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT))            DO x = 1, LOOPCOUNT             IF (abs(b(x)) .gt. PRECISION) THEN               IF (abs(b(x) - a(x)) .gt. PRECISION) THEN                 errors = errors + 1               END IF             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test4 = .FALSE.         ELSE           test4 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif #ifndef T4         LOGICAL :: test4 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif #ifndef T4         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test4()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 3           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture assign ior x expr", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   INTEGER, INTENT(IN) :: init   INTEGER,DIMENSION(length), INTENT(IN) :: a   INTEGER,DIMENSION(length), INTENT(IN) :: b   INTEGER,DIMENSION(length - 1) :: passed_a   INTEGER,DIMENSION(length - 1) :: passed_b   INTEGER :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (b(x) .eq. init) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = ior(a(x), init)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y, z !Iterators   INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms   INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison   INTEGER,DIMENSION(10):: passed_a, passed_b   INTEGER:: init   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)   a = 0   DO x = 1, LOOPCOUNT     DO y = 1, 10       DO z = 1, 8         IF (randoms(x, y, z) .gt. .933) THEN           a(x, y) = a(x, y) + ISHFT(1, z - 1)         END IF       END DO     END DO   END DO   totals = 0   totals_comparison = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             b(x, y) = totals(x)             totals(x) = ior(totals(x), a(x, y))           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data   DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = ior(totals_comparison(x), a(x, y))     END DO   END DO   DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NE. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 0     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction and general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);      char * a = (char *)malloc(n * sizeof(char));     real_t false_margin = pow(exp(1), log(.5)/n);     char result = 1;     char found = 0;      for (int x = 0; x < n; ++x){         if(rand() / (real_t)(RAND_MAX) < false_margin){             a[x] = 1;         }         else{             a[x] = 0;         }     }      #pragma acc data copyin(a[0:n])     {         #pragma acc parallel loop reduction(&&:result)         for (int x = 0; x < n; ++x){             result = result && a[x];         }     }      for (int x = 0; x < n; ++x){         if (a[x] == 0){             found = 1;             break;         }     }     if (found == result){         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(n * 5 * sizeof(char));     real_t false_margin = pow(exp(1), log(.5/n));     char result[5];     char host_result[5];      for (int x = 0; x < 5; ++x) {         result[x] = 1;         host_result[x] = 1;     }      for (int x = 0; x < 5 * n; ++x) {         if (rand() / (real_t)(RAND_MAX) < false_margin) {             a[x] = 1;         }         else {             a[x] = 0;         }     }      #pragma acc data copyin(a[0:5*n])     {         #pragma acc parallel loop reduction(&&:result)         for (int x = 0; x < 5 * n; ++x) {             result[x%5] = result[x%5] && a[x];         }     }      for (int x = 0; x < 5 * n; ++x) {         host_result[x%5] = host_result[x%5] && a[x];     }      for (int x = 0; x < 5; ++x){         if (host_result[x] != result[x]) {             err += 1;         }      }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update bitxor equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .5){                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] ^= a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] ^= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial default copy", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,data-region,default-mapping,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc serial         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:serial,data,data-region,default-mapping,devonly,V:2.6-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int * devtest = (int *)malloc(sizeof(real_t));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 1;         }          #pragma acc enter data copyin(c[0:n])         for (int x = 0; x < n; ++x){             c[x] = 0.0;         }         #pragma acc data copyin(a[0:n], b[0:n])         {             #pragma acc serial             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] += a[x] + b[x];                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(c[x]) > PRECISION){                 err += 1;             }         }          #pragma acc exit data copyout(c[0:n])          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction max general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t max = 0.0;     int found = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(max:max)         for (int x = 0; x < n; ++x){             max = fmax(a[x] * b[x], max);         }     }      for (int x = 0; x < n; ++x){         if (fabs(max - (a[x] * b[x] + PRECISION)) < 0){             err = 1;         }         if (fabs(max - (a[x] * b[x] - PRECISION)) > 0){             found = 1;         }     }     if (found = 0){         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t maximums[10];     real_t max_host[10];      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      for (int x = 0; x < 10; ++x) {         maximums[x] = 0;         max_host[x] = 0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n])     {         #pragma acc parallel loop reduction(max:maximums)         for (int x = 0; x < 10 * n; ++x) {             maximums[x%10] = fmax(a[x] * b[x], maximums[x%10]);         }     }      for (int x = 0; x < 10 * n; ++x) {         max_host[x%10] = fmax(a[x] * b[x], maximums[x%10]);     }          for (int x = 0; x < 10; ++x) {         if (fabs(max_host[x] - maximums[x]) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture assign expr neqv x", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         LOGICAL, INTENT(IN) :: init         LOGICAL,DIMENSION(length), INTENT(IN) :: a         LOGICAL,DIMENSION(length), INTENT(IN) :: b         LOGICAL,DIMENSION(length - 1) :: passed_a         LOGICAL,DIMENSION(length - 1) :: passed_b         LOGICAL :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (b(x) .eqv. init) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = a(x) .neqv. init             IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data         LOGICAL,DIMENSION(10):: passed_a, passed_b         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         LOGICAL IS_POSSIBLE         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   b(x, y) = totals(x)                   totals(x) = a(x, y) .NEQV. totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           IF (IS_POSSIBLE(passed_a, passed_b, 10, .FALSE.) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign x lshift expr", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if ((a>>x)%2 == 1){                 if (is_possible(passed_a, passed_b, length - 1, prev << 1)){                     return true;                 }             }             else {                 if (is_possible(passed_a, passed_b, length - 1, prev)){                     return true;                 }             }         }     }     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1;      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                         {                             c[x * 7 + y] = a[x];                             a[x] = a[x] << 1;                         }                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction multiply general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     int multiplicitive_n = 128;     srand(SEED);     real_t * a = (real_t *)malloc(multiplicitive_n * sizeof(real_t));     real_t * b = (real_t *)malloc(multiplicitive_n * sizeof(real_t));      real_t multiplied_total = 1.0;      for (int x = 0; x < multiplicitive_n; ++x){         a[x] = rand() / (real_t) RAND_MAX;         b[x] = rand() / (real_t) RAND_MAX;     }      #pragma acc data copyin(a[0:multiplicitive_n], b[0:multiplicitive_n]) copy(multiplied_total)     {         #pragma acc parallel loop reduction(*:multiplied_total)         for (int x = 0; x < multiplicitive_n; ++x){             multiplied_total *= a[x] + b[x];         }     }      for (int x = 0; x < multiplicitive_n; ++x){         multiplied_total /= (a[x] + b[x]);     }     if (fabs(multiplied_total - 1) > PRECISION * (2 * multiplicitive_n - 1)){         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     int m_n = 128;     srand(SEED);     real_t * a = (real_t *)malloc(10 * m_n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * m_n * sizeof(real_t));      real_t multiplicitive_total[10];      for (int x = 0; x < m_n; ++x){         a[x] = rand() / (real_t) RAND_MAX;         b[x] = rand() / (real_t) RAND_MAX;     }      for (int x = 0; x < 10; ++x) {         multiplicitive_total[x] = 1.0;     }      #pragma acc data copyin(a[0:10*m_n], b[0:10*m_n])     {         #pragma acc parallel loop reduction(*:multiplicitive_total)         for (int x = 0; x < 10 * m_n; ++x) {             multiplicitive_total[x%10] = multiplicitive_total[x%10] * (a[x] + b[x]);         }     }      for (int x = 0; x < 10 * m_n; ++x) {         multiplicitive_total[x%10] /= (a[x] + b[x]);     }      for (int x = 0; x < 10; ++x) {         if (fabs(multiplicitive_total[x]) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial copyin", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,data-region,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int* hasDevice = (int *) malloc(sizeof(int));     hasDevice[0] = 1;     #pragma acc enter data copyin(hasDevice[0:1])     #pragma acc parallel present(hasDevice[0:1])     {       hasDevice[0] = 0;     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         a_copy[x] = a[x];         b[x] = 0.0;     }      #pragma acc serial copyin(a[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             a[x] = 0.0;         }     }      for (int x = 0; x < n; ++x){         if (((fabs(a[x] - a_copy[x]) > PRECISION) && (hasDevice[0] == 1)) || ((hasDevice[0] == 0) && (fabs(a[x]) > PRECISION))){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:serial,data,data-region,V:2.6-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(b[0:n])     {         #pragma acc serial copyin(a[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction min vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * min = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 100;     real_t temp_min;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(min[0:10])     {         #pragma acc kernels loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 100;             #pragma acc loop vector reduction(min:temp)             for (int y = 0; y < n; ++y){                 temp = fmin(a[x * n + y] * b[x * n + y], temp);             }             min[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         temp_min = 100;         for (int y = 0; y < n; ++y){             if (temp_min > a[x * n + y] * b[x * n + y]){                 temp_min = a[x * n + y] * b[x * n + y];             }         }         if (fabs(temp_min - min[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr lshift x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};     int result;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 3; ++y){             a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));         }         b[x] = 0;     }      #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 3; ++y){                     #pragma acc atomic                         b[x] = a[x * 3 + y] << b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 6; ++y){             result = 0;             for (int z = 0; z < 3; ++z){                 result = a[x * 3 + orders[y * 3 + z]] << result;             }             if (result == b[x]){                 break;             }         }         if (result != b[x]){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction add loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10 * n];     real_t * d = new real_t[10 * n];     real_t avg = 0.0;     real_t rolling_total = 0;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) create(c[0:10*n]) copyout(d[0:10*n])     {         #pragma acc serial  \t{     \t#pragma acc loop gang private(avg)         for (int x = 0; x < 10; ++x){             avg = 0;             #pragma acc loop worker reduction(+:avg)             for (int y = 0; y < n; ++y){                 avg += c[x * n + y] = a[x * n + y] + b[x * n + y];             }             avg = avg / n;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 d[x * n + y] = c[x * n + y] - avg;             }         } \t}     }       for (int x = 0; x < 10; ++x){         rolling_total = 0;         for (int y = 0; y < n; ++y){             rolling_total += a[x * n + y] + b[x * n + y];         }         rolling_total = rolling_total / n;         for (int y = 0; y < n; ++y){             if (fabs(d[x * n + y] - ((a[x * n + y] + b[x * n + y]) - rolling_total)) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update expr bitand x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] &= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured x lshift expr assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if ((b[x] == (prev << 1) && (a>>x)%2 == 1) || ((a>>x)%2==0 && b[x] == prev)){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_b);                 return true;             }         }     }     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1;      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                         {                             a[x] = a[x] << 1;                             c[x * 7 + y] = a[x];                         }                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc get num devices", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,devonly,internal-control-values,syntactic,V:1.0-2.7 int test1(){     int err = 0;      if(acc_get_device_type() != acc_device_none && acc_get_num_devices(acc_get_device_type()) == 0){ //Can't have zero of current device type           err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x multiply expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc get device type", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:,V:1.0-3.2 int test1(){ \tint err = 0;  \tint device_type = acc_get_device_type();  \tif (acc_get_device_type() != device_type){ \t\terr += 1; \t}  \treturn err; } #endif  int main(){     \tint failcode = 0;     \tint failed; #ifndef T1     \tfailed = 0;     \tfor (int x = 0; x < NUM_TEST_CALLS; ++x){         \tfailed = failed + test1();     \t}     \tif (failed != 0){         \tfailcode = failcode + (1 << 0);     \t} #endif     \treturn failcode; } "}
{"prompt": "Create a test for the feature exit data delete no lower bound", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,construct-independent,syntactic,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])     #pragma acc parallel present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc exit data delete(a[:n], b[:n]) copyout(c[0:n])      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine nohost", "completion": "#include \"acc_testsuite.h\" #pragma acc routine worker nohost real_t function(real_t * a, long long n){     real_t returned = 0;     #pragma acc loop worker reduction(+:returned)     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  #ifndef T1 //T1:routine,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t summation;      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang             for (int x = 0; x < n; ++x){                 b[x] = function(a[x], n);             }         }     }      for (int x = 0; x < n; ++x){         summation = 0;         for (int y = 0; y < n; ++y){             summation += a[x][y];         }         if (fabs(summation - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data copyout reference counts", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,data-region,reference-counting,devonly,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int * devtest = (int *)malloc(sizeof(int));     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {       devtest[0] = 0;     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }       if (devtest[0] == 1) {         #pragma acc data copyin(c[0:n])         {             #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])             {                 #pragma acc parallel                 {                     #pragma acc loop                     for (int x = 0; x < n; ++x){                         c[x] += a[x] + b[x];                     }                 }             }             for (int x = 0; x < n; ++x){                 if (fabs(c[x]) > PRECISION){                     err += 1;                     break;                 }             }         }         for (int x = 0; x < n; ++x){             if (fabs(c[x]) > PRECISION){                 err += 1;                 break;             }         }      }      return err; } #endif  #ifndef T2 //T2:data,data-region,reference-counting,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int * devtest = (int *)malloc(sizeof(int));     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {       devtest[0] = 0;     }      for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = 0.0;     }      #pragma acc enter data copyin(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }     if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             if (fabs(c[x]) > PRECISION){                 err += 1;                 break;             }         }     }     #pragma acc exit data copyout(c[0:n])     for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T3 //T3:data,data-region,construct-independent,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int * devtest = (int *)malloc(sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }         #pragma acc exit data delete(c[0:n])     }     for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign x rshift expr", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if ((a >> x) % 2 == 1){                 if (is_possible(passed_a, passed_b, length - 1,prev >> 1)){                     free(passed_b);                     return true;                 }             }             else{                 if (is_possible(passed_a, passed_b, length - 1, prev)){                     free(passed_b);                     return true;                 }             }         }     }     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1<<8;      for (int x = 0; x < n; ++x){         a[x] = 1<<8;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                         {                             c[x * 7 + y] = a[x];                             a[x] = a[x] >> 1;                         }                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<8){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t* a = (real_t *) malloc(1024 * sizeof(real_t));     real_t* b = (real_t *) malloc(1024 * sizeof(real_t));     real_t* c = (real_t *) malloc(1024 * sizeof(real_t));      for(int x = 0; x < 1024; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:1024], b[0:1024]) copy(c[0:1024])     {         #pragma acc serial         {             #pragma acc loop             for (int _0 = 0; _0 < 2; ++_0){                 #pragma acc loop                 for (int _1 = 0; _1 < 2; ++_1){                     #pragma acc loop                     for (int _2 = 0; _2 < 2; ++_2){                         #pragma acc loop                         for (int _3 = 0; _3 < 2; ++_3){                             #pragma acc loop                             for (int _4 = 0; _4 < 2; ++_4){                                 #pragma acc loop                                 for (int _5 = 0; _5 < 2; ++_5){                                     #pragma acc loop                                     for (int _6 = 0; _6 < 2; ++_6){                                         #pragma acc loop                                         for (int _7 = 0; _7 < 2; ++_7){                                             #pragma acc loop                                             for (int _8 = 0; _8 < 2; ++_8){                                                 #pragma acc loop                                                 for (int _9 = 0; _9 < 2; ++_9){                                                     c[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] =                                                     a[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] +                                                     b[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9];                                                 }                                             }                                         }                                     }                                 }                             }                         }                     }                 }             }         }     }      for (int x = 0; x < 1024; ++x){         if(fabs(c[x] - (a[x] +b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc copyin with len", "completion": "#ifndef T1 !T1:runtime,data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL acc_copyin(a(1), LOOPCOUNT*8)         CALL acc_copyin(b(1), LOOPCOUNT*8)         !$acc data copy(c(1:LOOPCOUNT))           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc Loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_copyout(a(1:LOOPCOUNT))         CALL acc_copyout(b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END FUNCTION #endif  #ifndef T2 !T2:runtime,data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         REAL(8) :: RAND         INTEGER :: errors = 0          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_copyin(a(1), LOOPCOUNT*8)         CALL acc_copyin(b(1), LOOPCOUNT*8)         !$acc data copy(c(1:LOOPCOUNT))           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END FUNCTION #endif  #ifndef T3 !T3:runtime,data,executable-data,devonly,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test3()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data         REAL(8) :: RAND         INTEGER :: errors = 0         INTEGER,DIMENSION(1) :: devtest          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = 0         !$acc end parallel          IF (devtest(1) .eq. 1) THEN           SEEDDIM(1) = 1 #         ifdef SEED           SEEDDIM(1) = SEED #         endif           CALL RANDOM_SEED(PUT=SEEDDIM)           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           a_copy = a           b_copy = b           c = 0            CALL acc_copyin(a(1), LOOPCOUNT*8)           CALL acc_copyin(b(1), LOOPCOUNT*8)            a = 0           b = 0            !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) + b(x)               END DO             !$acc end parallel           !$acc end data            CALL acc_copyout(a(1:LOOPCOUNT))           CALL acc_copyout(b(1:LOOPCOUNT))            DO x = 1, LOOPCOUNT             IF (abs(a(x) - a_copy(x)) .gt. PRECISION) THEN               errors = errors + 1             END IF             IF (abs(b(x) - b_copy(x)) .gt. PRECISION) THEN               errors = errors + 1             END IF             IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END FUNCTION #endif  #ifndef T4 !T4:runtime,compatibility-features,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test4()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         REAL(8) :: RAND         INTEGER :: errors = 0          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_pcopyin(a(1), LOOPCOUNT*8)         CALL acc_pcopyin(b(1), LOOPCOUNT*8)          !$acc data copyout(c(1:LOOPCOUNT)) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test4 = .FALSE.         ELSE           test4 = .TRUE.         END IF       END FUNCTION #endif  #ifndef T5 !T5:runtime,compatibility-features,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test5()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         REAL(8) :: RAND         INTEGER :: errors = 0          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_present_or_copyin(a(1), LOOPCOUNT*8)         CALL acc_present_or_copyin(b(1), LOOPCOUNT*8)          !$acc data copyout(c(1:LOOPCOUNT)) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test5 = .FALSE.         ELSE           test5 = .TRUE.         END IF       END FUNCTION #endif  #ifndef T6 !T6:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7       LOGICAL FUNCTION test6()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         REAL(8) :: RAND         INTEGER :: errors = 0          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_copyin(a(1), LOOPCOUNT*8)         CALL acc_copyin(a(1), LOOPCOUNT*8)         CALL acc_copyin(b(1), LOOPCOUNT*8)         CALL acc_copyin(b(1), LOOPCOUNT*8)          !$acc data copyout(c(1:LOOPCOUNT))           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))         !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) + (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test6 = .FALSE.         ELSE           test6 = .TRUE.         END IF       END #endif  #ifndef T7 !T7:runtime,data,executable-data,construct-independent,reference-counting,devonly,V:2.5-2.7       LOGICAL FUNCTION test7()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data         REAL(8) :: RAND         INTEGER :: errors = 0         LOGICAL,DIMENSION(1):: devtest          devtest(1) = .TRUE.         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = .FALSE.         !$acc end parallel          IF (devtest(1) .eqv. .TRUE.) THEN           SEEDDIM(1) = 1 #         ifdef SEED           SEEDDIM(1) = SEED #         endif           CALL RANDOM_SEED(PUT=SEEDDIM)           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 0           a_copy = a           b_copy = b            CALL acc_copyin(a(1), LOOPCOUNT*8)           CALL acc_copyin(b(1), LOOPCOUNT*8)            a = 0           b = 0            CALL acc_copyin(a(1), LOOPCOUNT*8)           CALL acc_copyin(b(1), LOOPCOUNT*8)            !$acc data copyout(c(1:LOOPCOUNT))             !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) + b(x)               END DO             !$acc end parallel           !$acc end data            !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))            DO x = 1, LOOPCOUNT             IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF         IF (errors .eq. 0) THEN           test7 = .FALSE.         ELSE           test7 = .TRUE.         END IF       END #endif        PROGRAM main       IMPLICIT NONE       INTEGER :: failcode, testrun       LOGICAL :: failed       INCLUDE \"acc_testsuite.Fh\"       !Conditionally define test functions #ifndef T1       LOGICAL :: test1 #endif #ifndef T2       LOGICAL :: test2 #endif #ifndef T3       LOGICAL :: test3 #endif #ifndef T4       LOGICAL :: test4 #endif #ifndef T5       LOGICAL :: test5 #endif #ifndef T6       LOGICAL :: test6 #endif #ifndef T7       LOGICAL :: test7 #endif       failcode = 0       failed = .FALSE.  #ifndef T1       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test1()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 0         failed = .FALSE.       END IF #endif #ifndef T2       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test2()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 1         failed = .FALSE.       END IF #endif #ifndef T3       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test3()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 2         failed = .FALSE.       END IF #endif #ifndef T4       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test4()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 3         failed = .FALSE.       END IF #endif #ifndef T5       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test5()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 4         failed = .FALSE.       END IF #endif #ifndef T6       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test6()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 5         failed = .FALSE.       END IF #endif #ifndef T7       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test7()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 6         failed = .FALSE.       END IF #endif       CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature kernels loop reduction bitand loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;      for (int x = 0; x < 10 * n; ++x){         b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b_copy[x] = b[x];         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX < false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }     #pragma acc data copyin(a[0:10 * n]) copy(b[0:10 * n], c[0:10])     {         #pragma acc kernels loop gang private(temp)         for (int y = 0; y < 10; ++y){             temp = a[y * n];             #pragma acc loop worker reduction(&:temp)             for (int x = 1; x < n; ++x){                 temp = temp & a[y * n + x];             }             c[y] = temp;             #pragma acc loop worker             for (int x = 0; x < n; ++x){                 b[y * n + x] = b[y * n + x] + c[y];             }         }     }     unsigned int* host_c = (unsigned int *)malloc(10 * sizeof(unsigned int));     for (int x = 0; x < 10; ++x){         host_c[x] = a[x * n];         for (int y = 1; y < n; ++y){             host_c[x] = host_c[x] & a[x * n + y];         }         if (host_c[x] != c[x]){           err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (b[x * n + y] != b_copy[x * n + y] + c[x]){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update expr eqv x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = a(x, y) .EQV. totals(x)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign expr bitand x", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev & a[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         for (int y = 0; y < 8; ++y){             totals[x] =  1<<y;             totals_comparison[x] = 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         b[x] = totals[x/10];                         totals[x/10] = a[x] & totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] &= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }      for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitxor general", "completion": "#ifndef T1 !T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: randoms         INTEGER :: errors = 0         INTEGER :: b = 0         INTEGER :: temp = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = FLOOR(randoms*1000000)          !$acc data copyin(a(1:LOOPCOUNT))           !$acc parallel loop reduction(ieor:b)           DO x = 1, LOOPCOUNT             b = ieor(b, a(x))           END DO         !$acc end data          DO x = 1, LOOPCOUNT           temp = ieor(temp, a(x))         END DO         IF (temp .ne. b) THEN           errors = errors + 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc update self async", "completion": "#ifndef T1 !T1:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d !Data         INTEGER,DIMENSION(1):: devtest         REAL(8) :: RAND         INTEGER :: errors = 0          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         d = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT), d(1:LOOPCOUNT))           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           !$acc parallel async(2)             !$acc loop             DO x = 1, LOOPCOUNT               d(x) = a(x) * b(x)             END DO           !$acc end parallel           CALL acc_update_self_async(c(1:LOOPCOUNT), 1)           CALL acc_update_self_async(d(1:LOOPCOUNT), 2)           !$acc wait         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF           IF (abs(d(x) - (a(x) * b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d !Data         INTEGER,DIMENSION(1):: devtest         REAL(8) :: RAND         INTEGER :: errors = 0          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          IF (devtest(1) .eq. 1) THEN           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 0            !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc parallel async(1)               !$acc loop               DO x = 1, LOOPCOUNT                 a(x) = a(x) * a(x)               END DO             !$acc end parallel             CALL acc_update_self_async(a(1:LOOPCOUNT), 1)             !$acc parallel async(2)               !$acc loop               DO x = 1, LOOPCOUNT                 b(x) = b(x) * b(x)               END DO             !$acc end parallel             CALL acc_update_self_async(b(1:LOOPCOUNT), 2)             !$acc parallel async(1)               !$acc loop               DO x = 1, LOOPCOUNT                 a(x) = a(x) + 1               END DO             !$acc end parallel             !$acc parallel async(2)               !$acc loop               DO x = 1, LOOPCOUNT                 b(x) = b(x) + 1               END DO             !$acc end parallel             !$acc parallel async(1) wait(2)               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) * b(x)               END DO             !$acc end parallel           !$acc end data            DO x = 1, LOOPCOUNT             IF (abs(c(x) - ((a(x) + 1) * (b(x) + 1))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic x and expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) < .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = totals(x) .AND. a(x, y)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .AND. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update divided equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] /= (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop seq", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t temp = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copy(b[0:n])     {         #pragma acc serial loop seq         for (int x = 1; x < n; ++x){             b[x] = b[x-1] + a[x];         }     }      for (int x = 1; x < n; ++x){         temp += a[x];         if (fabs(b[x] - temp) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update min x expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign bitxor equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev ^ a[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         for (int y = 0; y < 8; ++y){             totals[x] =  1<<y;             totals_comparison[x] = 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         b[x] = totals[x/10];                         totals[x/10] ^= a[x];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] ^= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction bitand vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int c = 0;     unsigned int b_host;      for (int x = 0; x < 10 * n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX < false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc kernels loop private(c)         for (int x = 0; x < 10; ++x){             c = a[x * n];             #pragma acc loop vector reduction(&:c)             for (int y = 1; y < n; ++y){                 c = c & a[x * n + y];             }             b[x] = c;         }     }     for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host & a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction bitand vector loop", "completion": "#ifndef T1 !T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y, z, i !Iterators         INTEGER,DIMENSION(10*LOOPCOUNT):: a !Data         INTEGER,DIMENSION(10):: b         INTEGER :: c         REAL(8),DIMENSION(160*LOOPCOUNT):: random         REAL(8) :: false_margin         INTEGER :: errors = 0         INTEGER :: temp          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(random)         false_margin = exp(log(.5) / n)         DO x = 0, 9           DO y = 1, LOOPCOUNT             DO z = 1, 16               IF (random(x * 16 * LOOPCOUNT + (y - 1) * 16 + z - 1) < false_margin) THEN                 temp = 1                 DO i = 1, z                   temp = temp * 2                 END DO                 a(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + temp               END IF             END DO           END DO         END DO          !$acc data copyin(a(1:10*LOOPCOUNT)), copy(b(1:10))           !$acc kernels loop private(c)           DO x = 0, 9             c = a(x * LOOPCOUNT + 1)             !$acc loop vector reduction(iand:c)             DO y = 1, LOOPCOUNT               c = iand(c, a(x * LOOPCOUNT + y))             END DO             b(x + 1) = c           END DO         !$acc end data          DO x = 0, 9           temp = a(x * LOOPCOUNT + 1)           DO y = 2, LOOPCOUNT             temp = iand(temp, a(x * LOOPCOUNT + y))           END DO           IF (b(x + 1) .ne. temp) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign preincrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *c = new int[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];     bool found = false;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = distribution[(int) (a[x]*b[x]/10)];                     ++distribution[(int) (a[x]*b[x]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]++;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < distribution[x]; ++y){             for (int z = 0; z < n; ++z){                 if (c[z] == y && x == (int) (a[z] * b[z] / 10)){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update expr or x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = a(x, y) .OR. totals(x)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .OR. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture x minus expr assign", "completion": "RECURSIVE FUNCTION IS_POSSIBLE_2(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   REAL(8), INTENT(IN) :: init   REAL(8),DIMENSION(length), INTENT(IN) :: a   REAL(8),DIMENSION(length), INTENT(IN) :: b   REAL(8),DIMENSION(length - 1) :: passed_a   REAL(8),DIMENSION(length - 1) :: passed_b   REAL(8) :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (abs(b(x) - (init - a(x))) .GT. ((10 - length) * PRECISION)) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = b(x)       IF (IS_POSSIBLE_2(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE_2  RECURSIVE FUNCTION IS_POSSIBLE(subset, destination, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   REAL(8),DIMENSION(length), INTENT(IN) :: subset   REAL(8), INTENT(IN) :: destination   REAL(8), INTENT(IN) :: init   REAL(8),ALLOCATABLE :: passed(:)   LOGICAL :: POSSIBLE   INTEGER :: x, y   IF (length .gt. 0) THEN     ALLOCATE(passed(length - 1))   ELSE     IF (abs(init - destination) .gt. PRECISION) THEN       POSSIBLE = .TRUE.     ELSE       POSSIBLE = .FALSE.     END IF     RETURN   END IF   POSSIBLE = .FALSE.   DO x = 1, length     DO y = 1, x - 1       passed(y) = subset(y)     END DO     DO y = x + 1, length       passed(y - 1) = subset(y)     END DO     IF (IS_POSSIBLE(passed, destination, length - 1, init - subset(x))) THEN       POSSIBLE = .TRUE.       RETURN     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   LOGICAL IS_POSSIBLE   LOGICAL IS_POSSIBLE_2   REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT):: totals   REAL(8),DIMENSION(10):: passed_a, passed_b   REAL(8):: init   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)    totals = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             totals(x) = totals(x) - a(x, y)             b(x, y) = totals(x)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)     END DO     IF (IS_POSSIBLE(passed_a, totals(x), 10, 0) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 0     IF (IS_POSSIBLE_2(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel implicit data attributes", "completion": "#include \"acc_testsuite.h\"  #ifndef T1 //copy clause test wih parallel default(none) and reduction with scalar variable int test1(){     int err = 0;     srand(SEED);     int test = rand()/(real_t)(RAND_MAX/10);     int host = test;      #pragma acc parallel default(none) reduction(+:test)     for(int x = 0; x < n; ++x){ \ttest += 1;     }      if(fabs( test - host) >  PRECISION){ \terr++;     }          return err; }  #endif #ifndef T2 //copy clause test with parallel loop and reduction with scalar variable int test2(){ \tint err = 0; \tsrand(SEED); \treal_t a = rand()/(real_t)(RAND_MAX/10); \treal_t host = a;  \t#pragma acc parallel loop reduction(+:a) \tfor( int x = 0; x < n; ++x){ \t\ta += 1.0; \t}  \tif( fabs( a - host) > PRECISION){ \t\terr++; \t} \treturn err; } #endif #ifndef T3 //firstprivate test with only parallel and reduction with scalar variable int test3(){ \tint err = 0; \tsrand(SEED); \tint host_value = rand()/ (real_t)(RAND_MAX/10); \tint device_value = host_value;  \t#pragma acc parallel reduction(+:device_value)  \tfor( int x = 0; x > n; ++ x){ \t\tdevice_value += device_value; \t} \tif( fabs(host_value - device_value) > PRECISION){ \t\terr = 1; \t} \treturn err; }\t #endif #ifndef T4 //copy clause wtth that calles detach action only parallel loop  with aggregate variables int test4(){ \tint err = 0; \tsrand(SEED);  \treal_t *host_array = new real_t[n]; \treal_t *device_array = new real_t[n];  \tfor(int x = 0; x < n; ++ x){ \t\thost_array[x] = rand()/(real_t)(RAND_MAX/10); \t\tdevice_array[x] = host_array[x]; \t}  \t#pragma acc parallel loop \tfor( int x = 0; x < n; ++x){ \t\tdevice_array[x] += device_array[x]; \t}  \tfor(int x = 0; x < n; ++x){ \t\tif(fabs(host_array[x]*2 - device_array[x]) > PRECISION){ \t\t\terr = 1; \t\t} \t} \tdelete[] host_array; \tdelete[] device_array; \treturn err;  } #endif  int main(){ \tint failcode = 0; \tint failed; #ifndef T1 \tfailed = 0; \tfor( int x = 0; x < NUM_TEST_CALLS; ++x){ \t\tfailed += test1(); \t} \tif(failed){ \t\tfailcode += ( 1 << 0); \t} #endif #ifndef T2         failed = 0;         for( int x = 0; x < NUM_TEST_CALLS; ++x){                 failed += test2();         }         if(failed){                 failcode += ( 1 << 1);         } #endif #ifndef T3         failed = 0;         for( int x = 0; x < NUM_TEST_CALLS; ++x){                 failed += test3();         }         if(failed){                 failcode += ( 1 << 2);         } #endif #ifndef T4         failed = 0;         for( int x = 0; x < NUM_TEST_CALLS; ++x){                 failed += test4();         }         if(failed){                 failcode += ( 1 << 3);         } #endif \treturn failcode; } "}
{"prompt": "Create a test for the feature atomic capture expr plus x", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] + prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((int)(n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((int)(n/10 + 1) * sizeof(real_t));     real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:11]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = totals[x%((int)(n/10 + 1))] = (a[x] + b[x]) + totals[x%((int)(n/10 + 1))];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%((int)(n/10 + 1))] += (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured rshift equals assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if ((b[x] == (prev >> 1) && (a>>x)%2==1) || b[x] == prev && (a>>x)%2==0){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_b);                 return true;             }         }     }     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1<<8;      for (int x = 0; x < n; ++x){         a[x] = 1<<8;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                         {                             a[x] >>= 1;                             c[x * 7 + y] = a[x];                         }                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<8){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture assign max x expr list", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, c, length, init) RESULT(POSSIBLE) INTEGER, INTENT(IN) :: length REAL(8), INTENT(IN) :: init REAL(8),DIMENSION(length), INTENT(IN) :: a REAL(8),DIMENSION(length), INTENT(IN) :: b REAL(8),DIMENSION(length), INTENT(IN) :: c REAL(8),DIMENSION(length - 1) :: passed_a REAL(8),DIMENSION(length - 1) :: passed_b REAL(8),DIMENSION(length - 1) :: passed_c REAL(8) :: holder LOGICAL :: POSSIBLE INTEGER :: x, y  IF (length .eq. 0) THEN   POSSIBLE = .TRUE.   RETURN END IF POSSIBLE = .FALSE.  DO x = 1, length   IF (abs(c(x) - init) .lt. ((10 - length) * PRECISION)) THEN     DO y = 1, x - 1       passed_a(y) = a(y)       passed_b(y) = b(y)     END DO     DO y = x + 1, length       passed_a(y - 1) = a(y)       passed_b(y - 1) = b(y)     END DO     holder = max(a(x), b(x), init)     IF (IS_POSSIBLE(passed_a, passed_b, passed_c, length - 1, holder)) THEN       POSSIBLE = .TRUE.       RETURN     END IF   END IF END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1() IMPLICIT NONE INCLUDE \"acc_testsuite.Fh\" INTEGER :: x, y !Iterators REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c REAL(8):: init LOGICAL IS_POSSIBLE INTEGER :: errors = 0  !Initilization SEEDDIM(1) = 1 #ifdef SEED SEEDDIM(1) = SEED #endif CALL RANDOM_SEED(PUT=SEEDDIM)  CALL RANDOM_NUMBER(a) CALL RANDOM_NUMBER(b)  totals = 0 totals_comparison = 0  !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))   !$acc parallel     !$acc loop     DO x = 1, LOOPCOUNT       DO y = 1, 10         !$acc atomic capture           c(x, y) = totals(x)           totals(x) = max(totals(x), a(x, y), b(x, y))         !$acc end atomic       END DO     END DO   !$acc end parallel !$acc end data DO x = 1, LOOPCOUNT   DO y = 1, 10     totals_comparison(x) = max(totals_comparison(x), a(x, y), b(x, y))   END DO END DO DO x = 1, LOOPCOUNT   IF (totals_comparison(x) .NE. totals(x)) THEN     errors = errors + 1     WRITE(*, *) totals_comparison(x)   END IF END DO  DO x = 1, LOOPCOUNT   DO y = 1, 10     passed_a(y) = a(x, y)     passed_b(y) = b(x, y)     passed_c(y) = c(x, y)   END DO   init = 0   IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN     errors = errors + 1   END IF END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop tile", "completion": "#ifndef T1 !T1:kernels,reduction,combined-constructs,loop,tile,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y, z !Iterators         REAL(8),DIMENSION(SMALL_LOOPCOUNT):: a, b, c !Data         REAL(8),DIMENSION(SMALL_LOOPCOUNT,SMALL_LOOPCOUNT)::d         REAL(8) :: temp         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         CALL RANDOM_NUMBER(c)          !$acc data copyin(a(1:SMALL_LOOPCOUNT), b(1:SMALL_LOOPCOUNT), c(1:SMALL_LOOPCOUNT)) copyout(d(1:SMALL_LOOPCOUNT,1:SMALL_LOOPCOUNT))           !$acc kernels loop tile(*, *) reduction(+:temp)           DO x = 1, SMALL_LOOPCOUNT             DO y = 1, SMALL_LOOPCOUNT               temp = 0               DO z = 1, SMALL_LOOPCOUNT                 temp = temp + a(z) + b(z) + c(z)               END DO               d(x,y) = temp             END DO           END DO         !$acc end data          DO x = 1, SMALL_LOOPCOUNT           DO y = 1, SMALL_LOOPCOUNT             temp = 0             DO z = 1, SMALL_LOOPCOUNT               temp = temp + a(z) + b(z) + c(z)             END DO             IF (abs(d(x,y) - temp) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel scalar default firstprivate", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,data,data-region,default-mapping,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t scalar = rand() / (real_t)(RAND_MAX / 10);     real_t scalar_copy = scalar;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x] + scalar;             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - (a[x] + scalar_copy)) > PRECISION){             err += 1;         }     }     if (fabs(scalar_copy - scalar) > PRECISION){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine vector", "completion": "#include \"acc_testsuite.h\" void test_routine_vector_loop_named(real_t ** a, real_t * b, long long n); void test_routine_vector_vector_named(real_t ** a, real_t * b, long long n); void test_routine_vector_seq_named(real_t ** a, real_t * b, long long n);  #pragma acc routine(test_routine_vector_loop_named) vector #pragma acc routine(test_routine_vector_vector_named) vector #pragma acc routine(test_routine_vector_seq_named) vector  #pragma acc routine vector real_t called_function_vector(real_t **a, int x, long long n){     real_t returned = 0;     #pragma acc loop vector reduction(+:returned)     for (int y = 0; y < n; ++y){         returned += a[x][y];     }     return returned; }  #pragma acc routine seq real_t called_function_seq(real_t **a, int x, long long n){     real_t returned = 0;     #pragma acc loop seq reduction(+:returned)     for (int y = 0; y < n; ++y){         returned += a[x][y];     }     return returned; }  #pragma acc routine vector void test_routine_vector_loop_unnamed(real_t ** a, real_t * b, long long n){     #pragma acc loop vector     for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             b[x] += a[x][y];         }     } }  #pragma acc routine vector void test_routine_vector_vector_unnamed(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_vector(a, x, n);     } }  #pragma acc routine vector void test_routine_vector_seq_unnamed(real_t ** a, real_t *b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_seq(a, x, n);     } }  void test_routine_vector_loop_named(real_t ** a, real_t * b, long long n){     #pragma acc loop vector     for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             b[x] += a[x][y];         }     } }  void test_routine_vector_vector_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_vector(a, x, n);     } }  void test_routine_vector_seq_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_seq(a, x, n);     } }  bool validate_data(real_t ** a, real_t * b){     real_t local_total;     for (int x = 0; x < n; ++x){         local_total = 0;         for (int y = 0; y < n; ++y){             local_total += a[x][y];         }         if (fabs(b[x] - local_total) > PRECISION){             return true;         }     }     return false; }  #ifndef T1 //T1:routine,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {               test_routine_vector_loop_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T2 //T2:routine,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_vector_loop_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T3 //T3:routine,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_vector_vector_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T4 //T4:routine,construct-independent,V:2.0-2.7 int test4(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_vector_vector_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T5 //T5:routine,construct-independent,V:2.0-2.7 int test5(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_vector_seq_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T6 //T6:routine,construct-independent,V:2.0-2.7 int test6(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_vector_seq_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif #ifndef T6     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test6();     }     if (failed != 0){         failcode = failcode + (1 << 5);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr times x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = a(x, y) * totals(x)               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) * a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial default present", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,data-region,default,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = 0.0;     }     #pragma acc enter data copyin(a[0:n])     #pragma acc serial default(present)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             a[x] = 1.0;         }     }     #pragma acc exit data copyout(a[0:n])      for (int x = 0; x < n; ++x){         if (fabs(a[x] - 1.0) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction multiply loop", "completion": "#ifndef T1 !T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   REAL(8),DIMENSION(10, LOOPCOUNT):: a, b, c   REAL(8),DIMENSION(LOOPCOUNT):: totals, host_totals   REAL(8):: temp   INTEGER:: errors, x, y    errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 0     host_totals = 1   DO y = 1, LOOPCOUNT     DO x = 1, 10       host_totals(y) = host_totals(y) * (a(x, y) + b(x, y))     END DO   END DO    !$acc data copyin(a(1:10, 1:LOOPCOUNT), b(1:10, 1:LOOPCOUNT)) copyout(c(1:10, 1:LOOPCOUNT)) copy(totals(1:LOOPCOUNT))     !$acc serial loop gang private(temp)     DO y = 1, LOOPCOUNT       temp = 1       !$acc loop worker reduction(*:temp)       DO x = 1, 10         temp = temp * (a(x, y) + b(x, y))       END DO       totals(y) = temp       !$acc loop worker       DO x = 1, 10         c(x, y) = (a(x, y) + b(x, y)) / totals(y)       END DO     END DO   !$acc end data    DO y = 1, LOOPCOUNT     IF (abs(host_totals(y) - totals(y)) .gt. PRECISION) THEN       errors = errors + 1     END IF     DO x = 1, 10       IF (c(x, y) - ((a(x, y) + b(x, y)) / totals(y)) .gt. PRECISION) THEN         errors = errors + 1       END IF     END DO   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc copyout async", "completion": "#ifndef T1 !T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(d)         CALL RANDOM_NUMBER(e)         f = 0          !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           !$acc parallel async(2)             !$acc loop             DO x = 1, LOOPCOUNT               f(x) = d(x) + e(x)             END DO           !$acc end parallel           CALL acc_copyout_async(c(1:LOOPCOUNT), 1)           CALL acc_copyout_async(f(1:LOOPCOUNT), 2)         !$acc end data         !$acc wait         DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF           IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO         IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main       IMPLICIT NONE       INTEGER :: failcode, testrun       LOGICAL :: failed       INCLUDE \"acc_testsuite.Fh\"       !Conditionally define test functions #ifndef T1       LOGICAL :: test1 #endif       failcode = 0       failed = .FALSE.  #ifndef T1       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test1()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 0         failed = .FALSE.       END IF #endif        CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature atomic capture assign max x expr", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   REAL(8), INTENT(IN) :: init   REAL(8),DIMENSION(length), INTENT(IN) :: a   REAL(8),DIMENSION(length), INTENT(IN) :: b   REAL(8),DIMENSION(length - 1) :: passed_a   REAL(8),DIMENSION(length - 1) :: passed_b   REAL(8) :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (abs(b(x) - init) .lt. (10 - length) * PRECISION) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = max(a(x), init)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison   REAL(8),DIMENSION(10):: passed_a, passed_b   REAL(8):: init   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)    totals = 0   totals_comparison = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             b(x, y) = totals(x)             totals(x) = max(totals(x), a(x, y))           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data   DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = max(totals_comparison(x), a(x, y))     END DO   END DO   DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NE. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 0     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc set default async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,async,construct-independent,set,V:2.5-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *a_host = new real_t[n];     real_t *b_host = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         a_host[x] = a[x];         b_host[x] = b[x];     }      #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])     {         acc_set_default_async(1);         #pragma acc parallel async         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = a[x] * a[x];             }         }         acc_set_default_async(2);         #pragma acc parallel async         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = b[x] * b[x];             }         }         #pragma acc parallel async(1) wait(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc wait(1)     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4*PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial deviceptr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,data-region,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b;      for (int x = 0; x < n; ++x){         a[x] = 0;     }      #pragma acc enter data copyin(a[0:n])     b = (real_t *) acc_deviceptr(a);     if (b == NULL){         err = 1;     }     else{         #pragma acc serial deviceptr(b)         {             #pragma acc loop             for (int x = 0; x < (int) n/2; ++x){                 b[x] = 1;             }         }         #pragma acc exit data copyout(a[0:n])     }     for (int x = 0; x < n; ++x){         if (x < (int) n/2){             if (fabs(a[x] - 1) > PRECISION){                 err = 1;             }         }         else {             if (fabs(a[x]) > PRECISION){                 err = 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr bitor x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] |= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature init", "completion": "#ifndef T1 !T1:construct-independent,init,nonvalidating,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: errors = 0          !$acc init          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign lshift equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if ((a>>x)%2 == 1){                 if (is_possible(passed_a, passed_b, length - 1, prev << 1)){                     return true;                 }             }             else {                 if (is_possible(passed_a, passed_b, length - 1, prev)){                     return true;                 }             }         }     }     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1;      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                         {                             c[x * 7 + y] = a[x];                             a[x] <<= 1;                         }                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction min general", "completion": "#include \"acc_testsuite.h\" #pragma acc routine (fmin) seq  #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t min = 1000.0;     int found = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:n], b[0:n]) copy(min)     {         #pragma acc serial loop reduction(min:min)         for (int x = 0; x < n; ++x){             min = fmin(a[x] * b[x], min);         }     }      for (int x = 0; x < n; ++x){         if (fabs((a[x] * b[x]) - (min + PRECISION)) < 0){             err = 1;         }         if (fabs(min - (a[x] * b[x])) < PRECISION){             found = 1;         }     }     if (found == 0){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop vector blocking", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,V:2.6-2.7 int test1(){   int err = 0;   srand(SEED);   real_t * a = (real_t *)malloc(n * sizeof(real_t));   real_t * b = (real_t *)malloc(n * sizeof(real_t));   real_t * c = (real_t *)malloc(n * sizeof(real_t));   real_t multiplyer = 1;    for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = 0.0;   }    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])   {     #pragma acc serial     {       #pragma acc loop vector       for (int x = 0; x < n; ++x){         c[x] = (a[x] + b[x]) * multiplyer;       }       multiplyer += 1;       #pragma acc loop vector       for (int x = 0; x < n; ++x){         c[x] += (a[x] + b[x]) * multiplyer;       }     }   }    for (int x = 0; x < n; ++x){     if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){       err += 1;       break;     }   }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture postincrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *c = new int[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = distribution[(int) (a[x]*b[x]/10)]++;             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]++;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      bool found = false;     for (int x = 0; x < 10; ++x){         for (int y = 0; y < distribution_comparison[x]; ++y){             for (int z = 0; z < n; ++z){                 if (c[z] == y && (int) (a[z]*b[z]/10) == x){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction min vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * min = new real_t[10];     real_t temp = 100;     real_t temp_min;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(min[0:10])     {         #pragma acc serial  \t{     \t#pragma acc loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 100;             #pragma acc loop vector reduction(min:temp)             for (int y = 0; y < n; ++y){                 temp = fmin(a[x * n + y] * b[x * n + y], temp);             }             min[x] = temp;         } \t}     }     for (int x = 0; x < 10; ++x){         temp_min = 100;         for (int y = 0; y < n; ++y){             if (temp_min > a[x * n + y] * b[x * n + y]){                 temp_min = a[x * n + y] * b[x * n + y];             }         }         if (fabs(temp_min - min[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial copy", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,data-region,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * a_host = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         a_host[x] = a[x];     }      #pragma acc serial copy(a[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             a[x] = 2 * a[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (2 * a_host[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update x plus expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = totals(x) + a(x, y)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) + a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic x times expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = totals(x) * a(x, y)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) * a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial reduction", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,reduction,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t reduction;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc serial copyin(a[0:n]) reduction(+:reduction)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             reduction = reduction + a[x];         }     }      for (int x = 0; x < n; ++x){         reduction = reduction - a[x];     }     if (fabs(reduction) > PRECISION){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured expr bitand x assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == (prev & a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] = a[x] & totals[x/10];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] &= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitxor loop", "completion": "#ifndef T1 !T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b, host_b   INTEGER,DIMENSION(10):: c, host_c   REAL(8),DIMENSION(LOOPCOUNT, 10, 2):: randoms   INTEGER:: errors, x, y, temp    errors = 0   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)    c = 0   host_c = 0   DO x = 1, LOOPCOUNT     DO y = 1, 10       b(x, y) = INT(randoms(x, y, 1) * 1000)       a(x, y) = INT(randoms(x, y, 2) * 1000)     END DO   END DO   host_b = b    DO y = 1, 10     DO x = 1, LOOPCOUNT       host_c(y) = ieor(host_c(y), a(x, y))     END DO     DO x = 1, LOOPCOUNT       host_b(x, y) = host_b(x, y) + host_c(y)     END DO   END DO    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(b(1:LOOPCOUNT, 1:10), c(1:10))     !$acc serial loop gang private(temp)     DO y = 1, 10       temp = 0       !$acc loop worker reduction(ieor:temp)       DO x = 1, LOOPCOUNT         temp = ieor(temp, a(x, y))       END DO       c(y) = temp       DO x = 1, LOOPCOUNT         b(x, y) = b(x, y) + c(y)       END DO     END DO   !$acc end data    DO y = 1, 10     IF (c(y) .ne. host_c(y)) THEN       errors = errors + 1     END IF     DO x = 1, LOOPCOUNT       IF (host_b(x, y) .ne. b(x, y)) THEN         errors = errors + 1       END IF     END DO   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured preincrement assign", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *c = (int *)malloc(n * sizeof(int));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));     bool found = false;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     ++distribution[(int) (a[x]*b[x]/10)];                     c[x] = distribution[(int) (a[x]*b[x]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]++;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < distribution[x]; ++y){             for (int z = 0; z < n; ++z){                 if (c[z] == y + 1 && x == (int) (a[z] * b[z] / 10)){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update min expr x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction bitxor vector loop", "completion": "#ifndef T1 !T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER,DIMENSION(LOOPCOUNT, 10):: a   INTEGER,DIMENSION(10):: b, host_b   REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms   INTEGER:: errors, x, y, temp    errors = 0   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)    DO y = 1, 10     DO x = 1, LOOPCOUNT       a(x, y) = INT(randoms(x, y) * 10000)     END DO   END DO    DO y = 1, 10     DO x = 1, LOOPCOUNT       host_b(y) = ieor(host_b(y), a(x, y))     END DO   END DO    !$acc data copyin(a(1:LOOPCOUNT, 1:10))     !$acc serial loop private(temp)     DO y = 1, 10       temp = 0       !$acc loop vector reduction(ieor:temp)       DO x = 1, LOOPCOUNT         temp = ieor(temp, a(x, y))       END DO       b(y) = temp     END DO   !$acc end data    DO y = 1, 10     IF (b(y) .ne. host_b(y)) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc set device num", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,set,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(:, :),ALLOCATABLE :: host_copy         INTEGER :: errors = 0          CALL RANDOM_SEED         ALLOCATE(host_copy(acc_get_num_devices(acc_get_device_type()), LOOPCOUNT))          IF (acc_get_device_type() .ne. acc_device_none) THEN           !host_copy(acc_get_num_devices(acc_get_device_type()), LOOPCOUNT)           DO x = 1, acc_get_num_devices(acc_get_device_type())             DO y = 1, LOOPCOUNT               CALL RANDOM_NUMBER(a)               host_copy(x, :) = a             END DO             call acc_set_device_num(x, acc_get_device_type())             !$acc enter data copyin(a(1:LOOPCOUNT))           END DO            DO x = 1, acc_get_num_devices(acc_get_device_type())             call acc_set_device_num(x, acc_get_device_type())             !$acc data present(a(1:LOOPCOUNT))               !$acc parallel                 !$acc loop                 DO y = 1, LOOPCOUNT                   a(y) = a(y) + 1                 END DO               !$acc end parallel             !$acc end data           END DO            DO x = 1, acc_get_num_devices(acc_get_device_type())             call acc_set_device_num(x, acc_get_device_type())             !$acc exit data copyout(a(1:LOOPCOUNT))             DO y = 1, LOOPCOUNT               IF (abs(a(y) - (host_copy(x, y) + 1)) .gt. PRECISION) THEN                 errors = errors + 1               END IF             END DO           END DO         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif         PROGRAM test_acc_set_device_num         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured divided equals assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_c = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(c[x] - (prev / (a[x] + b[x]))) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];                 passed_c[y] = c[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];                 passed_c[y - 1] = c[y];             }             if (is_possible(passed_a, passed_b, passed_c, length - 1, c[x])){                 free(passed_a);                 free(passed_b);                 free(passed_c);                 return true;             }         }     }     free(passed_a);     free(passed_b);     free(passed_c);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));     real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));     real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {       #pragma acc parallel       {           #pragma acc loop           for (int x = 0; x < n; ++x){               #pragma acc atomic capture               {                   totals[x/10] /= (a[x] + b[x]);                   c[x] = totals[x/10];               }           }       }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];             temp_c[temp_iterator] = c[ab_iterator];             temp_iterator++;         }         if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update postincrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic update                         distribution[(int) (a[x]*b[y]/10)]++;                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             distribution_comparison[(int) (a[x]*b[y]/10)]++;         }     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic postincrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic                         distribution[(int) (a[x]*b[y]/10)]++;                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             distribution_comparison[(int) (a[x]*b[y]/10)]++;         }     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data wait", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:async,data,wait,V:3.2-3.3 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copy(a[0:n], b[0:n], c[0:n]) async(0)     {         #pragma acc parallel loop async(1) wait(0)         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }      #pragma acc wait(1) async(0)     }      #pragma acc data copy(a[0:n], b[0:n], c[0:n]) wait(0)     {         #pragma acc parallel loop         for (int x = 0; x < n; ++x){             c[x] += c[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1      failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature kernels loop reduction bitor loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int host_c;      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             b[x * n + y] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);             b_copy[x * n + y] = b[x * n + y];             for (int z = 0; z < 16; ++z){                 if (rand() / (real_t) RAND_MAX > false_margin){                     temp = 1;                     for (int i = 0; i < z; ++i){                         temp = temp * 2;                     }                     a[x * n + y] += temp;                 }             }         }     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])     {         #pragma acc kernels loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(|:temp)             for (int y = 0; y < n; ++y){                 temp = temp | a[x * n + y];             }             c[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 b[x * n + y] = b[x * n + y] + c[x];             }         }     }     for (int x = 0; x < 10; ++x){         host_c = a[x * n];         for (int y = 1; y < n; ++y){             host_c = host_c | a[x * n + y];         }         if (host_c != c[x]){             err += 1;         }         for (int y = 0; y < n; ++y){             if (b[x * n + y] != b_copy[x * n + y] + host_c){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic max x expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature init device type", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-3.2       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: errors = 0          !$acc init device_type(host)          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-3.2       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: errors = 0          !$acc init device_type(multicore)          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-3.2       LOGICAL FUNCTION test3()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: errors = 0          !$acc init device_type(default)          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM init_device_type         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction add vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 0.0;      for(int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10])     {         #pragma acc parallel loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0.0;             #pragma acc loop vector reduction(+:temp)             for (int y = 0; y < n; ++y){                 temp += a[(x * n) + y] + b[(x * n) + y];             }             c[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             c[x] -= a[(x * n) + y] + b[(x * n) + y];         }         if (fabs(c[x]) > PRECISION * (2 * n - 1)){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(25 * sizeof(real_t));     real_t * c_host = (real_t *)malloc(25 * sizeof(real_t));     real_t temp[5];      for (int x = 0; x < 25 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      for (int x = 0; x < 25; ++x) {         c[x] = 0;         c_host[x] = 0;     }      #pragma acc data copyin(a[0:25*n], b[0:25*n]) copyout(c[0:25])     {         #pragma acc parallel loop private(temp)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 temp[y] = 0;             }             #pragma acc loop vector reduction(+:temp)             for (int y = 0; y < 5 * n; ++y) {                 temp[y % 5] += a[x * 5 * n + y] + b[x * 5 * n + y];             }             for (int y = 0; y < 5; ++y) {                 c[x * 5 + y] = temp[y];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5 * n; ++y) {             c_host[x * 5 + (y % 5)] += a[x * 5 * n + y] + b[x * 5 * n + y];         }     }      for (int x = 0; x < 25; ++x) {         if (fabs(c[x] - c_host[x]) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature exit data", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,devonly,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * a_copy = new real_t[n];     int * devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             a_copy[x] = a[x];         }          #pragma acc enter data copyin(a[0:n])         #pragma acc parallel present(a[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = a[x] + 1;             }         }         #pragma acc exit data delete(a[0:n])          for (int x = 0; x < n; ++x){             if (fabs(a[x] - a_copy[x]) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:data,executable-data,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * a_copy = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         a_copy[x] = a[x];     }      #pragma acc enter data copyin(a[0:n])     #pragma acc parallel present(a[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             a[x] = a[x] + 1;         }     }     #pragma acc exit data copyout(a[0:n])      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (a_copy[x] + 1)) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc copyout finalize async", "completion": "#ifndef T1 !T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(d)         CALL RANDOM_NUMBER(e)         f = 0          !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))         !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           !$acc parallel async(2)             !$acc loop             DO x = 1, LOOPCOUNT               f(x) = d(x) + e(x)             END DO           !$acc end parallel           CALL acc_copyout_finalize_async(c(1:LOOPCOUNT), 1)           CALL acc_copyout_finalize_async(f(1:LOOPCOUNT), 2)           !$acc wait         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF           IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO         IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif         PROGRAM main       IMPLICIT NONE       INTEGER :: failcode, testrun       LOGICAL :: failed       INCLUDE \"acc_testsuite.Fh\"       !Conditionally define test functions #ifndef T1       LOGICAL :: test1 #endif       failcode = 0       failed = .FALSE.  #ifndef T1       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test1()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 0         failed = .FALSE.       END IF #endif        CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature parallel loop reduction and vector loop", "completion": "#ifndef T1 !T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         LOGICAL,DIMENSION(10*LOOPCOUNT):: a !Data         LOGICAL,DIMENSION(10):: b         LOGICAL,DIMENSION(10):: has_false         LOGICAL :: temp         REAL(8) :: false_margin         REAL(8),DIMENSION(10*LOOPCOUNT) :: randoms         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         false_margin = exp(log(.5) / LOOPCOUNT)         DO x = 1, 10           has_false(x) = .FALSE.           b(x) = .TRUE.         END DO          DO x = 0, 9           DO y = 1, LOOPCOUNT             IF (randoms(x * LOOPCOUNT + y) .lt. false_margin) THEN               a(x * LOOPCOUNT + y) = .TRUE.             ELSE               a(x * LOOPCOUNT + y) = .FALSE.               has_false(x + 1) = .TRUE.             END IF           END DO         END DO          !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10))           !$acc parallel loop private(temp)           DO x = 0, 9             temp = .TRUE.             !$acc loop vector reduction(.AND.:temp)             DO y = 1, LOOPCOUNT               temp = temp .AND. a(x * LOOPCOUNT + y)             END DO             b(x + 1) = temp           END DO         !$acc end data          DO x = 0, 9           temp = .FALSE.           DO y = 1, LOOPCOUNT             IF (a(x * LOOPCOUNT + y) .eqv. .FALSE.) THEN               temp = .TRUE.             END IF           END DO           IF (temp .neqv. has_false(x + 1)) THEN             errors = 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature shutdown device type nvidia", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,shutdown,nonvalidating,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: errors = 0          !$acc shutdown device_type(nvidia)          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM shutdown_device_type         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial switch", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     int * a = (int *)malloc(n * sizeof(int));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * b_host = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = floor(rand() / (real_t)(RAND_MAX / 10));         b[x] = rand() / (real_t)(RAND_MAX / 10);         b_host[x] = b[x];         c[x] = 0.0;     }     #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])     #pragma acc serial present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             switch(a[x]){                 case 0:                     c[x] = b[x] * b[x];                     break;                 case 1:                     c[x] = b[x] / b[x];                     break;                 case 2:                     b[x] = b[x] / 2;                 default:                     c[x] = a[x] + b[x];               }         }     }     #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])      real_t tempc = 0.0;     for (int x = 0; x < n; ++x){         switch(a[x]){             case 0:                 tempc = b_host[x] * b_host[x];                 break;             case 1:                 tempc = b_host[x] / b_host[x];                 break;             case 2:                 b_host[x] = b_host[x] / 2;             default:                 tempc = a[x] + b_host[x];         }         if (fabs(c[x] - tempc) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels vector length", "completion": "#ifndef T1 !T1:kernels,V:2.5-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0          !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))           !$acc kernels vector_length(16)             !$acc loop vector             DO x = 1, LOOPCOUNT               b(x) = a(x)             END DO           !$acc end kernels         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(a(x) - b(x)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic x and expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) < .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = totals(x) .AND. a(x, y)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .AND. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc on device", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,present,V:1.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: errors         INTEGER :: device_type         errors = 0         device_type = acc_get_device_type()         IF (device_type .ne. acc_device_none) THEN           !$acc parallel             IF (acc_on_device(device_type) .eqv. .FALSE.) THEN               errors = errors + 1             END IF           !$acc end parallel         ELSE           !$acc parallel             IF (acc_on_device(acc_device_host) .eqv. .FALSE.) THEN               errors = errors + 1             END IF           !$acc end parallel         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature atomic expr lshift x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};     int result;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 3; ++y){             a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));         }         b[x] = 0;     }      #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 3; ++y){                     #pragma acc atomic                         b[x] = a[x * 3 + y] << b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 6; ++y){             result = 0;             for (int z = 0; z < 3; ++z){                 result = a[x * 3 + orders[y * 3 + z]] << result;             }             if (result == b[x]){                 break;             }         }         if (result != b[x]){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign expr divided x", "completion": "#include \"acc_testsuite.h\" bool is_possible_2(real_t* a, real_t* b, int length, real_t prev, real_t destination){     if (length == 0 && abs(prev - destination) < PRECISION){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         for (int y = 0; y < x; ++y){             passed_a[y] = a[y];             passed_b[y] = b[y];         }         for (int y = x + 1; y < length; ++y){             passed_a[y - 1] = a[y];             passed_b[y - 1] = b[y];         }         if (is_possible_2(passed_a, passed_b, length - 1, (a[x] + b[x]) / prev, destination)){             delete[] passed_a;             delete[] passed_b;             return true;         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     real_t *passed_c = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(c[x] - prev) < 100*PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];                 passed_c[y] = c[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];                 passed_c[y - 1] = c[y];             }             if (is_possible(passed_a, passed_b, passed_c, length - 1, (a[x] + b[x]) / prev)){                 delete[] passed_a;                 delete[] passed_b;                 delete[] passed_c;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     delete[] passed_c;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t* passed_a = new real_t[10];     real_t* passed_b = new real_t[10];     real_t *temp_a = new real_t[10];     real_t *temp_b = new real_t[10];     real_t *temp_c = new real_t[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x/10];                     totals[x/10] = (a[x] + b[x]) / totals[x/10];                 }             }         }     }      for (int x = 0; x < n; x = x + 10){         for (int y = 0; y < 10 && (x + y) < n; ++y){             passed_a[y] = a[x + y];             passed_b[y] = b[x + y];         }         if (!(is_possible_2(passed_a, passed_b, 10, 1, totals[x/10]))){             err += 1;             break;         }     }      for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];             temp_c[temp_iterator] = c[ab_iterator];             temp_iterator++;         }         if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction multiply loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * totals = (real_t *)malloc(10 * sizeof(real_t));     real_t temp;      for (int x = 0; x < n; ++x){         a[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;         b[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;         c[x] = 0.0;     }       #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10*n]) copy(totals[0:10])     {         #pragma acc serial  \t{    \t#pragma acc loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop worker reduction(*:temp)             for (int y = 0; y < n; ++y){                 temp *= a[x * n + y] + b[x * n + y];             }             totals[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 c[x * n + y] = (a[x * n + y] + b[x * n + y]) / totals[x];             }         } \t}     }      for (int x = 0; x < 10; ++x){         temp = 1;         for (int y = 0; y < n; ++y){             temp *= a[x * n + y] + b[x * n + y];         }         if (fabs(temp - totals[x]) > (temp / 2 + totals[x] / 2) * PRECISION){             err += 1;         }         for (int y = 0; y < n; ++y){             if (fabs(c[x * n + y] - ((a[x * n + y] + b[x * n + y]) / totals[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc delete finalize async", "completion": "#ifndef T1 !T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data         INTEGER :: errors         errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(d)         CALL RANDOM_NUMBER(e)         f = 0          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))         !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))          !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           !$acc parallel async(2)             !$acc loop             DO x = 1, LOOPCOUNT               f(x) = d(x) + e(x)             END DO           !$acc end parallel           CALL acc_delete_finalize_async(a(1:LOOPCOUNT), 1)           CALL acc_delete_finalize_async(b(1:LOOPCOUNT), 1)           CALL acc_delete_finalize_async(d(1:LOOPCOUNT), 2)           CALL acc_delete_finalize_async(e(1:LOOPCOUNT), 2)           !$acc wait         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF           IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors         errors = 0          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))         !$acc enter data copyin(c(1:LOOPCOUNT))         !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_delete_finalize_async(c(1:LOOPCOUNT), 1)          !$acc enter data copyin(c(1:LOOPCOUNT)) async(1)         !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = c(x) + a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2**1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature kernels loop tile", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,tile,reduction,combined-constructs,V:2.0-2.7 int test1(){   int err = 0;   srand(SEED);   real_t * a = (real_t *)malloc(n * sizeof(real_t));   real_t * b = (real_t *)malloc(n * sizeof(real_t));   real_t * c = (real_t *)malloc(n * sizeof(real_t));   real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));   real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));   real_t temp = 0.0;    for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = rand() / (real_t)(RAND_MAX / 10);   }   #pragma acc data copy(a[0:n], b[0:n], c[0:n], d2[0:n*n])   {       #pragma acc kernels loop tile(*, *) reduction(+:temp)       for (int x = 0; x < n; ++x){           for (int y = 0; y < n; ++y){               temp = 0;               for (int z = 0; z < n; ++z){                   temp += a[x] + b[y] + c[z];               }               d2[x * n + y] = temp;           }       }   }   for (int x = 0; x < n; ++x){       for (int y = 0; y < n; ++y){           temp = 0.0;           for (int z = 0; z < n; ++z){               temp += a[x] + b[y] + c[z];           }           if (fabs(temp - d2[x * n + y]) > PRECISION * n){               err += 1;           }       }   }      return err; } #endif  #ifndef T2 //T2:kernels,loop,tile,combined-constructs,V:2.0-2.7 int test2(){   int err = 0;   srand(SEED);   real_t * a = (real_t *)malloc(n * sizeof(real_t));   real_t * b = (real_t *)malloc(n * sizeof(real_t));   real_t * c = (real_t *)malloc(n * sizeof(real_t));   real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));   real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));   real_t temp = 0.0;    for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = rand() / (real_t)(RAND_MAX / 10);   }    #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d3[0:n*n*n])   {       #pragma acc kernels loop tile(n/10, n, n*2)       for (int x = 0; x < n; ++x){           for (int y = 0; y < n; ++y){               for (int z = 0; z < n; ++z){                   d3[(n * n * x) + (n * y) + z] = a[x] + b[x] + c[x];               }           }       }   }    for (int x = 0; x < n; ++x){       for (int y = 0; y < n; ++y){           for (int z = 0; z < n; ++z){               if (fabs(d3[(n * n * x) + (n * y) + z] - a[x] - b[x] - c[x]) > PRECISION * 2){                   err = 1;               }           }       }   }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr rshift x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};     int result;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 3; ++y){             a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));         }         b[x] = 0;     }      #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop independent                 for (int y = 0; y < 3; ++y){                     #pragma acc atomic                         b[x] = a[x * 3 + y] >> b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 6; ++y){             result = 0;             for (int z = 0; z < 3; ++z){                 result = a[x * 3 + orders[y * 3 + z]] >> result;             }             if (result == b[x]){                 break;             }         }         if (result != b[x]){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature set device type num nvidia", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,set,nonvalidating,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: device_num         INTEGER :: device_type         INTEGER :: errors = 0          device_type = acc_get_device_type()         device_num = acc_get_device_num(device_type)         !$acc set device_type(nvidia) device_num(device_num)          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature copyin copyout", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:, V:1.0-2.7 int test1(){     int err = 0;     real_t test = 0;     #pragma acc parallel loop copyin(test) copyout(test) reduction(+:test)     for( int x = 0; x <n; ++x){         test += 1;     }      if(fabs(test - n) > PRECISION){         err++;     }      return err; } #endif  #ifndef T2 //T2: , V:1.0-2.7 int test2(){     int err = 0;     real_t *test = new real_t[n];      for(int x = 0; x < n; ++x){         test[x] = 1.0;     }     #pragma acc parallel loop copyin(test[0:n]) copyout(test[0:n])    for(int x = 0; x < n; ++x){         test[x] += 1.0;    }     for(int x = 0; x < n; ++x){         if(fabs(test[x] - 2.0) > PRECISION){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for( int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test1();     }     if(failed){ \tfailcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for( int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }     if(failed){         failcode += (1 << 1);     } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature atomic structured x minus expr assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (prev - a[x])) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[10];     real_t *totals_host = new real_t[10];     real_t * passed_ab = new real_t[(n/10 + 1)];     real_t * passed_c = new real_t[(n/10 + 1)];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0; \ttotals_host[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x%10] = totals[x%10] - (a[x] + b[x]);                     c[x] = totals[x%10];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update expr bitand x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] &= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc copyin async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:async,data,executable-data,runtime,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *a_host = (real_t *)malloc(n * sizeof(real_t));     real_t *b_host = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         a_host[x] = a[x];         b_host[x] = b[x];     }      acc_copyin_async(a, n * sizeof(real_t), 1);     acc_copyin_async(b, n * sizeof(real_t), 2);     #pragma acc data copyout(c[0:n]) present(a[0:n], b[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = a[x] * a[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = b[x] * b[x];             }         }         #pragma acc parallel async(2) wait(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > PRECISION * 4){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 1;     }      acc_copyin_async(a, n*sizeof(real_t), 1);     acc_copyin_async(b, n*sizeof(real_t), 2);      #pragma acc data copyout(c[0:n])     {         while (!acc_async_test_all());         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      acc_copyin_async(a, n * sizeof(real_t), 1);     acc_copyin_async(b, n * sizeof(real_t), 2);      #pragma acc data copyout(c[0:n])     {         #pragma acc wait         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err = err + 1;         }     }      return err; } #endif  #ifndef T4 //T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7 int test4(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * d = (real_t *)malloc(n * sizeof(real_t));     real_t * e = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = 0;     }      #pragma acc enter data create(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) copyout(e[0:n])     {         #pragma acc parallel present(c[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         acc_copyin_async(c, n * sizeof(real_t), 1);         #pragma acc parallel present(c[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 e[x] = c[x] + d[x];             }         }     }     #pragma acc wait     #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }         if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T5 //T5:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7 int test5(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));     int * devtest = (int *)malloc(sizeof(int));      devtest[0] = 0;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 1;     }      if (devtest[0] == 0){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0;             a_copy[x] = a[x];             b_copy[x] = b[x];         }          acc_copyin_async(a, n * sizeof(real_t), 1);         acc_copyin_async(b, n * sizeof(real_t), 2);          for (int x = 0; x < n; ++x) {             a[x] = 0;             b[x] = 0;         }          #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])         {             #pragma acc wait             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x) {                     c[x] = a[x] + b[x];                 }             }         }          #pragma acc exit data delete(a[0:n], b[0:n])          for (int x = 0; x < n; ++x) {             if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic ixor x expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .lt. .5) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           totals(x) = 0           totals_comparison(x) = 0         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc copyout finalize", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data create(c[0:n])     #pragma acc enter data create(c[0:n])      #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }     acc_copyout_finalize(c, n * sizeof(real_t));      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data copyin(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }     }     acc_copyout_finalize(c, n * sizeof(real_t));      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data copyin(c[0:n])     #pragma acc enter data copyin(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         acc_copyout_finalize(c, n * sizeof(real_t));         #pragma acc enter data copyin(c[0:n])         #pragma acc parallel present(c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] += a[x] + b[x];             }         }     }     #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {             err += 1;         }     }           return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction max vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * max = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 0;     real_t temp_max;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(max[0:10])     {         #pragma acc parallel loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(max:temp)             for (int y = 0; y < n; ++y){                 temp = fmax(a[x * n + y] * b[x * n + y], temp);             }             max[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         temp_max = 0;         for (int y = 0; y < n; ++y){             if (temp_max < a[x * n + y] * b[x * n + y]){                 temp_max = a[x * n + y] * b[x * n + y];             }         }         if (fabs(temp_max - max[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));     real_t * maximums = (real_t *)malloc(25 * sizeof(real_t));     real_t reduced[5];      for (int x = 0; x < 25 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      for (int x = 0; x < 25; ++x) {         maximums[x] = 0;     }      #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(maximums[0:25])     {         #pragma acc parallel loop private(reduced)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 reduced[y] = 0;             }             #pragma acc loop vector reduction(max:reduced)             for (int y = 0; y < 5 * n; ++y) {                 reduced[y%5] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);             }             for (int y = 0; y < 5; ++y) {                 maximums[x * 5 + y] = reduced[y];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             reduced[y] = 0;         }         for (int y = 0; y < 5 * n; ++y) {             reduced[y%5] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);         }         for (int y = 0; y < 5; ++y) {             if (fabs(maximums[x * 5 + y] - reduced[y]) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update iand x expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .gt. .933) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           DO y = 0, 7             totals(x) = totals(x) + ISHFT(1, y)             totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)           END DO         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature set if", "completion": "#include \"acc_testsuite.h\"  /*  * if clause not implimented for set as of now */  #ifndef T1 //T1:,V:2.7-3.0 int test1(){ \tint err = 0; \tsrand(SEED); \tint device_type = acc_get_device_type();  \t#pragma acc set if(acc_get_device_type == device_type)  \treturn err;\t } #endif #ifndef T2 //T2:,V:2.7-3.0 int test2(){ \tint err = 0;         srand(SEED);         int device_type = acc_get_device_type();          #pragma acc set if(acc_get_device_type != device_type)          return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature init device type num nvidia", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: device_num         INTEGER :: device_type         INTEGER :: errors = 0          device_type = acc_get_device_type()         device_num = acc_get_device_num(device_type)         !$acc init device_type(nvidia) device_num(device_num)          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM init_device_type_num         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update postincrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic update                         distribution[(int) (a[x]*b[y]/10)]++;                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             distribution_comparison[(int) (a[x]*b[y]/10)]++;         }     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc delete async", "completion": "#ifndef T1 !T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(d)         CALL RANDOM_NUMBER(e)         f = 0          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))          !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           !$acc parallel async(2)             !$acc loop             DO x = 1, LOOPCOUNT               f(x) = d(x) + e(x)             END DO           !$acc end parallel           CALL acc_delete_async(a(1:LOOPCOUNT), 1)           CALL acc_delete_async(b(1:LOOPCOUNT), 1)           CALL acc_delete_async(d(1:LOOPCOUNT), 2)           CALL acc_delete_async(e(1:LOOPCOUNT), 2)           !$acc wait         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF           IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c!Data         INTEGER,DIMENSION(1) :: devtest         INTEGER :: errors = 0          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = 0         !$acc end parallel          IF (devtest(1) == 1) THEN           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 0            !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))           !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))             !$acc parallel async(1)               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) + b(x)               END DO             !$acc end parallel           !$acc end data           CALL acc_delete_async(c(1:LOOPCOUNT), 1)           !$acc enter data copyin(c(1:LOOPCOUNT)) async(1)           !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))             !$acc parallel async(1)               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = c(x) + a(x) + b(x)               END DO             !$acc end parallel           !$acc end data           !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))            DO x = 1, LOOPCOUNT             IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2**1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature atomic update x minus expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = totals(x) - a(x, y)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) - a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop independent", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc kernels loop independent         for (int x = 0; x < n; ++x){             b[x] = a[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop independent reduction", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,reduction,V:2.7-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t reduction;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc parallel copyin(a[0:n]) reduction(+:reduction)     {         #pragma acc loop independent         for (int x = 0; x < n; ++x){             reduction = reduction + a[x];         }     }      for (int x = 0; x < n; ++x){         reduction = reduction - a[x];     }     if (fabs(reduction) > PRECISION){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature atomic capture postincrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *c = (int *)malloc(n * sizeof(int));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = distribution[(int) (a[x]*b[x]/10)]++;             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]++;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      bool found = false;     for (int x = 0; x < 10; ++x){         for (int y = 0; y < distribution_comparison[x]; ++y){             for (int z = 0; z < n; ++z){                 if (c[z] == y && (int) (a[z]*b[z]/10) == x){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature shutdown", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:shutdown,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);      #pragma acc shutdown      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction or loop", "completion": "#ifndef T1 !T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         LOGICAL,DIMENSION(10*LOOPCOUNT):: a, a_copy !Data         LOGICAL,DIMENSION(10) :: results         LOGICAL :: temp = .FALSE.         REAL(8),DIMENSION(10 * LOOPCOUNT) :: random         REAL(8) :: false_margin = exp(log(.5) / n)         INTEGER :: errors = 0          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(random)          !Initilization         DO x = 1, 10 * LOOPCOUNT           IF (random(x) .gt. false_margin) THEN             a(x) = .TRUE.           ELSE             a(x) = .FALSE.           END IF           a_copy(x) = a(x)         END DO          DO x = 1, 10           results(x) = .FALSE.         END DO          !$acc data copy(a(1:10*LOOPCOUNT), results(1:10))           !$acc parallel loop gang private(temp)           DO x = 0, 9             temp = .FALSE.             !$acc loop worker reduction(.OR.:temp)             DO y = 1, LOOPCOUNT               temp = temp .OR. a(x * LOOPCOUNT + y)             END DO             results(x + 1) = temp             !$acc loop worker             DO y = 1, LOOPCOUNT               IF (results(x + 1) .eqv. .TRUE.) THEN                 IF(a(x * LOOPCOUNT + y) .eqv. .TRUE.) THEN                   a(x * LOOPCOUNT + y) = .FALSE.                 ELSE                   a(x * LOOPCOUNT + y) = .TRUE.                 END IF               END IF             END DO           END DO         !$acc end data          DO x = 0, 9           temp = .FALSE.           DO y = 1, LOOPCOUNT             temp = temp .OR. a_copy(x * LOOPCOUNT + y)           END DO           IF (temp .neqv. results(x + 1)) THEN             errors = errors + 1           END IF           DO y = 1, LOOPCOUNT             IF (temp .eqv. .FALSE.) THEN               IF (a(x * LOOPCOUNT + y) .neqv. a_copy(x * LOOPCOUNT + y)) THEN                 errors = errors + 1               END IF             ELSE               IF (a(x * LOOPCOUNT + y) .eqv. a_copy(x * LOOPCOUNT + y)) THEN                 errors = errors + 1               END IF             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop reduction bitxor general", "completion": "#ifndef T1 !T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: randoms         INTEGER :: errors = 0         INTEGER :: b = 0         INTEGER :: temp = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = FLOOR(randoms*1000000)          !$acc data copyin(a(1:LOOPCOUNT))           !$acc kernels loop reduction(ieor:b)           DO x = 1, LOOPCOUNT             b = ieor(b, a(x))           END DO         !$acc end data          DO x = 1, LOOPCOUNT           temp = ieor(temp, a(x))         END DO         IF (temp .ne. b) THEN           errors = errors + 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction or vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(10 * n * sizeof(char));     char * b = (char *)malloc(10 * sizeof(char));     real_t false_margin = pow(exp(1), log(.5)/n);     char temp = 0;     char found;      for (int x = 0; x < 10 * n; ++x){         if(rand() / (real_t)(RAND_MAX) > false_margin){             a[x] = 1;         }         else{             a[x] = 0;         }     }     #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(||:temp)             for (int y = 0; y < n; ++y){                 temp = temp || a[x * n + y];             }             b[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         found = 0;         for (int y = 0; y < n; ++y){             if (a[x * n + y] &! 0){                 found = 1;             }         }         if (found != b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels num gangs", "completion": "#ifndef T1 !T1:kernels,reduction,V:2.5-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         INTEGER :: results !Data         INTEGER :: errors = 0          results = 0          !$acc kernels num_gangs(8)           !$acc loop gang reduction(+:results)           DO x = 1, LOOPCOUNT             results = 1           END DO         !$acc end kernels                    IF (results .ne. 8) THEN           errors = errors + 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature loop collapse", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:loop,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }     for (int x = 0; x < 10; ++x){         c[x * n] = a[x * n] + b[x * n];     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n])     {         #pragma acc parallel         {             #pragma acc loop independent collapse(1)             for (int x = 0; x < 10; ++x){                 for (int y = 1; y < n; ++y){                     c[x * n + y] = c[x * n + y - 1] + a[x * n + y] + b[x * n + y];                 }             }         }     }      real_t total;     for (int x = 0; x < 10; ++x){         total = 0;         for (int y = 0; y < n; ++y){             total += a[x * n + y] + b[x * n + y];             if (fabs(c[x * n + y] - total) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:loop,syntactic,construct-independent,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10*n])     {         #pragma acc parallel         {             #pragma acc loop independent collapse(2)             for (int x = 0; x < 10; ++x){                 for (int y = 0; y < n; ++y){                     c[x * n + y] = a[x * n + y] + b[x * n + y];                 }             }         }     }      for (int x = 0; x < 10 * n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc update device", "completion": "#ifndef T1 !T1:runtime,data,executable-data,construct-independent,update,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyout(c(1:LOOPCOUNT)) create(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           CALL acc_update_device(a(1:LOOPCOUNT))           CALL acc_update_device(b(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,data,executable-data,devonly,construct-independent,update,V:2.0-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER,DIMENSION(1):: devtest         INTEGER :: errors = 0          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = 0         !$acc end parallel          IF (devtest(1) .eq. 1) THEN           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 0            !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 a(x) = a(x) * a(x)               END DO             !$acc end parallel             CALL acc_update_device(a(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 b(x) = b(x) * b(x)               END DO             !$acc end parallel             CALL acc_update_device(b(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) + b(x)               END DO             !$acc end parallel           !$acc end data            DO x = 1, LOOPCOUNT             IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature kernels num workers", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * restrict a = new real_t[n];     real_t * restrict b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc kernels loop num_workers(16)         for (int x = 0; x < n; ++x){             b[x] = a[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign x bitor expr", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev | a[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         b[x] = totals[x/10];                         totals[x/10] = totals[x/10] | a[x];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] |= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel wait", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,wait,async,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      #pragma acc enter data create(a[0:n])     #pragma acc update device(a[0:n]) async(1)     #pragma acc parallel present(a[0:n]) wait(1)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             a[x] += 1;         }     }     #pragma acc exit data copyout(a[0:n])     for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] + 1)) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture postdecrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *c = new int[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = (distribution[(int) (a[x]*b[x]/10)])--;             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]--;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      bool found = false;     for (int x = 0; x < 10; ++x){         for (int y = 0; y > -distribution_comparison[x]; --y){             for (int z = 0; z < n; ++z){                 if (y == c[z] && x == (int) (a[x] * b[x] / 10)){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc free", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,V:2.6-2.7 int test1(){     int err = 0;     int *a = (int *)acc_malloc(n * sizeof(int));     size_t initial_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);      acc_free(a);     size_t final_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);     if (final_memory < initial_memory + n * sizeof(int)){         err += 1;     }     return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign predecrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *c = new int[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];     bool found = false;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = distribution[(int) (a[x]*b[x]/10)];                     --distribution[(int) (a[x]*b[x]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]--;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y > distribution[x]; --y){             for (int z = 0; z < n; ++z){                 if (c[z] == y && x == (int) (a[z] * b[z] / 10)){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature gang-dimensions", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,gang,dim,V:3.3 int test1(){     int err = 0;     srand(SEED);       real_t arr1[n][n];     real_t arr2[n][n];      for(int i = 0; i < n; i++) {         for(int j = 0; j < n; j++) {             arr1[i][j] = rand() / (real_t)(RAND_MAX / 10);             arr2[i][j] = arr1[i][j] + 1;         }     }      #pragma acc parallel num_gangs(n,n)      #pragma acc loop gang(dim:2)     for (int i = 0; i < n; i++)     {             #pragma acc loop gang(dim:1)         for (int j = 0; j < n; j++)         {             arr1[i][j] = arr1[i][j] + 1;         }     }      for(int i = 0; i < n; i++) {         for(int j = 0; j < n; j++) {             if (fabs(arr1[i][j] - arr2[i][j]) > PRECISION)  {                 err = 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,gang,dim,V:3.3 int test2(){     int err = 0;     srand(SEED);       real_t arr1[n][n][n];     real_t arr2[n][n][n];      for(int i = 0; i < n; i++) {         for(int j = 0; j < n; j++) {             for(int k = 0; k < n; k++) {                 arr1[i][j][k] = rand() / (real_t)(RAND_MAX / 10);                 arr2[i][j][k] = arr1[i][j][k] + 1;             }         }     }      #pragma acc parallel num_gangs(n,n,n)      #pragma acc loop gang(dim:3)     for (int i = 0; i < n; i++)     {         #pragma acc loop gang(dim:2)         for (int j = 0; j < n; j++)         {             #pragma acc loop gang(dim:1)             for (int k = 0; k < n; k++)             {                 arr1[i][j][k] = arr1[i][j][k] + 1;             }         }     }      for(int i = 0; i < n; i++) {         for(int j = 0; j < n; j++) {             for(int k = 0; k < n; k++) {                 if (fabs(arr1[i][j][k] - arr2[i][j][k]) > PRECISION)  {                     err = 1;                 }             }         }     }      return err; } #endif  #pragma acc routine vector void inner(real_t arr1, int n) {     #pragma acc loop vector     for(int i = 0; i < n; i++)     {         arr1 = arr1 + 1;     } }  #pragma acc routine gang(dim:1) void outer(real_t arr1[n], int n) {     #pragma acc loop gang(dim:1)     for(int i = 0; i < n; i++)     {         inner(arr1[i], n);     } }  #ifndef T3 //T3:parallel,gang,dim,routine,V:3.3 int test3() {     int err = 0;     srand(SEED);       real_t arr1[n][n];     real_t arr2[n][n];      for(int i = 0; i < n; i++) {         for(int j = 0; j < n; j++) {             arr1[i][j] = rand() / (real_t)(RAND_MAX / 10);             arr2[i][j] = arr1[i][j] + 1;         }     }          #pragma acc parallel loop num_gang(n,n) gang(dim:2)     for(int i = 0; i < n; i++)     {         outer(arr1[i], n);     }      for(int i = 0; i < n; i++) {         for(int j = 0; j < n; j++) {             if (fabs(arr1[i][j] - arr2[i][j]) > PRECISION)  {                 err = 1;             }         }     }      return err; } #endif  #pragma acc routine vector void inner_3D(real_t arr1, int n) {     #pragma acc loop vector     for(int i = 0; i < n; i++)     {         arr1 = arr1 + 1;     } }  #pragma acc_routine gang(dim:1) void middle(real_t arr1[n], int n) {     #pragma acc loop gang(dim:1)     for(int i = 0; i < n; i++)     {         inner_3D(arr1[i], n);     } }  #pragma acc routine gang(dim:2) void outer_3D(real_t arr1[n][n], int n) {     #pragma acc loop gang(dim:1)     for(int i = 0; i < n; i++)     {         middle(arr1[i], n);     } }  #ifndef T4 //T4:parallel,gang,dim,routine,V:3.3 int test4() {     int err = 0;     srand(SEED);       real_t arr1[n][n][n];     real_t arr2[n][n][n];      for(int i = 0; i < n; i++) {         for(int j = 0; j < n; j++) {             for(int k = 0; k < n; k++) {                 arr1[i][j][k] = rand() / (real_t)(RAND_MAX / 10);                 arr2[i][j][k] = arr1[i][j][k] + 1;             }         }     }      #pragma acc parallel loop num_gang(n,n,n) gang(dim:3)     for(int i = 0; i < n; i++)     {         outer_3D(arr1[i], n);     }      for(int i = 0; i < n; i++) {         for(int j = 0; j < n; j++) {             for(int k = 0; k < n; k++) {                 if (fabs(arr1[i][j][k] - arr2[i][j][k]) > PRECISION)  {                     err = 1;                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction min loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * minimum = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 0;      for (int x = 0; x < 10 * n; ++x){         a[x] = 1 + rand() / (real_t)(RAND_MAX/10);         b[x] = 1 + rand() / (real_t)(RAND_MAX/10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], minimum[0:10])     {         #pragma acc kernels loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1000;             #pragma acc loop reduction(min:temp)             for (int y = 0; y < n; ++y){                 temp = fmin(a[x * n + y] * b[x * n + y], temp);             }             minimum[x] = temp;             #pragma acc loop             for (int y = 0; y < n; ++y){                 c[x * n + y] = (a[x * n + y] * b[x * n + y]) / minimum[x];             }         }     }      for (int x = 0; x < 10; ++x){         temp = 1000;         for (int y = 0; y < n; ++y){             temp = fmin(temp, a[x * n + y] * b[x * n + y]);         }         if (fabs(temp - minimum[x]) > PRECISION){             err += 1;         }         for (int y = 0; y < n; ++y){             if (fabs(c[x * n + y] - (a[x * n + y] * b[x * n + y] / minimum[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature shutdown if", "completion": "#include \"acc_testsuite.h\" /*  *if clause not implimented as of now */  #ifndef T1 //T1:,V:2.7-3.0 int test1(){ \tint err = 0; \tsrand(SEED); \tint device_num;  \tdevice_num = acc_get_device_num(acc_get_device_type()); \t#pragma acc shutdown if(device_num == device_num)  \treturn err; } #endif  #ifndef T2 //T2:,V:2.7-3.0 int test2(){ \tint err = 0; \tsrand(SEED); \tint device_num;  \tdevice_num = acc_get_device_num(acc_get_device_type()); \t#pragma acc shutdown if(device_num != device_num)  \treturn err; } #endif  int main(){ \tint failcode = 0; \tint failed; #ifndef T1 \tfailed = 0; \tfor (int x = 0; x < NUM_TEST_CALLS; ++x){ \t\tfailed = failed + test1(); \t} \tif (failed != 0){ \t\tfailcode = failcode + (1 << 0); \t} #endif #ifndef T2         failed = 0;         for (int x = 0; x < NUM_TEST_CALLS; ++x){                 failed = failed + test2();         }         if (failed != 0){                 failcode = failcode + (1 << 1);         } #endif \treturn failcode; } "}
{"prompt": "Create a test for the feature atomic structured preincrement assign", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *c = new int[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];     bool found = false;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     ++distribution[(int) (a[x]*b[x]/10)];                     c[x] = distribution[(int) (a[x]*b[x]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]++;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < distribution[x]; ++y){             for (int z = 0; z < n; ++z){                 if (c[z] == y + 1 && x == (int) (a[z] * b[z] / 10)){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture multiply equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] * prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = totals[x%(n/10 + 1)] *= a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction multiply general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     int multiplicitive_n = 128;     srand(SEED);     real_t * a = new real_t[multiplicitive_n];     real_t * b = new real_t[multiplicitive_n];      real_t multiplied_total = 1.0;      for (int x = 0; x < multiplicitive_n; ++x){         a[x] = rand() / (real_t) RAND_MAX;         b[x] = rand() / (real_t) RAND_MAX;     }      #pragma acc data copyin(a[0:multiplicitive_n], b[0:multiplicitive_n]) copy(multiplied_total)     {         #pragma acc kernels loop reduction(*:multiplied_total)         for (int x = 0; x < multiplicitive_n; ++x){             multiplied_total *= a[x] + b[x];         }     }      for (int x = 0; x < multiplicitive_n; ++x){         multiplied_total /= (a[x] + b[x]);     }     if (fabs(multiplied_total - 1) > PRECISION * (2 * multiplicitive_n - 1)){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data with structs", "completion": "#include \"acc_testsuite.h\" typedef struct multi_item {     real_t a;     real_t b;     real_t c; } multi_item;  #ifndef T1 //T1:data,data-region,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     multi_item * a = new multi_item[n];      for (int x = 0; x < n; ++x){         a[x].a = rand() / (real_t)(RAND_MAX / 10);         a[x].b = rand() / (real_t)(RAND_MAX / 10);         a[x].c = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x].c = a[x].a + a[x].b;             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x].c - (a[x].a + a[x].b)) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature set default async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:async,set,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *a_host = (real_t *)malloc(n * sizeof(real_t));     real_t *b_host = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         a_host[x] = a[x];         b_host[x] = b[x];     }      #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])     {         #pragma acc set default_async(1)         #pragma acc parallel async         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = a[x] * a[x];             }         }         #pragma acc set default_async(2)         #pragma acc parallel async         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = b[x] * b[x];             }         }         #pragma acc parallel async(1) wait(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc wait(1)     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4*PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction add vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10];     real_t temp = 0.0;      for(int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0.0;             #pragma acc loop vector reduction(+:temp)             for (int y = 0; y < n; ++y){                 temp += a[(x * n) + y] + b[(x * n) + y];             }             c[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             c[x] -= a[(x * n) + y] + b[(x * n) + y];         }         if (fabs(c[x]) > PRECISION * (2 * n - 1)){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop", "completion": "#ifndef T1 !T1:parallel,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         a = 0         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          !$acc data copy(a(1:LOOPCOUNT))           !$acc parallel loop           DO x = 1, LOOPCOUNT             a(x) = 1           END DO         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(a(x) - 1) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:parallel,loop,V:1.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         a = 0         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(b)         CALL RANDOM_NUMBER(c)          !$acc data copy(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               a(x) = b(x)             END DO             !$acc loop             DO x = 1, LOOPCOUNT               a(x) = a(x) + c(x)             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(a(x) - (b(x) + c(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel present", "completion": "#ifndef T1 !T1:parallel,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))         !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))           !$acc loop           DO x = 1, LOOPCOUNT             c(x) = a(x) + b(x)           END DO         !$acc end parallel         !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign postdecrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *c = (int *)malloc(n * sizeof(int));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));     bool found = false;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = distribution[(int) (a[x]*b[x]/10)];                     (distribution[(int) (a[x]*b[x]/10)])--;                 }             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]--;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y > -distribution_comparison[x]; --y){             for (int z = 0; z < n; ++z){                 if (y == c[z] && x == (int) (a[x] * b[x] / 10)){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data copyout reference counts", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,data-region,reference-counting,devonly,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int * devtest = (int *)malloc(sizeof(int));     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {       devtest[0] = 0;     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }       if (devtest[0] == 1) {         #pragma acc data copyin(c[0:n])         {             #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])             {                 #pragma acc parallel                 {                     #pragma acc loop                     for (int x = 0; x < n; ++x){                         c[x] += a[x] + b[x];                     }                 }             }             for (int x = 0; x < n; ++x){                 if (fabs(c[x]) > PRECISION){                     err += 1;                     break;                 }             }         }         for (int x = 0; x < n; ++x){             if (fabs(c[x]) > PRECISION){                 err += 1;                 break;             }         }      }      return err; } #endif  #ifndef T2 //T2:data,data-region,reference-counting,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int * devtest = (int *)malloc(sizeof(int));     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {       devtest[0] = 0;     }      for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = 0.0;     }      #pragma acc enter data copyin(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }     if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             if (fabs(c[x]) > PRECISION){                 err += 1;                 break;             }         }     }     #pragma acc exit data copyout(c[0:n])     for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T3 //T3:data,data-region,construct-independent,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int * devtest = (int *)malloc(sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }         #pragma acc exit data delete(c[0:n])     }     for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction min general", "completion": "#include \"acc_testsuite.h\" #pragma acc routine (fmin) seq  #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t min = 1000.0;     int found = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:n], b[0:n]) copy(min)     {         #pragma acc kernels loop reduction(min:min)         for (int x = 0; x < n; ++x){             min = fmin(a[x] * b[x], min);         }     }      for (int x = 0; x < n; ++x){         if (fabs((a[x] * b[x]) - (min + PRECISION)) < 0){             err = 1;         }         if (fabs(min - (a[x] * b[x])) < PRECISION){             found = 1;         }     }     if (found == 0){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop worker blocking", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     real_t multiplyer = 1;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])     {       #pragma acc parallel       {         #pragma acc loop worker         for (int x = 0; x < n; ++x){           c[x] = (a[x] + b[x]) * multiplyer;         }         multiplyer += 1;         #pragma acc loop worker         for (int x = 0; x < n; ++x){           c[x] += (a[x] + b[x]) * multiplyer;         }       }     }      for (int x = 0; x < n; ++x){       if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){         err + 1;         break;       }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature host data", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,data-region,host-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     int * high = new int[n];     int high_current_index = 0;     size_t * a_points = (size_t *)malloc(n * sizeof(void *));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         if (a[x] > 5) {             high[high_current_index] = x;             high_current_index += 1;         }     }      #pragma acc enter data copyin(a[0:n])      #pragma acc host_data use_device(a)     {         int x = 0;         for (x = 0; x < high_current_index; ++x){             a_points[x] = (size_t) a + (high[x]*sizeof(real_t*));         }         for (; x < n; ++x){             a_points[x] = 0;         }     }     #pragma acc enter data copyin(a_points[0:n])     #pragma acc parallel present(a[0:n], a_points[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             if (a_points[x] != 0){                 *((real_t *) a_points[x]) -= 5;             }         }     }     #pragma acc exit data delete(a_points[0:n]) copyout(a[0:n])     for (int x = 0; x < n; ++x){         if (a[x] < 0 || a[x] > 5) {             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture expr bitand x", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == (a[x] & prev)){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *passed_a = (int *)malloc(10 * sizeof(int));     int *passed_b = (int *)malloc(10 * sizeof(int));     int passed_total = 0;     int absolute_indexer;     int passed_indexer;      for (int x = 0; x < n; ++x){ \tfor (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0; \tfor (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                      b[x] = totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] &= a[x];     }      for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < 8; ++x){         passed_total += 1<<x;     }     for (int x = 0; x < (n/10 + 1); ++x){         for (absolute_indexer = x, passed_indexer = 0; absolute_indexer < n; absolute_indexer += (n/10 + 1), passed_indexer++){             passed_a[passed_indexer] = a[absolute_indexer];             passed_b[passed_indexer] = b[absolute_indexer];         }         if (!is_possible(passed_a, passed_b, passed_indexer, passed_total)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture min x expr assign", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8), INTENT(IN) :: init         REAL(8),DIMENSION(length), INTENT(IN) :: a         REAL(8),DIMENSION(length), INTENT(IN) :: b         REAL(8),DIMENSION(length - 1) :: passed_a         REAL(8),DIMENSION(length - 1) :: passed_b         REAL(8) :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (abs(b(x) - min(init, a(x))) .gt. (10 - length) * PRECISION) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = b(x)             IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         REAL(8),DIMENSION(10):: passed_a, passed_b         REAL(8):: init         LOGICAL IS_POSSIBLE         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   totals(x) = min(totals(x), a(x, y))                   b(x, y) = totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = min(totals_comparison(x), a(x, y))           END DO         END DO         DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           init = 0           IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc wait any", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,async,wait,V:3.2-3.3 int test1() {      int err = 0;     srand(SEED);      real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];       for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = (a[x] + 1) * 2 + (b[x] + 1) * 2;     }          real_t *list[3] = {a, b, c};      #pragma acc data copyin(list[0:3][0:n])     {         int queues[10];         for (int i = 0; i < 2; i++)         {             // Do some unbalanced operation on several queues             #pragma acc enter data copyin(list[i]) async(i)                          // Put the queue number in the queues list             queues[i] = i;              #pragma acc parallel loop async(i)             for(int k = 0; k < n; k++) {                 list[i][k]++;             }         }         int next;         // Look for queue that is ready to process         while ((next = acc_wait_any(3, queues)) >= 0)         {             // Remove this queue from consideration next time around             queues[next] = acc_async_sync;                          // Process work dependent on above             #pragma acc kernels             {                 for(int i = 0; i < n; i++)                 {                     list[next][i] = list[next][i] * 2;                 }             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine bind nonprototype function nonstring function", "completion": "#include \"acc_testsuite.h\"  //test 1 host function #pragma acc routine vector bind(device_array_array) real_t host_array_array(real_t * a, long long n){     #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  //test 1 device function real_t device_array_array(real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  //test 2 host function #pragma acc routine vector bind(device_object_array) real_t host_object_array(data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned += a->data[x];     }     return returned; }  //test 2 device function real_t device_object_array(data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; }  //test 3 host function #pragma acc routine vector bind(device_array_object) real_t host_array_object(real_t * a, long long n){    #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  //test 3 device function real_t device_array_object(real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  //test 4 host function #pragma acc routine vector bind(device_object_object) real_t host_object_object(data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned += a->data[x];     }     return returned; }  //test 4 device function real_t device_object_object(data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; }  #ifndef T1 //T1:routine,V:2.7-3.3 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){        \ta[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_array_array(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_array(a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_array(a, n) - b[x]) > PRECISION)){             err += 1;         }     }     delete[] a;     delete[] b;      return err; } #endif #ifndef T2 //T2:routine,V:2.7-3.3 int test2(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a, a.data[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_object_array(&a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_array(&a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_array(&a, n) - b[x]) > PRECISION)){             err += 1;         }     }      delete[] b;      return err; } #endif #ifndef T3 //T3:routine,V:2.7-3.3 int test3(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b, b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_array_object(a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_object(a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_object(a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      delete[] a;      return err; } #endif #ifndef T4 //T4:routine,V:2.7-3.3 int test4(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a, a.data[0:n], b ,b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_object_object(&a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_object(&a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_object(&a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      return err; } #endif int main(){     int failcode = 0;     int failed = 0; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }      if(failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }      if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }      if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test4();     }      if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update expr plus x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = a(x, y) + totals(x)               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) + a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction and loop", "completion": "#ifndef T1 !T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         LOGICAL,DIMENSION(10*LOOPCOUNT):: a, a_copy !Data         LOGICAL,DIMENSION(10) :: results, has_false         LOGICAL :: host_results = .TRUE.         LOGICAL :: temp = .TRUE.         REAL(8),DIMENSION(10*LOOPCOUNT):: randoms         REAL(8) :: false_margin = exp(log(.5) / LOOPCOUNT)         INTEGER :: errors = 0         !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, 10           results(x) = .TRUE.           has_false(x) = .FALSE.         END DO         DO x = 1, 10*LOOPCOUNT           IF (randoms(x) .lt. false_margin) THEN             a(x) = .TRUE.             a_copy(x) = .TRUE.           ELSE             a(x) = .FALSE.             a_copy(x) = .FALSE.             has_false(x / LOOPCOUNT) = .TRUE.           END IF         END DO          !$acc data copy(a(1:10*LOOPCOUNT), results(1:10))           !$acc parallel loop gang           DO x = 0, 9             temp = .TRUE.             !$acc loop worker reduction(.AND.:temp)             DO y = 1, LOOPCOUNT               temp = temp .AND. a(x * LOOPCOUNT + y)             END DO             results(x + 1) = temp             !$acc loop worker             DO y = 1, LOOPCOUNT               IF (temp .eqv. .TRUE.) THEN                 IF (a(x * LOOPCOUNT + y) .eqv. .TRUE.) THEN                   a(x * LOOPCOUNT + y) = .FALSE.                 ELSE                   a(x * LOOPCOUNT + y) = .TRUE.                 END IF               END IF             END DO           END DO         !$acc end data         DO x = 0, 9           temp = .TRUE.           DO y = 1, LOOPCOUNT             temp = temp .AND. a_copy(x * LOOPCOUNT + y)           END DO           IF (temp .neqv. results(x + 1)) THEN             errors = errors + 1           END IF           DO y = 1, LOOPCOUNT             IF (temp .eqv. .TRUE.) THEN               IF (a(x * LOOPCOUNT + y) .eqv. a_copy(x * LOOPCOUNT + y)) THEN                 errors = errors + 1               END IF             ELSE               IF (a(x * LOOPCOUNT + y) .neqv. a_copy(x * LOOPCOUNT + y)) THEN                 errors = errors + 1               END IF             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update x plus expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[10];     real_t *totals_comparison = new real_t[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic update                         totals[(int) ((a[x] + b[x])/2)] = totals[(int) ((a[x] + b[x])/2)] + a[x] * b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];         }     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update x divided expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = totals(x) / a(x, y)               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) / a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic multiply equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] *= a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc wait all", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,async,construct-independent,wait,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));     real_t *a_host = (real_t *)malloc(n * sizeof(real_t));     real_t *b_host = (real_t *)malloc(n * sizeof(real_t));     real_t *c_host = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = rand() / (real_t)(RAND_MAX / 10);         d[x] = 0;         a_host[x] = a[x];         b_host[x] = b[x];         c_host[x] = c[x];     }      #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = a[x] * a[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = b[x] * b[x];             }         }         #pragma acc parallel async(3)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = c[x] * c[x];             }         }         acc_wait_all();         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 d[x] = a[x] + b[x] + c[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(d[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x] + c_host[x] * c_host[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction or loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     char * a = new char[10 * n];     char * a_copy = new char[10 * n];     char * results = new char[10];     char temp = 0;     real_t false_margin = pow(exp(1), log(.5)/n);      for (int x = 0; x < 10 * n; ++x){         if (rand() / (real_t)(RAND_MAX) > false_margin){             a[x] = 1;             a_copy[x] = 1;         }         else{             a[x] = 0;             a_copy[x] = 0;         }     }     #pragma acc data copy(a[0:10*n]) copyout(results[0:10])     {         #pragma acc serial  \t{ \t#pragma loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(||:temp)             for (int y = 0; y < n; ++y){                 temp = temp || a[x * n + y];             }             results[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 if(results[x] == 1){                     if (a[x * n + y] == 1){                         a[x * n + y] = 0;                     }                     else{                         a[x * n + y] = 1;                     }                 }             }         } \t}     }     for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = temp || a_copy[x * n + y];         }         if (temp != results[x]) {             err += 1;         }         for (int y = 0; y < n; ++y){             if (temp == 1){                 if (a[x * n + y] == a_copy[x * n + y]){                     err += 1;                 }             }             else {                 if (a[x * n + y] != a_copy[x * n + y]){                     err += 1;                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update postdecrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     distribution[(int) (a[x] * b[x] / 10)]--;             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]--;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture assign x or expr", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   LOGICAL, INTENT(IN) :: init   LOGICAL,DIMENSION(length), INTENT(IN) :: a   LOGICAL,DIMENSION(length), INTENT(IN) :: b   LOGICAL,DIMENSION(length - 1) :: passed_a   LOGICAL,DIMENSION(length - 1) :: passed_b   LOGICAL :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (b(x) .eqv. init) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = a(x) .or. init       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms   LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data   LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison   LOGICAL,DIMENSION(10):: passed_a, passed_b   LOGICAL IS_POSSIBLE   LOGICAL:: init   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)   DO x = 1, LOOPCOUNT     DO y = 1, 10       IF (randoms(x, y) > .933) THEN         a(x, y) = .TRUE.       ELSE         a(x, y) = .FALSE.       END IF     END DO   END DO    totals = .FALSE.   totals_comparison = .FALSE.    !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             b(x, y) = totals(x)             totals(x) = totals(x) .OR. a(x, y)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = totals_comparison(x) .OR. a(x, y)     END DO   END DO    DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NEQV. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = .FALSE.     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured expr bitor x assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == (prev | a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] = a[x] | totals[x/10];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] |= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc map data", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d;     real_t *e = (real_t *)malloc(n * sizeof(real_t));      d = (real_t *)acc_malloc(n * sizeof(real_t));     for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      acc_map_data(c, d, n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      #pragma acc update host(c[0:n])     for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x]))> PRECISION){             err += 1;         }     }      acc_unmap_data(c);     acc_free(d);      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d;     real_t *e = (real_t *)malloc(n * sizeof(real_t));      d = (real_t *)acc_malloc(2 * n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     acc_map_data(c, d, n * sizeof(real_t));     acc_map_data(e, &(d[n]), n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n], e[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 e[x] = a[x] * b[x];             }         }     }      #pragma acc update host(c[0:n])     #pragma acc update host(e[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }         if (fabs(e[x] - (a[x] * b[x])) > PRECISION){             err += 1;         }     }     acc_unmap_data(c);     acc_unmap_data(e);     acc_free(d);      return err; } #endif  #ifndef T3 //T3:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d;     real_t *e = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     d = (real_t *)acc_malloc(n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n]) deviceptr(d)     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 d[x] = a[x] + b[x];             }         }     }      acc_map_data(c, d, n * sizeof(real_t));     #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      #pragma acc update host(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - 2 * (a[x] + b[x])) > 2 * PRECISION){             err += 1;         }     }      acc_unmap_data(c);     acc_free(d);      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc get property", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,nonvalidating,V:2.6-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: output         IF (acc_get_device_type() .ne. acc_device_none) THEN           output = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_memory)           output = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory)         END IF         test1 = .FALSE.       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature atomic update expr neqv x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = a(x, y) .NEQV. totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update max x expr list", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature declare create", "completion": "#include \"acc_testsuite.h\" #define DECLARE_TEST #define DECLARE_CREATE #include \"acc_testsuite_declare.h\" #pragma acc declare create(fixed_size_array) #pragma acc declare create(scalar) #pragma acc declare create(datapointer)  int mult_create = 2;  #pragma acc declare create(n) #pragma acc routine vector void multiplyData(real_t *a){     for (int x = 0; x < n; ++x){         a[x] = a[x] * 2;     } }  #ifndef T1 //T1:declare,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     int mult = 2;     #pragma acc update device(n)      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < 10; ++x){                 fixed_size_array[x] = x*x;             }         }         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x] + fixed_size_array[x%10];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - (a[x] + (x%10) * (x%10))) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T2 //T2:declare,construct-independent,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     int mult = 2;     #pragma acc update device(n)      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      scalar = 10;     #pragma acc update device(scalar)     #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x] + scalar;             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - (a[x] + 10)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T3 //T3:declare,construct-independent,V:1.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     int mult = 2;     #pragma acc update device(n)      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      #pragma acc update device(mult_create)     #pragma acc data copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < 1; ++x){                 extern_multiplyData_create(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] * 2)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T4 //T4:declare,construct-independent,V:2.0-2.7 int test4(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     int mult = 2;     #pragma acc update device(n)      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }     #pragma acc data copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < 1; ++x){                 multiplyData(a);             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] * 2)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T5 //T5:declare,construct-independent,V:2.6-2.7 int test5(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     int mult = 2;     #pragma acc update device(n)      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }     datapointer = a;      #pragma acc data copyin(a[0:n]) attach(datapointer)     {         #pragma acc parallel present(datapointer[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 datapointer[x] = datapointer[x] * 2;             }         }     }      #pragma acc exit data copyout(a[0:n])     for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] * 2)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction add general", "completion": "#ifndef T1 !T1:serial,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT):: a, b   REAL(8):: total   INTEGER:: x   errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)    total = 10   !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))     !$acc serial loop reduction(+:total)     DO x = 1, LOOPCOUNT       total = total + a(x) + b(x)     END DO   !$acc end data    DO x = 1, LOOPCOUNT     total = total - (a(x) + b(x))   END DO    IF (abs(total - 10) .gt. PRECISION) THEN     errors = errors + 1   END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc copyin", "completion": "#ifndef T1 !T1:runtime,data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_copyin(a(1:LOOPCOUNT))         CALL acc_copyin(b(1:LOOPCOUNT))          !$acc data copy(c(1:LOOPCOUNT))           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END FUNCTION #endif  #ifndef T2 !T2:runtime,data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 1          CALL acc_copyin(a(1:LOOPCOUNT))         CALL acc_copyin(b(1:LOOPCOUNT))          !$acc data copyout(c(1:LOOPCOUNT))           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_copyout(a(1:LOOPCOUNT))         CALL acc_copyout(b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END FUNCTION #endif  #ifndef T3 !T3:runtime,data,executable-data,devonly,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test3()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data         INTEGER :: errors = 0         LOGICAL,DIMENSION(1):: devtest          devtest(1) = .TRUE.         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = .FALSE.         !$acc end parallel          IF (devtest(1) .eqv. .TRUE.) THEN           SEEDDIM(1) = 1 #         ifdef SEED           SEEDDIM(1) = SEED #         endif           CALL RANDOM_SEED(PUT=SEEDDIM)           CALL RANDOM_NUMBER(a)           a_copy(:) = a(:)           CALL RANDOM_NUMBER(b)           b_copy(:) = b(:)           c = 0            CALL acc_copyin(a(1:LOOPCOUNT))           CALL acc_copyin(b(1:LOOPCOUNT))            a = 0           b = 0            !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) + b(x)               END DO             !$acc end parallel           !$acc end data            !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT))            DO x = 1, LOOPCOUNT             IF (abs(a(x) - a_copy(x)) .gt. PRECISION) THEN               errors = errors + 1             END IF             IF (abs(b(x) - b_copy(x)) .gt. PRECISION) THEN               errors = errors + 1             END IF             IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif  #ifndef T4 !T4:runtime,executable-data,construct-independent,compatibility-features,V:2.0-2.7       LOGICAL FUNCTION test4()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initialization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_pcopyin(a(1:LOOPCOUNT))         CALL acc_pcopyin(b(1:LOOPCOUNT))          !$acc data copyout(c(1:LOOPCOUNT))           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test4 = .FALSE.         ELSE           test4 = .TRUE.         END IF       END #endif  #ifndef T5 !T5:runtime,executable-data,construct-independent,compatibility-features,V:2.0-2.7       LOGICAL FUNCTION test5()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initialization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0                  CALL acc_present_or_copyin(a(1:LOOPCOUNT))         CALL acc_present_or_copyin(b(1:LOOPCOUNT))          !$acc data copyout(c(1:LOOPCOUNT))           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test5 = .FALSE.         ELSE           test5 = .TRUE.         END IF       END #endif  #ifndef T6 !T6:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7       LOGICAL FUNCTION test6()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initialization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_copyin(a(1:LOOPCOUNT))         CALL acc_copyin(a(1:LOOPCOUNT))         CALL acc_copyin(b(1:LOOPCOUNT))         CALL acc_copyin(b(1:LOOPCOUNT))          !$acc data copyout(c(1:LOOPCOUNT))           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))         !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test6 = .FALSE.         ELSE           test6 = .TRUE.         END IF       END #endif  #ifndef T7 !T7:runtime,data,executable-data,construct-independent,reference-counting,devonly,V:2.5-2.7       LOGICAL FUNCTION test7()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data         INTEGER :: errors = 0         LOGICAL,DIMENSION(1):: devtest          devtest(1) = .TRUE.         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = .FALSE.         !$acc end parallel          IF (devtest(1) .eqv. .TRUE.) THEN           !Initialization           SEEDDIM(1) = 1 #         ifdef SEED           SEEDDIM(1) = SEED #         endif           CALL RANDOM_SEED(PUT=SEEDDIM)           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 0           a_copy = a           b_copy = b            CALL acc_copyin(a(1:LOOPCOUNT))           CALL acc_copyin(b(1:LOOPCOUNT))            a = 0           b = 0            CALL acc_copyin(a(1:LOOPCOUNT))           CALL acc_copyin(b(1:LOOPCOUNT))            !$acc data copyout(c(1:LOOPCOUNT))             !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) + b(x)               END DO             !$acc end parallel           !$acc end data            !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))            DO x = 1, LOOPCOUNT             IF (abs(c(x) - (a_copy(x) + b_copy(x))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test7 = .FALSE.         ELSE           test7 = .TRUE.         END IF       END #endif       PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif #ifndef T4         LOGICAL :: test4 #endif #ifndef T5         LOGICAL :: test5 #endif #ifndef T6         LOGICAL :: test6 #endif #ifndef T7         LOGICAL :: test7 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif #ifndef T4         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test4()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 3           failed = .FALSE.         END IF #endif #ifndef T5         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test5()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 4           failed = .FALSE.         END IF #endif #ifndef T6         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test6()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 5           failed = .FALSE.         END IF #endif #ifndef T7         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test7()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 6           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature data create zero", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,data-region,V:3.0-3.2 int test1(){     int err = 0;     srand(SEED);      real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 1;     }      #pragma acc data copyin(a[0:n]) create(zero: b[0:n]) copyout(b[0:n])     {       #pragma acc parallel       {         #pragma acc loop         {           for (int x = 0; x < n; ++x){             b[x] += a[x];           }         }       }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int testrun;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif   return failcode; }"}
{"prompt": "Create a test for the feature atomic structured assign expr bitor x", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev | a[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         for (int y = 0; y < 8; ++y){             totals[x] =  1<<y;             totals_comparison[x] = 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         b[x] = totals[x/10];                         totals[x/10] = a[x] | totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] |= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc wait", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,async,construct-independent,wait,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));     real_t *e = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = 0;     }      #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n]) async(1)     #pragma acc enter data copyin(d[0:n]) create(e[0:n]) async(2)     #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1) wait(2)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             e[x] = c[x] + d[x];         }     }     #pragma acc exit data copyout(e[0:n]) async(1)      acc_wait(1);     for (int x = 0; x < n; ++x){         if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){             err += 1;         }     }      #pragma acc exit data delete(a[0:n], b[0:n], c[0:n], d[0:n])      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured bitxor equals assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == (prev ^ a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] ^= a[x];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] ^= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data copyout no lower bound", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,data-region,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction add loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t* b = new real_t[10 * n];     real_t* c = new real_t[10 * n];     real_t* d = new real_t[10 * n];     real_t avg = 0.0;     real_t rolling_total = 0;      for (int x = 0; x < 10 * n; ++x) {         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) create(c[0:10*n]) copyout(d[0:10*n])     {         #pragma acc parallel loop gang private(avg)         for (int x = 0; x < 10; ++x) {             avg = 0;             #pragma acc loop worker reduction(+:avg)             for (int y = 0; y < n; ++y) {                 avg += c[x * n + y] = a[x * n + y] + b[x * n + y];             }             avg = avg / n;             #pragma acc loop worker             for (int y = 0; y < n; ++y) {                 d[x * n + y] = c[x * n + y] - avg;             }         }     }       for (int x = 0; x < 10; ++x) {         rolling_total = 0;         for (int y = 0; y < n; ++y) {             rolling_total += a[x * n + y] + b[x * n + y];         }         rolling_total = rolling_total / n;         for (int y = 0; y < n; ++y) {             if (fabs(d[x * n + y] - ((a[x * n + y] + b[x * n + y]) - rolling_total)) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,loop,reduction,combined-constructs,V:2.7-2.7 int test2() {     int err = 0;     srand(SEED);     real_t* a = new real_t[25 * n];     real_t* b = new real_t[25 * n];     real_t* c = new real_t[25 * n];     real_t* d = new real_t[25 * n];     real_t avgs[5];     real_t host_avgs[5];      for (int x = 0; x < 25 * n; ++x) {         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = 0;     }      #pragma acc data copyin(a[0:25*n], b[0:25*n]) copyout(c[0:25*n], d[0:25*n])     {         #pragma acc parallel loop gang private(avgs)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 avgs[y] = 0;             }             #pragma acc loop worker reduction(+:avgs)             for (int y = 0; y < 5 * n; ++y) {                 avgs[y % 5] += c[x * 5 * n + y] = a[x * 5 * n + y] + b[x * 5 * n + y];             }             for (int y = 0; y < 5; ++y) {                 avgs[y] = avgs[y] / n;             }             #pragma acc loop worker             for (int y = 0; y < 5 * n; ++y) {                 d[x * 5 * n + y] = c[x * 5 * n + y] - avgs[y % 5];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             host_avgs[y] = 0;         }         for (int y = 0; y < 5 * n; ++y) {             host_avgs[y % 5] += a[x * 5 * n + y] + b[x * 5 * n + y];             if (fabs(c[x * 5 * n + y] - (a[x * n * 5 + y] + b[x * n * 5 + y])) > PRECISION) {                 err += 1;             }         }         for (int y = 0; y < 5; ++y) {             host_avgs[y] = host_avgs[y] / n;         }         for (int y = 0; y < 5 * n; ++y) {             if (fabs(d[x * 5 * n + y] - (c[x * 5 * n + y] - host_avgs[y % 5])) > PRECISION){                 err += 1;                          }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature exit data copyout no lower bound", "completion": "#ifndef T1 !T1:data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         !$acc enter data create(c(1:LOOPCOUNT))         !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data         !$acc exit data copyout(c(:LOOPCOUNT))         DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature exit data delete no lower bound", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,construct-independent,syntactic,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])     #pragma acc parallel present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc exit data delete(a[:n], b[:n]) copyout(c[0:n])      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic minus equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_host[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%10] -= (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign predecrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *c = (int *)malloc(n * sizeof(int));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));     bool found = false;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = distribution[(int) (a[x]*b[x]/10)];                     --distribution[(int) (a[x]*b[x]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]--;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y > distribution[x]; --y){             for (int z = 0; z < n; ++z){                 if (c[z] == y && x == (int) (a[z] * b[z] / 10)){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine bind prototype function string lambda", "completion": "#include \"acc_testsuite.h\"  //test 1 host function real_t host_array_array(real_t * a, long long n){     #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  //test 2 host function real_t host_object_array(data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned += a->data[x];     }     return returned; }  //test 3 host function real_t host_array_object(real_t * a, long long n){    #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  //test 4 host function real_t host_object_object(data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned += a->data[x];     }     return returned; }  #pragma acc routine(host_array_array) vector bind(\"device_array_array\") #pragma acc routine(host_object_array) vector bind(\"device_object_array\") #pragma acc routine(host_array_object) vector bind(\"device_array_object\") #pragma acc routine(host_object_object) vector bind(\"device_object_object\")  //test 1 device function auto device_array_array = [](real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; };  //test 2 device function auto device_object_array = [](data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned -= a->data[x];     }     return returned; };  //test 3 device function auto device_array_object = [](real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; };  //test 4 device function auto  device_object_object= [](data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; };  #ifndef T1 //T1:routine,V:2.7-3.3 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){        \ta[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_array_array(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_array(a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_array(a, n) - b[x]) > PRECISION)){             err += 1;         }     }     delete[] a;     delete[] b;      return err; } #endif #ifndef T2 //T2:routine,V:2.7-3.3 int test2(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a, a.data[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_object_array(&a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_array(&a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_array(&a, n) - b[x]) > PRECISION)){             err += 1;         }     }      delete[] b;      return err; } #endif #ifndef T3 //T3:routine,V:2.7-3.3 int test3(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b, b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_array_object(a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_object(a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_object(a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      delete[] a;      return err; } #endif #ifndef T4 //T4:routine,V:2.7-3.3 int test4(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a, a.data[0:n], b ,b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_object_object(&a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_object(&a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_object(&a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed = 0; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }      if(failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }      if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }      if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test4();     }      if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction or loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(10 * n * sizeof(char));     char * a_copy = (char *)malloc(10 * n * sizeof(char));     char * results = (char *)malloc(10 * sizeof(char));     char temp = 0;     real_t false_margin = pow(exp(1), log(.5)/n);      for (int x = 0; x < 10 * n; ++x){         if (rand() / (real_t)(RAND_MAX) > false_margin){             a[x] = 1;             a_copy[x] = 1;         }         else{             a[x] = 0;             a_copy[x] = 0;         }     }     #pragma acc data copy(a[0:10*n])     {         #pragma acc kernels loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(||:temp)             for (int y = 0; y < n; ++y){                 temp = temp || a[x * n + y];             }             results[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 if(results[x] == 1){                     if (a[x * n + y] == 1){                         a[x * n + y] = 0;                     }                     else{                         a[x * n + y] = 1;                     }                 }             }         }     }     for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = temp || a_copy[x * n + y];         }         if (temp != results[x]) {             err += 1;         }         for (int y = 0; y < n; ++y){             if (temp == 1){                 if (a[x * n + y] == a_copy[x * n + y]){                     err += 1;                 }             }             else {                 if (a[x * n + y] != a_copy[x * n + y]){                     err += 1;                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop worker", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])     {         #pragma acc parallel loop worker         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature host data", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,data-region,host-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     int * high = (int *)malloc(n * sizeof(int));     int high_current_index = 0;     size_t * a_points = (size_t *)malloc(n * sizeof(void *));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         if (a[x] > 5) {             high[high_current_index] = x;             high_current_index += 1;         }     }      #pragma acc enter data copyin(a[0:n])      #pragma acc host_data use_device(a)     {         int x = 0;         for (x = 0; x < high_current_index; ++x){             a_points[x] = (size_t) a + (high[x]*sizeof(real_t*));         }         for (; x < n; ++x){             a_points[x] = 0;         }     }     #pragma acc enter data copyin(a_points[0:n])     #pragma acc parallel present(a[0:n], a_points[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             if (a_points[x] != 0){                 *((real_t *) a_points[x]) -= 5;             }         }     }     #pragma acc exit data delete(a_points[0:n]) copyout(a[0:n])     for (int x = 0; x < n; ++x){         if (a[x] < 0 || a[x] > 5) {             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel independent atomic update", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.7-3.2 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      #pragma acc data copy(a[0:n])     {         #pragma acc parallel         { \t    #pragma acc loop independent             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     (a[x])++;             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] + 1)) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1    failed = 0;    for (int x = 0; x < NUM_TEST_CALLS; ++x){        failed = failed + test1();    }    if (failed != 0){        failcode = failcode + (1 << 0);    } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature shutdown", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:shutdown,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);      #pragma acc shutdown      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel private", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,private,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[n];     real_t * d = new real_t[10];      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             a[x * n + y] = rand() / (real_t)(RAND_MAX / 10);             b[x * n + y] = rand() / (real_t)(RAND_MAX / 10);             c[y] = 0.0;         }         d[x] = 0.0;     }      #pragma acc enter data copyin(a[0:10*n], b[0:10*n], d[0:10])     #pragma acc parallel num_gangs(10) private(c[0:n])     {         #pragma acc loop gang         for (int x = 0; x < 10; ++x){             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 c[y] = a[x * n + y] + b[x * n + y];             }             #pragma acc loop seq             for (int y = 0; y < n; ++y){                 d[x] += c[y];             }         }     }     #pragma acc exit data copyout(d[0:10]) delete(a[0:10*n], b[0:10*n])      real_t temp;     for (int x = 0; x < 10; ++x){         temp = 0.0;         for (int y = 0; y < n; ++y){             temp += a[x * n + y] + b[x * n + y];         }         if (fabs(temp - d[x]) > (2 * PRECISION * n)){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop auto", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,auto,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t rolling_total = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {       #pragma acc serial loop auto       for (int x = 0; x < n; ++x){         b[x] = a[x];       }     }      for (int x = 0; x < n; ++x){       if (fabs(b[x] - a[x]) > PRECISION){         err = 1;       }     }      return err; } #endif  #ifndef T2 //T2:serial,loop,combined-constructs,V:2.6-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t rolling_total = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         a_copy[x] = a[x];     }      #pragma acc data copy(a[0:n])     {       #pragma acc serial loop auto       for (int x = 1; x < n; ++x){         a[x] = a[x - 1] + a[x];       }     }      for (int x = 0; x < n; ++x){       rolling_total += a_copy[x];       if (fabs(rolling_total - a[x]) > PRECISION){         err = 1;       }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic postdecrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     distribution[(int) (a[x] * b[x] / 10)]--;             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]--;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = 0;     }      #pragma acc data copy(a[0:n])     {         #pragma acc serial loop         for (int x = 0; x < n; ++x){             a[x] = 1.0;         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - 1.0) > PRECISION){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:serial,loop,V:2.6-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){       a[x] = 0.0;       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = rand() / (real_t)(RAND_MAX / 10);     }     #pragma acc data copy(a[0:n], b[0:n], c[0:n])     {         #pragma acc serial         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = b[x];             }             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] += c[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] + c[x])) > PRECISION * 2){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update ixor expr x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .lt. .5) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           totals(x) = 0           totals_comparison(x) = 0         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel copyin", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,data,data-region,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int* hasDevice = (int *) malloc(sizeof(int));     hasDevice[0] = 1;     #pragma acc enter data copyin(hasDevice[0:1])     #pragma acc parallel present(hasDevice[0:1])     {       hasDevice[0] = 0;     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         a_copy[x] = a[x];         b[x] = 0.0;     }      #pragma acc parallel copyin(a[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             a[x] = 0.0;         }     }      for (int x = 0; x < n; ++x){         if (((fabs(a[x] - a_copy[x]) > PRECISION) && (hasDevice[0] == 1)) || ((hasDevice[0] == 0) && (fabs(a[x]) > PRECISION))){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,data,data-region,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(b[0:n])     {         #pragma acc parallel copyin(a[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture assign x neqv expr", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   LOGICAL, INTENT(IN) :: init   LOGICAL,DIMENSION(length), INTENT(IN) :: a   LOGICAL,DIMENSION(length), INTENT(IN) :: b   LOGICAL,DIMENSION(length - 1) :: passed_a   LOGICAL,DIMENSION(length - 1) :: passed_b   LOGICAL :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (b(x) .eqv. init) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = a(x) .neqv. init       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms   LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data   LOGICAL,DIMENSION(10):: passed_a, passed_b   LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)   DO x = 1, LOOPCOUNT     DO y = 1, 10       IF (randoms(x, y) > .5) THEN         a(x, y) = .TRUE.       ELSE         a(x, y) = .FALSE.       END IF     END DO   END DO    totals = .FALSE.   totals_comparison = .FALSE.    !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             b(x, y) = totals(x)             totals(x) = totals(x) .NEQV. a(x, y)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)     END DO   END DO    DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NEQV. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     IF (IS_POSSIBLE(passed_a, passed_b, 10, .FALSE.) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction multiply vector loop", "completion": "#ifndef T1 !T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(10) :: c         REAL(8) :: temp         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         a = (999.4 + a) / 1000         b = (999.4 + b) / 1000          !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copyout(c(1:10))           !$acc parallel loop private(temp)           DO x = 0, 9             temp = 1             !$acc loop vector reduction(*:temp)             DO y = 1, LOOPCOUNT               temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))             END DO             c(x + 1) = temp           END DO         !$acc end data          DO x = 0, 9           temp = 1           DO y = 1, LOOPCOUNT             temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))           END DO           IF (abs(temp - c(x + 1)) .gt. ((temp / 2) + (c(x + 1) / 2)) * PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update multiply equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] *= a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine gang", "completion": "#include \"acc_testsuite.h\" void test_routine_gang_loop_named(real_t ** a, real_t * b, long long n); void test_routine_gang_gang_named(real_t ** a, real_t * b, long long n); void test_routine_gang_worker_named(real_t ** a, real_t * b, long long n); void test_routine_gang_vector_named(real_t ** a, real_t * b, long long n); void test_routine_gang_seq_named(real_t ** a, real_t * b, long long n);  #pragma acc routine(test_routine_gang_loop_named) gang #pragma acc routine(test_routine_gang_gang_named) gang #pragma acc routine(test_routine_gang_worker_named) gang #pragma acc routine(test_routine_gang_vector_named) gang #pragma acc routine(test_routine_gang_seq_named) gang   #pragma acc routine worker real_t called_function_worker(real_t ** a, int x, long long n){     real_t returned = 0;     #pragma acc loop worker reduction(+:returned)     for (int y = 0; y < n; ++y){         returned += a[x][y];     }     return returned; }  #pragma acc routine vector real_t called_function_vector(real_t ** a, int x, long long n){     real_t returned = 0;     #pragma acc loop vector reduction(+:returned)     for (int y = 0; y < n; ++y){         returned += a[x][y];     }     return returned; }  #pragma acc routine seq real_t called_function_seq(real_t ** a, int x, long long n){     real_t returned = 0;     #pragma acc loop seq reduction(+:returned)     for (int y = 0; y < n; ++y){         returned += a[x][y];     }     return returned; }  #pragma acc routine gang real_t called_function_gang(real_t ** a, int x, long long n){     real_t returned = 0;     real_t* itemized_return = (real_t *)malloc(((int) (n/10)) * sizeof(real_t)); //Lol     real_t privatized_return = 0;     #pragma acc loop gang     for (int y = 0; y < (int) n/10; ++y){         privatized_return = 0;         #pragma acc loop worker reduction(+:privatized_return)         for (int z = 0; z < 10; ++z){             privatized_return += a[x][y*10 + z];         }         itemized_return[y] = privatized_return;     }     #pragma acc loop seq     for (int y = 0; y < (int) n/10; ++y){         returned += itemized_return[y];     }     free(itemized_return);     return returned; }  #pragma acc routine gang void test_routine_gang_loop_unnamed(real_t ** a, real_t * b, long long n){     real_t temp;     #pragma acc loop gang private(temp)     for (int x = 0; x < n; ++x){         temp = 0;         #pragma acc loop worker reduction(+:temp)         for (int y = 0; y < n; ++y){             temp += a[x][y];         }         b[x] = temp;     } }  #pragma acc routine gang void test_routine_gang_gang_unnamed(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_gang(a, x, n);     } }  #pragma acc routine gang void test_routine_gang_worker_unnamed(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_worker(a, x, n);     } }  #pragma acc routine gang void test_routine_gang_vector_unnamed(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_vector(a, x, n);     } }  #pragma acc routine gang void test_routine_gang_seq_unnamed(real_t ** a, real_t *b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_seq(a, x, n);     } }  void test_routine_gang_loop_named(real_t ** a, real_t * b, long long n){     real_t temp;     #pragma acc loop gang private(temp)     for (int x = 0; x < n; ++x){         temp = 0;         #pragma acc loop worker reduction(+:temp)         for (int y = 0; y < n; ++y){             temp += a[x][y];         }         b[x] = temp;     } }  void test_routine_gang_gang_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_gang(a, x, n);     } }  void test_routine_gang_worker_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_worker(a, x, n);     } }  void test_routine_gang_vector_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_vector(a, x, n);     } }  void test_routine_gang_seq_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_seq(a, x, n);     } }  bool validate_data(real_t ** a, real_t * b){     real_t local_total;     for (int x = 0; x < n; ++x){         local_total = 0;         for (int y = 0; y < n; ++y){             local_total += a[x][y];         }         if (fabs(b[x] - local_total) > PRECISION){             return true;         }     }     return false; }  #ifndef T1 //T1:routine,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {               test_routine_gang_loop_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T2 //T2:routine,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_gang_loop_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T3 //T3:routine,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_gang_gang_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T4 //T4:routine,construct-independent,V:2.0-2.7 int test4(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_gang_gang_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T5 //T5:routine,construct-independent,V:2.0-2.7 int test5(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_gang_worker_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T6 //T6:routine,construct-independent,V:2.0-2.7 int test6(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_gang_worker_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T7 //T7:routine,construct-independent,V:2.0-2.7 int test7(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_gang_vector_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T8 //T8:routine,construct-independent,V:2.0-2.7 int test8(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_gang_vector_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T9 //T9:routine,construct-independent,V:2.0-2.7 int test9(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_gang_seq_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T10 //T10:routine,construct-independent,V:2.0-2.7 int test10(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_gang_seq_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif #ifndef T6     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test6();     }     if (failed != 0){         failcode = failcode + (1 << 5);     } #endif #ifndef T7     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test7();     }     if (failed != 0){         failcode = failcode + (1 << 6);     } #endif #ifndef T8     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test8();     }     if (failed != 0){         failcode = failcode + (1 << 7);     } #endif #ifndef T9     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test9();     }     if (failed != 0){         failcode = failcode + (1 << 8);     } #endif #ifndef T10     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test10();     }     if (failed != 0){         failcode = failcode + (1 << 9);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop worker", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])     {         #pragma acc parallel loop worker         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction max general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t max = 0.0;     int found = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:n], b[0:n]) copy(max)     {         #pragma acc kernels loop reduction(max:max)         for (int x = 0; x < n; ++x){             max = fmax(a[x] * b[x], max);         }     }      for (int x = 0; x < n; ++x){         if (fabs(max - (a[x] * b[x] + PRECISION)) < 0){             err = 1;         }         if (fabs(max - (a[x] * b[x] - PRECISION)) > 0){             found = 1;         }     }     if (found == 0){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop vector", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,vector,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])     {         #pragma acc parallel loop vector         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      for (int x = 0; x < n; ++x){         if(fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction and vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(10 * n * sizeof(char));     char * b = (char *)malloc(10 * sizeof(char));     char * has_false = (char *)malloc(10 * sizeof(char));     char temp = 1;     real_t false_margin = pow(exp(1), log(.5)/n);      for (int x = 0; x < 10; ++x){         has_false[x] = 0;     }     for (int x = 0; x < 10 * n; ++x){         if(rand() / (real_t)(RAND_MAX) < false_margin){             a[x] = 1;         }         else{             a[x] = 0;             has_false[x/n] = 1;         }     }     #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop vector reduction(&&:temp)             for (int y = 0; y < n; ++y){                 temp = temp && a[x * n + y];             }             b[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         if (has_false[x] == b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop vector blocking", "completion": "#ifndef T1 !T1:parallel,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         REAL(8) :: multiplyer         INTEGER :: errors = 0          multiplyer = 1         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop vector             DO x = 1, LOOPCOUNT               c(x) = (a(x) + b(x)) * multiplyer             END DO             multiplyer = multiplyer + 1             !$acc loop vector             DO x = 1, LOOPCOUNT               c(x) = c(x) + ((a(x) + b(x)) * multiplyer)             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (3 * (a(x) + b(x)))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update x bitand expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0; \tfor (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] & a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] &= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture expr plus x assign", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8), INTENT(IN) :: init         REAL(8),DIMENSION(length), INTENT(IN) :: a         REAL(8),DIMENSION(length), INTENT(IN) :: b         REAL(8),DIMENSION(length - 1) :: passed_a         REAL(8),DIMENSION(length - 1) :: passed_b         REAL(8) :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (abs(b(x) - (init + a(x))) .GT. ((10 - length) * PRECISION)) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = b(x)             IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         REAL(8),DIMENSION(10):: passed_a, passed_b         REAL(8):: init         LOGICAL IS_POSSIBLE         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   totals(x) = a(x, y) + totals(x)                   b(x, y) = totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) + a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           init = 0           IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign multiply equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, a[x] * prev)){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x%(n/10 + 1)];                     totals[x%(n/10 + 1)] *= a[x] + b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured rshift equals assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if ((b[x] == (prev >> 1) && (a>>x)%2==1) || b[x] == prev && (a>>x)%2==0){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1<<8;      for (int x = 0; x < n; ++x){         a[x] = 1<<8;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                         {                             a[x] >>= 1;                             c[x * 7 + y] = a[x];                         }                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<8){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitor vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int b_host;      for (int x = 0; x < 10 * n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX > false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }     temp = 0;     #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc parallel loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(|:temp)             for (int y = 0; y < n; ++y){                 temp = temp | a[x * n + y];             }             b[x] = temp;         }     }      for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host | a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));      unsigned int reduced[5];     real_t false_margin = pow(exp(1), log(.5)/n);          for (int x = 0; x < 25 * n; ++x) {         a[x] = 0;         for (int y = 0; y < 16; ++y) {             if (rand() / (real_t)RAND_MAX > false_margin) {                 a[x] += 1<<y;             }         }     }      #pragma acc data copyin(a[0:25*n]) copy(b[0:25])     {         #pragma acc parallel loop private(reduced)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 reduced[y] = 0;             }             #pragma acc loop vector reduction(|:reduced)             for (int y = 0; y < 5 * n; ++y) {                 reduced[y%5] = reduced[y%5] | a[x * 5 * n + y];             }             for (int y = 0; y < 5; ++y) {                 b[x * 5 + y] = reduced[y];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             reduced[y] = 0;         }         for (int y = 0; y < 5 * n; ++y) {             reduced[y%5] = reduced[y%5] | a[x * 5 * n + y];         }         for (int y = 0; y < 5; ++y) {             if (b[x * 5 + y] != reduced[y]) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic preincrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic                         ++distribution[(int) (a[x]*b[y]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             distribution_comparison[(int) (a[x]*b[y]/10)]++;         }     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured x lshift expr assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if ((b[x] == (prev << 1) && (a>>x)%2 == 1) || ((a>>x)%2==0 && b[x] == prev)){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1;      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                         {                             a[x] = a[x] << 1;                             c[x * 7 + y] = a[x];                         }                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction and loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = new char[10 * n];     char * a_copy = new char[10 * n];     char * has_false = new char[10];     real_t false_margin = pow(exp(1), log(.5)/n);      for (int x = 0; x < 10; ++x){         has_false[x] = 0;     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (rand() / (real_t)(RAND_MAX) < false_margin){                 a[x * n + y] = 1;                 a_copy[x * n + y] = 1;             }             else {                 a[x * n + y] = 0;                 a_copy[x * n + y] = 0;                 has_false[x] = 1;             }         }     }      char temp = 1;     #pragma acc data copy(a[0:10*n])     {         #pragma acc kernels loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop worker reduction(&&:temp)             for (int y = 0; y < n; ++y){                 temp = temp && a[x * n + y];             }             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 if(temp == 1){                     if  (a[x * n + y] == 1){                         a[x * n + y] = 0;                     }                     else {                         a[x * n + y] = 1;                     }                 }             }         }     }       for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){                 err = 1;             }             else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){                 err = 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction multiply general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     int multiplicitive_n = 128;     srand(SEED);     real_t * a = new real_t[multiplicitive_n];     real_t * b = new real_t[multiplicitive_n];      real_t multiplied_total = 1.0;      for (int x = 0; x < multiplicitive_n; ++x){         a[x] = rand() / (real_t) RAND_MAX;         b[x] = rand() / (real_t) RAND_MAX;     }      #pragma acc data copyin(a[0:multiplicitive_n], b[0:multiplicitive_n]) copy(multiplied_total)     {         #pragma acc parallel loop reduction(*:multiplied_total)         for (int x = 0; x < multiplicitive_n; ++x){             multiplied_total *= a[x] + b[x];         }     }      for (int x = 0; x < multiplicitive_n; ++x){         multiplied_total /= (a[x] + b[x]);     }     if (fabs(multiplied_total - 1) > PRECISION * (2 * multiplicitive_n - 1)){         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     int m_n = 128;     srand(SEED);     real_t * a = new real_t[10 * m_n];     real_t * b = new real_t[10 * m_n];      real_t multiplicitive_total[10];      for (int x = 0; x < m_n; ++x){         a[x] = rand() / (real_t) RAND_MAX;         b[x] = rand() / (real_t) RAND_MAX;     }      for (int x = 0; x < 10; ++x) {         multiplicitive_total[x] = 1.0;     }      #pragma acc data copyin(a[0:10*m_n], b[0:10*m_n])     {         #pragma acc parallel loop reduction(*:multiplicitive_total)         for (int x = 0; x < 10 * m_n; ++x) {             multiplicitive_total[x%10] = multiplicitive_total[x%10] * (a[x] + b[x]);         }     }      for (int x = 0; x < 10 * m_n; ++x) {         multiplicitive_total[x%10] /= (a[x] + b[x]);     }      for (int x = 0; x < 10; ++x) {         if (fabs(multiplicitive_total[x]) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels copyout", "completion": "#ifndef T1 !T1:devonly,kernels,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest         devtest(1) = 1          !$acc enter data copyin(devtest(1:1))         !$acc kernels present(devtest(1:1))           devtest(1) = 0         !$acc end kernels          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0          !$acc data copyin(a(1:LOOPCOUNT))           !$acc kernels copyout(b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = a(x)             END DO           !$acc end kernels         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(a(x) - b(x)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:devonly,kernels,V:2.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest         devtest(1) = 1          !$acc enter data copyin(devtest(1:1))         !$acc kernels present(devtest(1:1))           devtest(1) = 0         !$acc end kernels          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          IF (devtest(1) .eq. 1) THEN           CALL RANDOM_NUMBER(a)           b = 0                      !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc kernels copyout(b(1:LOOPCOUNT))               !$acc loop               DO x = 1, LOOPCOUNT                 b(x) = a(x)               END DO             !$acc end kernels           !$acc end data                      DO x = 1, LOOPCOUNT             IF (abs(b(x)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign bitor equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev | a[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         for (int y = 0; y < 8; ++y){             totals[x] =  1<<y;             totals_comparison[x] = 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         b[x] = totals[x/10];                         totals[x/10] |= a[x];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] |= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction add general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc serial loop reduction(+:total)         for (int x = 0; x < n; ++x){             total += a[x] + b[x];         }     }     for (int x = 0; x < n; ++x){         total -= a[x] + b[x];     }     if (fabs(total - 10) > PRECISION * (2 * n - 1)){ //199 = # of mathematical operations necessary         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature exit data finalize", "completion": "#ifndef T1 !T1:data,executable-data,devonly,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1) :: devtest          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))         !$acc enter data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))         !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))           !$acc loop           DO x = 1, LOOPCOUNT             c(x) = a(x) + b(x)           END DO         !$acc end parallel         !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))         IF (devtest(1) .eq. 1) THEN           DO x = 1, LOOPCOUNT             IF (abs(c(x)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF         !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))         DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:data,executable-data,devonly,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1) :: devtest          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))         !$acc enter data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))         !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))           !$acc loop           DO x = 1, LOOPCOUNT             c(x) = a(x) + b(x)           END DO         !$acc end parallel         !$acc exit data copyout(c(1:LOOPCOUNT)) delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) finalize         DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial present", "completion": "#ifndef T1 !T1:serial,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   REAL(8),DIMENSION(LOOPCOUNT):: a, b, c   INTEGER:: x   INTEGER:: errors    errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 0    !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT))   !$acc serial present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))     !$acc loop     DO x = 1, LOOPCOUNT       c(x) = a(x) + b(x)     END DO   !$acc end serial   !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))    DO x = 1, LOOPCOUNT     IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc get property", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,devonly,syntactic,V:2.6-2.7 int test1(){     int err = 0;      if (acc_get_device_type() != acc_device_none){         const char* returned_string1;         const char* returned_string2;         const char* returned_string3;         int returned_int;         returned_int = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_memory);         returned_int = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);         returned_string1 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_name);         returned_string2 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_vendor);         returned_string3 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_driver);     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign postdecrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *c = new int[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];     bool found = false;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = distribution[(int) (a[x]*b[x]/10)];                     (distribution[(int) (a[x]*b[x]/10)])--;                 }             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]--;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y > -distribution_comparison[x]; --y){             for (int z = 0; z < n; ++z){                 if (y == c[z] && x == (int) (a[x] * b[x] / 10)){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data present no lower bound", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,data-region,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n]) present(c[:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }     #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture expr and x assign", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         LOGICAL,DIMENSION(length), INTENT(IN) :: a         LOGICAL,DIMENSION(length), INTENT(IN) :: b         LOGICAL, INTENT(IN) :: init         LOGICAL,DIMENSION(length - 1) :: passed_a         LOGICAL,DIMENSION(length - 1) :: passed_b         LOGICAL :: POSSIBLE         INTEGER :: x, y         IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.         DO x = 1, length           IF (b(x) .eqv. (init .AND. a(x))) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             IF (IS_POSSIBLE(passed_a, passed_b, length - 1, b(x))) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT, 10):: b         LOGICAL IS_POSSIBLE         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) < .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   totals(x) = a(x, y) .AND. totals(x)                   b(x, y) = totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .AND. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           IF (.FALSE. .eqv. IS_POSSIBLE(a(x, 1:10), b(x, 1:10), 10, .FALSE.)) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured x divided expr assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_c = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(c[x] - (prev / (a[x] + b[x]))) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];                 passed_c[y] = c[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];                 passed_c[y - 1] = c[y];             }             if (is_possible(passed_a, passed_b, passed_c, length - 1, c[x])){                 free(passed_a);                 free(passed_b);                 free(passed_c);                 return true;             }         }     }     free(passed_a);     free(passed_b);     free(passed_c);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));     real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));     real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x/10] = totals[x/10] / (a[x] + b[x]);                     c[x] = totals[x/10];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];             temp_c[temp_iterator] = c[ab_iterator];             temp_iterator++;         }         if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitxor loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));     unsigned int temp = 0;      for (int x = 0; x < 10*n; ++x){         b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b_copy[x] = b[x];         a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);     }     for (int x = 0; x < 10; ++x){         c[x] = 0;     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(^:temp)             for (int y = 0; y < n; ++y){                 temp = temp ^ a[x * n + y];             }             c[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 b[x * n + y] = b[x * n + y] + c[x];             }         }     }      for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = temp ^ a[x * n + y];         }         if (temp != c[x]){             err += 1;         }         for (int y = 0; y < n; ++y){             if (b[x * n + y] != b_copy[x * n + y] + c[x]){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,nonvalidating,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(25 * sizeof(unsigned int));      unsigned int temp[5];      for (int x = 0; x < n; ++x){         a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b_copy[x] = b[x];     }      for (int x = 0; x < 25; ++x) {         c[x] = 0;     }      for (int x = 0; x < 5; ++x) {         temp[x] = 0;     }      #pragma acc data copyin(a[0:25*n]) copy(b[0:25*n], c[0:25])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 temp[y] = 0;             }             #pragma acc loop worker reduction(^:temp)             for (int y = 0; y < 5 * n; ++y) {                 temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];             }             for (int y = 0; y < 5; ++y) {                 c[x * 5 + y] = temp[y];             }             #pragma acc loop worker             for (int y = 0; y < 5 * n; ++y) {                 b[x * 5 * n + y] = b[x * 5 * n + y] + c[x * 5 + (y % 5)];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             temp[y] = 0;         }         for (int y = 0; y < 5 * n; ++y) {             temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];         }              }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial create", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,data-region,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copy(c[0:n])     {         #pragma acc serial create(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - c[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction bitxor general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     unsigned int b = 0;      for (int x = 0; x < n; ++x){         a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);     }     unsigned int host_b = a[0];      #pragma acc data copyin(a[0:n])     {         #pragma acc kernels loop reduction(^:b)         for (int x = 0; x < n; ++x){             b = b ^ a[x];         }     }       for (int x = 1; x < n; ++x){         host_b = host_b ^ a[x];     }     if (b != host_b){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction multiply vector loop", "completion": "#ifndef T1 !T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   REAL(8),DIMENSION(10, LOOPCOUNT):: a, b   REAL(8),DIMENSION(LOOPCOUNT):: totals, host_totals   REAL(8):: temp   INTEGER:: errors, x, y    errors = 0    SEEDDIM(1) = 1   #ifdef SEED   SEEDDIM(1) = SEED   #endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)    host_totals = 1   DO y = 1, LOOPCOUNT     DO x = 1, 10       host_totals(y) = host_totals(y) * (a(x, y) + b(x, y))     END DO   END DO    !$acc data copyin(a(1:10, 1:LOOPCOUNT), b(1:10, 1:LOOPCOUNT)) copyout(totals(1:LOOPCOUNT))     !$acc serial loop private(temp)     DO y = 1, LOOPCOUNT       temp = 1       !$acc loop vector reduction(*:temp)       DO x = 1, 10         temp = temp * (a(x, y) + b(x, y))       END DO       totals(y) = temp     END DO   !$acc end data    DO y = 1, LOOPCOUNT     IF (abs(host_totals(y) - totals(y)) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM serial_loop_reduction_multiply_vector_loop         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial async", "completion": "#ifndef T1 !T1:async,serial,update,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f, g   INTEGER:: x    errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 0   CALL RANDOM_NUMBER(d)   CALL RANDOM_NUMBER(e)   f = 0   g = 0    !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT), f(1:LOOPCOUNT), g(1:LOOPCOUNT))     !$acc serial async(1)       !$acc loop       DO x = 1, LOOPCOUNT         c(x) = a(x) + b(x)       END DO     !$acc end serial     !$acc serial async(2)       !$acc loop       DO x = 1, LOOPCOUNT         f(x) = d(x) + e(x)       END DO     !$acc end serial     !$acc serial wait(1, 2) async(3)       !$acc loop       DO x = 1, LOOPCOUNT         g(x) = c(x) + f(x)       END DO     !$acc end serial      !$acc update host(c(1:LOOPCOUNT)) async(1)     !$acc update host(f(1:LOOPCOUNT)) async(2)     !$acc update host(g(1:LOOPCOUNT)) async(3)      !$acc wait(1)     DO x = 1, LOOPCOUNT       IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN         errors = errors + 1       END IF     END DO      !$acc wait(2)     DO x = 1, LOOPCOUNT       IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN         errors = errors + 1       END IF     END DO      !$acc wait(3)     DO x = 1, LOOPCOUNT       IF (abs(g(x) - (a(x) + b(x) + d(x) + e(x))) .gt. 4 * PRECISION) THEN         errors = errors + 1       END IF     END DO   !$acc end data          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured expr plus x assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] + prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x%(n/10 + 1)] = (a[x] * b[x]) + totals[x%(n/10 + 1)];                     c[x] = totals[x%(n/10 + 1)];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] += a[x] * b[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){             passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc async test all", "completion": "#ifndef T1 !T1:runtime,async,construct-independent,update,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c, d, e !Data         INTEGER :: errors         errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         CALL RANDOM_NUMBER(d)         c = 0         e = 0          !$acc enter data create(a(1:LOOPCOUNT,1:10), b(1:LOOPCOUNT,1:10), c(1:LOOPCOUNT,1:10), d(1:LOOPCOUNT,1:10), e(1:LOOPCOUNT,1:10))         DO y = 1, 10           !$acc update device(a(1:LOOPCOUNT,y:y), b(1:LOOPCOUNT,y:y), d(1:LOOPCOUNT,y:y)) async(y)           !$acc parallel present(a(1:LOOPCOUNT,y:y), b(1:LOOPCOUNT,y:y), c(1:LOOPCOUNT,y:y)) async(y)             !$acc loop             DO x = 1, LOOPCOUNT               c(x, y) = a(x, y) + b(x, y)             END DO           !$acc end parallel           !$acc parallel present(c(1:LOOPCOUNT,y:y), d(1:LOOPCOUNT,y:y),e(1:LOOPCOUNT,y:y)) async(y)             !$acc loop             DO x = 1, LOOPCOUNT               e(x, y) = c(x, y) + d(x, y)             END DO           !$acc end parallel           !$acc update host(e(1:LOOPCOUNT,y:y)) async(y)         END DO          DO WHILE (acc_async_test_all() .eqv. .FALSE.)           CONTINUE         END DO          DO y = 1, 10           DO x = 1, LOOPCOUNT             IF (abs(e(x, y) - (a(x, y) + b(x, y) + d(x, y))) .GT. PRECISION) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif  #ifndef T2 !T2:async,runtime,construct-independent,V:1.0-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c, d, e !Data         INTEGER :: errors         errors = 0          !Initialization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         CALL RANDOM_NUMBER(d)         c = 0         e = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT,1:10), d(1:LOOPCOUNT, 1:10)) copyout(c(1:LOOPCOUNT, 1:10), e(1:LOOPCOUNT, 1:10))           DO x = 1, 10             !$acc parallel present(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10), c(1:LOOPCOUNT, 1:10)) async(x)               !$acc loop               DO y = 1, LOOPCOUNT                 c(y, x) = a(y, x) + b(y, x)               END DO             !$acc end parallel             !$acc parallel present(c(1:LOOPCOUNT, 1:10), d(1:LOOPCOUNT, 1:10), e(1:LOOPCOUNT, 1:10)) async(x)               !$acc loop               DO y = 1, LOOPCOUNT                 e(y, x) = c(y, x) + d(y, x)               END DO             !$acc end parallel           END DO           DO WHILE (acc_async_test_all() .eqv. .FALSE.)             CONTINUE           END DO         !$acc end data          DO x = 1, 10           DO y = 1, LOOPCOUNT             IF (abs(e(y, x) - (a(y, x) + b(y, x) + d(y, x))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif  #ifndef T3 !T3:async,runtime,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test3()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c, d, e !Data         INTEGER :: errors         errors = 0          !Initialization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         CALL RANDOM_NUMBER(d)         c = 0         e = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10), d(1:LOOPCOUNT, 1:10)) copyout(c(1:LOOPCOUNT, 1:10), e(1:LOOPCOUNT, 1:10))           DO x = 1, 10             CALL acc_set_default_async(x)             !$acc parallel present(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10), c(1:LOOPCOUNT, 1:10)) async               !$acc loop               DO y = 1, LOOPCOUNT                 c(y, x) = a(y, x) + b(y, x)               END DO             !$acc end parallel             !$acc parallel present(c(1:LOOPCOUNT, 1:10), d(1:LOOPCOUNT, 1:10), e(1:LOOPCOUNT, 1:10)) async               !$acc loop               DO y = 1, LOOPCOUNT                 e(y, x) = c(y, x) + d(y, x)               END DO             !$acc end parallel           END DO           DO WHILE (acc_async_test_all() .eqv. .FALSE.)             CONTINUE           END DO         !$acc end data          DO x = 1, 10           DO y = 1, LOOPCOUNT             IF (abs(e(y, x) - (a(y, x) + b(y, x) + d(y, x))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM main       IMPLICIT NONE       INTEGER :: failcode, testrun       LOGICAL :: failed       INCLUDE \"acc_testsuite.Fh\"       !Conditionally define test functions #ifndef T1       LOGICAL :: test1 #endif #ifndef T2       LOGICAL :: test2 #endif #ifndef T3       LOGICAL :: test3 #endif       failcode = 0       failed = .FALSE.  #ifndef T1       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test1()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 0         failed = .FALSE.       END IF #endif #ifndef T2       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test2()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 1         failed = .FALSE.       END IF #endif #ifndef T3       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test3()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 2         failed = .FALSE.       END IF #endif       CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop gang", "completion": "#ifndef T1 !T1:parallel,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))           !$acc parallel loop gang           DO x = 1, LOOPCOUNT             c(x) = a(x) + b(x)           END DO         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc wait all async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,async,construct-independent,wait,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));     real_t *e = (real_t *)malloc(n * sizeof(real_t));     real_t *f = (real_t *)malloc(n * sizeof(real_t));     real_t *g = (real_t *)malloc(n * sizeof(real_t));     real_t *h = (real_t *)malloc(n * sizeof(real_t));     real_t *i = (real_t *)malloc(n * sizeof(real_t));     real_t *j = (real_t *)malloc(n * sizeof(real_t));     real_t *k = (real_t *)malloc(n * sizeof(real_t));     real_t *a_host = (real_t *)malloc(n * sizeof(real_t));     real_t *d_host = (real_t *)malloc(n * sizeof(real_t));     real_t *g_host = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0;         g[x] = rand() / (real_t)(RAND_MAX / 10);         h[x] = rand() / (real_t)(RAND_MAX / 10);         i[x] = 0;         j[x] = 0;         k[x] = 0;         a_host[x] = a[x];         d_host[x] = d[x];         g_host[x] = g[x];     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], g[0:n], h[0:n]) create(c[0:n], f[0:n], i[0:n], j[0:n]) copyout(k[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         #pragma acc parallel async(3)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 i[x] = g[x] + h[x];             }         }         acc_wait_all_async(4);         #pragma acc parallel async(4)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 j[x] = c[x] + f[x] + i[x];             }         }         #pragma acc parallel async(1)         {             for (int x = 0; x < n; ++x){                 a[x] = b[x] * c[x];             }         }         #pragma acc parallel async(2)         {             for (int x = 0; x < n; ++x){                 d[x] = e[x] * f[x];             }         }         #pragma acc parallel async(3)         {             for (int x = 0; x < n; ++x){                 g[x] = h[x] * i[x];             }         }         acc_wait_all_async(4);         #pragma acc parallel async(4)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 k[x] = j[x] + a[x] + d[x] + g[x];             }         }         #pragma acc wait(4)     }      real_t temp;     for (int x = 0; x < n; ++x){         temp = a_host[x] + b[x] + d_host[x] + e[x] + g_host[x] + h[x];         temp += b[x] * (a_host[x] + b[x]) + e[x] * (d_host[x] + e[x]) + h[x] * (g_host[x] + h[x]);         if (fabs(k[x] - temp) > PRECISION * 10){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature set device type", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,set,V:2.5-3.2       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: errors = 0          !$acc set device_type(host)          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,construct-independent,internal-control-values,set,V:2.5-3.2       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: errors = 0          !$acc set device_type(multicore)          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:runtime,construct-independent,internal-control-values,set,V:2.5-3.2       LOGICAL FUNCTION test3()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: errors = 0          !$acc set device_type(default)          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM set_device_type         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture divided equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     real_t *passed_c = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(c[x] - (prev / (a[x] + b[x]))) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];                 passed_c[y] = c[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];                 passed_c[y - 1] = c[y];             }             if (is_possible(passed_a, passed_b, passed_c, length - 1, c[x])){                 delete[] passed_a;                 delete[] passed_b;                 delete[] passed_c;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     delete[] passed_c;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t *temp_a = new real_t[10];     real_t *temp_b = new real_t[10];     real_t *temp_c = new real_t[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = totals[x%(n/10 + 1)] /= (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < (n/10 + 1); ++x){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n;  ab_iterator+=((n/10) + 1)){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];             temp_c[temp_iterator] = c[ab_iterator];             temp_iterator++;         }         if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign expr bitxor x", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev ^ a[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         for (int y = 0; y < 8; ++y){             totals[x] =  1<<y;             totals_comparison[x] = 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         b[x] = totals[x/10];                         totals[x/10] = a[x] ^ totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] ^= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitand general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     n = 10;     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int b = 0;     unsigned int host_b;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX < false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }     for (int x = 0; x < 16; ++x){         temp = 1;         for (int y = 0; y < x; ++y){             temp *= 2;         }         b += temp;     }     #pragma acc data copyin(a[0:n])     {         #pragma acc serial loop reduction(&:b)         for (int x = 0; x < n; ++x){             b = b & a[x];         }     }      host_b = a[0];     for (int x = 1; x < n; ++x){         host_b = host_b & a[x];     }     if (b != host_b){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction add loop", "completion": "#ifndef T1 !T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10*LOOPCOUNT):: a, b, c, d !Data         REAL(8) :: avg         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         avg = 0         !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) create(c(1:10*LOOPCOUNT)) copyout(d(1:10*LOOPCOUNT))           !$acc kernels loop gang private(avg)           DO x = 0, 9             avg = 0             !$acc loop worker reduction(+:avg)             DO y = 1, LOOPCOUNT               avg = avg + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)               c(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)             END DO             avg = avg / LOOPCOUNT             !$acc loop worker             DO y = 1, LOOPCOUNT               d(x * LOOPCOUNT + y) = c(x * LOOPCOUNT + y) / avg             END DO           END DO         !$acc end data         DO x = 0, 9           avg = 0           DO y = 1, LOOPCOUNT             avg = avg + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)           END DO           avg = avg / LOOPCOUNT           DO y = 1, LOOPCOUNT             IF (abs(d(x * LOOPCOUNT + y) - ((a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)) / avg)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop worker", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])     {         #pragma acc serial loop worker         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels copyout zero", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data,data-region,V:3.0-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n])     {         #pragma acc kernels copyout(zero: b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] += a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:kernels,data,data-region,devonly,V:3.0-3.1 int test2(){     int err = 0;     srand(SEED);     int * devtest = (int *)malloc(sizeof(int));     real_t * a = new real_t[n];     real_t * b = new real_t[n];     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc kernels present(devtest[0:1])     {       devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0;         }          #pragma acc data copyin(a[0:n])         {             #pragma acc kernels copyout(zero: b[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] += a[x];                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(a[x] - b[x]) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:async,data,V:3.2-3.3 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copy(a[0:n], b[0:n], c[0:n]) async(1)     {         #pragma acc parallel          {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      #pragma acc data copy(a[0:n], b[0:n], c[0:n]) async(1)     {         #pragma acc parallel          {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      #pragma acc wait(1)           for (int x = 0; x < n; ++x){         if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION){             err += 1;         }     }      return err; } #endif #ifndef T2 //T2:async,data,V:3.2-3.3 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copy(a[0:n], b[0:n], c[0:n]) async(0)     {         #pragma acc parallel loop async(1) wait(0)             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }      #pragma acc wait(1) async(0)     }      #pragma acc wait(0)      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic min x expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial present", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,present,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n])     #pragma acc serial present(a[0:n], b[0:n]) copy(c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc exit data delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels wait", "completion": "#ifndef T1 !T1:async,kernels,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) async(1)         !$acc kernels wait(1)           !$acc loop           DO x = 1, LOOPCOUNT             c(x) = a(x) + b(x)           END DO         !$acc end kernels         !$acc exit data copyout(c(1:LOOPCOUNT)) delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature init device num", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: device_num         INTEGER :: device_type         INTEGER :: errors = 0          device_num = acc_get_device_num(acc_get_device_type())         !$acc init device_num(device_num)          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop reduction bitxor vector loop", "completion": "#ifndef T1 !T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(10*LOOPCOUNT):: a !Data         REAL(8),DIMENSION(10*LOOPCOUNT):: randoms         INTEGER,DIMENSION(10):: b         INTEGER :: errors = 0         INTEGER :: temp          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = FLOOR(randoms*1000000)          !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10))           !$acc kernels loop gang private(temp)           DO x = 0, 9             temp = 0             !$acc loop vector reduction(ieor:temp)             DO y = 1, LOOPCOUNT               temp = ieor(temp, a(x * LOOPCOUNT + y))             END DO             b(x + 1) = temp           END DO         !$acc end data          DO x = 0, 9           temp = 0           DO y = 1, LOOPCOUNT             temp = ieor(temp, a(x * LOOPCOUNT + y))           END DO           IF (temp .ne. b(x + 1)) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel switch", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,syntactic,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int * a = (int *)malloc(n * sizeof(int));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * b_host = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t tempc = 0.0;      for (int x = 0; x < n; ++x){         a[x] = floor(rand() / (real_t)(RAND_MAX / 10));         b[x] = rand() / (real_t)(RAND_MAX / 10);         b_host[x] = b[x];         c[x] = 0.0;     }     #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])     #pragma acc parallel present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             switch(a[x]){                 case 0:                     c[x] = b[x] * b[x];                     break;                 case 1:                     c[x] = b[x] / b[x];                     break;                 case 2:                     b[x] = b[x] / 2;                 default:                     c[x] = a[x] + b[x];               }         }     }     #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])      for (int x = 0; x < n; ++x){         switch(a[x]){             case 0:                 tempc = b_host[x] * b_host[x];                 break;             case 1:                 tempc = b_host[x] / b_host[x];                 break;             case 2:                 b_host[x] = b_host[x] / 2;             default:                 tempc = a[x] + b_host[x];         }         if (fabs(c[x] - tempc) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update max expr x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign x bitxor expr", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev ^ a[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         b[x] = totals[x/10];                         totals[x/10] = totals[x/10] ^ a[x];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] ^= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture assign min x expr list", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, c, length, init) RESULT(POSSIBLE)       INTEGER, INTENT(IN) :: length       REAL(8), INTENT(IN) :: init       REAL(8),DIMENSION(length), INTENT(IN) :: a       REAL(8),DIMENSION(length), INTENT(IN) :: b       REAL(8),DIMENSION(length), INTENT(IN) :: c       REAL(8),DIMENSION(length - 1) :: passed_a       REAL(8),DIMENSION(length - 1) :: passed_b       REAL(8),DIMENSION(length - 1) :: passed_c       REAL(8) :: holder       LOGICAL :: POSSIBLE       INTEGER :: x, y        IF (length .eq. 0) THEN         POSSIBLE = .TRUE.         RETURN       END IF       POSSIBLE = .FALSE.        DO x = 1, length         IF (abs(c(x) - init) .lt. (10 - length) * PRECISION) THEN           DO y = 1, x - 1             passed_a(y) = a(y)             passed_b(y) = b(y)           END DO           DO y = x + 1, length             passed_a(y - 1) = a(y)             passed_b(y - 1) = b(y)           END DO           holder = min(a(x), b(x), init)           IF (IS_POSSIBLE(passed_a, passed_b, passed_c, length - 1, holder)) THEN             POSSIBLE = .TRUE.             RETURN           END IF         END IF       END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()       IMPLICIT NONE       INCLUDE \"acc_testsuite.Fh\"       INTEGER :: x, y !Iterators       REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data       REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison       REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c       REAL(8):: init       LOGICAL IS_POSSIBLE       INTEGER :: errors = 0        !Initilization       SEEDDIM(1) = 1 #     ifdef SEED       SEEDDIM(1) = SEED #     endif       CALL RANDOM_SEED(PUT=SEEDDIM)        CALL RANDOM_NUMBER(a)       CALL RANDOM_NUMBER(b)        totals = 1       totals_comparison = 1        !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))         !$acc parallel           !$acc loop           DO x = 1, LOOPCOUNT             DO y = 1, 10               !$acc atomic capture                 c(x, y) = totals(x)                 totals(x) = min(totals(x), a(x, y), b(x, y))               !$acc end atomic             END DO           END DO         !$acc end parallel       !$acc end data       DO x = 1, LOOPCOUNT         DO y = 1, 10           totals_comparison(x) = min(totals_comparison(x), a(x, y), b(x, y))         END DO       END DO       DO x = 1, LOOPCOUNT         IF (totals_comparison(x) .NE. totals(x)) THEN           errors = errors + 1           WRITE(*, *) totals_comparison(x)         END IF       END DO        DO x = 1, LOOPCOUNT         DO y = 1, 10           passed_a(y) = a(x, y)           passed_b(y) = b(x, y)           passed_c(y) = c(x, y)         END DO         init = 1         IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN           errors = errors + 1         END IF       END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic iand expr x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .gt. .933) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           DO y = 0, 7             totals(x) = totals(x) + ISHFT(1, y)             totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)           END DO         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign assign", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *b_copy = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         b_copy[x] = b[x];     }      #pragma acc data copyin(a[0:n]) copy(b[0:n]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = b[x];                     b[x] = a[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         if (abs(c[x] - b_copy[x]) > PRECISION){             err++;         }         if (abs(b[x] - a[x]) > PRECISION){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction max general", "completion": "#ifndef T1 !T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8) :: maximum, temp         INTEGER :: errors = 0          !Initilization         maximum = 0         temp = 0         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc kernels loop reduction(max:maximum)           DO x = 1, LOOPCOUNT             maximum = max(maximum, a(x) * b(x))           END DO         !$acc end data          DO x = 1, LOOPCOUNT           temp = max(temp, a(x) * b(x))         END DO         IF (abs(temp - maximum) .gt. PRECISION) THEN           errors = errors + 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial firstprivate", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,firstprivate,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10];     real_t * c_copy = new real_t[10];     real_t * d = new real_t[10 * n];      for (int x = 0; x < 10*n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         d[x] = 0.0;     }     for (int x = 0; x < 10; ++x){         c[x] = rand() / (real_t)(RAND_MAX / 10);         c_copy[x] = c[x];     }     #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])     {         #pragma acc serial firstprivate(c[0:n])         {             #pragma acc loop gang             for (int x = 0; x < n; ++x){                 #pragma acc loop worker                 for (int y = 0; y < 10; ++y){                     d[x * 10 + y] = a[x * 10 + y] + b[x * 10 + y] + c[y];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 10; ++y){             if (fabs(d[x * 10 + y] - (a[x * 10 + y] + b[x * 10 + y] + c_copy[y])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:serial,firstprivate,V:2.6-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10];     real_t * c_copy = new real_t[10];     real_t * d = new real_t[10 * n];      for (int x = 0; x < 10*n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         d[x] = 0.0;     }     for (int x = 0; x < 10; ++x){         c[x] = 0.0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])     {         #pragma acc serial firstprivate(c[0:n])         {             #pragma acc loop gang independent             for (int x = 0; x < n; ++x){                 #pragma acc loop worker independent                 for (int y = 0; y < 10; ++y){                     c[y] = a[x * 10 + y] - b[x * 10 + y];                 }                 #pragma acc loop worker independent                 for (int y = 0; y < 10; ++y){                     d[x * 10 + y] = a[x * 10 + y] + b[x * 10 + y] + c[y];                 }             }         }     }      for (int x = 0; x < 10 * n; ++x){         if (fabs(d[x] - 2 * a[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels copy", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data,data-region,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 1;     }     #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc kernels copy(c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     int * devtest = (int *)malloc(sizeof(int));     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc kernels present(devtest[0:1])     {       devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){           a[x] = rand() / (real_t)(RAND_MAX / 10);           b[x] = rand() / (real_t)(RAND_MAX / 10);           c[x] = 1;         }         #pragma acc data copyin(a[0:n], b[0:n], c[0:n])         {             #pragma acc kernels copy(c[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] += a[x] + b[x];                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(c[x] - 1) > PRECISION && (a[x] + b[x]) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  #ifndef T3 //T3:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     int * devtest = (int *)malloc(sizeof(int));     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc kernels present(devtest[0:1])     {       devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++ x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 1;         }          #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])         {             for (int x = 0; x < n; ++x){                 c[x] = 0;             }             #pragma acc kernels copy(c[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] += a[x] + b[x];                 }             }             for (int x = 0; x < n; ++x){                 if (fabs(c[x]) > PRECISION) {                     err += 1;                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc wait all async", "completion": "#ifndef T1 !T1:runtime,async,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f, g, h, i, j, k !Data         REAL(8),DIMENSION(LOOPCOUNT):: a_host, d_host, g_host         REAL(8) :: RAND         REAL(8) :: temp         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(d)         CALL RANDOM_NUMBER(e)         f = 0         CALL RANDOM_NUMBER(g)         CALL RANDOM_NUMBER(h)         i = 0         j = 0         k = 0         a_host = a         d_host = d         g_host = g          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT), g(1:LOOPCOUNT), h(1:LOOPCOUNT)) create(c(1:LOOPCOUNT), f(1:LOOPCOUNT), i(1:LOOPCOUNT), j(1:LOOPCOUNT)) copyout(k(1:LOOPCOUNT))           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           !$acc parallel async(2)             !$acc loop             DO x = 1, LOOPCOUNT               f(x) = d(x) + e(x)             END DO           !$acc end parallel           !$acc parallel async(3)             !$acc loop             DO x = 1, LOOPCOUNT               i(x) = g(x) + h(x)             END DO           !$acc end parallel           CALL acc_wait_all_async(4)           !$acc parallel async(4)             !$acc loop             DO x = 1, LOOPCOUNT               j(x) = c(x) + f(x) + i(x)             END DO           !$acc end parallel           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               a(x) = b(x) * c(x)             END DO           !$acc end parallel           !$acc parallel async(2)             !$acc loop             DO x = 1, LOOPCOUNT               d(x) = e(x) * f(x)             END DO           !$acc end parallel           !$acc parallel async(3)             !$acc loop             DO x = 1, LOOPCOUNT               g(x) = h(x) * i(x)             END DO           !$acc end parallel           CALL acc_wait_all_async(4)           !$acc parallel async(4)             !$acc loop             DO x = 1, LOOPCOUNT               k(x) = j(x) + a(x) + d(x) + g(x)             END DO           !$acc end parallel           !$acc wait(4)         !$acc end data          DO x = 1, LOOPCOUNT           temp = a_host(x) + b(x) + d_host(x) + e(x) + g_host(x) + h(x)           temp = temp + (b(x) * (a_host(x) + b(x))) + (e(x) * (d_host(x) + e(x))) + (h(x) * (g_host(x) + h(x)))           IF (abs(k(x) - temp) .gt. PRECISION * 10) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature reference count zero", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:reference-counting,data,V:3.2-3.3 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }       #pragma acc data copy(a[0:n], b[0:n], c[0:n])     {         #pragma acc parallel loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature atomic expr and x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) < .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = a(x, y) .AND. totals(x)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .AND. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc copyout finalize async with len", "completion": "#ifndef T1 !T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(d)         CALL RANDOM_NUMBER(e)         f = 0          !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))         !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           !$acc parallel async(2)             !$acc loop             DO x = 1, LOOPCOUNT               f(x) = d(x) + e(x)             END DO           !$acc end parallel           CALL acc_copyout_finalize_async(c(1), LOOPCOUNT*8, 1)           CALL acc_copyout_finalize_async(f(1), LOOPCOUNT*8, 2)           !$acc wait         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF           IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO         IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif       PROGRAM main       IMPLICIT NONE       INTEGER :: failcode, testrun       LOGICAL :: failed       INCLUDE \"acc_testsuite.Fh\"       !Conditionally define test functions #ifndef T1       LOGICAL :: test1 #endif       failcode = 0       failed = .FALSE.  #ifndef T1       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test1()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 0         failed = .FALSE.       END IF #endif        CALL EXIT (failcode)     END PROGRAM  "}
{"prompt": "Create a test for the feature kernels loop reduction multiply general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     int multiplicitive_n = 128;     srand(SEED);     real_t * a = (real_t *)malloc(multiplicitive_n * sizeof(real_t));     real_t * b = (real_t *)malloc(multiplicitive_n * sizeof(real_t));      real_t multiplied_total = 1.0;      for (int x = 0; x < multiplicitive_n; ++x){         a[x] = rand() / (real_t) RAND_MAX;         b[x] = rand() / (real_t) RAND_MAX;     }      #pragma acc data copyin(a[0:multiplicitive_n], b[0:multiplicitive_n]) copy(multiplied_total)     {         #pragma acc kernels loop reduction(*:multiplied_total)         for (int x = 0; x < multiplicitive_n; ++x){             multiplied_total *= a[x] + b[x];         }     }      for (int x = 0; x < multiplicitive_n; ++x){         multiplied_total /= (a[x] + b[x]);     }     if (fabs(multiplied_total - 1) > PRECISION * (2 * multiplicitive_n - 1)){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitand general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     n = 10;     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int b;     unsigned int host_b;      for (int x = 0; x < n; ++x){         a[x] = 0;         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX < false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }      b = a[0];     host_b = a[0];      #pragma acc data copyin(a[0:n])     {         #pragma acc parallel loop reduction(&:b)         for (int x = 0; x < n; ++x){             b = b & a[x];         }     }      for (int x = 1; x < n; ++x){         host_b = host_b & a[x];     }     if (b != host_b){         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(int));     real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int device[10];     unsigned int host[10];      for (int x = 0; x < 10 * n; ++x) {         a[x] = 0;         for (int y = 0; y < 16; ++y){             if (rand() / (real_t)RAND_MAX < false_margin) {                 a[x] += 1<<y;             }         }     }      for (int x = 0; x < 10; ++x) {         device[x] = 0;         host[x] = 0;         for (int y = 0; y < 16; ++y) {             device[x] += 1<<y;             host[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:10*n])     {         #pragma acc parallel loop reduction(&:device)         for (int x = 0; x < 10 * n; ++x) {             device[x%10] = device[x%10] & a[x];         }     }      for (int x = 0; x < 10 * n; ++x) {         host[x%10] = host[x%10] & a[x];     }      for (int x = 0; x < 10; ++x) {         if (host[x] != device[x]) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic plus equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] += a[x] * b[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] += a[x] * b[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > (n/10 + 1) * PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine vector", "completion": "#include \"acc_testsuite.h\" void test_routine_vector_loop_named(real_t ** a, real_t * b, long long n); void test_routine_vector_vector_named(real_t ** a, real_t * b, long long n); void test_routine_vector_seq_named(real_t ** a, real_t * b, long long n);  #pragma acc routine(test_routine_vector_loop_named) vector #pragma acc routine(test_routine_vector_vector_named) vector #pragma acc routine(test_routine_vector_seq_named) vector  #pragma acc routine vector real_t called_function_vector(real_t **a, int x, long long n){     real_t returned = 0;     #pragma acc loop vector reduction(+:returned)     for (int y = 0; y < n; ++y){         returned += a[x][y];     }     return returned; }  #pragma acc routine seq real_t called_function_seq(real_t **a, int x, long long n){     real_t returned = 0;     #pragma acc loop seq reduction(+:returned)     for (int y = 0; y < n; ++y){         returned += a[x][y];     }     return returned; }  #pragma acc routine vector void test_routine_vector_loop_unnamed(real_t ** a, real_t * b, long long n){     #pragma acc loop vector     for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             b[x] += a[x][y];         }     } }  #pragma acc routine vector void test_routine_vector_vector_unnamed(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_vector(a, x, n);     } }  #pragma acc routine vector void test_routine_vector_seq_unnamed(real_t ** a, real_t *b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_seq(a, x, n);     } }  void test_routine_vector_loop_named(real_t ** a, real_t * b, long long n){     #pragma acc loop vector     for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             b[x] += a[x][y];         }     } }  void test_routine_vector_vector_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_vector(a, x, n);     } }  void test_routine_vector_seq_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_seq(a, x, n);     } }  bool validate_data(real_t ** a, real_t * b){     real_t local_total;     for (int x = 0; x < n; ++x){         local_total = 0;         for (int y = 0; y < n; ++y){             local_total += a[x][y];         }         if (fabs(b[x] - local_total) > PRECISION){             return true;         }     }     return false; }  #ifndef T1 //T1:routine,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {               test_routine_vector_loop_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T2 //T2:routine,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_vector_loop_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T3 //T3:routine,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_vector_vector_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T4 //T4:routine,construct-independent,V:2.0-2.7 int test4(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_vector_vector_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T5 //T5:routine,construct-independent,V:2.0-2.7 int test5(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_vector_seq_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T6 //T6:routine,construct-independent,V:2.0-2.7 int test6(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_vector_seq_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif #ifndef T6     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test6();     }     if (failed != 0){         failcode = failcode + (1 << 5);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction multiply vector loop", "completion": "#ifndef T1 !T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(10) :: c         REAL(8) :: temp         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         a = (999.4 + a) / 1000         b = (999.4 + b) / 1000          !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copyout(c(1:10))           !$acc parallel loop private(temp)           DO x = 0, 9             temp = 1             !$acc loop vector reduction(*:temp)             DO y = 1, LOOPCOUNT               temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))             END DO             c(x + 1) = temp           END DO         !$acc end data          DO x = 0, 9           temp = 1           DO y = 1, LOOPCOUNT             temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))           END DO           IF (abs(temp - c(x + 1)) .gt. ((temp / 2) + (c(x + 1) / 2)) * PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update expr minus x", "completion": "#include \"acc_testsuite.h\" bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){     if (length == 0){         if (fabs(current_value - test_value) > PRECISION){             return true;         }         else {             return false;         }     }     real_t * passed = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         for (int y = 0; y < x; ++y){             passed[y] = remaining_combinations[y];         }         for (int y = x + 1; y < length; ++y){             passed[y - 1] = remaining_combinations[y];         }         if (possible_result(passed, length - 1, remaining_combinations[x] - current_value, test_value)){             delete[] passed;             return true;         }     }     delete[] passed;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *totals = new real_t[((n/10) + 1)];     int indexer = 0;     real_t * passed = new real_t[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < (n/10) + 1; ++x){         totals[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];             }         }     }     for (int x = 0; x < (n/10) + 1; ++x){         indexer = x;         while (indexer < n){             passed[indexer/((int) (n/10) + 1)] = a[indexer];             indexer += (n/10) + 1;         }         if (!(possible_result(passed, 10, 0, totals[x]))){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture ixor expr x assign", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   INTEGER, INTENT(IN) :: init   INTEGER,DIMENSION(length), INTENT(IN) :: a   INTEGER,DIMENSION(length), INTENT(IN) :: b   INTEGER,DIMENSION(length - 1) :: passed_a   INTEGER,DIMENSION(length - 1) :: passed_b   INTEGER :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (b(x) .eq. ieor(init, a(x))) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = b(x)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y, z !Iterators   INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms   INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison   INTEGER,DIMENSION(10):: passed_a, passed_b   INTEGER:: init   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)   a = 0   DO x = 1, LOOPCOUNT     DO y = 1, 10       DO z = 1, 8         IF (randoms(x, y, z) .gt. .5) THEN           a(x, y) = a(x, y) + ISHFT(1, z - 1)         END IF       END DO     END DO   END DO   totals = 0   totals_comparison = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             totals(x) = ieor(a(x, y), totals(x))             b(x, y) = totals(x)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data   DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = ieor(totals_comparison(x), a(x, y))     END DO   END DO   DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NE. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 0     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel async", "completion": "#ifndef T1 !T1:async,parallel,update,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y, z !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f, g !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(d)         CALL RANDOM_NUMBER(e)         f = 0         g = 0                  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT), c(1:LOOPCOUNT), f(1:LOOPCOUNT), g(1:LOOPCOUNT))           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           !$acc parallel async(2)             !$acc loop             DO x = 1, LOOPCOUNT               f(x) = d(x) + e(x)             END DO           !$acc end parallel           !$acc update host(c(1:LOOPCOUNT)) wait(1) async(4)           !$acc update host(f(1:LOOPCOUNT)) wait(2) async(5)           !$acc parallel wait(1, 2) async(3)             !$acc loop             DO x = 1, LOOPCOUNT               g(x) = c(x) + f(x)             END DO           !$acc end parallel           !$acc update host(g(1:LOOPCOUNT)) async(3)         !$acc end data         !$acc wait         DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           ELSE IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN             errors = errors + 1           ELSE IF (abs(g(x) - (f(x) + c(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature routine worker", "completion": "#include \"acc_testsuite.h\" void test_routine_worker_loop_named(real_t ** a, real_t * b, long long n); void test_routine_worker_worker_named(real_t ** a, real_t * b, long long n); void test_routine_worker_vector_named(real_t ** a, real_t * b, long long n); void test_routine_worker_seq_named(real_t ** a, real_t * b, long long n);  #pragma acc routine(test_routine_worker_loop_named) worker #pragma acc routine(test_routine_worker_worker_named) worker #pragma acc routine(test_routine_worker_vector_named) worker #pragma acc routine(test_routine_worker_seq_named) worker   #pragma acc routine worker real_t called_function_worker(real_t **a, int x, long long n){     real_t returned = 0;     #pragma acc loop worker reduction(+:returned)     for (int y = 0; y < n; ++y){         returned += a[x][y];     }     return returned; }  #pragma acc routine vector real_t called_function_vector(real_t **a, int x, long long n){     real_t returned = 0;     #pragma acc loop vector reduction(+:returned)     for (int y = 0; y < n; ++y){         returned += a[x][y];     }     return returned; }  #pragma acc routine seq real_t called_function_seq(real_t **a, int x, long long n){     real_t returned = 0;     #pragma acc loop seq reduction(+:returned)     for (int y = 0; y < n; ++y){         returned += a[x][y];     }     return returned; }  #pragma acc routine worker void test_routine_worker_loop_unnamed(real_t ** a, real_t * b, long long n){     #pragma acc loop worker     for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             b[x] += a[x][y];         }     } }  #pragma acc routine worker void test_routine_worker_worker_unnamed(real_t ** a, real_t * b, long long n){   for (int x = 0; x < n; ++x){         b[x] = called_function_worker(a, x, n);     } }  #pragma acc routine worker void test_routine_worker_vector_unnamed(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_vector(a, x, n);     } }  #pragma acc routine worker void test_routine_worker_seq_unnamed(real_t ** a, real_t *b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_seq(a, x, n);     } }  void test_routine_worker_loop_named(real_t ** a, real_t * b, long long n){     #pragma acc loop worker     for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             b[x] += a[x][y];         }     } }  void test_routine_worker_worker_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_worker(a, x, n);     } }  void test_routine_worker_vector_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_vector(a, x, n);     } }  void test_routine_worker_seq_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_seq(a, x, n);     } }  bool validate_data(real_t ** a, real_t * b){     real_t local_total;     for (int x = 0; x < n; ++x){         local_total = 0;         for (int y = 0; y < n; ++y){             local_total += a[x][y];         }         if (fabs(b[x] - local_total) > PRECISION){             return true;         }     }     return false; }  #ifndef T1 //T1:routine,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {               test_routine_worker_loop_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T2 //T2:routine,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_worker_loop_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T3 //T3:routine,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_worker_worker_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T4 //T4:routine,construct-independent,V:2.0-2.7 int test4(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_worker_worker_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T5 //T5:routine,construct-independent,V:2.0-2.7 int test5(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_worker_vector_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T6 //T6:routine,construct-independent,V:2.0-2.7 int test6(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_worker_vector_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T7 //T7:routine,construct-independent,V:2.0-2.7 int test7(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_worker_seq_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T8 //T8:routine,construct-independent,V:2.0-2.7 int test8(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_worker_seq_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif #ifndef T6     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test6();     }     if (failed != 0){         failcode = failcode + (1 << 5);     } #endif #ifndef T7     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test7();     }     if (failed != 0){         failcode = failcode + (1 << 6);     } #endif #ifndef T8     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test8();     }     if (failed != 0){         failcode = failcode + (1 << 7);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop tile", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,tile,combined-constructs,syntactic,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     real_t * d2 = new real_t[n * n];     real_t * d3 = new real_t[n * n * n];     real_t temp = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = rand() / (real_t)(RAND_MAX / 10);     }     #pragma acc data copy(a[0:n], b[0:n], c[0:n], d2[0:n*n])     {         #pragma acc serial loop tile(*, *) reduction(+:temp)         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 temp = 0;                 for (int z = 0; z < n; ++z){                     temp += a[x] + b[y] + c[z];                 }                 d2[x * n + y] = temp;             }         }     }     for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             temp = 0.0;             for (int z = 0; z < n; ++z){                 temp += a[x] + b[y] + c[z];             }             if (fabs(temp - d2[x * n + y]) > PRECISION * n){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:serial,loop,combined-constructs,tile,V:2.6-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     real_t * d2 = new real_t[n * n];     real_t * d3 = new real_t[n * n * n];     real_t temp = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d3[0:n*n*n])     {         #pragma acc serial loop tile(2, 4, 8)         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 for (int z = 0; z < n; ++z){                     d3[(n * n * x) + (n * y) + z] = a[x] + b[x] + c[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             for (int z = 0; z < n; ++z){                 if (fabs(d3[(n * n * x) + (n * y) + z] - a[x] - b[x] - c[x]) > PRECISION * 2){                     err = 1;                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial private", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,private,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     n = 10;     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[n];     real_t * d = new real_t[10];     real_t temp;      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             a[x * n + y] = rand() / (real_t)(RAND_MAX / 10);             b[x * n + y] = rand() / (real_t)(RAND_MAX / 10);             c[y] = 0.0;         }         d[x] = 0.0;     }      #pragma acc enter data copyin(a[0:10*n], b[0:10*n], d[0:10])     #pragma acc serial private(c[0:n])     {         #pragma acc loop gang         for (int x = 0; x < 10; ++x){             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 c[y] = a[x * n + y] + b[x * n + y];             }             #pragma acc loop seq             for (int y = 0; y < n; ++y){                 d[x] += c[y];             }         }     }     #pragma acc exit data copyout(d[0:10]) delete(a[0:10*n], b[0:10*n])      for (int x = 0; x < 10; ++x){         temp = 0.0;         for (int y = 0; y < n; ++y){             temp += a[x * n + y] + b[x * n + y];         }         if (fabs(temp - d[x]) > (2 * PRECISION * n)){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop auto", "completion": "#include \"acc_testsuite.h\"  #ifndef T1 //T1:parallel,loop,combined-constructs,V:2.0-2.7 //data dependent, treated with as a seq clause. Added the num_gangs clause with 1 int test1(){     int err = 0;     srand(SEED);     real_t * device = (real_t *)malloc(n * sizeof(real_t));     real_t * host = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         device[x] = rand() / (real_t)(RAND_MAX / 10);         host[x] = device[x];     }      #pragma acc data copy(device[0:n])     {       #pragma acc parallel loop num_gangs(1) vector_length(1) num_workers(1) auto       for (int x = 1; x < n; ++x){         device[x] = device[x - 1] + device[x];       }     }      real_t rolling_total = 0.0;     for (int x = 0; x < n; ++x){       rolling_total += host[x];       if (fabs(rolling_total - device[x]) > PRECISION){         err = 1;       }     }      free(device);     free(host);      return err; }   #endif  int main(){     int failcode = 0;     int failed;  #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }     if (failed){         failcode += (1 << 2);     } #endif     return failcode; }"}
{"prompt": "Create a test for the feature parallel independent atomic read", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.7-3.2 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(a[0:n], b[0:n])     {         #pragma acc parallel         { \t    #pragma acc loop independent             for (int x = 0; x < n; ++x){                 #pragma acc atomic read                     b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1    failed = 0;    for (int x = 0; x < NUM_TEST_CALLS; ++x){        failed = failed + test1();    }    if (failed != 0){        failcode = failcode + (1 << 0);    } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature kernels loop reduction bitand loop", "completion": "#ifndef T1 !T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y, z !Iterators         INTEGER,DIMENSION(10*LOOPCOUNT):: a, b, b_copy !Data         REAL(8),DIMENSION(10*LOOPCOUNT):: randoms2         INTEGER,DIMENSION(10) :: c         REAL(8) :: false_margin         REAL(8),DIMENSION(160*LOOPCOUNT)::randoms         INTEGER :: errors = 0         INTEGER :: temp          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         CALL RANDOM_NUMBER(randoms2)         b = FLOOR(10000 * randoms2)         b_copy = b         false_margin = exp(log(.5)/LOOPCOUNT)         DO x = 1, 10 * LOOPCOUNT           DO y = 1, 16             IF (randoms((y - 1) * 10 * LOOPCOUNT + x) < false_margin) THEN               temp = 1               DO z = 1, y                 temp = temp * 2               END DO               a(x) = a(x) + temp             END IF           END DO         END DO          DO x = 1, 10          c(x) = a((x - 1) * LOOPCOUNT + x)         END DO          !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10*LOOPCOUNT), c(1:10))           !$acc kernels loop gang private(temp)           DO x = 1, 10             temp = a((x - 1) * LOOPCOUNT + 1)             !$acc loop worker reduction(iand:temp)             DO y = 2, LOOPCOUNT               temp = iand(temp, a((x - 1) * LOOPCOUNT + y))             END DO             c(x) = temp             !$acc loop worker             DO y = 1, LOOPCOUNT               b((x - 1) * LOOPCOUNT + y) = b((x - 1) * LOOPCOUNT + y) + c(x)             END DO           END DO         !$acc end data         DO x = 1, 10          temp = a((x - 1) * LOOPCOUNT + 1)          DO y = 2, LOOPCOUNT            temp = iand(temp, a((x - 1) * LOOPCOUNT + y))          END DO          IF (temp .ne. c(x)) THEN            errors = errors + 1          END IF          DO y = 1, LOOPCOUNT            IF (b((x - 1) * LOOPCOUNT + y) .ne. b_copy((x - 1) * LOOPCOUNT + y) + temp) THEN              errors = errors + 1            END IF          END DO        END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update x bitor expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] |= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel default copy", "completion": "#ifndef T1 !T1:devonly,parallel,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         LOGICAL,DIMENSION(1):: devtest         devtest(1) = .TRUE.          !$acc enter data copyin(devtest(1:1))         !$acc parallel           devtest(1) = .FALSE.         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = c(x) + a(x) + b(x)             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:devonly,parallel,V:2.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         LOGICAL,DIMENSION(1):: devtest         devtest(1) = .TRUE.          !$acc enter data copyin(devtest(1:1))         !$acc parallel           devtest(1) = .FALSE.         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          IF (devtest(1)) THEN           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 1            !$acc enter data copyin(c(1:LOOPCOUNT))           c = 0           !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = c(x) + a(x) + b(x)               END DO             !$acc end parallel           !$acc end data           DO x = 1, LOOPCOUNT             IF (abs(c(x)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO           !$acc exit data copyout(c(1:LOOPCOUNT))           DO x = 1, LOOPCOUNT             IF (abs(c(x) - (a(x) + b(x) + 1)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction add general type check pt3", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     double _Complex * a = (double _Complex *)malloc(n * sizeof(double _Complex));     double _Complex * b = (double _Complex *)malloc(n * sizeof(double _Complex));     double _Complex total = 10 + 10 * I;     double _Complex host_total = 10 + 10 * I;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;         b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (fabs(creal(total) - creal(host_total)) > PRECISION) {         err += 1;     }     if (fabs(cimag(total) - cimag(host_total)) > PRECISION) {         err += 1;     }      return err; } #endif   #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     long double _Complex * a = (long double _Complex*)malloc(n * sizeof(long double _Complex));     long double _Complex * b = (long double _Complex*)malloc(n * sizeof(long double _Complex));     long double _Complex total = 10 + 10 * I;     long double _Complex host_total = 10 + 10 * I;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;         b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (fabsl(creall(total) - creall(host_total)) > PRECISION) {         err += 1;     }     if (fabsl(cimagl(total) - cimagl(host_total)) > PRECISION) {         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature parallel present", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,present,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n])     #pragma acc parallel present(a[0:n], b[0:n]) copy(c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc exit data delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction or general", "completion": "#ifndef T1 !T1:serial,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   LOGICAL,DIMENSION(LOOPCOUNT):: a   LOGICAL:: result, host_result   REAL(8),DIMENSION(LOOPCOUNT):: randoms   REAL(8):: false_margin   INTEGER:: errors, x    errors = 0   false_margin = exp(log(.5) / LOOPCOUNT)    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)    DO x = 1, LOOPCOUNT     IF (randoms(x) .gt. false_margin) THEN       a(x) = .TRUE.     ELSE       a(x) = .FALSE.     END IF   END DO    host_result = .FALSE.   result = .FALSE.    DO x = 1, LOOPCOUNT     host_result = host_result .OR. a(x)   END DO    !$acc data copyin(a(1:LOOPCOUNT))     !$acc serial loop reduction(.OR.: result)     DO x = 1, LOOPCOUNT       result = result .OR. a(x)     END DO   !$acc end data    IF (host_result .neqv. result) THEN     errors = errors + 1   END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial scalar default firstprivate", "completion": "#ifndef T1 !T1:,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   REAL(8),DIMENSION(LOOPCOUNT):: a, b   REAL(8):: scalar, scalar_copy   INTEGER:: x   INTEGER:: errors    errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   b = 0   scalar = 5.5   scalar_copy = scalar    !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))     !$acc serial       !$acc loop       DO x = 1, LOOPCOUNT         b(x) = a(x) + scalar       END DO     !$acc end serial   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(b(x) - (a(x) + scalar_copy)) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO    IF (abs(scalar_copy - scalar) .gt. PRECISION) THEN     errors = errors + 1   END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction max vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * max = new real_t[10];     real_t temp = 0;     real_t temp_max;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(max[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(max:temp)             for (int y = 0; y < n; ++y){                 temp = fmax(a[x * n + y] * b[x * n + y], temp);             }             max[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         temp_max = 0;         for (int y = 0; y < n; ++y){             if (temp_max < a[x * n + y] * b[x * n + y]){                 temp_max = a[x * n + y] * b[x * n + y];             }         }         if (fabs(temp_max - max[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitand vector loop", "completion": "#ifndef T1 !T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7   LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER,DIMENSION(LOOPCOUNT, 10):: a   INTEGER,DIMENSION(10):: b, b_host   REAL(8),DIMENSION(LOOPCOUNT, 10, 16):: randoms   REAL(8):: false_margin   INTEGER:: x, y, temp, c, z   INTEGER:: errors    errors = 0   false_margin = exp(log(.5) / LOOPCOUNT)   SEEDDIM(1) = 1   #ifdef SEED   SEEDDIM(1) = SEED   #endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)    DO y = 1, 10     DO x = 1, LOOPCOUNT       DO z = 1, 16         IF (randoms(x, y, z) .lt. false_margin) THEN           a(x, y) = a(x, y) + 2**(z - 1)         END IF       END DO     END DO   END DO    DO y = 1, 10     b_host(y) = a(1, y)     DO x = 1, LOOPCOUNT       b_host(y) = iand(b_host(y), a(x, y))     END DO   END DO    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(b(1:10))     !$acc serial loop private(c)     DO y = 1, 10       c = a(1, y)       !$acc loop vector reduction(iand:c)       DO x = 1, LOOPCOUNT         c = iand(c, a(x, y))       END DO       b(y) = c     END DO   !$acc end data    DO x = 1, 10     IF (b(x) .ne. b_host(x)) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM serial_loop_reduction_bitand_vector_loop         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction add loop type check pt1", "completion": "#include \"acc_testsuite.h\" #ifndef T1:private,reduction,combined-constructs,loop,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(10 * n * sizeof(char));     char * b = (char *)malloc(10 * n * sizeof(char));     char * c = (char *)malloc(10 * n * sizeof(char));     char * d = (char *)malloc(10 * n * sizeof(char));     char total = 10;     char host_total = 10;     char temp;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:10*n],b[0:10*n], c[0:10*n]) copyout(d[0:10*n])     {         #pragma acc parallel loop gang private(total)         for (int x = 0; x < 10; ++x) {             total = 10;             #pragma acc loop worker reduction(+:total)             for (int y = 0; y < n; ++y) {                 total += a[x * n + y] + b[x * n + y];             }             #pragma acc loop worker             for (int y = 0; y < n; ++y) {                 d[x * n + y] = c[x * n + y] + total;             }         }     }     int error_count = 0;     int total_count = 0;     for (int x = 0; x < 10; ++x) {         host_total = 10;         for (int y = 0; y < n; ++y) {             host_total += a[x * n + y] + b[x * n + y];         }         for (int y = 0; y < n; ++y) {             temp = host_total + c[x * n + y];             if (d[x * n + y] != temp) {                 err += 1;                 error_count += 1;                 printf(\"Error location x: %d \\t y: %d\\n\", x, y);                  printf(\"%d != %d\\n\", d[x * n + y], temp);             }             total_count += 1;         }     }      //printf(\"%d out of %d failed\\n\", error_count, total_count);      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; }"}
{"prompt": "Create a test for the feature acc get default async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,async,construct-independent,internal-control-values,V:2.5-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     int holder = acc_get_default_async();      for(int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])     {         #pragma acc parallel async         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc wait(holder)     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }     if (acc_get_default_async() < 0){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial copyout zero", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,data-region,V:3.0-3.1 int test1(){     int err = 0;     srand(SEED);      real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n])     {         #pragma acc serial copyout(zero: b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] += a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T2 //T2:serial,data,data-region,reference-counting,devonly,V:3.0-3.1 int test2(){     int err = 0;     srand(SEED);      real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int* hasDevice = (int *) malloc(sizeof(int));     hasDevice[0] = 1;     #pragma acc enter data copyin(hasDevice[0:1])     #pragma acc serial present(hasDevice[0:1])     {       hasDevice[0] = 0;     }      if (hasDevice[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0;         }         #pragma acc data copyin(a[0:n], b[0:n])         {             #pragma acc serial copyout(b[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] += a[x];                 }             }         }         for (int x = 0; x < n; ++x){             if (fabs(b[x]) > PRECISION){                 err += 1;                 break;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x bitor expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] |= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop tile", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,tile,reduction,combined-constructs,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     real_t * d2 = new real_t[n * n];     real_t * d3 = new real_t[n * n * n];     real_t temp = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = rand() / (real_t)(RAND_MAX / 10);     }     #pragma acc data copy(a[0:n], b[0:n], c[0:n], d2[0:n*n])     {         #pragma acc parallel loop tile(*, *) reduction(+:temp)         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 temp = 0;                 for (int z = 0; z < n; ++z){                     temp += a[x] + b[y] + c[z];                 }                 d2[x * n + y] = temp;             }         }     }     for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             temp = 0.0;             for (int z = 0; z < n; ++z){                 temp += a[x] + b[y] + c[z];             }             if (fabs(temp - d2[x * n + y]) > PRECISION * n){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,loop,tile,combined-constructs,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     real_t * d2 = new real_t[n * n];     real_t * d3 = new real_t[n * n * n];     real_t temp = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d3[0:n*n*n])     {         #pragma acc parallel loop tile(2, 4, 8)         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 for (int z = 0; z < n; ++z){                     d3[(n * n * x) + (n * y) + z] = a[x] + b[x] + c[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             for (int z = 0; z < n; ++z){                 if (fabs(d3[(n * n * x) + (n * y) + z] - a[x] - b[x] - c[x]) > PRECISION * 2){                     err = 1;                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction and general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(n * sizeof(char));     real_t false_margin = pow(exp(1), log(.5)/n);     char result = 1;     char found = 0;      for (int x = 0; x < n; ++x){         if(rand() / (real_t)(RAND_MAX) < false_margin){             a[x] = 1;         }         else{             a[x] = 0;         }     }      #pragma acc data copyin(a[0:n])     {         #pragma acc serial loop reduction(&&:result)         for (int x = 0; x < n; ++x){             result = result && a[x];         }     }      for (int x = 0; x < n; ++x){         if (a[x] == 0){             found = 1;             break;         }     }     if (found == result){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel copyout", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,data,data-region,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);      real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n])     {         #pragma acc parallel copyout(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,data,data-region,devonly,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);      real_t * a = new real_t[n];     real_t * b = new real_t[n];      int* hasDevice = (int *) malloc(sizeof(int));     hasDevice[0] = 1;     #pragma acc enter data copyin(hasDevice[0:1])     #pragma acc parallel present(hasDevice[0:1])     {       hasDevice[0] = 0;     }      if (hasDevice[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = a[x];         }          #pragma acc data copyin(a[0:n], b[0:n])         {             #pragma acc parallel copyout(b[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = b[x] - a[x];                 }             }         }         for (int x = 0; x < n; ++x){           if (fabs(a[x] - b[x]) > PRECISION){             err += 2;             break;           }         }     }      return err; } #endif  #ifndef T3 //T3:parallel,data,data-region,V:1.0-2.7 int test3(){     int err = 0;     srand(SEED);      real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel copyout(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = b[x] - a[x];             }         }         #pragma acc update host(b[0:n])     }      for (int x = 0; x < n; ++x){         if (fabs(b[x]) > 2 * PRECISION){             err += 4;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic min x expr list end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop worker blocking", "completion": "#ifndef T1 !T1:kernels,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         REAL(8) :: RAND         REAL(8) :: multiplier         INTEGER :: errors = 0          multiplier = 1          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))           !$acc kernels             !$acc loop worker             DO x = 1, LOOPCOUNT               c(x) = (a(x) + b(x)) * multiplier             END DO             multiplier = multiplier + 1             !$acc loop worker             DO x = 1, LOOPCOUNT               c(x) = c(x) + (a(x) + b(x)) * multiplier             END DO           !$acc end kernels         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (3 * (a(x) + b(x)))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop reduction max vector loop", "completion": "#ifndef T1 !T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(10):: maximum         INTEGER :: errors = 0         REAL(8) :: temp          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         maximum = 0          !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(maximum(1:10))           !$acc kernels loop private(temp)           DO x = 0, 9             temp = 0             !$acc loop vector reduction(max:temp)             DO y = 1, LOOPCOUNT               temp = max(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))             END DO             maximum(x + 1) = temp           END DO         !$acc end data          DO x = 0, 9           temp = 0           DO y = 1, LOOPCOUNT             temp = max(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))           END DO           IF (abs(temp - maximum(x + 1)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc get default async", "completion": "#ifndef T1 !T1:runtime,async,construct-independent,internal-control-values,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, holder !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors         INTEGER :: acc_get_default_async         errors = 0         holder = acc_get_default_async()         !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))           !$acc parallel async             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           !$acc wait(holder)         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (acc_get_default_async() .lt. 0) THEN           errors = errors + 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature acc delete", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n])      #pragma acc data copyout(c[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      acc_delete(a, n * sizeof(real_t));     acc_delete(b, n * sizeof(real_t));      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      acc_copyin(a, n * sizeof(real_t));     acc_copyin(b, n * sizeof(real_t));      #pragma acc data copyout(c[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      acc_delete(a, n * sizeof(real_t));     acc_delete(b, n * sizeof(real_t));      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data create no lower bound", "completion": "#ifndef T1 !T1:data,data_region,construct-independent,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(d)         e = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) create(c(:LOOPCOUNT)) copyout(e(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO             !$acc loop             DO x = 1, LOOPCOUNT               e(x) = c(x) + d(x)             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial copyin", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,data-region,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * a_copy = new real_t[n];     real_t * b = new real_t[n];     int* hasDevice = (int *) malloc(sizeof(int));     hasDevice[0] = 1;     #pragma acc enter data copyin(hasDevice[0:1])     #pragma acc parallel present(hasDevice[0:1])     {       hasDevice[0] = 0;     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         a_copy[x] = a[x];         b[x] = 0.0;     }      #pragma acc serial copyin(a[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             a[x] = 0.0;         }     }      for (int x = 0; x < n; ++x){         if (((fabs(a[x] - a_copy[x]) > PRECISION) && (hasDevice[0] == 1)) || ((hasDevice[0] == 0) && (fabs(a[x]) > PRECISION))){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:serial,data,data-region,V:2.6-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * a_copy = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(b[0:n])     {         #pragma acc serial copyin(a[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop worker blocking", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     real_t multiplyer = 1;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])     {       #pragma acc serial       {         #pragma acc loop worker         for (int x = 0; x < n; ++x){           c[x] = (a[x] + b[x]) * multiplyer;         }         multiplyer += 1;         #pragma acc loop worker         for (int x = 0; x < n; ++x){           c[x] += (a[x] + b[x]) * multiplyer;         }       }     }      for (int x = 0; x < n; ++x){       if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){         err += 1;         break;       }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine bind nonprototype lambda nonstring function", "completion": "#include \"acc_testsuite.h\"  //test 1 host lambda #pragma acc routine vector bind(device_array_array) auto  host_array_array = [](real_t * a, long long n){     #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; };  //test 1 device function real_t device_array_array(real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  //test 2 host lambda #pragma acc routine vector bind(device_object_array) auto host_object_array= [](data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned += a->data[x];     }     return returned; };  //test 2 device function real_t device_object_array(data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; }  //test 3 host lambda #pragma acc routine vector bind(device_array_object) auto host_array_object = [](real_t * a, long long n){    #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; };  //test 3 device function real_t device_array_object(real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  //test 4 host lambda #pragma acc routine vector bind(device_object_object) auto host_object_object = [](data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned += a->data[x];     }     return returned; };  //test 4 device function real_t device_object_object(data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; }  #ifndef T1 //T1:routine,V:2.7-3.3 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){        \ta[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_array_array(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_array(a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_array(a, n) - b[x]) > PRECISION)){             err += 1;         }     }     delete[] a;     delete[] b;      return err; } #endif #ifndef T2 //T2:routine,V:2.7-3.3 int test2(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a, a.data[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_object_array(&a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_array(&a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_array(&a, n) - b[x]) > PRECISION)){             err += 1;         }     }      delete[] b;      return err; } #endif #ifndef T3 //T3:routine,V:2.7-3.3 int test3(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b, b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_array_object(a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_object(a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_object(a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      delete[] a;      return err; } #endif #ifndef T4 //T4:routine,V:2.7-3.3 int test4(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a, a.data[0:n], b ,b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_object_object(&a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_object(&a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_object(&a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed = 0; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }      if(failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }      if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }      if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test4();     }      if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial if", "completion": "#ifndef T1 !T1:devonly,serial,if,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT):: a, b, c   LOGICAL,DIMENSION(1):: devtest   LOGICAL:: host, device   INTEGER:: x   host = .FALSE.   device = .TRUE.   errors = 0    devtest(1) = .TRUE.   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = .FALSE.   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 0    !$acc serial if(host)     !$acc loop     DO x = 1, LOOPCOUNT       c(x) = a(x) + b(x)     END DO   !$acc end serial    DO x = 1, N     IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:devonly,serial,if,V:2.6-2.7       LOGICAL FUNCTION test2()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT):: a, b, c   LOGICAL,DIMENSION(1):: devtest   LOGICAL:: host, device   INTEGER:: x   host = .FALSE.   device = .TRUE.   errors = 0    devtest(1) = .TRUE.   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = .FALSE.   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    IF (devtest(1)) THEN     CALL RANDOM_NUMBER(a)     CALL RANDOM_NUMBER(b)     c = a + b      !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))     !$acc serial if(host) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))       !$acc loop       DO x = 1, LOOPCOUNT         c(x) = c(x) + a(x) + b(x)       END DO     !$acc end serial     !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))      DO x = 1, LOOPCOUNT       IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN         errors = errors + 1       END IF     END DO   END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:devonly,serial,if,V:2.6-2.7       LOGICAL FUNCTION test3()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT):: a, b, c   LOGICAL,DIMENSION(1):: devtest   LOGICAL:: host, device   INTEGER:: x   host = .FALSE.   device = .TRUE.   errors = 0    devtest(1) = .TRUE.   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = .FALSE.   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = a + b      !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))   !$acc serial if(device) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))     !$acc loop     DO x = 1, LOOPCOUNT       c(x) = c(x) + a(x) + b(x)     END DO   !$acc end serial   !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))    DO x = 1, LOOPCOUNT     IF (abs(c(x) - (2 * (a(x) + b(x)))) .gt. PRECISION * 2) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic ixor expr x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .lt. .5) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           totals(x) = 0           totals_comparison(x) = 0         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop async", "completion": "#ifndef T1 !T1:async,serial,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c, d   INTEGER,DIMENSION(10):: error_array   INTEGER:: x, y    errors = 0   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 0    DO y = 1, 10     DO x = 1, LOOPCOUNT       d(x, y) = a(x, y) + b(x, y)     END DO   END DO    error_array = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10), c(1:LOOPCOUNT, 1:10), d(1:LOOPCOUNT, 1:10)) copy(error_array(1:10))     DO y = 1, 10       !$acc serial loop async(y)       DO x = 1, LOOPCOUNT         c(x, y) = a(x, y) + b(x, y)       END DO       !$acc serial loop async(y)       DO x = 1, LOOPCOUNT         IF (((c(x, y) - d(x, y)) .gt. PRECISION) .OR. ((d(x, y) - c(x, y)) .gt. PRECISION)) THEN           error_array(y) = error_array(y) + 1         END IF       END DO     END DO   !$acc end data    DO x = 1, 10     errors = errors + error_array(x)   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction or general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = new char[n];     real_t false_margin = pow(exp(1), log(.5)/n);     char result = 0;     char found = 0;      for (int x = 0; x < n; ++x){         if(rand() / (real_t)(RAND_MAX) > false_margin){             a[x] = 1;         }         else{             a[x] = 0;         }     }       #pragma acc data copyin(a[0:n])     {         #pragma acc parallel loop reduction(||:result)         for (int x = 0; x < n; ++x){             result = result || a[x];         }     }      for (int x = 0; x < n; ++x){         if (a[x] == 1){             found = 1;         }     }     if (found != result){         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     char* a = new char[5 * n];     char result[5];     char host_result[5];     real_t false_margin = pow(exp(1), log(.5)/n);      for (int x = 0; x < 5; ++x) {         result[x] = 0;         host_result[x] = 0;     }      for (int x = 0; x < 5 * n; ++x) {         if (rand() / (real_t)(RAND_MAX) > false_margin) {             a[x] = 1;         }         else {             a[x] = 0;         }     }      #pragma acc data copyin(a[0:5*n])     {         #pragma acc parallel loop reduction(||:result)         for (int x = 0; x < 5 * n; ++x) {             result[x%5] = result[x%5] || a[x];         }     }      for (int x = 0; x < 5 * n; ++x) {         host_result[x%5] = host_result[x%5] || a[x];     }          for (int x = 0; x < 5; ++x) {         if (host_result[x] != result[x]) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitxor loop", "completion": "#ifndef T1 !T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(10*LOOPCOUNT):: a, b, b_copy !Data         REAL(8),DIMENSION(10*LOOPCOUNT):: randoms, randoms2         INTEGER,DIMENSION(10):: c         REAL*8 :: RAND         INTEGER :: errors = 0         INTEGER :: temp          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = FLOOR(randoms*1000000)         CALL RANDOM_NUMBER(randoms2)         b = FLOOR(randoms2*1000000)         b_copy = b         c = 0          !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10*LOOPCOUNT), c(1:10))           !$acc parallel loop gang private(temp)           DO x = 0, 9             temp = 0             !$acc loop worker reduction(ieor:temp)             DO y = 1, LOOPCOUNT               temp = ieor(temp, a(x * LOOPCOUNT + y))             END DO             c(x + 1) = temp             !$acc loop worker             DO y = 1, LOOPCOUNT               b(x * LOOPCOUNT + y) = b(x * LOOPCOUNT + y) + c(x + 1)             END DO           END DO         !$acc end data          DO x = 0, 9           temp = 0           DO y = 1, LOOPCOUNT             temp = ieor(temp, a(x * LOOPCOUNT + y))           END DO           IF (temp .ne. c(x + 1)) THEN             errors = errors + 1           END IF           DO y = 1, LOOPCOUNT             IF (b(x * LOOPCOUNT + y) .ne. b_copy(x * LOOPCOUNT + y) + c(x + 1)) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,async,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * d = (real_t *)malloc(10 * n * sizeof(real_t)); \t\tint * errors = (int *)malloc(10 * sizeof(int));  \t\tfor (int x = 0; x < 10; ++x){ \t\t\terrors[x] = 0; \t\t}      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = a[x] + b[x];     }      #pragma acc data copyin(a[0:10*n], b[0:10*n], c[0:10*n], d[0:10*n]) copy(errors[0:10])     {         for (int x = 0; x < 10; ++x){             #pragma acc parallel loop async(x)             for (int y = 0; y < n; ++y){                 c[x * n + y] = a[x * n + y] + b[x * n + y];             }             #pragma acc parallel loop async(x) reduction(+:errors[x])             for (int y = 0; y < n; ++y){                 if(c[x * n + y] - d[x * n + y] > PRECISION || d[x * n + y] - c[x * n + y] > PRECISION){                     errors[x] += 1;                 }             }         } \t\t\t\t#pragma acc wait     }      for (int x = 0; x < 10; ++x){         err += errors[x];     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x plus expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[10];     real_t *totals_comparison = new real_t[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic                         totals[(int) ((a[x] + b[x])/2)] = totals[(int) ((a[x] + b[x])/2)] + a[x] * b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];         }     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop vector", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])     {         #pragma acc serial loop vector         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      for (int x = 0; x < n; ++x){         if(fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc copyin async", "completion": "#ifndef T1 !T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         a_host = a         b_host = b          CALL acc_copyin_async(a(1:LOOPCOUNT), 1)         CALL acc_copyin_async(b(1:LOOPCOUNT), 2)          !$acc data copyout(c(1:LOOPCOUNT))           !$acc parallel async(1) present(a(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               a(x) = a(x) * a(x)             END DO           !$acc end parallel           !$acc parallel async(2) present(b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = b(x) * b(x)             END DO           !$acc end parallel           !$acc parallel async(2) wait(1) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a_host(x)*a_host(x) + b_host(x)*b_host(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO         IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif  #ifndef T2 !T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initialization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_copyin_async(a(1:LOOPCOUNT), 1)         CALL acc_copyin_async(b(1:LOOPCOUNT), 2)          !$acc data copyout(c(1:LOOPCOUNT))           DO WHILE (acc_async_test_all() .eqv. .FALSE.)             CONTINUE           END DO           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif  #ifndef T3 !T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test3()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initialization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_copyin_async(a(1:LOOPCOUNT), 1)         CALL acc_copyin_async(b(1:LOOPCOUNT), 2)          !$acc data copyout(c(1:LOOPCOUNT))           !$acc wait           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif  #ifndef T4 !T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7       LOGICAL FUNCTION test4()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initialization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(d)         e = 0          !$acc enter data create(c(1:LOOPCOUNT))         !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) copyout(e(1:LOOPCOUNT))           !$acc parallel present(c(1:LOOPCOUNT)) async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           CALL acc_copyin_async(c(1:LOOPCOUNT), 1)           !$acc exit data delete(c(1:LOOPCOUNT))           !$acc parallel present(c(1:LOOPCOUNT)) async(1)             !$acc loop             DO x = 1, LOOPCOUNT               e(x) = c(x) + d(x)             END DO           !$acc end parallel         !$acc end data         !$acc exit data copyout(c(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF           IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test4 = .FALSE.         ELSE           test4 = .TRUE.         END IF       END #endif  #ifndef T5 !T5:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7       LOGICAL FUNCTION test5()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initialization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         a_copy = a         CALL RANDOM_NUMBER(b)         b_copy = b         c = 0          CALL acc_copyin_async(a(1:LOOPCOUNT), 1)         CALL acc_copyin_async(b(1:LOOPCOUNT), 2)          a = 0         b = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))           !$acc wait           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a_copy(x) + b_copy(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test5 = .FALSE.         ELSE           test5 = .TRUE.         END IF       END #endif         PROGRAM main       IMPLICIT NONE       INTEGER :: failcode, testrun       LOGICAL :: failed       INCLUDE \"acc_testsuite.Fh\"       !Conditionally define test functions #ifndef T1       LOGICAL :: test1 #endif #ifndef T2       LOGICAL :: test2 #endif #ifndef T3       LOGICAL :: test3 #endif #ifndef T4       LOGICAL :: test4 #endif #ifndef T5       LOGICAL :: test5 #endif       failcode = 0       failed = .FALSE.  #ifndef T1       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test1()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 0         failed = .FALSE.       END IF #endif #ifndef T2       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test2()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 1         failed = .FALSE.       END IF #endif #ifndef T3       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test3()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 2         failed = .FALSE.       END IF #endif #ifndef T4       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test4()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 3         failed = .FALSE.       END IF #endif #ifndef T5       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test5()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 4         failed = .FALSE.       END IF #endif       CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture lshift equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if ((b[x] == prev<<1 && ((a>>x)%2)==1) || ((a>>x)%2==0 && b[x] == prev)){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1;      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                             c[x * 7 + y] = a[x] <<= 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr plus x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = a(x, y) + totals(x)               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) + a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update x or expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = totals(x) .OR. a(x, y)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .OR. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc malloc", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:3.3       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         REAL(8),DIMENSION(LOOPCOUNT):: initial_memory, final_memory !Data         INTEGER, POINTER :: a(:)         INTEGER :: errors = 0          initial_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory)                  acc_malloc(a(N))          IF (initial_memory .ne. 0) THEN           test1 = .FALSE.         END IF          final_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory)          DO x = 1, LOOPCOUNT           IF (final_memory + N * sizeof(a(1)) .gt. initial_memory) THEN             errors = errors + 1           END IF         END DO          acc_free(a(N))          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM   "}
{"prompt": "Create a test for the feature atomic expr and x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) < .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = a(x, y) .AND. totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .AND. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction or general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(n * sizeof(char));     real_t false_margin = pow(exp(1), log(.5)/n);     char result = 0;     char found = 0;      for (int x = 0; x < n; ++x){         if(rand() / (real_t)(RAND_MAX) > false_margin){             a[x] = 1;         }         else{             a[x] = 0;         }     }       #pragma acc data copyin(a[0:n])     {         #pragma acc parallel loop reduction(||:result)         for (int x = 0; x < n; ++x){             result = result || a[x];         }     }      for (int x = 0; x < n; ++x){         if (a[x] == 1){             found = 1;         }     }     if (found != result){         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     char* a = (char *)malloc(5 * n * sizeof(char));     char result[5];     char host_result[5];     real_t false_margin = pow(exp(1), log(.5)/n);      for (int x = 0; x < 5; ++x) {         result[x] = 0;         host_result[x] = 0;     }      for (int x = 0; x < 5 * n; ++x) {         if (rand() / (real_t)(RAND_MAX) > false_margin) {             a[x] = 1;         }         else {             a[x] = 0;         }     }      #pragma acc data copyin(a[0:5*n])     {         #pragma acc parallel loop reduction(||:result)         for (int x = 0; x < 5 * n; ++x) {             result[x%5] = result[x%5] || a[x];         }     }      for (int x = 0; x < 5 * n; ++x) {         host_result[x%5] = host_result[x%5] || a[x];     }          for (int x = 0; x < 5; ++x) {         if (host_result[x] != result[x]) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction min general", "completion": "#include \"acc_testsuite.h\"  #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t min = 1000.0;     int found = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:n], b[0:n]) copy(min)     {         #pragma acc parallel loop reduction(min:min)         for (int x = 0; x < n; ++x){             min = fmin(a[x] * b[x], min);         }     }      for (int x = 0; x < n; ++x){         if (fabs((a[x] * b[x]) - (min + PRECISION)) < 0){             err = 1;         }         if (fabs(min - (a[x] * b[x])) < PRECISION){             found = 1;         }     }     if (found == 0){         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t minimums[10];     real_t host_minimums[10];      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      for (int x = 0; x < 10; ++x) {         minimums[x] = 1000;         host_minimums[x] = 1000;     }      printf(\"Here\");      #pragma acc data copyin(a[0:10*n], b[0:10*n])     {         #pragma acc parallel loop reduction(min:minimums)         for (int x = 0; x < 10 * n; ++x) {             minimums[x%10] = fmin(a[x] * b[x], minimums[x%10]);         }     }      for (int x = 0; x < 10 * n; ++x) {         host_minimums[x%10] = fmin(a[x] * b[x], host_minimums[x%10]);     }     for (int x = 0; x < 10; ++x) {         if (fabs(minimums[x] - host_minimums[x]) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction or loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = new char[10 * n];     char * a_copy = new char[10 * n];     char * results = new char[10];     char temp = 0;     real_t false_margin = pow(exp(1), log(.5)/n);      for (int x = 0; x < 10 * n; ++x){         if (rand() / (real_t)(RAND_MAX) > false_margin){             a[x] = 1;             a_copy[x] = 1;         }         else{             a[x] = 0;             a_copy[x] = 0;         }     }     #pragma acc data copy(a[0:10*n])     {         #pragma acc kernels loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(||:temp)             for (int y = 0; y < n; ++y){                 temp = temp || a[x * n + y];             }             results[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 if(results[x] == 1){                     if (a[x * n + y] == 1){                         a[x * n + y] = 0;                     }                     else{                         a[x * n + y] = 1;                     }                 }             }         }     }     for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = temp || a_copy[x * n + y];         }         if (temp != results[x]) {             err += 1;         }         for (int y = 0; y < n; ++y){             if (temp == 1){                 if (a[x * n + y] == a_copy[x * n + y]){                     err += 1;                 }             }             else {                 if (a[x * n + y] != a_copy[x * n + y]){                     err += 1;                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction bitor vector loop", "completion": "#ifndef T1 !T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y, z !Iterators         INTEGER,DIMENSION(10 * LOOPCOUNT):: a !Data         INTEGER,DIMENSION(10) :: b         REAL(8) :: false_margin         REAL(8),DIMENSION(160 * LOOPCOUNT) :: randoms         INTEGER :: errors = 0         INTEGER :: temp          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         false_margin = exp(log(.5) / n)         DO x = 1, 10 * LOOPCOUNT           DO y = 1, 16             IF (randoms(y * 10 * LOOPCOUNT + y - 1) .gt. false_margin) THEN               temp = 1               DO z = 1, y                 temp = temp * 2               END DO               a(x) = a(x) + temp             END IF           END DO         END DO          !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10))           !$acc kernels loop private(temp)           DO x = 0, 9             temp = 0             !$acc loop vector reduction(ior:temp)             DO y = 1, LOOPCOUNT               temp = ior(temp, a(x * LOOPCOUNT + y))             END DO             b(x + 1) = temp           END DO         !$acc end data          DO x = 0, 9           temp = 0           DO y = 1, LOOPCOUNT             temp = ior(temp, a(x * LOOPCOUNT + y))           END DO           IF (temp .ne. b(x + 1)) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction or vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = new char[10 * n];     char * b = new char[10];     real_t false_margin = pow(exp(1), log(.5)/n);     char temp = 0;     char found;      for (int x = 0; x < 10 * n; ++x){         if(rand() / (real_t)(RAND_MAX) > false_margin){             a[x] = 1;         }         else{             a[x] = 0;         }     }     #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc parallel loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(||:temp)             for (int y = 0; y < n; ++y){                 temp = temp || a[x * n + y];             }             b[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         found = 0;         for (int y = 0; y < n; ++y){             if (a[x * n + y] &! 0){                 found = 1;             }         }         if (found != b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction and loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(10 * n * sizeof(char));     char * a_copy = (char *)malloc(10 * n * sizeof(char));     char * has_false = (char *)malloc(10 * sizeof(char));     real_t false_margin = pow(exp(1), log(.5)/n);      for (int x = 0; x < 10; ++x){         has_false[x] = 0;     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (rand() / (real_t)(RAND_MAX) < false_margin){                 a[x * n + y] = 1;                 a_copy[x * n + y] = 1;             }             else {                 a[x * n + y] = 0;                 a_copy[x * n + y] = 0;                 has_false[x] = 1;             }         }     }      char temp = 1;     #pragma acc data copy(a[0:10*n])     {         #pragma acc kernels loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop worker reduction(&&:temp)             for (int y = 0; y < n; ++y){                 temp = temp && a[x * n + y];             }             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 if(temp == 1){                     if  (a[x * n + y] == 1){                         a[x * n + y] = 0;                     }                     else {                         a[x * n + y] = 1;                     }                 }             }         }     }       for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){                 err = 1;             }             else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){                 err = 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop seq", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,combined-constructs,V:1.0-2.7 int test1(){   int err = 0;   srand(SEED);   real_t * a = (real_t *)malloc(n * sizeof(real_t));   real_t * b = (real_t *)malloc(n * sizeof(real_t));   real_t temp = 0.0;    for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = 0.0;   }    #pragma acc data copyin(a[0:n]) copy(b[0:n])   {       #pragma acc kernels loop seq       for (int x = 1; x < n; ++x){           b[x] = b[x-1] + a[x];       }   }    for (int x = 1; x < n; ++x){       temp += a[x];       if (fabs(b[x] - temp) > PRECISION){           err = 1;       }   }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction multiply general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     int multiplicitive_n = 128;     srand(SEED);     real_t * a = (real_t *)malloc(multiplicitive_n * sizeof(real_t));     real_t * b = (real_t *)malloc(multiplicitive_n * sizeof(real_t));      real_t multiplied_total = 1.0;      for (int x = 0; x < multiplicitive_n; ++x){         a[x] = rand() / (real_t) RAND_MAX;         b[x] = rand() / (real_t) RAND_MAX;     }      #pragma acc data copyin(a[0:multiplicitive_n], b[0:multiplicitive_n]) copy(multiplied_total)     {         #pragma acc serial loop reduction (*:multiplied_total)         for (int x = 0; x < multiplicitive_n; ++x){             multiplied_total *= a[x] + b[x];         }     }      for (int x = 0; x < multiplicitive_n; ++x){         multiplied_total /= (a[x] + b[x]);     }     if (fabs(multiplied_total - 1) > PRECISION * (2 * multiplicitive_n - 1)){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction add vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10];     real_t temp = 0.0;      for(int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10])     {         #pragma acc parallel loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0.0;             #pragma acc loop vector reduction(+:temp)             for (int y = 0; y < n; ++y){                 temp += a[(x * n) + y] + b[(x * n) + y];             }             c[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             c[x] -= a[(x * n) + y] + b[(x * n) + y];         }         if (fabs(c[x]) > PRECISION * (2 * n - 1)){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[25 * n];     real_t * b = new real_t[25 * n];     real_t * c = new real_t[25];     real_t * c_host = new real_t[25];     real_t temp[5];      for (int x = 0; x < 25 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      for (int x = 0; x < 25; ++x) {         c[x] = 0;         c_host[x] = 0;     }      #pragma acc data copyin(a[0:25*n], b[0:25*n]) copyout(c[0:25])     {         #pragma acc parallel loop private(temp)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 temp[y] = 0;             }             #pragma acc loop vector reduction(+:temp)             for (int y = 0; y < 5 * n; ++y) {                 temp[y % 5] += a[x * 5 * n + y] + b[x * 5 * n + y];             }             for (int y = 0; y < 5; ++y) {                 c[x * 5 + y] = temp[y];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5 * n; ++y) {             c_host[x * 5 + (y % 5)] += a[x * 5 * n + y] + b[x * 5 * n + y];         }     }      for (int x = 0; x < 25; ++x) {         if (fabs(c[x] - c_host[x]) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic predecrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic                         --distribution[(int) (a[x]*b[y]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             distribution_comparison[(int) (a[x]*b[y]/10)]--;         }     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels default present", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data,data-region,default,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc enter data copyin(a[0:n]), create(b[0:n])     #pragma acc kernels default(present)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             b[x] = a[x];         }     }     #pragma acc exit data delete(a[0:n]), copyout(b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic lshift equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic                             a[x] <<= 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc async test all", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:async,runtime,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     real_t **a = (real_t **)malloc(10 * sizeof(real_t*));     real_t **b = (real_t **)malloc(10 * sizeof(real_t*));     real_t **c = (real_t **)malloc(10 * sizeof(real_t*));     real_t **d = (real_t **)malloc(10 * sizeof(real_t*));     real_t **e = (real_t **)malloc(10 * sizeof(real_t*));      for (int x = 0; x < 10; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));         b[x] = (real_t *)malloc(n * sizeof(real_t));         c[x] = (real_t *)malloc(n * sizeof(real_t));         d[x] = (real_t *)malloc(n * sizeof(real_t));         e[x] = (real_t *)malloc(n * sizeof(real_t));         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 0;             d[x][y] = rand() / (real_t)(RAND_MAX / 10);             e[x][y] = 0;         }     }      #pragma acc enter data create(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n], d[0:10][0:n], e[0:10][0:n])     for (int x = 0; x < 10; ++x){         #pragma acc update device(a[x:1][0:n], b[x:1][0:n], d[x:1][0:n]) async(x)         #pragma acc parallel present(a[x:1][0:n], b[x:1][0:n], c[x:1][0:n]) async(x)         {             #pragma acc loop             for (int y = 0; y < n; ++y){                 c[x][y] = a[x][y] + b[x][y];             }         }         #pragma acc parallel present(c[x:1][0:n], d[x:1][0:n], e[x:1][0:n]) async(x)         {             #pragma acc loop             for (int y = 0; y < n; ++y){                 e[x][y] = c[x][y] + d[x][y];             }         }         #pragma acc update host(e[x:1][0:n]) async(x)     }         while(!acc_async_test_all());     for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (fabs(e[x][y] - (a[x][y] + b[x][y] + d[x][y])) > PRECISION){                 err += 1;             }         }     }     #pragma acc exit data delete(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n], d[0:10][0:n], e[0:10][0:n])     for (int x = 0; x < 10; ++x){         free(a[x]);         free(b[x]);         free(c[x]);         free(d[x]);         free(e[x]);     }     free(a);     free(b);     free(c);     free(d);     free(e);          return err; } #endif  #ifndef T2 //T2:async,runtime,construct-independent,V:1.0-2.7 int test2(){     int err = 0;     real_t *a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t *b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t *c = (real_t *)malloc(10 * n * sizeof(real_t));     real_t *d = (real_t *)malloc(10 * n * sizeof(real_t));     real_t *e = (real_t *)malloc(10 * n * sizeof(real_t));      for (int x = 0; x < 10*n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = 0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n], d[0:10*n]) copyout(c[0:10*n], e[0:10*n])     {         for (int x = 0; x < 10; ++x){             #pragma acc parallel present(a[0:10*n], b[0:10*n], c[0:10*n]) async(x)             {                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     c[x * n + y] = a[x * n + y] + b[x * n + y];                 }             }             #pragma acc parallel present(c[0:10*n], d[0:10*n], e[0:10*n]) async(x)             {                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     e[x * n + y] = c[x * n + y] + d[x * n + y];                 }             }         }         while(!acc_async_test_all());     }      for (int x = 0; x < 10*n; ++x){         if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){             err += 1;         }     }          free(a);     free(b);     free(c);     free(d);     free(e);          return err; } #endif  #ifndef T3 //T3:async,runtime,construct-independent,V:2.5-2.7 int test3(){     int err = 0;     real_t **a = (real_t **)malloc(10 * sizeof(real_t *));     real_t **b = (real_t **)malloc(10 * sizeof(real_t *));     real_t **c = (real_t **)malloc(10 * sizeof(real_t *));     real_t **d = (real_t **)malloc(10 * sizeof(real_t *));     real_t **e = (real_t **)malloc(10 * sizeof(real_t *));      for (int x = 0; x < 10; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));         b[x] = (real_t *)malloc(n * sizeof(real_t));         c[x] = (real_t *)malloc(n * sizeof(real_t));         d[x] = (real_t *)malloc(n * sizeof(real_t));         e[x] = (real_t *)malloc(n * sizeof(real_t));         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 0;             d[x][y] = rand() / (real_t)(RAND_MAX / 10);             e[x][y] = 0;         }     }      #pragma acc data copyin(a[0:10][0:n], b[0:10][0:n], d[0:10][0:n]) copyout(c[0:10][0:n], e[0:10][0:n])     {         for (int x = 0; x < 10; ++x){             acc_set_default_async(x);             #pragma acc parallel present(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n]) async             {                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     c[x][y] = a[x][y] + b[x][y];                 }             }             #pragma acc parallel present(c[0:10][0:n], d[0:10][0:n], e[0:10][0:n]) async             {                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     e[x][y] = c[x][y] + d[x][y];                 }             }         }         while (!acc_async_test_all());     }      int count = 0;     int total = 0;     for (int x = 0; x < 10; ++x) {         for (int y = 0; y < n; ++y) {             if (fabs(e[x][y]) < PRECISION) {                 count += 1;             }             total += 1;         }     }     printf(\"%d out of %d\\n\", count, total);      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (fabs(e[x][y] - (a[x][y] + b[x][y] + d[x][y])) > PRECISION){                 err += 1;             }         }     }          for (int x = 0; x < 10; ++x){         free(a[x]);         free(b[x]);         free(c[x]);         free(d[x]);         free(e[x]);     }     free(a);     free(b);     free(c);     free(d);     free(e);          return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture expr lshift x", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int* a, unsigned int* b, int length, int prev){     if (length == 0){         return true;     }     unsigned int *passed_a = (unsigned int *)malloc((length - 1) * sizeof(int));     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == (a[x]<<prev)){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(3 * n * sizeof(int));     int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};     int result;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 3; ++y){             a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));         }         b[x] = 0;     }      #pragma acc data copyin(a[0:3 * n]) copy(b[0:n]) copyout(c[0:3*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 3; ++y){                     #pragma acc atomic capture                         c[x * 3 + y] = b[x] = a[x * 3 + y] << b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 6; ++y){             result = 0;             for (int z = 0; z < 3; ++z){                 result = a[x * 3 + orders[y * 3 + z]] << result;             }             if (result == b[x]){                 break;             }         }         if (result != b[x]){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!(is_possible(&(a[x*3]), &(c[x*3]), 3, 0))){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine bind prototype lambda nonstring lambda", "completion": "#include \"acc_testsuite.h\"  //test 1 host lambda auto host_array_array = [](real_t * a, long long n){     #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; };  //test 2 host lambda auto host_object_array = [](data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned += a->data[x];     }     return returned; };  //test 3 host lambda auto host_array_object = [](real_t * a, long long n){    #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; };  //test 4 host lambda auto host_object_object = [](data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned += a->data[x];     }     return returned; };  #pragma acc routine(host_array_array) vector bind(device_array_array) #pragma acc routine(host_object_array) vector bind(device_object_array) #pragma acc routine(host_array_object) vector bind(device_array_object) #pragma acc routine(host_object_object) vector bind(device_object_object)  //test 1 device lambda auto device_array_array = [](real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; };  //test 2 device lambda auto device_object_array = [](data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned -= a->data[x];     }     return returned; };  //test 3 device lambda auto device_array_object = [](real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; };  //test 4 device lambda auto  device_object_object= [](data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; };  #ifndef T1 //T1:routine,V:2.7-3.3 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){        \ta[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_array_array(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_array(a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_array(a, n) - b[x]) > PRECISION)){             err += 1;         }     }     delete[] a;     delete[] b;      return err; } #endif #ifndef T2 //T2:routine,V:2.7-3.3 int test2(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a, a.data[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_object_array(&a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_array(&a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_array(&a, n) - b[x]) > PRECISION)){             err += 1;         }     }      delete[] b;      return err; } #endif #ifndef T3 //T3:routine,V:2.7-3.3 int test3(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b, b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_array_object(a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_object(a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_object(a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      delete[] a;      return err; } #endif #ifndef T4 //T4:routine,V:2.7-3.3 int test4(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a, a.data[0:n], b ,b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_object_object(&a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_object(&a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_object(&a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed = 0; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }      if(failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }      if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }      if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test4();     }      if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr minus x", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(subset, destination, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8),DIMENSION(length), INTENT(IN) :: subset         REAL(8), INTENT(IN) :: destination         REAL(8), INTENT(IN) :: init         REAL(8),ALLOCATABLE :: passed(:)         LOGICAL :: POSSIBLE         INTEGER :: x, y         IF (length .gt. 0) THEN           ALLOCATE(passed(length - 1))         ELSE           IF (abs(init - destination) .gt. PRECISION) THEN             POSSIBLE = .TRUE.           ELSE             POSSIBLE = .FALSE.           END IF           RETURN         END IF         POSSIBLE = .FALSE.         DO x = 1, length           DO y = 1, x - 1             passed(y) = subset(y)           END DO           DO y = x + 1, length             passed(y - 1) = subset(y)           END DO           IF (IS_POSSIBLE(passed, destination, length - 1, subset(x) - init)) THEN             POSSIBLE = .TRUE.             RETURN           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         LOGICAL IS_POSSIBLE         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals         INTEGER :: errors = 0         REAL(8),DIMENSION(10):: passed          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = a(x, y) - totals(x)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed(y) = a(x, y)           END DO           IF (IS_POSSIBLE(passed, totals(x), 10, 0) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc unmap data", "completion": "#ifndef T1 !T1:runtime,data,executable-data,construct-independent,V:3.3     LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         REAL(8),DIMENSION(LOOPCOUNT) :: a, b, c, d, e !Data         INTEGER :: errors = 0         INTEGER :: x,i          !Initilization          SEEDDIM(1) = 1         #ifdef SEED             SEEDDIM(1) = SEED         #endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          CALL acc_map_data(C_LOC(c), C_LOC(d), LOOPCOUNT)          !$acc data copyin(a(0:LOOPCOUNT), b(0:LOOPCOUNT)) present(c(0:LOOPCOUNT)) copyout(c(0:LOOPCOUNT))             !$acc parallel                 !$acc loop                     DO i = 0, LOOPCOUNT                         c(x) = a(x) + b(x)                     END DO                 !$acc end loop             !$acc end parallel         !$acc end data           !$acc update host(c(0:n))                              DO x = 0, LOOPCOUNT             IF (ABS(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN                 errors = errors + 1             END IF         END DO          CALL acc_unmap_data(C_LOC(c))         CALL acc_free(C_LOC(d))          IF (errors .eq. 0) THEN             test1 = .FALSE.         ELSE             test1 = .TRUE.         END IF     END #endif  PROGRAM main     IMPLICIT NONE     INTEGER :: failcode, testrun     LOGICAL :: failed     INCLUDE \"acc_testsuite.Fh\" #ifndef T1     LOGICAL :: test1 #endif     failed = .FALSE.     failcode = 0 #ifndef T1     DO testrun = 1, NUM_TEST_CALLS       failed = failed .or. test1()     END DO     IF (failed) THEN       failcode = failcode + 2 ** 0       failed = .FALSE.     END IF #endif     CALL EXIT (failcode)   END PROGRAM"}
{"prompt": "Create a test for the feature serial loop gang", "completion": "#ifndef T1 !T1:serial,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT):: a, b, c   INTEGER:: x    errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 0    !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))     !$acc serial loop gang     DO x = 1, LOOPCOUNT       c(x) = a(x) + b(x)     END DO   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture expr rshift x", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int* a, unsigned int* b, int length, int prev){     if (length == 0){         return true;     }     unsigned int *passed_a = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if (b[x] == (a[x]>>prev)){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(3 * n * sizeof(int));     int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};     int result;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 3; ++y){             a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));         }         b[x] = 0;     }      #pragma acc data copyin(a[0:3 * n]) copy(b[0:n]) copyout(c[0:3*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop independent                 for (int y = 0; y < 3; ++y){                     #pragma acc atomic capture                         c[x * 3 + y] = b[x] = a[x * 3 + y] >> b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 6; ++y){             result = 0;             for (int z = 0; z < 3; ++z){                 result = a[x * 3 + orders[y * 3 + z]] >> result;             }             if (result == b[x]){                 break;             }         }         if (result != b[x]){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(&(a[3*x]), &(c[3*x]), 3, 0)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction max loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10 * n];     real_t * maximum = new real_t[10];     real_t temp = 0;     real_t max = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);         c[x] = 0.0;     }     for (int x = 0; x < 10; ++x){         maximum[x] = 0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], maximum[0:10])     {         #pragma acc kernels loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(max:temp)             for (int y = 0; y < n; ++y){                 temp = fmax(a[x * n + y] * b[x * n + y], temp);             }             maximum[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 c[x * n + y] = (a[x * n + y] * b[x * n + y]) / maximum[x];             }         }     }     for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = fmax(temp, a[x * n + y] * b[x * n + y]);         }         if (fabs(temp - maximum[x]) > PRECISION){             err += 1;         }         for (int y = 0; y < n; ++y){             if (c[x * n + y] > 1){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop async", "completion": "#ifndef T1 !T1:async,parallel,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c, d !Data \t\t\t\tINTEGER,DIMENSION(10):: errors_array         INTEGER :: errors          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         d = a + b \t\t\t\terrors = 0          !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT), c(1:10*LOOPCOUNT), d(1:10*LOOPCOUNT)) copy(errors_array(1:10))           DO x = 0, 9             !$acc parallel loop async(x)             DO y = 1, LOOPCOUNT               c(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)             END DO             !$acc parallel loop async(x) reduction(+:errors_array(x))             DO y = 1, LOOPCOUNT               IF (c(x * LOOPCOUNT + y) - d(x * LOOPCOUNT + y) .gt.  PRECISION .OR. &                 d(x * LOOPCOUNT + y) - c(x * LOOPCOUNT + y) .gt. PRECISION) THEN                 errors_array(x) = errors_array(x) + 1               END IF             END DO           END DO \t\t\t\t\t!$acc wait         !$acc end data  \t\t\t\tDO x = 1, 10 \t\t\t\t\terrors = errors + errors_array(x) \t\t\t\tEND DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop reduction or general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = new char[n];     real_t false_margin = pow(exp(1), log(.5)/n);     char result = 0;     char found = 0;      for (int x = 0; x < n; ++x){         if(a[x] = rand() / (real_t)(RAND_MAX) > false_margin){             a[x] = 1;         }         else{             a[x] = 0;         }     }       #pragma acc data copyin(a[0:n])     {         #pragma acc kernels loop reduction(||:result)         for (int x = 0; x < n; ++x){             result = result || a[x];         }     }      for (int x = 0; x < n; ++x){         if (a[x] == 1){             found = 1;         }     }     if (found != result){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop worker", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])     {         #pragma acc serial loop worker         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel copy", "completion": "#ifndef T1 !T1:parallel,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, a_host !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         a_host = a          !$acc parallel copy(a(1:LOOPCOUNT))           !$acc loop           DO x = 1, LOOPCOUNT             a(x) = 2 * a(x)           END DO          !$acc end parallel               DO x = 1, LOOPCOUNT           IF (abs(a_host(x) - (a(x) / 2)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured x bitxor expr assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == (prev ^ a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] = totals[x/10] ^ a[x];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] ^= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture expr divided x", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x]/prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){     if (length == 0){         if (fabs(current_value - test_value) > PRECISION){             return true;         }         else {             return false;         }     }     real_t * passed = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         for (int y = 0; y < x; ++y){             passed[y] = remaining_combinations[y];         }         for (int y = x + 1; y < length; ++y){             passed[y - 1] = remaining_combinations[y];         }         if (possible_result(passed, length - 1, remaining_combinations[x] / current_value, test_value)){             free(passed);             return true;         }     }     free(passed);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;     real_t * passed = (real_t *)malloc(10 * sizeof(real_t));     int indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];             }         }     }       for (int x = 0; x < (n/10 + 1); ++x){         indexer = x;         while (indexer < n){             passed[indexer/(n/10 + 1)] = (a[x] + b[x]);             indexer += (n/10 + 1);         }         if (!(possible_result(passed, 10, 1, totals[x]))){             err += 1;         }     }      for (int x = 0; x < (n/10 + 1); ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction bitand general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     n = 10;     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX < false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }     unsigned int b = 0;     for (int x = 0; x < 16; ++x){         temp = 1;         for (int y = 0; y < x; ++y){             temp *= 2;         }         b += temp;     }     #pragma acc data copyin(a[0:n])     {         #pragma acc kernels loop reduction(&:b)         for (int x = 0; x < n; ++x){             b = b & a[x];         }     }     unsigned int host_b = a[0];      for (int x = 1; x < n; ++x){         host_b = host_b & a[x];     }     if (b != host_b){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop vector", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])     {         #pragma acc serial loop vector         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      for (int x = 0; x < n; ++x){         if(fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction min loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10 * n];     real_t * minimum = new real_t[10];     real_t temp = 0;      for (int x = 0; x < 10 * n; ++x){         a[x] = 1 + rand() / (real_t)(RAND_MAX/10);         b[x] = 1 + rand() / (real_t)(RAND_MAX/10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], minimum[0:10])     {         #pragma acc serial  \t{     \t     \t#pragma acc loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1000;             #pragma acc loop reduction(min:temp)             for (int y = 0; y < n; ++y){                 temp = fmin(a[x * n + y] * b[x * n + y], temp);             }             minimum[x] = temp;             #pragma acc loop             for (int y = 0; y < n; ++y){                 c[x * n + y] = (a[x * n + y] * b[x * n + y]) / minimum[x];             }         } \t}     }      for (int x = 0; x < 10; ++x){         temp = 1000;         for (int y = 0; y < n; ++y){             temp = fmin(temp, a[x * n + y] * b[x * n + y]);         }         if (fabs(temp - minimum[x]) > PRECISION){             err += 1;         }         for (int y = 0; y < n; ++y){             if (fabs(c[x * n + y] - (a[x * n + y] * b[x * n + y] / minimum[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature set device type nvidia", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,set,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: errors = 0          !$acc set device_type(nvidia)          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM set_device_type         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel independent atomic", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.7-3.2 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(a[0:n], b[0:n])     {         #pragma acc parallel         { \t    #pragma acc loop independent             for (int x = 0; x < n; ++x){                 #pragma acc atomic                      a[x] = a[x] * 2; //dependent                     b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,loop,V:2.7-3.2 int test2(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      #pragma acc data copy(a[0:n])     {         #pragma acc parallel         { \t    #pragma acc loop independent             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     (a[x])++; //independent - without a clause, you're doing atomic update                }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] + 1)) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1    failed = 0;    for (int x = 0; x < NUM_TEST_CALLS; ++x){        failed = failed + test1();    }    if (failed != 0){        failcode = failcode + (1 << 0);    } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature serial reduction", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,reduction,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t reduction;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc serial copyin(a[0:n]) reduction(+:reduction)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             reduction = reduction + a[x];         }     }      for (int x = 0; x < n; ++x){         reduction = reduction - a[x];     }     if (fabs(reduction) > PRECISION){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel wait", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,wait,async,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      #pragma acc enter data create(a[0:n])     #pragma acc update device(a[0:n]) async(1)     #pragma acc parallel present(a[0:n]) wait(1)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             a[x] += 1;         }     }     #pragma acc exit data copyout(a[0:n])     for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] + 1)) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction multiply loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     int m_n = 128;     srand(SEED);     real_t * a = (real_t *)malloc(10 * m_n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * m_n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * m_n * sizeof(real_t));     real_t * totals = (real_t *)malloc(10 * sizeof(real_t));     real_t temp;      for (int x = 0; x < 10 * m_n; ++x){         a[x] = .05 + rand() / (real_t)(RAND_MAX);         b[x] = .05 + rand() / (real_t)(RAND_MAX);         c[x] = 0.0;     }       #pragma acc data copyin(a[0:10*m_n], b[0:10*m_n]) copyout(c[0:10*m_n], totals[0:10])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop worker reduction(*:temp)             for (int y = 0; y < m_n; ++y){                 temp *= a[x * m_n + y] + b[x * m_n + y];             }             totals[x] = temp;             #pragma acc loop worker             for (int y = 0; y < m_n; ++y){                 c[x * m_n + y] = (a[x * m_n + y] + b[x * m_n + y]) / totals[x];             }         }     }      for (int x = 0; x < 10; ++x){         temp = 1;         for (int y = 0; y < m_n; ++y){             temp *= a[x * m_n + y] + b[x * m_n + y];         }         if (fabs(temp - totals[x]) > (temp / 2 + totals[x] / 2) * PRECISION){             err += 1;         }         for (int y = 0; y < m_n; ++y){             if (fabs(c[x * m_n + y] - ((a[x * m_n + y] + b[x * m_n + y]) / totals[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     int m_n = 128;     srand(SEED);     real_t * a = (real_t *)malloc(25 * m_n * sizeof(real_t));     real_t * b = (real_t *)malloc(25 * m_n * sizeof(real_t));     real_t * c = (real_t *)malloc(25 * m_n * sizeof(real_t));      real_t * totals = (real_t *)malloc(25 * sizeof(real_t));     real_t reduced[5];      for (int x = 0; x < n; ++x){         a[x] = .05 + rand() / (real_t)(RAND_MAX / 10);         b[x] = .05 + rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc data copyin(a[0:25*m_n], b[0:25*m_n]) copyout(c[0:25*m_n], totals[0:25])     {         #pragma acc parallel loop gang private(reduced)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 reduced[y] = 1.0;             }             #pragma acc loop worker reduction(*:reduced)             for (int y = 0; y < 5 * m_n; ++y) {                 reduced[y%5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];             }             for (int y = 0; y < 5; ++y) {                 totals[x * 5 + y] = reduced[y];             }             for (int y = 0; y < 5 * m_n; ++y) {                 c[x * 5 * m_n + y] = (a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[x * 5 + (y%5)];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             reduced[y] = 1;         }         for (int y = 0; y < 5 * m_n; ++y) {             reduced[y%5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];         }         for (int y = 0; y < 5; ++y) {             if (fabs(totals[x * 5 + y] - reduced[y]) > PRECISION) {                 err += 1;             }         }         for (int y = 0; y < 5 * m_n; ++y) {             if (fabs(c[x * 5 * m_n + y] - ((a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[x * 5 + (y % 5)])) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update lshift equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic update                             a[x] <<= 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture x times expr assign", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   REAL(8), INTENT(IN) :: init   REAL(8),DIMENSION(length), INTENT(IN) :: a   REAL(8),DIMENSION(length), INTENT(IN) :: b   REAL(8),DIMENSION(length - 1) :: passed_a   REAL(8),DIMENSION(length - 1) :: passed_b   REAL(8) :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (abs(b(x) - (init * a(x))) .GT. ((10 - length) * PRECISION)) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = b(x)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison   REAL(8),DIMENSION(10):: passed_a, passed_b   REAL(8):: init   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)    totals = 1   totals_comparison = 1    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             totals(x) = totals(x) * a(x, y)             b(x, y) = totals(x)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data   DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = totals_comparison(x) * a(x, y)     END DO   END DO    DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NE. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 1     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .TRUE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update iand expr x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .gt. .933) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           DO y = 0, 7             totals(x) = totals(x) + ISHFT(1, y)             totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)           END DO         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc is present", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,devonly,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      #pragma acc enter data create(a[0:n])     if (acc_is_present(a, n * sizeof(real_t)) == 0){         err += 1;     }     #pragma acc exit data delete(a[0:n])      if (devtest[0] == 1){         if (acc_is_present(a, n * sizeof(real_t)) != 0){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel copyout zero", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,data,data-region,V:3.0-3.2 int test1(){     int err = 0;     srand(SEED);      real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n])      {       #pragma acc parallel copyout(zero: b[0:n])       {         #pragma acc loop         {           for (int x = 0; x < n; ++x){             b[x] += a[x];           }         }       }     }      for (int x = 0; x < n; ++x){         if(fabs(a[x] - b[x]) > PRECISION){                 err += 1;                 break;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,data,data-region,devonly,V:3.0-3.1 int test2(){     //for development; logic test     int err = 0;     srand(SEED);      real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      int* hasDevice = (int *) malloc(sizeof(int));     hasDevice[0] = 1;     #pragma acc enter data copyin(hasDevice[0:1])     #pragma acc parallel present(hasDevice[0:1])     {       hasDevice[0] = 0;     }      if (hasDevice[0] == 1){       for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 1;       }        #pragma acc data copyin(a[0:n])       {         #pragma acc parallel copyout(zero: b[0:n])         {           #pragma acc loop           {             for (int x = 0; x < n; ++x){               b[x] += a[x];             }           }         }       }        for (int x = 0; x < n; ++x){           if(fabs(a[x] - b[x]) > PRECISION){                   err += 1;                   break;           }       }     }      return err; } #endif  #ifndef T3 //T3:parallel,data,data-region,V:3.0-3.1 int test3(){     int err = 0;     srand(SEED);      real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 1;     }      #pragma acc data copyin(a[0:n]) copy(b[0:n])     {       #pragma acc parallel copyout(zero: b[0:n])       {         #pragma acc loop         {           for (int x = 0; x < n; ++x){             b[x] += a[x];           }         }       }     }      for (int x = 0; x < n; ++x){         if(fabs(a[x] - b[x] + 1) > PRECISION){                 err += 1;                 break;         }     }      return err; } #endif  int main(){     int failcode = 0;      int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction add general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      real_t total = 10; //Should be innitialized to 0 anyway.     #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc kernels loop reduction(+:total)         for (int x = 0; x < n; ++x){             total += a[x] + b[x];         }     }     for (int x = 0; x < n; ++x){         total -= a[x] + b[x];     }     if (fabs(total - 10) > PRECISION * (2 * n - 1)){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature copy copyout", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1: , V:1.0-2.7 int test1(){     int err = 0;     real_t test = 0;     #pragma acc parallel loop copy(test) copyout(test) reduction(+:test)     for( int x = 0; x <n; ++x){         test += 1;     }      if(fabs(test - n) > PRECISION){         err++;     }      return err; } #endif  #ifndef T2 //T2: , V:1.0-2.7 int test2(){     int err = 0;     real_t *test = (real_t *)malloc(n * sizeof(real_t));      for(int x = 0; x < n; ++x){         test[x] = 1.0;     }     #pragma acc parallel loop copy(test[0:n]) copyout(test[0:n])    for(int x = 0; x < n; ++x){         test[x] += 1.0;    }     for(int x = 0; x < n; ++x){         if(fabs(test[x] - 2.0) > PRECISION){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for( int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test1();     }     if(failed){ \tfailcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for( int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }     if(failed){         failcode += (1 << 1);     } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature parallel wait devnum", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,wait,async,V:2.0-3.2 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n])     { \t#pragma acc parallel loop present(a[0:n], b[0:n]) async(1)         for (int x = 0; x < n; ++x){ \t    b[x] = a[x];         } \t#pragma acc update host(b[0:n]) wait(1)     }     for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }     if (failed){         failcode +=  (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature enter data copyin no lower bound", "completion": "#ifndef T1 !T1:data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data copyin(a(:LOOPCOUNT), b(:LOOPCOUNT))         !$acc data copyout(c(1:LOOPCOUNT)) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data         !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic x times expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = totals(x) * a(x, y)               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) * a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature data copy no lower bound", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,data-region,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(c[:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction bitor general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int b = 0;     unsigned int host_b = a[0];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX > false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }      #pragma acc data copyin(a[0:n])     {         #pragma acc kernels loop reduction(|:b)         for (int x = 0; x < n; ++x){             b = b | a[x];         }     }       for (int x = 1; x < n; ++x){         host_b = host_b | a[x];     }     if (b != host_b){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature set default async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:async,set,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *a_host = new real_t[n];     real_t *b_host = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         a_host[x] = a[x];         b_host[x] = b[x];     }      #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])     {         #pragma acc set default_async(1)         #pragma acc parallel async         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = a[x] * a[x];             }         }         #pragma acc set default_async(2)         #pragma acc parallel async         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = b[x] * b[x];             }         }         #pragma acc parallel async(1) wait(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc wait(1)     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4*PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data copyout zero", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,data-region,V:3.0-3.2 int test1(){      int err = 0;     srand(SEED);      real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(zero: b[0:n])     {       #pragma acc parallel       {         #pragma acc loop         {           for (int x = 0; x < n; ++x){             b[x] += a[x];           }         }       }     }      for (int x = 0; x < n; ++x){         if(fabs(a[x] - b[x]) > PRECISION){                 err += 1;                 break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);      real_t * a = new real_t[1024];     real_t * b = new real_t[1024];      for (int x = 0; x < 1024; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc kernels loop copy(a[0:1024]) copyout(b[0:1024])     for (int _0 = 0; _0 < 2; ++_0){         #pragma acc loop         for (int _1 = 0; _1 < 2; ++_1){             #pragma acc loop             for (int _2 = 0; _2 < 2; ++_2){                 #pragma acc loop                 for (int _3 = 0; _3 < 2; ++_3){                     #pragma acc loop                     for (int _4 = 0; _4 < 2; ++_4){                         #pragma acc loop                         for (int _5 = 0; _5 < 2; ++_5){                             #pragma acc loop                             for (int _6 = 0; _6 < 2; ++_6){                                 #pragma acc loop                                 for (int _7 = 0; _7 < 2; ++_7){                                     #pragma acc loop                                     for (int _8 = 0; _8 < 2; ++_8){                                         #pragma acc loop                                         for (int _9 = 0; _9 < 2; ++_9){                                             b[_0 * 512 + _1 * 256 + _2 * 128 + _3 * 64 + _4 * 32 + _5 * 16 + _6 * 8 + _7 * 4 + _8 * 2 + _9] = a[_0 * 512 + _1 * 256 + _2 * 128 + _3 * 64 + _4 * 32 + _5 * 16 + _6 * 8 + _7 * 4 + _8 * 2 + _9];                                         }                                     }                                 }                             }                         }                     }                 }             }         }     }      for (int x = 0; x < 1024; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic bitor equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] |= a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] |= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured minus equals assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (prev - a[x])) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));     real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0; \ttotals_host[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x%10] -= (a[x] + b[x]);                     c[x] = totals[x%10];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop seq", "completion": "#ifndef T1 !T1:parallel,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0          !$acc data copyin(a(1:LOOPCOUNT)) copy(b(1:LOOPCOUNT))           !$acc parallel loop seq           DO x = 2, LOOPCOUNT             b(x) = b(x - 1) + a(x)           END DO         !$acc end data                  DO x = 2, LOOPCOUNT           IF (abs(b(x) - (b(x - 1) + a(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature data copy no lower bound", "completion": "#ifndef T1 !T1:data,data_region,construct-independent,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = c(x) + a(x) + b(x)             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction max loop", "completion": "#ifndef T1 !T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c !Data         REAL(8),DIMENSION(10):: maximum         REAL(8) :: temp         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT))           !$acc parallel loop gang private(temp)           DO x = 0, 9             temp = 0             !$acc loop worker reduction(max:temp)             DO y = 1, LOOPCOUNT               temp = max(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))             END DO             maximum(x + 1) = temp             !$acc loop worker             DO y = 1, LOOPCOUNT               c(x * LOOPCOUNT + y) = (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y)) / maximum(x + 1)             END DO           END DO         !$acc end data                  DO x = 0, 9           DO y = 1, LOOPCOUNT             IF (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y) - maximum(x + 1) .gt. PRECISION) THEN               errors = errors + 1             ELSE IF ((c(x * LOOPCOUNT + y) - 1) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture assign x plus expr", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   REAL(8), INTENT(IN) :: init   REAL(8),DIMENSION(length), INTENT(IN) :: a   REAL(8),DIMENSION(length), INTENT(IN) :: b   REAL(8),DIMENSION(length - 1) :: passed_a   REAL(8),DIMENSION(length - 1) :: passed_b   REAL(8) :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (abs(b(x) - init) .GT. ((10 - length) * PRECISION)) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = a(x) + init       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison   REAL(8),DIMENSION(10):: passed_a, passed_b   REAL(8):: init   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)    totals = 0   totals_comparison = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             b(x, y) = totals(x)             totals(x) = totals(x) + a(x, y)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data   DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = totals_comparison(x) + a(x, y)     END DO   END DO    DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NE. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 0     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update plus equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] += a[x] * b[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] += a[x] * b[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > (n/10 + 1) * PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc hostptr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *a_ptr;      a_ptr = reinterpret_cast<real_t*>(acc_create(a, n * sizeof(real_t)));      if (a != acc_hostptr(acc_deviceptr(a))){         err += 1;     }      acc_delete(a, n * sizeof(real_t));      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc wait async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,async,construct-independent,wait,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];     real_t *e = new real_t[n];     real_t *f = new real_t[n];     real_t *g = new real_t[n];     real_t *h = new real_t[n];     real_t *i = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0;         g[x] = rand() / (real_t)(RAND_MAX / 10);         h[x] = 0;         i[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], g[0:n]) create(c[0:n], f[0:n], h[0:n]) copyout(i[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         acc_wait_async(1, 2);         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 h[x] = c[x] + g[x];             }         }         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         acc_wait_async(1, 2);         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 i[x] = h[x] + f[x];             }         }         #pragma acc wait(2)     }      for (int x = 0; x < n; ++x){         if (fabs(i[x] - (a[x] + b[x] + g[x] + d[x] + e[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign lshift equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if ((a>>x)%2 == 1){                 if (is_possible(passed_a, passed_b, length - 1, prev << 1)){                     return true;                 }             }             else {                 if (is_possible(passed_a, passed_b, length - 1, prev)){                     return true;                 }             }         }     }     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1;      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                         {                             c[x * 7 + y] = a[x];                             a[x] <<= 1;                         }                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc delete async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,async,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));     real_t *e = (real_t *)malloc(n * sizeof(real_t));     real_t *f = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0;     }      #pragma acc enter data copyin(a[0:n], b[0:n], d[0:n], e[0:n])      #pragma acc data present(a[0:n], b[0:n], d[0:n], e[0:n]) copyout(c[0:n], f[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         acc_delete_async(a, n * sizeof(real_t), 1);         acc_delete_async(b, n * sizeof(real_t), 1);         acc_delete_async(d, n * sizeof(real_t), 2);         acc_delete_async(e, n * sizeof(real_t), 2);         #pragma acc wait     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }         if (fabs(f[x] - (d[x] + e[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));     real_t *e = (real_t *)malloc(n * sizeof(real_t));     real_t *f = (real_t *)malloc(n * sizeof(real_t));     int* devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0;         }          #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])         #pragma acc data present(a[0:n], b[0:n], c[0:n])         {             #pragma acc parallel async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] * b[x];                 }             }         }         acc_delete_async(c, n * sizeof(real_t), 1);         #pragma acc enter data copyin(c[0:n]) async(1)         #pragma acc data present(a[0:n], b[0:n], c[0:n])         {             #pragma acc parallel async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] += a[x] + b[x];                 }             }         }         #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc set device type", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,internal-control-values,syntactic,V:2.0-2.7 int test1(){     int err = 0;      int device_type = acc_get_device_type();      acc_set_device_type(device_type);     if (acc_get_device_type() != device_type){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine seq", "completion": "#include \"acc_testsuite.h\" void test_routine_seq_loop_named(real_t ** a, real_t * b, long long n); void test_routine_seq_seq_named(real_t ** a, real_t * b, long long n);  #pragma acc routine(test_routine_seq_loop_named) seq #pragma acc routine(test_routine_seq_seq_named) seq  #pragma acc routine seq real_t called_function_seq(real_t **a, int x, long long n){     real_t returned = 0;     #pragma acc loop seq reduction(+:returned)     for (int y = 0; y < n; ++y){         returned += a[x][y];     }     return returned; }  #pragma acc routine seq void test_routine_seq_loop_unnamed(real_t ** a, real_t * b, long long n){     #pragma acc loop seq     for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             b[x] += a[x][y];         }     } }  #pragma acc routine seq void test_routine_seq_seq_unnamed(real_t ** a, real_t *b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_seq(a, x, n);     } }  void test_routine_seq_loop_named(real_t ** a, real_t * b, long long n){     #pragma acc loop seq     for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             b[x] += a[x][y];         }     } }  void test_routine_seq_seq_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_seq(a, x, n);     } }  bool validate_data(real_t ** a, real_t * b){     real_t local_total;     for (int x = 0; x < n; ++x){         local_total = 0;         for (int y = 0; y < n; ++y){             local_total += a[x][y];         }         if (fabs(b[x] - local_total) > PRECISION){             return true;         }     }     return false; }  #ifndef T1 //T1:routine,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {               test_routine_seq_loop_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T2 //T2:routine,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_seq_loop_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T3 //T3:routine,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_seq_seq_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T4 //T4:routine,construct-independent,V:2.0-2.7 int test4(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_seq_seq_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial copyout", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,data-region,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);      real_t * a = new real_t[n];     real_t * b = new real_t[n];     int* hasDevice = (int *) malloc(sizeof(int));     hasDevice[0] = 1;     #pragma acc enter data copyin(hasDevice[0:1])     #pragma acc serial present(hasDevice[0:1])     {       hasDevice[0] = 0;     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n])     {         #pragma acc serial copyout(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T2 //T2:serial,data,data-region,reference-counting,devonly,V:2.6-2.7 int test2(){     int err = 0;     srand(SEED);      real_t * a = new real_t[n];     real_t * b = new real_t[n];     int* hasDevice = (int *) malloc(sizeof(int));     hasDevice[0] = 1;     #pragma acc enter data copyin(hasDevice[0:1])     #pragma acc serial present(hasDevice[0:1])     {       hasDevice[0] = 0;     }      if (hasDevice[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0;         }         #pragma acc data copyin(a[0:n], b[0:n])         {             #pragma acc serial copyout(b[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = a[x];                 }             }         }         for (int x = 0; x < n; ++x){             if (fabs(b[x]) > PRECISION){                 err += 2;                 break;             }         }     }      return err; } #endif  #ifndef T3 //T3:serial,data,data-region,reference-counting,V:2.6-2.7 int test3(){     int err = 0;     srand(SEED);      real_t * a = new real_t[n];     real_t * b = new real_t[n];     int* hasDevice = (int *) malloc(sizeof(int));     hasDevice[0] = 1;     #pragma acc enter data copyin(hasDevice[0:1])     #pragma acc serial present(hasDevice[0:1])     {       hasDevice[0] = 0;     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc serial copyout(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }         #pragma acc update host(b[0:n])     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - a[x]) > PRECISION){             err += 4;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture assign expr and x", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         LOGICAL,DIMENSION(length), INTENT(IN) :: a         LOGICAL,DIMENSION(length), INTENT(IN) :: b         LOGICAL, INTENT(IN) :: init         LOGICAL,DIMENSION(length - 1) :: passed_a         LOGICAL,DIMENSION(length - 1) :: passed_b         LOGICAL :: POSSIBLE         INTEGER :: x, y         IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.         DO x = 1, length           IF (b(x) .eqv. init) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             IF (IS_POSSIBLE(passed_a, passed_b, length - 1, a(x) .AND. init)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data         LOGICAL,DIMENSION(10):: passed_a, passed_b         LOGICAL IS_POSSIBLE         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0         LOGICAL :: init          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) < .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   b(x, y) = totals(x)                   totals(x) = a(x, y) .AND. totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .AND. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           init = .FALSE.           IF (.FALSE. .eqv. IS_POSSIBLE(a(x, 1:10), b(x, 1:10), 10, .FALSE.)) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop reduction bitand general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     n = 10;     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX < false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }     unsigned int b = 0;     for (int x = 0; x < 16; ++x){         temp = 1;         for (int y = 0; y < x; ++y){             temp *= 2;         }         b += temp;     }     #pragma acc data copyin(a[0:n])     {         #pragma acc kernels loop reduction(&:b)         for (int x = 0; x < n; ++x){             b = b & a[x];         }     }     unsigned int host_b = a[0];      for (int x = 1; x < n; ++x){         host_b = host_b & a[x];     }     if (b != host_b){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture bitxor equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == (a[x] ^ prev)){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int * temp_a = (int *)malloc(10 * sizeof(int));     int * temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .5){                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     b[x] = totals[x%(n/10 + 1)] ^= a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] ^= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (temp_iterator = 0, ab_iterator = x; ab_iterator < n; temp_iterator++, ab_iterator += n/10 + 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!(is_possible(temp_a, temp_b, temp_iterator, 0))){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data present no lower bound", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,data-region,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n]) present(c[:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }     #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture assign iand expr x", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         INTEGER, INTENT(IN) :: init         INTEGER,DIMENSION(length), INTENT(IN) :: a         INTEGER,DIMENSION(length), INTENT(IN) :: b         INTEGER,DIMENSION(length - 1) :: passed_a         INTEGER,DIMENSION(length - 1) :: passed_b         INTEGER :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (b(x) .eq. init) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = iand(a(x), init)             IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y, z !Iterators         INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER,DIMENSION(10):: passed_a, passed_b         INTEGER:: init         LOGICAL IS_POSSIBLE         INTEGER :: errors = 0          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 10             DO z = 1, 8               IF (randoms(x, y, z) .lt. .933) THEN                 a(x, y) = a(x, y) + ISHFT(1, z - 1)               END IF             END DO           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT           DO y = 0, 7             totals(x) = totals(x) + ISHFT(1, y)             totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)           END DO         END DO          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   b(x, y) = totals(x)                   totals(x) = iand(a(x, y), totals(x))                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = iand(totals_comparison(x), a(x, y))           END DO         END DO         DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           init = 0           DO y = 0, 7             init = init + ISHFT(1, y)           END DO           IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels scalar default copy", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data,data-region,default-mapping,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t sum = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      for (int x = 0; x < n; ++x){         sum = sum + a[x];     }      #pragma acc data copyin(b[0:n])     {         #pragma acc kernels num_gangs(1) vector_length(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 sum = sum + b[x];             }         }     }      for (int x = 0; x < n; ++x){         sum = sum - (a[x] + b[x]);     }      if (fabs(sum) > (2 * n - 2) * PRECISION){         err += 1;         sum = 0.0;         for (int x = 0; x < n; ++x){             sum = sum + a[x];         }         sum = 0.0;         for (int x = 0; x < n; ++x){             sum = sum + b[x];         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitor vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));     unsigned int b_host;      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;      for (int x = 0; x < 10 * n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX > false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }     temp = 0;     #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(|:temp)             for (int y = 0; y < n; ++y){                 temp = temp | a[x * n + y];             }             b[x] = temp;         }     }      for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host | a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc set device num", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,devonly,construct-independent,set,V:2.0-2.7 int test1(){     int err = 0;      if (acc_get_device_type() != acc_device_none){         real_t **host_copy = (real_t **)malloc(acc_get_num_devices(acc_get_device_type()) * sizeof(real_t *));         for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){             host_copy[x] = (real_t *)malloc(n * sizeof(real_t));         }         real_t *a = (real_t *)malloc(n * sizeof(real_t));         for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){             for (int y = 0; y < n; ++y){                 a[y] = rand() / (real_t)(RAND_MAX / 10);                 host_copy[x][y] = a[y];             }             acc_set_device_num(x, acc_get_device_type());             #pragma acc enter data copyin(a[0:n])         }         for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){             acc_set_device_num(x, acc_get_device_type());             #pragma acc data present(a[0:n])             {                 #pragma acc parallel                 {                     #pragma acc loop                     for (int y = 0; y < n; ++y){                         a[y] = a[y] + 1;                     }                 }             }         }         for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){             acc_set_device_num(x, acc_get_device_type());             #pragma acc exit data copyout(a[0:n])             for (int y = 0; y < n; ++y){                 if (fabs(a[y] - (host_copy[x][y] + 1)) > PRECISION){                     err += 1;                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured postincrement assign", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *c = (int *)malloc(n * sizeof(int));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));     bool found = false;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     distribution[(int) (a[x]*b[x]/10)]++;                     c[x] = distribution[(int) (a[x]*b[x]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]++;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < distribution_comparison[x]; ++y){             for (int z = 0; z < n; ++z){                 if (c[z] == y + 1 && (int) (a[z]*b[z]/10) == x){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels present", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data,structured-data,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n]) create(b[0:n])     #pragma acc kernels present(a[0:n], b[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             b[x] = a[x];         }     }     #pragma acc exit data copyout(b[0:n]) delete(a[0:n])      for (int x = 0; x < n; ++x){         if (fabs(b[x] - a[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture rshift equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if ((b[x] == prev>>1 && ((a>>x)%2)==1) || ((a>>x)%2==0 && b[x] == prev)){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_b);                 return true;             }         }     }     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1<<8;      for (int x = 0; x < n; ++x){         a[x] = 1<<8;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                             c[x * 7 + y] = a[x] >>= 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<8){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop vector blocking", "completion": "#ifndef T1 !T1:loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT):: a, b, c   INTEGER:: multiplier, x   errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 0    !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))     !$acc serial       !$acc loop vector       DO x = 1, LOOPCOUNT         c(x) = (a(x) + b(x)) * multiplier       END DO       multiplier = multiplier + 1       !$acc loop vector       DO x = 1, LOOPCOUNT         c(x) = c(x) + ((a(x) + b(x)) * multiplier)       END DO     !$acc end serial   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(c(x) - ((a(x) + b(x)) * 3)) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop vector blocking", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,V:1.0-2.7 int test1(){   int err = 0;   srand(SEED);   real_t * a = new real_t[n];   real_t * b = new real_t[n];   real_t * c = new real_t[n];   real_t multiplyer = 1;    for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = 0.0;   }    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])   {     #pragma acc kernels     {       #pragma acc loop vector       for (int x = 0; x < n; ++x){         c[x] = (a[x] + b[x]) * multiplyer;       }       multiplyer += 1;       #pragma acc loop vector       for (int x = 0; x < n; ++x){         c[x] += (a[x] + b[x]) * multiplyer;       }     }   }    for (int x = 0; x < n; ++x){     if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){       err + 1;       break;     }   }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc create async", "completion": "#ifndef T1 !T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(d)         CALL RANDOM_NUMBER(e)         f = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))           CALL acc_create_async(c(1:LOOPCOUNT), 1)           CALL acc_create_async(f(1:LOOPCOUNT), 2)           !$acc data present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))             !$acc parallel async(1)               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) + b(x)               END DO             !$acc end parallel             !$acc parallel async(2)               !$acc loop               DO x = 1, LOOPCOUNT                 f(x) = d(x) + e(x)               END DO             !$acc end parallel             !$acc wait           !$acc end data         !$acc end data          !$acc exit data copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF           IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO         IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif          CALL EXIT (failcode)         END PROGRAM  "}
{"prompt": "Create a test for the feature data copyin no lower bound", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,data-region,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[:n], b[:n]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update x divided expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] / (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured lshift equals assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if ((b[x] == (prev << 1) && (a>>x)%2 == 1) || ((a>>x)%2==0 && b[x] == prev)){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_b);                 return true;             }         }     }     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1;      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                         {                             a[x] <<= 1;                             c[x * 7 + y] = a[x];                         }                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel private", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,private,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * d = (real_t *)malloc(10 * sizeof(real_t));      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             a[x * n + y] = rand() / (real_t)(RAND_MAX / 10);             b[x * n + y] = rand() / (real_t)(RAND_MAX / 10);             c[y] = 0.0;         }         d[x] = 0.0;     }      #pragma acc enter data copyin(a[0:10*n], b[0:10*n], d[0:10])     #pragma acc parallel num_gangs(10) private(c[0:n])     {         #pragma acc loop gang         for (int x = 0; x < 10; ++x){             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 c[y] = a[x * n + y] + b[x * n + y];             }             #pragma acc loop seq             for (int y = 0; y < n; ++y){                 d[x] += c[y];             }         }     }     #pragma acc exit data copyout(d[0:10]) delete(a[0:10*n], b[0:10*n])      real_t temp;     for (int x = 0; x < 10; ++x){         temp = 0.0;         for (int y = 0; y < n; ++y){             temp += a[x * n + y] + b[x * n + y];         }         if (fabs(temp - d[x]) > (2 * PRECISION * n)){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc init", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:1.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         IF (acc_get_device_type() .ne. acc_device_none) THEN           CALL acc_init(acc_get_device_type())         END IF          test1 = .FALSE.       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature acc create", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      acc_create(c, n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      acc_copyout(c, n * sizeof(real_t));      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      acc_create(c, n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:runtime,data,executable-data,compatibility-features,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      acc_pcreate(c, n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T4 //T4:runtime,data,executable-data,compatibility-features,construct-independent,V:2.0-2.7 int test4(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      acc_present_or_create(c, n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T5 //T5:runtime,data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7 int test5(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int * dev_test = (int *)malloc(sizeof(int));      dev_test[0] = 1;     #pragma acc enter data copyin(dev_test[0:1])     #pragma acc parallel present(dev_test[0:1])     {         dev_test[0] = 0;     }     if (dev_test[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 1;         }          #pragma acc enter data copyin(c[0:n])         for (int x = 0; x < n; ++x){             c[x] = 0;         }         acc_create(c, n * sizeof(real_t));         #pragma acc data copyin(a[0:n], b[0:n])         {             #pragma acc parallel present(c[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x) {                     c[x] += a[x] + b[x];                 }             }         }          #pragma acc exit data copyout(c[0:n])         #pragma acc exit data delete(c[0:n])          \tfor (int x = 0; x < n; ++x) {             if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc init", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,init,syntactic,V:2.5-2.7 int test1(){     int err = 0;      if (acc_get_device_type() != acc_device_none){         acc_init(acc_get_device_type());     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic ior x expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .lt. .933) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           totals(x) = 0           totals_comparison(x) = 0         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction and general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);      char * a = new char[n];     real_t false_margin = pow(exp(1), log(.5)/n);     char result = 1;     char found = 0;      for (int x = 0; x < n; ++x){         if(rand() / (real_t)(RAND_MAX) < false_margin){             a[x] = 1;         }         else{             a[x] = 0;         }     }      #pragma acc data copyin(a[0:n])     {         #pragma acc parallel loop reduction(&&:result)         for (int x = 0; x < n; ++x){             result = result && a[x];         }     }      for (int x = 0; x < n; ++x){         if (a[x] == 0){             found = 1;             break;         }     }     if (found == result){         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     char * a = new char[n * 5];     real_t false_margin = pow(exp(1), log(.5/n));     char result[5];     char host_result[5];      for (int x = 0; x < 5; ++x) {         result[x] = 1;         host_result[x] = 1;     }      for (int x = 0; x < 5 * n; ++x) {         if (rand() / (real_t)(RAND_MAX) < false_margin) {             a[x] = 1;         }         else {             a[x] = 0;         }     }      #pragma acc data copyin(a[0:5*n])     {         #pragma acc parallel loop reduction(&&:result)         for (int x = 0; x < 5 * n; ++x) {             result[x%5] = result[x%5] && a[x];         }     }      for (int x = 0; x < 5 * n; ++x) {         host_result[x%5] = host_result[x%5] && a[x];     }      for (int x = 0; x < 5; ++x){         if (host_result[x] != result[x]) {             err += 1;         }      }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitxor vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));      unsigned int temp = 0;     unsigned int b_host;      for (int x = 0; x < 10 * n; ++x){         a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc parallel loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(^:temp)             for (int y = 0; y < n; ++y){                 temp = temp ^ a[x * n + y];             }             b[x] = temp;         }     }      for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host ^ a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));      unsigned int temp[5];      for (int x = 0; x < 25 * n; ++x){         a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);     }      #pragma acc data copyin(a[0:25*n]) copy(b[0:25])     {         #pragma acc parallel loop private(temp)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y){                 temp[y] = 0;             }             #pragma acc loop vector reduction(^:temp)             for (int y = 0; y < 5 * n; ++y) {                 temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];             }             for (int y = 0; y < 5; ++y) {                 b[x * 5 + y] = temp[y];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             temp[y] = 0;         }         for (int y = 0; y < 5 * n; ++y) {             temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];         }         for (int y = 0; y < 5; ++y) {             if (b[x * 5 + y] != temp[y]) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update expr divided x", "completion": "#include \"acc_testsuite.h\" bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){     if (length == 0){         if (fabs(current_value - test_value) > PRECISION){             return true;         }         else {             return false;         }     }     real_t * passed = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         for (int y = 0; y < x; ++y){             passed[y] = remaining_combinations[y];         }         for (int y = x + 1; y < length; ++y){             passed[y - 1] = remaining_combinations[y];         }         if (possible_result(passed, length - 1, remaining_combinations[x] / current_value, test_value)){             delete[] passed;             return true;         }     }     delete[] passed;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t * passed = new real_t[10];     int indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];             }         }     }       for (int x = 0; x < (n/10 + 1); ++x){         indexer = x;         while (indexer < n){             passed[indexer/(n/10 + 1)] = (a[x] + b[x]);             indexer += (n/10 + 1);         }         if (!(possible_result(passed, 10, 1, totals[x]))){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels present", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data,structured-data,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n]) create(b[0:n])     #pragma acc kernels present(a[0:n], b[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             b[x] = a[x];         }     }     #pragma acc exit data copyout(b[0:n]) delete(a[0:n])      for (int x = 0; x < n; ++x){         if (fabs(b[x] - a[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitand loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));     unsigned int* host_c = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;      for (int x = 0; x < 10 * n; ++x){         b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b_copy[x] = b[x];         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX < false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }     #pragma acc data copyin(a[0:10 * n]) copy(b[0:10 * n], c[0:10])     {         #pragma acc serial \t{    \t\t#pragma acc loop gang private(temp)         \tfor (int y = 0; y < 10; ++y){             \t\ttemp = a[y * n];             \t\t#pragma acc loop worker reduction(&:temp)            \t\tfor (int x = 1; x < n; ++x){                \t\ttemp = temp & a[y * n + x];             \t\t}             \t \t\t\tc[y] = temp;             \t \t\t\t#pragma acc loop worker             \t\tfor (int x = 0; x < n; ++x){ \t       \t\t\tb[y * n + x] = b[y * n + x] + c[y];             \t\t}         \t}     \t}     }     for (int x = 0; x < 10; ++x){         host_c[x] = a[x * n];         for (int y = 1; y < n; ++y){             host_c[x] = host_c[x] & a[x * n + y];         }         if (host_c[x] != c[x]){           err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (b[x * n + y] != b_copy[x * n + y] + c[x]){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data create", "completion": "#ifndef T1 !T1:data,data_region,construct-independent,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0         c = 0           !$acc data create(b(1:LOOPCOUNT))           !$acc data copyin(a(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 b(x) = a(x)               END DO             !$acc end parallel           !$acc end data           !$acc data copyout(c(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = b(x)               END DO             !$acc end parallel           !$acc end data         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(a(x) - c(x)) .gt. PRECISION) THEN             errors = errors + 1             EXIT           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:data,data_region,construct-independent,V:1.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0         c = 0           !$acc data present_or_create(b(1:LOOPCOUNT))           !$acc data copyin(a(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 b(x) = a(x)               END DO             !$acc end parallel           !$acc end data           !$acc data copyout(c(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = b(x)               END DO             !$acc end parallel           !$acc end data         !$acc end data           DO x = 1, LOOPCOUNT           IF (abs(a(x) - c(x)) .gt. PRECISION) THEN             errors = errors + 2             EXIT           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:data,data_region,construct-independent,V:1.0-2.7       LOGICAL FUNCTION test3()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0         c = 0           !$acc data pcreate(b(1:LOOPCOUNT))           !$acc data copyin(a(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 b(x) = a(x)               END DO             !$acc end parallel           !$acc end data           !$acc data copyout(c(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = b(x)               END DO             !$acc end parallel           !$acc end data         !$acc end data               DO x = 1, LOOPCOUNT           IF (abs(a(x) - c(x)) .gt. PRECISION) THEN             errors = errors + 4             EXIT           END IF         END DO          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels copy", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data,data-region,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 1;     }     #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc kernels copy(c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     int * devtest = (int *)malloc(sizeof(int));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc kernels present(devtest[0:1])     {       devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){           a[x] = rand() / (real_t)(RAND_MAX / 10);           b[x] = rand() / (real_t)(RAND_MAX / 10);           c[x] = 1;         }         #pragma acc data copyin(a[0:n], b[0:n], c[0:n])         {             #pragma acc kernels copy(c[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] += a[x] + b[x];                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(c[x] - 1) > PRECISION && (a[x] + b[x]) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  #ifndef T3 //T3:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     int * devtest = (int *)malloc(sizeof(int));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc kernels present(devtest[0:1])     {       devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++ x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 1;         }          #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])         {             for (int x = 0; x < n; ++x){                 c[x] = 0;             }             #pragma acc kernels copy(c[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] += a[x] + b[x];                 }             }             for (int x = 0; x < n; ++x){                 if (fabs(c[x]) > PRECISION) {                     err += 1;                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature set if", "completion": "#include \"acc_testsuite.h\"  /*  * if clause not implimented for set as of now */  #ifndef T1 //T1:,V:2.7-3.0 int test1(){ \tint err = 0; \tsrand(SEED); \tint device_type = acc_get_device_type();  \t#pragma acc set if(acc_get_device_type == device_type)  \treturn err;\t } #endif #ifndef T2 //T2:,V:2.7-3.0 int test2(){ \tint err = 0;         srand(SEED);         int device_type = acc_get_device_type();          #pragma acc set if(acc_get_device_type != device_type)          return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature enter data create no lower bound", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,syntactic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[:n])     #pragma acc parallel present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel independent atomic capture", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.7-3.2 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(a[0:n], b[0:n])     {         #pragma acc parallel         { \t    #pragma acc loop independent             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     b[x] = (a[x])++;             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] + 1)) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1    failed = 0;    for (int x = 0; x < NUM_TEST_CALLS; ++x){        failed = failed + test1();    }    if (failed != 0){        failcode = failcode + (1 << 0);    } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature serial", "completion": "#ifndef T1 !T1:,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, i_a, i_b, i_c, i_d, i_e, i_f, i_g, i_h, i_i, i_j !Iterators   INTEGER, PARAMETER :: PRIVATE_LOOPCOUNT = 1024   REAL(8),DIMENSION(PRIVATE_LOOPCOUNT):: a, b, c !Data   INTEGER :: errors   errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 0    !$acc data copyin(a(1:PRIVATE_LOOPCOUNT), b(1:PRIVATE_LOOPCOUNT)) copy(c(1:PRIVATE_LOOPCOUNT))     !$acc serial       !$acc loop       DO i_a = 0, 1         !$acc loop         DO i_b = 0, 1           !$acc loop           DO i_c = 0, 1             !$acc loop             DO i_d = 0, 1               !$acc loop               DO i_e = 0, 1                 !$acc loop                 DO i_f = 0, 1                   !$acc loop                   DO i_g = 0, 1                     !$acc loop                     DO i_h = 0, 1                       !$acc loop                       DO i_i = 0, 1                         !$acc loop                         DO i_j = 0, 1                           c(i_a*512 + i_b*256 + i_c*128 + i_d*64 + i_e*32 + i_f*16 + i_g*8 + i_h*4 + i_i*2 + i_j + 1) = &                           a(i_a*512 + i_b*256 + i_c*128 + i_d*64 + i_e*32 + i_f*16 + i_g*8 + i_h*4 + i_i*2 + i_j + 1) + &                           b(i_a*512 + i_b*256 + i_c*128 + i_d*64 + i_e*32 + i_f*16 + i_g*8 + i_h*4 + i_i*2 + i_j + 1)                         END DO                       END DO                     END DO                   END DO                 END DO               END DO             END DO           END DO         END DO       END DO     !$acc end serial   !$acc end data    DO x = 1, PRIVATE_LOOPCOUNT     IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels async", "completion": "#ifndef T1 !T1:async,kernels,update,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f, g !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(d)         CALL RANDOM_NUMBER(e)         f = 0         g = 0         !$acc enter data create(g(1:LOOPCOUNT), c(1:LOOPCOUNT), f(1:LOOPCOUNT))         !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))           !$acc kernels async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end kernels           !$acc kernels async(2)             !$acc loop             DO x = 1, LOOPCOUNT               f(x) = d(x) + e(x)             END DO           !$acc end kernels           !$acc kernels wait(1, 2) async(3)             !$acc loop             DO x = 1, LOOPCOUNT               g(x) = c(x) + f(x)             END DO           !$acc end kernels         !$acc end data         !$acc wait(1, 2)         !$acc update host(c(1:LOOPCOUNT), f(1:LOOPCOUNT))         !$acc exit data copyout(g(1:LOOPCOUNT)) async(3)         DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1             WRITE(*, *) x, \" a: \", c(x), \" = \", a(x), \" + \", b(x)           END IF           IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN             errors = errors + 1             WRITE(*, *) x, \" b: \", f(x), \" = \", d(x), \" + \", e(x)           END IF         END DO         !$acc wait(3)         DO x = 1, LOOPCOUNT           IF (abs(g(x) - (c(x) + f(x))) .gt. PRECISION) THEN             errors = errors + 1             WRITE(*, *) x, \" c: \", g(x), \" = \", c(x), \" + \", f(x)           END IF         END DO         !$acc exit data delete(c(1:LOOPCOUNT), f(1:LOOPCOUNT))          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction bitand vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));     unsigned int b_host;     unsigned int c = 0;      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;      for (int x = 0; x < 10 * n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX < false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc serial loop private(c)         for (int x = 0; x < 10; ++x){             c = a[x * n];             #pragma acc loop vector reduction(&:c)             for (int y = 1; y < n; ++y){                 c = c & a[x * n + y];             }             b[x] = c;         }     }     for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host & a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitxor general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     unsigned int b = 0;     unsigned int host_b = 0;      for (int x = 0; x < n; ++x){         a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);     }      #pragma acc data copyin(a[0:n])     {         #pragma acc parallel loop reduction(^:b)         for (int x = 0; x < n; ++x){             b = b ^ a[x];         }     }      for (int x = 0; x < n; ++x){         host_b = host_b ^ a[x];     }     if (b != host_b){         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int b[10];     unsigned int host_b[10];      for (int x = 0; x < 10 * n; ++x){         a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);     }      for (int x = 0; x < 10; ++x) {         b[x] = 0;         host_b[x] = 0;     }      #pragma acc data copyin(a[0:10*n])     {         #pragma acc parallel loop reduction(^:b)         for (int x = 0; x < 10 * n; ++x) {             b[x % 10] = b[x % 10] ^ a[x];         }     }      for (int x = 0; x < 10 * n; ++x) {         host_b[x % 10] = host_b[x % 10] ^ a[x];     }      for (int x = 0; x < 10; ++x) {         if (host_b[x] != b[x]) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel switch", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,syntactic,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int * a = new int[n];     real_t * b = new real_t[n];     real_t * b_host = new real_t[n];     real_t * c = new real_t[n];     real_t tempc = 0.0;      for (int x = 0; x < n; ++x){         a[x] = floor(rand() / (real_t)(RAND_MAX / 10));         b[x] = rand() / (real_t)(RAND_MAX / 10);         b_host[x] = b[x];         c[x] = 0.0;     }     #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])     #pragma acc parallel present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             switch(a[x]){                 case 0:                     c[x] = b[x] * b[x];                     break;                 case 1:                     c[x] = b[x] / b[x];                     break;                 case 2:                     b[x] = b[x] / 2;                 default:                     c[x] = a[x] + b[x];               }         }     }     #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])      for (int x = 0; x < n; ++x){         switch(a[x]){             case 0:                 tempc = b_host[x] * b_host[x];                 break;             case 1:                 tempc = b_host[x] / b_host[x];                 break;             case 2:                 b_host[x] = b_host[x] / 2;             default:                 tempc = a[x] + b_host[x];         }         if (fabs(c[x] - tempc) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitxor general", "completion": "#ifndef T1 !T1:serial,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER,DIMENSION(LOOPCOUNT):: a   REAL(8),DIMENSION(LOOPCOUNT):: randoms   INTEGER:: errors, b, host_b, x    errors = 0   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)    DO x = 1, LOOPCOUNT     a(x) = INT(randoms(x) * 100000)   END DO    b = 0   host_b = 0    DO x = 1, LOOPCOUNT     host_b = ieor(host_b, a(x))   END DO    !$acc data copyin(a(1:LOOPCOUNT))     !$acc serial loop reduction(ieor:b)     DO x = 1, LOOPCOUNT       b = ieor(b, a(x))     END DO   !$acc end data    IF (b .ne. host_b) THEN     errors = errors + 1   END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic min expr list x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature routine bind nonprototype function nonstring lambda", "completion": "#include \"acc_testsuite.h\"  //test 1 host function #pragma acc routine vector bind(device_array_array) real_t host_array_array(real_t * a, long long n){     #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  //test 1 device lambda auto device_array_array = [](real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; };  //test 2 host function #pragma acc routine vector bind(device_object_array) real_t host_object_array(data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned += a->data[x];     }     return returned; }  //test 2 device lambda auto device_object_array = [](data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; };  //test 3 host function #pragma acc routine vector bind(device_array_object) real_t host_array_object(real_t * a, long long n){    #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  //test 3 device lambda auto device_array_object = [](real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; };  //test 4 host function #pragma acc routine vector bind(device_object_object) real_t host_object_object(data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned += a->data[x];     }     return returned; }  //test 4 device lambda auto  device_object_object= [](data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; };  #ifndef T1 //T1:routine,V:2.7-3.3 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){        \ta[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_array_array(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_array(a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_array(a, n) - b[x]) > PRECISION)){             err += 1;         }     }     delete[] a;     delete[] b;      return err; } #endif #ifndef T2 //T2:routine,V:2.7-3.3 int test2(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a, a.data[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_object_array(&a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_array(&a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_array(&a, n) - b[x]) > PRECISION)){             err += 1;         }     }      delete[] b;      return err; } #endif #ifndef T3 //T3:routine,V:2.7-3.3 int test3(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b, b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_array_object(a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_object(a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_object(a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      delete[] a;      return err; } #endif #ifndef T4 //T4:routine,V:2.7-3.3 int test4(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a, a.data[0:n], b ,b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_object_object(&a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_object(&a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_object(&a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed = 0; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }      if(failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }      if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }      if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test4();     }      if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature set device type num", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,set,nonvalidating,V:2.5-3.2       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: device_type         INTEGER :: errors = 0          device_type = acc_get_device_type()         device_num = acc_get_device_num(device_type)         !$acc set device_type(host)          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,construct-independent,internal-control-values,set,nonvalidating,V:2.5-3.2       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: device_num         INTEGER :: device_type         INTEGER :: errors = 0          device_type = acc_get_device_type()         device_num = acc_get_device_num(device_type)         !$acc set device_type(multicore) device_num(device_num)          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:runtime,construct-independent,internal-control-values,set,nonvalidating,V:2.5-3.2       LOGICAL FUNCTION test3()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: device_num         INTEGER :: device_type         INTEGER :: errors = 0          device_type = acc_get_device_type()         device_num = acc_get_device_num(device_type)         !$acc set device_type(default) device_num(device_num)          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop reduction add vector loop", "completion": "#ifndef T1 !T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10*LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(10) :: c         REAL(8) :: temp         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copyout(c(1:10))           !$acc kernels loop private(temp)           DO x = 0, 9             temp = 0.0             !$acc loop vector reduction(+:temp)             DO y = 1, LOOPCOUNT               temp = temp + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)             END DO             c(x + 1) = temp           END DO         !$acc end data          DO x = 0, 9           temp = 0           DO y = 1, LOOPCOUNT             temp = temp + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)           END DO           IF (abs(temp - c(x + 1)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign divided equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     real_t *passed_c = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(c[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];                 passed_c[y] = c[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];                 passed_c[y - 1] = c[y];             }             if (is_possible(passed_a, passed_b, passed_c, length - 1, prev / (a[x] + b[x]))){                 delete[] passed_a;                 delete[] passed_b;                 delete[] passed_c;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     delete[] passed_c;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t *temp_a = new real_t[10];     real_t *temp_b = new real_t[10];     real_t *temp_c = new real_t[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x/10];                     totals[x/10] /= (a[x] + b[x]);                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];             temp_c[temp_iterator] = c[ab_iterator];             temp_iterator++;         }         if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture max expr list x assign", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, c, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8), INTENT(IN) :: init         REAL(8),DIMENSION(length), INTENT(IN) :: a         REAL(8),DIMENSION(length), INTENT(IN) :: b         REAL(8),DIMENSION(length), INTENT(IN) :: c         REAL(8),DIMENSION(length - 1) :: passed_a         REAL(8),DIMENSION(length - 1) :: passed_b         REAL(8),DIMENSION(length - 1) :: passed_c         REAL(8) :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (abs(c(x) - max(init, a(x), b(x))) .lt. ((10 - length) * PRECISION)) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = c(x)             IF (IS_POSSIBLE(passed_a, passed_b, passed_c, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c         REAL(8):: init         LOGICAL IS_POSSIBLE         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   totals(x) = max(a(x, y), b(x, y), totals(x))                   c(x, y) = totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = max(totals_comparison(x), a(x, y), b(x, y))           END DO         END DO         DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)             passed_c(y) = c(x, y)           END DO           init = 0           IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic x bitand expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] & a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] &= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured predecrement assign", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *c = new int[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];     bool found = false;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     --distribution[(int) (a[x]*b[x]/10)];                     c[x] = distribution[(int) (a[x]*b[x]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]--;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y > distribution[x]; --y){             for (int z = 0; z < n; ++z){                 if (c[z] == y - 1 && x == (int) (a[z] * b[z] / 10)){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial private", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,private,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     n = 10;     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * d = (real_t *)malloc(10 * sizeof(real_t));     real_t temp;      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             a[x * n + y] = rand() / (real_t)(RAND_MAX / 10);             b[x * n + y] = rand() / (real_t)(RAND_MAX / 10);             c[y] = 0.0;         }         d[x] = 0.0;     }      #pragma acc enter data copyin(a[0:10*n], b[0:10*n], d[0:10])     #pragma acc serial private(c[0:n])     {         #pragma acc loop gang         for (int x = 0; x < 10; ++x){             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 c[y] = a[x * n + y] + b[x * n + y];             }             #pragma acc loop seq             for (int y = 0; y < n; ++y){                 d[x] += c[y];             }         }     }     #pragma acc exit data copyout(d[0:10]) delete(a[0:10*n], b[0:10*n])      for (int x = 0; x < 10; ++x){         temp = 0.0;         for (int y = 0; y < n; ++y){             temp += a[x * n + y] + b[x * n + y];         }         if (fabs(temp - d[x]) > (2 * PRECISION * n)){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc create", "completion": "#ifndef T1 !T1:runtime,data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors         errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_create(c(1:LOOPCOUNT))          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc parallel present(c(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_copyout(c(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c         INTEGER:: errors         errors = 0          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c= 0          CALL acc_create(c(1:LOOPCOUNT))          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc parallel present(c(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data copyout(c(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:runtime,compatibility-features,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test3()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER:: x         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c         INTEGER:: errors         errors = 0          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_pcreate(c(1:LOOPCOUNT))          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data copyout(c(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif #ifndef T4 !T4:runtime,compatibility-features,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test4()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER:: x         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c         INTEGER:: errors         errors = 0          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_present_or_create(c(1:LOOPCOUNT))          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data copyout(c(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test4 = .FALSE.         ELSE           test4 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif #ifndef T4         LOGICAL :: test4 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif #ifndef T4         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test4()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 3           failed = .FALSE.         END IF #endif          CALL EXIT (failcode)         END PROGRAM  "}
{"prompt": "Create a test for the feature acc update device async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *a_host = (real_t *)malloc(n * sizeof(real_t));     real_t *b_host = (real_t *)malloc(n * sizeof(real_t));      int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         a_host[x] = a[x];         b_host[x] = b[x];     }        #pragma acc data copyout(c[0:n]) create(a[0:n], b[0:n])     {         acc_update_device_async(a, n * sizeof(real_t), 1);         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = a[x] * a[x];             }         }         acc_update_device_async(b, n * sizeof(real_t), 2);         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = b[x] * b[x];             }         }         #pragma acc parallel async(1) wait(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc wait(1)     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,async,devonly,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *a_host = (real_t *)malloc(n * sizeof(real_t));     real_t *b_host = (real_t *)malloc(n * sizeof(real_t));      int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0;         }          #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])         {             #pragma acc parallel async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     a[x] = a[x] * a[x];                 }             }             acc_update_device_async(a, n * sizeof(real_t), 1);             #pragma acc parallel async(2)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = b[x] * b[x];                 }             }             acc_update_device_async(b, n * sizeof(real_t), 2);             #pragma acc parallel async(1) wait(2)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] + b[x];                 }             }             #pragma acc wait(1)         }           for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel reduction", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,reduction,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t reduction;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc parallel copyin(a[0:n]) reduction(+:reduction)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             reduction = reduction + a[x];         }     }      for (int x = 0; x < n; ++x){         reduction = reduction - a[x];     }     if (fabs(reduction) > PRECISION){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic max x expr list", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic expr neqv x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = a(x, y) .NEQV. totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature exit data copyout reference counts", "completion": "#ifndef T1 !T1:data,executable-data,devonly,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          IF (devtest(1) .eq. 1) THEN           !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))           !$acc data copyin(c(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = c(x) + a(x) + b(x)               END DO             !$acc end parallel             !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))           !$acc end data            DO x = 1, LOOPCOUNT             IF (abs(c(x)) .gt. PRECISION) THEN               errors = errors + 1               EXIT             END IF           END DO          END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:data,executable-data,devonly,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))         !$acc data copyin(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = c(x) + a(x) + b(x)             END DO           !$acc end parallel         !$acc end data         !$acc exit data copyout(c(1:LOOPCOUNT)) delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 2             EXIT           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:data,executable-data,devonly,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test3()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))         !$acc enter data copyin(c(1:LOOPCOUNT))         !$acc parallel           !$acc loop           DO x = 1, LOOPCOUNT             c(x) = c(x) + a(x) + b(x)           END DO         !$acc end parallel         !$acc exit data delete(c(1:LOOPCOUNT))         !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 4             EXIT           END IF         END DO          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic expr or x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = a(x, y) .OR. totals(x)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .OR. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature declare copyin", "completion": "#define DECLARE_TEST #define DECLARE_COPYIN int mult_copyin = 2; #include \"acc_testsuite_declare.h\" #include \"acc_testsuite.h\"  #pragma acc declare copyin(fixed_size_array) #pragma acc declare copyin(scalar) #pragma acc declare copyin(datapointer) #pragma acc declare copyin(n) #pragma acc routine vector void multiplyData(real_t *a){     #pragma acc loop vector     for (int x = 0; x < n; ++x){         a[x] = a[x] * 2;     } }  #ifndef T1 //T1:declare,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     int mult = 2;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x] + fixed_size_array[x%10];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - (a[x] + fixed_size_array[x%10])) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T2 //T2:declare,construct-independent,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     int mult = 2;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(scalar)     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x] + scalar;             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - (a[x] + scalar)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T3 //T3:declare,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     int mult = 2;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      #pragma acc data copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < 1; ++x){                 extern_multiplyData_copyin(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] * 2)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T4 //T4:declare,construct-independent,V:2.0-2.7 int test4(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     int mult = 2;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      #pragma acc data copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < 1; ++x){                 multiplyData(a);             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] * 2)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T5 //T5:declare,construct-independent,attach,V:2.6-2.7 int test5(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     int mult = 2;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      datapointer = a;     #pragma acc enter data copyin(a[0:n]) attach(datapointer)     #pragma acc data present(datapointer[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 datapointer[x] = datapointer[x] * 2;             }         }     }     #pragma acc exit data copyout(a[0:n])      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] * 2)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured x bitor expr assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == (prev | a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] = totals[x/10] | a[x];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] |= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels copyout zero", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data,data-region,V:3.0-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n])     {         #pragma acc kernels copyout(zero: b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] += a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:kernels,data,data-region,devonly,V:3.0-3.1 int test2(){     int err = 0;     srand(SEED);     int * devtest = (int *)malloc(sizeof(int));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc kernels present(devtest[0:1])     {       devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0;         }          #pragma acc data copyin(a[0:n])         {             #pragma acc kernels copyout(zero: b[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] += a[x];                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(a[x] - b[x]) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture expr minus x assign", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE_2(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8), INTENT(IN) :: init         REAL(8),DIMENSION(length), INTENT(IN) :: a         REAL(8),DIMENSION(length), INTENT(IN) :: b         REAL(8),DIMENSION(length - 1) :: passed_a         REAL(8),DIMENSION(length - 1) :: passed_b         REAL(8) :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (abs(b(x) - (a(x) - init)) .GT. ((10 - length) * PRECISION)) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = b(x)             IF (IS_POSSIBLE_2(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE_2        RECURSIVE FUNCTION IS_POSSIBLE(subset, destination, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8),DIMENSION(length), INTENT(IN) :: subset         REAL(8), INTENT(IN) :: destination         REAL(8), INTENT(IN) :: init         REAL(8),ALLOCATABLE :: passed(:)         LOGICAL :: POSSIBLE         INTEGER :: x, y         IF (length .gt. 0) THEN           ALLOCATE(passed(length - 1))         ELSE           IF (abs(init - destination) .gt. PRECISION) THEN             POSSIBLE = .TRUE.           ELSE             POSSIBLE = .FALSE.           END IF           RETURN         END IF         POSSIBLE = .FALSE.         DO x = 1, length           DO y = 1, x - 1             passed(y) = subset(y)           END DO           DO y = x + 1, length             passed(y - 1) = subset(y)           END DO           IF (IS_POSSIBLE(passed, destination, length - 1, subset(x) - init)) THEN             POSSIBLE = .TRUE.             RETURN           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         LOGICAL IS_POSSIBLE         LOGICAL IS_POSSIBLE_2         REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals         REAL(8),DIMENSION(10):: passed_a, passed_b         REAL(8):: init         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   totals(x) = a(x, y) - totals(x)                   b(x, y) = totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)           END DO           IF (IS_POSSIBLE(passed_a, totals(x), 10, 0) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           init = 0           IF (IS_POSSIBLE_2(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture expr eqv x assign", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         LOGICAL, INTENT(IN) :: init         LOGICAL,DIMENSION(length), INTENT(IN) :: a         LOGICAL,DIMENSION(length), INTENT(IN) :: b         LOGICAL,DIMENSION(length - 1) :: passed_a         LOGICAL,DIMENSION(length - 1) :: passed_b         LOGICAL :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (b(x) .eqv. (init .eqv. a(x))) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = b(x)             IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         LOGICAL,DIMENSION(10):: passed_a, passed_b         LOGICAL:: init         INTEGER :: errors = 0         LOGICAL IS_POSSIBLE          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   totals(x) = a(x, y) .EQV. totals(x)                   b(x, y) = totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           init = .FALSE.           IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN             errors = errors + 1           END IF         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction max vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * max = new real_t[10];     real_t temp = 0;     real_t temp_max;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(max[0:10])     {         #pragma acc parallel loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(max:temp)             for (int y = 0; y < n; ++y){                 temp = fmax(a[x * n + y] * b[x * n + y], temp);             }             max[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         temp_max = 0;         for (int y = 0; y < n; ++y){             if (temp_max < a[x * n + y] * b[x * n + y]){                 temp_max = a[x * n + y] * b[x * n + y];             }         }         if (fabs(temp_max - max[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[25 * n];     real_t * b = new real_t[25 * n];     real_t * maximums = new real_t[25];     real_t reduced[5];      for (int x = 0; x < 25 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      for (int x = 0; x < 25; ++x) {         maximums[x] = 0;     }      #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(maximums[0:25])     {         #pragma acc parallel loop private(reduced)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 reduced[y] = 0;             }             #pragma acc loop vector reduction(max:reduced)             for (int y = 0; y < 5 * n; ++y) {                 reduced[y%5] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);             }             for (int y = 0; y < 5; ++y) {                 maximums[x * 5 + y] = reduced[y];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             reduced[y] = 0;         }         for (int y = 0; y < 5 * n; ++y) {             reduced[y%5] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);         }         for (int y = 0; y < 5; ++y) {             if (fabs(maximums[x * 5 + y] - reduced[y]) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop vector", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,vector,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])     {         #pragma acc parallel loop vector         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      for (int x = 0; x < n; ++x){         if(fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction max general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t max = 0.0;     int found = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:n], b[0:n]) copy(max)     {         #pragma acc serial loop reduction(max:max)         for (int x = 0; x < n; ++x){             max = fmax(a[x] * b[x], max);         }     }      for (int x = 0; x < n; ++x){         if (fabs(max - (a[x] * b[x] + PRECISION)) < 0){             err = 1;         }         if (fabs(max - (a[x] * b[x] - PRECISION)) > 0){             found = 1;         }     }     if (found = 0){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature init device type num", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:init,runtime,V:2.5-3.2 int test1(){     int err = 0;     srand(SEED);     int device_num = acc_get_device_num(acc_get_device_type());      #pragma acc init device_type(host) device_num(device_num)      return err; } #endif #ifndef T2 //T1:init,runtime,V:2.5-3.2 int test2(){     int err = 0;     srand(SEED);     int device_num = acc_get_device_num(acc_get_device_type());      #pragma acc init device_type(multicore) device_num(device_num)      return err; } #endif #ifndef T3 //T1:init,runtime,V:2.5-3.2 int test3(){     int err = 0;     srand(SEED);     int device_num = acc_get_device_num(acc_get_device_type());      #pragma acc init device_type(default) device_num(device_num)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }     if (failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }     if (failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }     if (failed){         failcode += (1 << 2);     } #endif      return failcode; } "}
{"prompt": "Create a test for the feature serial implicit data attributes", "completion": "#include \"acc_testsuite.h\"  #ifndef T1 //T1:serial,V:1.0-2.7 //copy cluase test with serial default(none) and reduction with scalar variables int test1(){ \tint err = 0; \tsrand(SEED); \tint temp = rand()/(real_t)(RAND_MAX / 10); \t#pragma acc serial default(none) reduction(+:temp) \tfor(int x = 0; x < n; ++x){ \t\ttemp += temp; \t} \tif(temp > PRECISION){ \t\terr = 1; \t} \treturn err; } #endif #ifndef T2 //T2:serial,V:1.0-2.7 //copy clause test with serial loop and reduction with scalar int test2(){ \tint err = 0; \tsrand(SEED); \tint temp = rand()/(real_t)(RAND_MAX / 10); \t#pragma acc serial loop reduction(+:temp) \tfor(int x = 0; x < n; ++x){ \t\ttemp += temp; \t} \tif(temp > PRECISION){ \t\terr = 1; \t} \treturn err; } #endif #ifndef T3 //T3:serial, firstprivate, V:1.0-2.7 //firstprivate test with only serial and reduction with scalar variables int test3(){ \tint err = 0; \tsrand(SEED); \tint host = rand()/(real_t)(RAND_MAX/10); \tint device = host; \t#pragma acc serial reduction(+:device) \tfor( int x = 0; x < n; ++x){ \t\tdevice += device; \t}  \tif( fabs(host - device) > PRECISION ){ \t\terr = 1; \t} \treturn err; } #endif #ifndef T4 //T4:serial, host_dataV:1.0-2.7 int test4(){ \tint err = 0; \tsrand(SEED);  \treal_t *host_array = new real_t[n];         real_t *device_array = new real_t[n];  \tfor( int x = 0; x < n; ++x){                 host_array[x] = rand()/ (real_t)(RAND_MAX/10);                 device_array[x] = host_array[x];         } \t \t#pragma acc serial loop \tfor ( int x = 0; x < n; ++x){ \t\tdevice_array[x] += device_array[x]; \t} \t \tfor( int x = 0; x < n; ++x){                 if(fabs(host_array[x]*2 - device_array[x]) > PRECISION){                         err = 1;                 }         }         delete[] host_array;         delete[] device_array;         return err; } #endif  int main(){ \tint failcode = 0; \tint failed; #ifndef T1 \tfailed = 0; \tfor( int x = 0; x < NUM_TEST_CALLS; ++x){ \t\tfailed += test1(); \t} \tif(failed){ \t\tfailcode += (1 << 0); \t} #endif #ifndef T2         failed = 0;         for( int x = 0; x < NUM_TEST_CALLS; ++x){                 failed += test2();         }         if(failed){                 failcode += (1 << 1); \t} #endif #ifndef T3         failed = 0;         for( int x = 0; x < NUM_TEST_CALLS; ++x){                 failed += test3();         }         if(failed){                 failcode += (1 << 2);         } #endif #ifndef T4         failed = 0;         for( int x = 0; x < NUM_TEST_CALLS; ++x){                 failed += test4();         }         if(failed){                 failcode += (1 << 3);         } #endif \treturn failcode; } "}
{"prompt": "Create a test for the feature acc get device num", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,devonly,internal-control-values,syntactic,V:1.0-2.7 int test1(){     int err = 0;      if (acc_get_device_type() != acc_device_none){         for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){             acc_set_device_num(x, acc_get_device_type());             if (acc_get_device_num(acc_get_device_type()) != x){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc is present", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,devonly,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      #pragma acc enter data create(a[0:n])     if (acc_is_present(a, n * sizeof(real_t)) == 0){         err += 1;     }     #pragma acc exit data delete(a[0:n])      if (devtest[0] == 1){         if (acc_is_present(a, n * sizeof(real_t)) != 0){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured x bitxor expr assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == (prev ^ a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] = totals[x/10] ^ a[x];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] ^= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc map data", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d;     real_t *e = new real_t[n];      d = (real_t *)acc_malloc(n * sizeof(real_t));     for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      acc_map_data(c, d, n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      #pragma acc update host(c[0:n])     for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x]))> PRECISION){             err += 1;         }     }      acc_unmap_data(c);     acc_free(d);      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d;     real_t *e = new real_t[n];      d = (real_t *)acc_malloc(2 * n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     acc_map_data(c, d, n * sizeof(real_t));     acc_map_data(e, &(d[n]), n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n], e[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 e[x] = a[x] * b[x];             }         }     }      #pragma acc update host(c[0:n])     #pragma acc update host(e[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }         if (fabs(e[x] - (a[x] * b[x])) > PRECISION){             err += 1;         }     }     acc_unmap_data(c);     acc_unmap_data(e);     acc_delete(d, n * sizeof(real_t));      return err; } #endif  #ifndef T3 //T3:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d;     real_t *e = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     d = (real_t *)acc_malloc(n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n]) deviceptr(d)     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 d[x] = a[x] + b[x];             }         }     }      acc_map_data(c, d, n * sizeof(real_t));     #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      #pragma acc update host(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - 2 * (a[x] + b[x])) > 2 * PRECISION){             err += 1;         }     }      acc_unmap_data(c);     acc_delete(d, n * sizeof(real_t));      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction and general", "completion": "#ifndef T1 !T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: randoms         LOGICAL,DIMENSION(LOOPCOUNT):: a !Data         LOGICAL :: results = .TRUE.         LOGICAL :: host_results = .TRUE.         REAL(8) :: false_margin         INTEGER :: errors = 0         false_margin = exp(log(.5) / LOOPCOUNT)         !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           IF (randoms(x) .lt. false_margin) THEN             a(x) = .TRUE.           ELSE             a(x) = .FALSE.           END IF         END DO          !$acc data copyin(a(1:LOOPCOUNT))           !$acc kernels loop reduction(.and.:results)           DO x = 1, LOOPCOUNT             results = results .and. a(x)           END DO         !$acc end data          DO x = 1, LOOPCOUNT           host_results = host_results .and. a(x)         END DO         IF (host_results .neqv. results) THEN           errors = 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic x plus expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = totals(x) + a(x, y)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) + a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction add general type check pt3", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     double _Complex * a = (double _Complex *)malloc(n * sizeof(double _Complex));     double _Complex * b = (double _Complex *)malloc(n * sizeof(double _Complex));     double _Complex total = 10 + 10 * I;     double _Complex host_total = 10 + 10 * I;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;         b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (fabs(creal(total) - creal(host_total)) > PRECISION) {         err += 1;     }     if (fabs(cimag(total) - cimag(host_total)) > PRECISION) {         err += 1;     }      return err; } #endif   #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     long double _Complex * a = (long double _Complex*)malloc(n * sizeof(long double _Complex));     long double _Complex * b = (long double _Complex*)malloc(n * sizeof(long double _Complex));     long double _Complex total = 10 + 10 * I;     long double _Complex host_total = 10 + 10 * I;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;         b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (fabsl(creall(total) - creall(host_total)) > PRECISION) {         err += 1;     }     if (fabsl(cimagl(total) - cimagl(host_total)) > PRECISION) {         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature atomic capture assign min expr x", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8), INTENT(IN) :: init         REAL(8),DIMENSION(length), INTENT(IN) :: a         REAL(8),DIMENSION(length), INTENT(IN) :: b         REAL(8),DIMENSION(length - 1) :: passed_a         REAL(8),DIMENSION(length - 1) :: passed_b         REAL(8) :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (abs(b(x) - init) .gt. (10 - length) * PRECISION) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = min(a(x), init)             IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         REAL(8),DIMENSION(10):: passed_a, passed_b         REAL(8):: init         LOGICAL IS_POSSIBLE         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   b(x, y) = totals(x)                   totals(x) = min(a(x, y), totals(x))                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = min(totals_comparison(x), a(x, y))           END DO         END DO         DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           init = 0           IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature copyin copyout", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:, V:1.0-2.7 int test1(){     int err = 0;     real_t test = 0;     #pragma acc parallel loop copyin(test) copyout(test) reduction(+:test)     for( int x = 0; x <n; ++x){         test += 1;     }      if(fabs(test - n) > PRECISION){         err++;     }      return err; } #endif  #ifndef T2 //T2: , V:1.0-2.7 int test2(){     int err = 0;     real_t *test = (real_t *)malloc(n * sizeof(real_t));      for(int x = 0; x < n; ++x){         test[x] = 1.0;     }     #pragma acc parallel loop copyin(test[0:n]) copyout(test[0:n])    for(int x = 0; x < n; ++x){         test[x] += 1.0;    }     for(int x = 0; x < n; ++x){         if(fabs(test[x] - 2.0) > PRECISION){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for( int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test1();     }     if(failed){ \tfailcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for( int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }     if(failed){         failcode += (1 << 1);     } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature atomic x bitxor expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .5){                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] =  totals[x%(n/10 + 1)] ^ a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] ^= a[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature declare function scope copy", "completion": "FUNCTION copyin_copyout_test(a, b, c, LOOPCOUNT)   REAL(8),DIMENSION(LOOPCOUNT),INTENT(IN) :: a, b   REAL(8),DIMENSION(LOOPCOUNT),INTENT(INOUT) :: c   INTEGER,INTENT(IN) :: LOOPCOUNT   INTEGER :: y   !$acc declare copy(c(1:LOOPCOUNT))   !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))     !$acc loop     DO y = 1, LOOPCOUNT       c(y) = c(y) + a(y) + b(y)     END DO   !$acc end parallel END FUNCTION copyin_copyout_test  #ifndef T1 !T1:devonly,construct-independent,declare,V:2.0-2.7       LOGICAL FUNCTION test1()   USE OPENACC   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c   INTEGER,DIMENSION(1) :: devtest   INTEGER :: x, y    devtest(1) = 1   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = 0   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 1   !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))     DO x = 1, LOOPCOUNT       CALL copyin_copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)     END DO   !$acc end data   DO x = 1, LOOPCOUNT     DO y = 1, LOOPCOUNT       IF (abs(c(x, y) - (1 + a(x, y) + b(x, y))) .gt. PRECISION) THEN         errors = errors + 1       END IF     END DO   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:devonly,construct-independent,declare,V:2.0-2.7       LOGICAL FUNCTION test2()   USE OPENACC   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c   INTEGER,DIMENSION(1) :: devtest   INTEGER :: x, y    devtest(1) = 1   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = 0   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 2    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))     DO x = 1, LOOPCOUNT       !$acc data copy(c(1:LOOPCOUNT, x:x))         CALL copyin_copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)       !$acc end data     END DO   !$acc end data    DO x = 1, LOOPCOUNT     DO y = 1, LOOPCOUNT       IF (abs(c(x, y) - (2 + a(x, y) + b(x, y))) .gt. PRECISION) THEN         errors = errors + 1       END IF     END DO   END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:devonly,construct-independent,declare,V:2.0-2.7       LOGICAL FUNCTION test3()   USE OPENACC   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c   INTEGER,DIMENSION(1) :: devtest   INTEGER :: x, y    devtest(1) = 1   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = 0   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    IF (devtest(1) .eq. 1) THEN     CALL RANDOM_NUMBER(a)     CALL RANDOM_NUMBER(b)     c = 3      !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))       DO x = 1, LOOPCOUNT         !$acc data copyin(c(1:LOOPCOUNT, x:x))           CALL copyin_copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)           DO y = 1, LOOPCOUNT             IF (abs(c(y, x) - 3) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         !$acc end data         DO y = 1, LOOPCOUNT           IF (abs(c(y, x) - 3) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO       END DO     !$acc end data   END IF          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif #ifndef T4 !T4:devonly,construct-independent,declare,V:2.0-2.7       LOGICAL FUNCTION test4()   USE OPENACC   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c   INTEGER,DIMENSION(1) :: devtest   INTEGER :: x, y    devtest(1) = 1   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = 0   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    IF (devtest(1) .eq. 1) THEN     CALL RANDOM_NUMBER(a)     CALL RANDOM_NUMBER(b)     c = 4      !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))       DO x = 1, LOOPCOUNT         !$acc data copy(c(1:LOOPCOUNT, x:x))           CALL copyin_copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)           DO y = 1, LOOPCOUNT             IF (abs(c(y, x) - 4) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         !$acc end data         DO y = 1, LOOPCOUNT           IF (abs(c(y, x) - (4 + a(y, x) + b(y, x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO       END DO     !$acc end data   END IF          IF (errors .eq. 0) THEN           test4 = .FALSE.         ELSE           test4 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif #ifndef T4         LOGICAL :: test4 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif #ifndef T4         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test4()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 3           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update x rshift expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1<<7;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic update                             a[x] = a[x] >> 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<7){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture ior x expr assign", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   INTEGER, INTENT(IN) :: init   INTEGER,DIMENSION(length), INTENT(IN) :: a   INTEGER,DIMENSION(length), INTENT(IN) :: b   INTEGER,DIMENSION(length - 1) :: passed_a   INTEGER,DIMENSION(length - 1) :: passed_b   INTEGER :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (b(x) .eq. ior(init, a(x))) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = b(x)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y, z !Iterators   INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms   INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison   INTEGER,DIMENSION(10):: passed_a, passed_b   INTEGER:: init   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)   a = 0   DO x = 1, LOOPCOUNT     DO y = 1, 10       DO z = 1, 8         IF (randoms(x, y, z) .gt. .933) THEN           a(x, y) = a(x, y) + ISHFT(1, z - 1)         END IF       END DO     END DO   END DO   totals = 0   totals_comparison = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             totals(x) = ior(totals(x), a(x, y))             b(x, y) = totals(x)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data   DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = ior(totals_comparison(x), a(x, y))     END DO   END DO   DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NE. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 0     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);      real_t * a = (real_t *)malloc(1024 * sizeof(real_t));     real_t * b = (real_t *)malloc(1024 * sizeof(real_t));      for (int x = 0; x < 1024; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc kernels loop copy(a[0:1024]) copyout(b[0:1024])     for (int _0 = 0; _0 < 2; ++_0){         #pragma acc loop         for (int _1 = 0; _1 < 2; ++_1){             #pragma acc loop             for (int _2 = 0; _2 < 2; ++_2){                 #pragma acc loop                 for (int _3 = 0; _3 < 2; ++_3){                     #pragma acc loop                     for (int _4 = 0; _4 < 2; ++_4){                         #pragma acc loop                         for (int _5 = 0; _5 < 2; ++_5){                             #pragma acc loop                             for (int _6 = 0; _6 < 2; ++_6){                                 #pragma acc loop                                 for (int _7 = 0; _7 < 2; ++_7){                                     #pragma acc loop                                     for (int _8 = 0; _8 < 2; ++_8){                                         #pragma acc loop                                         for (int _9 = 0; _9 < 2; ++_9){                                             b[_0 * 512 + _1 * 256 + _2 * 128 + _3 * 64 + _4 * 32 + _5 * 16 + _6 * 8 + _7 * 4 + _8 * 2 + _9] = a[_0 * 512 + _1 * 256 + _2 * 128 + _3 * 64 + _4 * 32 + _5 * 16 + _6 * 8 + _7 * 4 + _8 * 2 + _9];                                         }                                     }                                 }                             }                         }                     }                 }             }         }     }      for (int x = 0; x < 1024; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature declare function scope copy", "completion": "#include \"acc_testsuite.h\" void copyin_copyout_test(real_t *a, real_t *b, real_t *c){     #pragma acc declare copy(c[0:n])     #pragma acc parallel present(a[0:n], b[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = c[x] + a[x] + b[x];         }     } }  #ifndef T1 //T1:declare,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));         b[x] = (real_t *)malloc(n * sizeof(real_t));         c[x] = (real_t *)malloc(n * sizeof(real_t));         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 1;         }     }     #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])     {         for (int x = 0; x < n; ++x){             copyin_copyout_test(a[x], b[x], c[x]);         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:declare,construct-independent,reference-counting,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 2;         }     }      #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])     {         for (int x = 0; x < n; ++x){             #pragma acc data copy(c[x:1][0:n])             {                 copyin_copyout_test(a[x], b[x], c[x]);             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             if (fabs(c[x][y] - (2 + a[x][y] + b[x][y])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T3 //T3:declare,construct-independent,devonly,reference-counting,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 a[x][y] = rand() / (real_t)(RAND_MAX / 10);                 b[x][y] = rand() / (real_t)(RAND_MAX / 10);                 c[x][y] = 3;             }         }          #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])         {             for (int x = 0; x < n; ++x){                 #pragma acc data copyin(c[x:1][0:n])                 {                     copyin_copyout_test(a[x], b[x], c[x]);                     for (int y = 0; y < n; ++y){                         if (fabs(c[x][y] - 3) > PRECISION){                             err += 1;                         }                     }                 }                 for (int y = 0; y < n; ++y){                     if (fabs(c[x][y] - 3) > PRECISION){                         err += 1;                     }                 }             }         }     }      return err; } #endif  #ifndef T4 //T4:declare,construct-independent,devonly,reference-counting,V:2.5-2.7 int test4(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[1] == 1){         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 a[x][y] = rand() / (real_t)(RAND_MAX / 10);                 b[x][y] = rand() / (real_t)(RAND_MAX / 10);                 c[x][y] = 4;             }         }          #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])         {             for (int x = 0; x < n; ++x){                 #pragma acc data copy(c[x:1][0:n])                 {                     copyin_copyout_test(a[x], b[x], c[x]);                     for (int y = 0; y < n; ++y){                         if (fabs(c[x][y] - 4) > PRECISION){                             err += 1;                         }                     }                 }                 for (int y = 0; y < n; ++y){                     if (fabs(c[x][y] - (4 + a[x][y] + b[x][y])) > PRECISION){                         err += 1;                     }                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured x minus expr assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (prev - a[x])) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));     real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0; \ttotals_host[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x%10] = totals[x%10] - (a[x] + b[x]);                     c[x] = totals[x%10];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update min x expr list end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture assign ixor x expr", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   INTEGER, INTENT(IN) :: init   INTEGER,DIMENSION(length), INTENT(IN) :: a   INTEGER,DIMENSION(length), INTENT(IN) :: b   INTEGER,DIMENSION(length - 1) :: passed_a   INTEGER,DIMENSION(length - 1) :: passed_b   INTEGER :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (b(x) .eq. init) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = ieor(a(x), init)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7 LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y, z !Iterators   INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms   INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison   INTEGER,DIMENSION(10):: passed_a, passed_b   INTEGER:: init   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)   a = 0   DO x = 1, LOOPCOUNT     DO y = 1, 10       DO z = 1, 8         IF (randoms(x, y, z) .gt. .5) THEN           a(x, y) = a(x, y) + ISHFT(1, z - 1)         END IF       END DO     END DO   END DO   totals = 0   totals_comparison = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             b(x, y) = totals(x)             totals(x) = ieor(totals(x), a(x, y))           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data   DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = ieor(totals_comparison(x), a(x, y))     END DO   END DO   DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NE. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 0     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature set device type", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:set,runtime,syntactic,V:2.5-3.2 int test1(){     int err = 0;      int device_type = acc_get_device_type();      #pragma acc set device_type(host)     if (acc_get_device_type() != device_type){         err += 1;     }      return err; } #endif #ifndef T2 //T2:set,runtime,syntactic,V:2.5-3.2 int test2(){     int err = 0;      int device_type = acc_get_device_type();      #pragma acc set device_type(multicore)     if (acc_get_device_type() != device_type){         err += 1;     }      return err; } #endif #ifndef T3 //T3:set,runtime,syntactic,V:2.5-3.2 int test3(){     int err = 0;      int device_type = acc_get_device_type();      #pragma acc set device_type(default)     if (acc_get_device_type() != device_type){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature set device type num nvidia", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:set,runtime,syntactic,V:2.5-3.2 int test1(){         int err = 0;         int device_num;          device_num = acc_get_device_num(acc_get_device_type());         #pragma acc set device_type(nvidia) device_num(device_num)          return err; } #endif  int main(){     \tint failcode = 0;     \tint failed; #ifndef T1     \tfailed = 0;     \tfor (int x = 0; x < NUM_TEST_CALLS; ++x){         \tfailed = failed + test1();     \t}     \tif (failed != 0){         \tfailcode = failcode + (1 << 0);     \t} #endif     \treturn failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction or general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(n * sizeof(char));     real_t false_margin = pow(exp(1), log(.5)/n);     char result = 0;     char found = 0;      for (int x = 0; x < n; ++x){         if(rand() / (real_t)(RAND_MAX) > false_margin){             a[x] = 1;         }         else{             a[x] = 0;         }     }       #pragma acc data copyin(a[0:n])     {         #pragma acc serial loop reduction(||:result)         for (int x = 0; x < n; ++x){             result = result || a[x];         }     }      for (int x = 0; x < n; ++x){         if (a[x] == 1){             found = 1;         }     }     if (found != result){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic bitor equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] |= a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] |= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured x bitand expr assign", "completion": "#include \"acc_testsuite.h\"  bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == (prev & a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] = totals[x/10] & a[x];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] &= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign x multiply expr", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, a[x] * prev)){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t * passed_ab = new real_t[10];     real_t * passed_c = new real_t[10];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x%(n/10 + 1)];                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic ior x expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .lt. .933) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           totals(x) = 0           totals_comparison(x) = 0         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic expr minus x end", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(subset, destination, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8),DIMENSION(length), INTENT(IN) :: subset         REAL(8), INTENT(IN) :: destination         REAL(8), INTENT(IN) :: init         REAL(8),ALLOCATABLE :: passed(:)         LOGICAL :: POSSIBLE         INTEGER :: x, y         IF (length .gt. 0) THEN           ALLOCATE(passed(length - 1))         ELSE           IF (abs(init - destination) .gt. PRECISION) THEN             POSSIBLE = .TRUE.           ELSE             POSSIBLE = .FALSE.           END IF           RETURN         END IF         POSSIBLE = .FALSE.         DO x = 1, length           DO y = 1, x - 1             passed(y) = subset(y)           END DO           DO y = x + 1, length             passed(y - 1) = subset(y)           END DO           IF (IS_POSSIBLE(passed, destination, length - 1, subset(x) - init)) THEN             POSSIBLE = .TRUE.             RETURN           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         LOGICAL IS_POSSIBLE         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals         INTEGER :: errors = 0         REAL(8),DIMENSION(10):: passed          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = a(x, y) - totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed(y) = a(x, y)           END DO           IF (IS_POSSIBLE(passed, totals(x), 10, 0) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update max expr x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature init device type nvidia", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:init,runtime,V:2.5-3.2 int test1(){     int err = 0;     srand(SEED);      #pragma acc init device_type(nvidia)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }     if (failed){         failcode += (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction max loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * maximum = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 0;     real_t max = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);         c[x] = 0.0;     }     for (int x = 0; x < 10; ++x){         maximum[x] = 0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], maximum[0:10])     {         #pragma acc kernels loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(max:temp)             for (int y = 0; y < n; ++y){                 temp = fmax(a[x * n + y] * b[x * n + y], temp);             }             maximum[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 c[x * n + y] = (a[x * n + y] * b[x * n + y]) / maximum[x];             }         }     }     for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = fmax(temp, a[x * n + y] * b[x * n + y]);         }         if (fabs(temp - maximum[x]) > PRECISION){             err += 1;         }         for (int y = 0; y < n; ++y){             if (c[x * n + y] > 1){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture expr bitxor x", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == (a[x]^prev)){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *passed_a = new int[10];     int *passed_b = new int[10];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .5){                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     b[x] = totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] ^= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_a[passed_indexer] = a[absolute_indexer];             passed_b[passed_indexer] = b[absolute_indexer];         }         if (!(is_possible(passed_a, passed_b, passed_indexer, 0))){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel while loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,syntactic,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t avg = 0.0;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         avg += a[x]/(n * 10);     }      #pragma acc data copy(a[0:10*n])     {         #pragma acc parallel         {             real_t avg = 0.0;             #pragma acc loop             for (int y = 0; y < 10; ++y){                 avg = 0.0;                 while (avg - 1000 < PRECISION * n){                     avg = 0.0;                     #pragma acc loop reduction(+:avg)                     for (int x = 0; x < n; ++x){                         a[n * y + x] *= 1.5;                         avg += a[n * y + x] / n;                     }                 }             }         }     }      avg = 0.0;     for (int x = 0; x < n; ++x){         avg += a[x]/n;     }      if (avg < 1000 || avg > 1600){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc update self async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));      int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = 0;     }        #pragma acc data create(c[0:n], d[0:n]) copyin(a[0:n], b[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 d[x] = a[x] * b[x];             }         }         acc_update_self_async(c, n * sizeof(real_t), 1);         acc_update_self_async(d, n * sizeof(real_t), 2);         #pragma acc wait     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }         if (fabs(d[x] - (a[x] * b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7 int test2(){ \tint err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));      int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0;         }          #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])         {             #pragma acc parallel async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     a[x] = a[x] * a[x];                 }             }             acc_update_self_async(a, n * sizeof(real_t), 1);             #pragma acc parallel async(2)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = b[x] * b[x];                 }             }             acc_update_self_async(b, n * sizeof(real_t), 2);             #pragma acc parallel async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     a[x] = a[x] + 1;                 }             }             #pragma acc parallel async(2)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = b[x] + 1;                 }             }             #pragma acc parallel async(1) wait(2)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] * b[x];                 }             }             #pragma acc wait(1)         }           for (int x = 0; x < n; ++x){             if (fabs(c[x] - ((a[x] + 1) * (b[x] + 1))) > 4 * PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update x bitxor expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .5){                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] =  totals[x%(n/10 + 1)] ^ a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] ^= a[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc memcpy device", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *hostdata = (real_t *)malloc(3 * n * sizeof(real_t));     real_t *devdata;      for (int x = 0; x < n; ++x){         hostdata[x] = rand() / (real_t)(RAND_MAX / 10);         hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);         hostdata[2*n + x] = 1;     }      devdata = acc_copyin(hostdata, 3 * n * sizeof(real_t));     #pragma acc enter data create(a[0:n], b[0:n], c[0:n])     acc_memcpy_device(acc_deviceptr(a), devdata, n * sizeof(real_t));     acc_memcpy_device(acc_deviceptr(b), devdata+n, n * sizeof(real_t));     acc_memcpy_device(acc_deviceptr(c), devdata+2*n, n * sizeof(real_t));      #pragma acc data present(a[0:n], b[0:n], c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      #pragma acc exit data copyout(a[0:n], b[0:n], c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(a[x] - hostdata[x]) > PRECISION){             err += 1;         }         if (fabs(b[x] - hostdata[n + x]) > PRECISION){             err += 1;         }         if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){             err += 1;         }     }      #pragma acc exit data delete(hostdata[0:3*n])      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc wait", "completion": "#ifndef T1 !T1:runtime,async,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(d)         e = 0          !$acc enter data  copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT)) async(1)         !$acc enter data copyin(d(1:LOOPCOUNT)) create(e(1:LOOPCOUNT)) async(2)         !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) async(1)           !$acc loop           DO x = 1, LOOPCOUNT             c(x) = a(x) + b(x)           END DO         !$acc end parallel         !$acc parallel present(c(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) async(1) wait(2)           !$acc loop           DO x = 1, LOOPCOUNT             e(x) = c(x) + d(x)           END DO         !$acc end parallel         !$acc exit data copyout(e(1:LOOPCOUNT)) async(1)          CALL acc_wait(1)          DO x = 1, LOOPCOUNT           IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT), d(1:LOOPCOUNT))          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction min vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * min = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 100;     real_t temp_min;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(min[0:10])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 100;             #pragma acc loop vector reduction(min:temp)             for (int y = 0; y < n; ++y){                 temp = fmin(a[x * n + y] * b[x * n + y], temp);             }             min[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         temp_min = 100;         for (int y = 0; y < n; ++y){             if (temp_min > a[x * n + y] * b[x * n + y]){                 temp_min = a[x * n + y] * b[x * n + y];             }         }         if (fabs(temp_min - min[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));     real_t * minimums = (real_t *)malloc(25 * sizeof(real_t));     real_t reduced[5];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(minimums[0:25])     {         #pragma acc parallel loop gang private(reduced)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 reduced[y] = 1000;             }             #pragma acc loop vector reduction(min:reduced)             for (int y = 0; y < 5 * n; ++y) {                 reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y % 5]);             }             for (int y = 0; y < 5; ++y) {                 minimums[x * 5 + y] = reduced[y];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             reduced[y] = 1000;         }         for (int y = 0; y < 5 * n; ++y) {             reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y % 5]);         }         for (int y = 0; y < 5; ++y) {             if (fabs(reduced[y] - minimums[x * 5 + y]) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine worker", "completion": "#include \"acc_testsuite.h\" void test_routine_worker_loop_named(real_t ** a, real_t * b, long long n); void test_routine_worker_worker_named(real_t ** a, real_t * b, long long n); void test_routine_worker_vector_named(real_t ** a, real_t * b, long long n); void test_routine_worker_seq_named(real_t ** a, real_t * b, long long n);  #pragma acc routine(test_routine_worker_loop_named) worker #pragma acc routine(test_routine_worker_worker_named) worker #pragma acc routine(test_routine_worker_vector_named) worker #pragma acc routine(test_routine_worker_seq_named) worker   #pragma acc routine worker real_t called_function_worker(real_t **a, int x, long long n){     real_t returned = 0;     #pragma acc loop worker reduction(+:returned)     for (int y = 0; y < n; ++y){         returned += a[x][y];     }     return returned; }  #pragma acc routine vector real_t called_function_vector(real_t **a, int x, long long n){     real_t returned = 0;     #pragma acc loop vector reduction(+:returned)     for (int y = 0; y < n; ++y){         returned += a[x][y];     }     return returned; }  #pragma acc routine seq real_t called_function_seq(real_t **a, int x, long long n){     real_t returned = 0;     #pragma acc loop seq reduction(+:returned)     for (int y = 0; y < n; ++y){         returned += a[x][y];     }     return returned; }  #pragma acc routine worker void test_routine_worker_loop_unnamed(real_t ** a, real_t * b, long long n){     #pragma acc loop worker     for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             b[x] += a[x][y];         }     } }  #pragma acc routine worker void test_routine_worker_worker_unnamed(real_t ** a, real_t * b, long long n){   for (int x = 0; x < n; ++x){         b[x] = called_function_worker(a, x, n);     } }  #pragma acc routine worker void test_routine_worker_vector_unnamed(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_vector(a, x, n);     } }  #pragma acc routine worker void test_routine_worker_seq_unnamed(real_t ** a, real_t *b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_seq(a, x, n);     } }  void test_routine_worker_loop_named(real_t ** a, real_t * b, long long n){     #pragma acc loop worker     for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             b[x] += a[x][y];         }     } }  void test_routine_worker_worker_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_worker(a, x, n);     } }  void test_routine_worker_vector_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_vector(a, x, n);     } }  void test_routine_worker_seq_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_seq(a, x, n);     } }  bool validate_data(real_t ** a, real_t * b){     real_t local_total;     for (int x = 0; x < n; ++x){         local_total = 0;         for (int y = 0; y < n; ++y){             local_total += a[x][y];         }         if (fabs(b[x] - local_total) > PRECISION){             return true;         }     }     return false; }  #ifndef T1 //T1:routine,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {               test_routine_worker_loop_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T2 //T2:routine,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_worker_loop_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T3 //T3:routine,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_worker_worker_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T4 //T4:routine,construct-independent,V:2.0-2.7 int test4(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_worker_worker_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T5 //T5:routine,construct-independent,V:2.0-2.7 int test5(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_worker_vector_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T6 //T6:routine,construct-independent,V:2.0-2.7 int test6(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_worker_vector_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T7 //T7:routine,construct-independent,V:2.0-2.7 int test7(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_worker_seq_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T8 //T8:routine,construct-independent,V:2.0-2.7 int test8(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_worker_seq_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif #ifndef T6     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test6();     }     if (failed != 0){         failcode = failcode + (1 << 5);     } #endif #ifndef T7     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test7();     }     if (failed != 0){         failcode = failcode + (1 << 6);     } #endif #ifndef T8     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test8();     }     if (failed != 0){         failcode = failcode + (1 << 7);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x rshift expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1<<7;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic                             a[x] = a[x] >> 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<7){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature shutdown device type", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,shutdown,nonvalidating,V:2.5-3.2       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: errors = 0          !$acc shutdown device_type(host)          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,construct-independent,internal-control-values,shutdown,nonvalidating,V:2.5-3.2       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: errors = 0          !$acc shutdown device_type(multicore)          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:runtime,construct-independent,internal-control-values,shutdown,nonvalidating,V:2.5-3.2       LOGICAL FUNCTION test3()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: errors = 0          !$acc shutdown device_type(default)          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM shutdown_device_type         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture min expr list x assign", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, c, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8), INTENT(IN) :: init         REAL(8),DIMENSION(length), INTENT(IN) :: a         REAL(8),DIMENSION(length), INTENT(IN) :: b         REAL(8),DIMENSION(length), INTENT(IN) :: c         REAL(8),DIMENSION(length - 1) :: passed_a         REAL(8),DIMENSION(length - 1) :: passed_b         REAL(8),DIMENSION(length - 1) :: passed_c         REAL(8) :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (abs(c(x) - min(init, a(x), b(x))) .gt. (10 - length) * PRECISION) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = c(x)             IF (IS_POSSIBLE(passed_a, passed_b, passed_c, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c         REAL(8):: init         LOGICAL IS_POSSIBLE         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   totals(x) = min(a(x, y), b(x, y), totals(x))                   c(x, y) = totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = min(totals_comparison(x), a(x, y), b(x, y))           END DO         END DO         DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)             passed_c(y) = c(x, y)           END DO           init = 0           IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture assign x minus expr", "completion": "RECURSIVE FUNCTION IS_POSSIBLE_2(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   REAL(8), INTENT(IN) :: init   REAL(8),DIMENSION(length), INTENT(IN) :: a   REAL(8),DIMENSION(length), INTENT(IN) :: b   REAL(8),DIMENSION(length - 1) :: passed_a   REAL(8),DIMENSION(length - 1) :: passed_b   REAL(8) :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (abs(b(x) - init) .GT. ((10 - length) * PRECISION)) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = init - a(x)       IF (IS_POSSIBLE_2(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE_2  RECURSIVE FUNCTION IS_POSSIBLE(subset, destination, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   REAL(8),DIMENSION(length), INTENT(IN) :: subset   REAL(8), INTENT(IN) :: destination   REAL(8), INTENT(IN) :: init   REAL(8),ALLOCATABLE :: passed(:)   LOGICAL :: POSSIBLE   INTEGER :: x, y   IF (length .gt. 0) THEN     ALLOCATE(passed(length - 1))   ELSE     IF (abs(init - destination) .gt. PRECISION) THEN       POSSIBLE = .TRUE.     ELSE       POSSIBLE = .FALSE.     END IF     RETURN   END IF   POSSIBLE = .FALSE.   DO x = 1, length     DO y = 1, x - 1       passed(y) = subset(y)     END DO     DO y = x + 1, length       passed(y - 1) = subset(y)     END DO     IF (IS_POSSIBLE(passed, destination, length - 1, init - subset(x))) THEN       POSSIBLE = .TRUE.       RETURN     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   LOGICAL IS_POSSIBLE   LOGICAL IS_POSSIBLE_2   REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT):: totals   REAL(8),DIMENSION(10):: passed_a, passed_b   REAL(8):: init   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)    totals = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             b(x, y) = totals(x)             totals(x) = totals(x) - a(x, y)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)     END DO     IF (IS_POSSIBLE(passed_a, totals(x), 10, 0) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 0     IF (IS_POSSIBLE_2(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature declare device resident", "completion": "#include \"acc_testsuite.h\" #define DECLARE_TEST #define DECLARE_DEVICE_RESIDENT #include \"acc_testsuite_declare.h\" #pragma acc declare device_resident(fixed_size_array) #pragma acc declare device_resident(scalar) #pragma acc declare device_resident(datapointer)  int mult_device_resident = 5;  #ifndef T1 //T1:declare,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     int mult = 2;      #pragma acc parallel     {       mult_device_resident = 2;       scalar = 10;       for (int x = 0; x < 10; ++x){         fixed_size_array[x] = x*x;       }     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < 10; ++x){                 fixed_size_array[x] = x*x;             }         }         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x] + fixed_size_array[x%10];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - (a[x] + (x%10) * (x%10))) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T2 //T2:declare,construct-independent,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     int mult = 2;      #pragma acc parallel     {       mult_device_resident = 2;       scalar = 10;       for (int x = 0; x < 10; ++x){         fixed_size_array[x] = x*x;       }     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x] + scalar;             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - (a[x] + 10)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T3 //T3:declare,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     int mult = 2;      #pragma acc parallel     {       mult_device_resident = 2;       scalar = 10;       for (int x = 0; x < 10; ++x){         fixed_size_array[x] = x*x;       }     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      #pragma acc data copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < 1; ++x){                 extern_multiplyData_device_resident(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] * 2)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update ixor x expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .lt. .5) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           totals(x) = 0           totals_comparison(x) = 0         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture x and expr assign", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   LOGICAL,DIMENSION(length), INTENT(IN) :: a   LOGICAL,DIMENSION(length), INTENT(IN) :: b   LOGICAL, INTENT(IN) :: init   LOGICAL,DIMENSION(length - 1) :: passed_a   LOGICAL,DIMENSION(length - 1) :: passed_b   LOGICAL :: POSSIBLE, holder   INTEGER :: x, y   IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.   DO x = 1, length     IF (b(x) .eqv. (a(x) .AND. init)) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = b(x)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms   LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data   LOGICAL,DIMENSION(10):: passed_a, passed_b   LOGICAL IS_POSSIBLE   LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison   INTEGER :: errors = 0   LOGICAL :: init    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)   DO x = 1, LOOPCOUNT     DO y = 1, 10       IF (randoms(x, y) < .933) THEN         a(x, y) = .TRUE.       ELSE         a(x, y) = .FALSE.       END IF     END DO   END DO    totals = .FALSE.   totals_comparison = .FALSE.    !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             totals(x) = totals(x) .AND. a(x, y)             b(x, y) = totals(x)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = totals_comparison(x) .AND. a(x, y)     END DO   END DO    DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NEQV. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = .FALSE.     IF (.FALSE. .eqv. IS_POSSIBLE(a(x, 1:10), b(x, 1:10), 10, .FALSE.)) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop worker blocking", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t multiplyer = 1;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])     {       #pragma acc serial       {         #pragma acc loop worker         for (int x = 0; x < n; ++x){           c[x] = (a[x] + b[x]) * multiplyer;         }         multiplyer += 1;         #pragma acc loop worker         for (int x = 0; x < n; ++x){           c[x] += (a[x] + b[x]) * multiplyer;         }       }     }      for (int x = 0; x < n; ++x){       if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){         err += 1;         break;       }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction min vector loop", "completion": "#ifndef T1 !T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y!Iterators         REAL(8),DIMENSION(10*LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(10):: minimum         REAL(8):: temp = 1000         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(minimum(1:10))           !$acc kernels loop gang private(temp)           DO x = 0, 9             temp = 1000             !$acc loop vector reduction(min:temp)             DO y = 1, LOOPCOUNT               temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))             END DO             minimum(x + 1) = temp           END DO         !$acc end data          DO x = 0, 9           temp = 1000           DO y = 1, LOOPCOUNT             temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))           END DO           IF (abs(temp - minimum(x + 1)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic expr bitxor x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .5){                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] ^= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture plus equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] + prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t *passed_ab = new real_t[10];     real_t *passed_c = new real_t[10];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = totals[x%(n/10 + 1)] += a[x] * b[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] += a[x] * b[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){             passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel deviceptr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,runtime,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b;      for (int x = 0; x < n; ++x){         a[x] = 0;     }      #pragma acc enter data copyin(a[0:n])     b = (real_t *) acc_deviceptr(a);     if (b == NULL){         err = 1;     }     else{         #pragma acc parallel deviceptr(b)         {             #pragma acc loop             for (int x = 0; x < (int) n/2; ++x){                 b[x] = 1;             }         }         #pragma acc exit data copyout(a[0:n])     }     for (int x = 0; x < n; ++x){         if (x < (int) n/2){             if (fabs(a[x] - 1) > PRECISION){                 err = 1;             }         }         else {             if (fabs(a[x]) > PRECISION){                 err = 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign divided equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_c = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(c[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];                 passed_c[y] = c[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];                 passed_c[y - 1] = c[y];             }             if (is_possible(passed_a, passed_b, passed_c, length - 1, prev / (a[x] + b[x]))){                 free(passed_a);                 free(passed_b);                 free(passed_c);                 return true;             }         }     }     free(passed_a);     free(passed_b);     free(passed_c);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));     real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));     real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x/10];                     totals[x/10] /= (a[x] + b[x]);                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];             temp_c[temp_iterator] = c[ab_iterator];             temp_iterator++;         }         if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update expr minus x", "completion": "#include \"acc_testsuite.h\" bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){     if (length == 0){         if (fabs(current_value - test_value) > PRECISION){             return true;         }         else {             return false;         }     }     real_t * passed = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         for (int y = 0; y < x; ++y){             passed[y] = remaining_combinations[y];         }         for (int y = x + 1; y < length; ++y){             passed[y - 1] = remaining_combinations[y];         }         if (possible_result(passed, length - 1, remaining_combinations[x] - current_value, test_value)){             free(passed);             return true;         }     }     free(passed);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(((n/10) + 1) * sizeof(real_t));     int indexer = 0;     real_t * passed = (real_t *)malloc(10 * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < (n/10) + 1; ++x){         totals[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];             }         }     }     for (int x = 0; x < (n/10) + 1; ++x){         indexer = x;         while (indexer < n){             passed[indexer/((int) (n/10) + 1)] = a[indexer];             indexer += (n/10) + 1;         }         if (!(possible_result(passed, 10, 0, totals[x]))){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature enter exit data if", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,construct-independent,if,reference-counting,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int dev = 1;     int host = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n]) if(dev)     #pragma acc data create(a[0:n], b[0:n]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }     #pragma acc exit data delete(a[0:n], b[0:n]) if(dev)      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:data,executable-data,construct-independent,if,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int dev = 1;     int host = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data create(a[0:n], b[0:n]) if(host)     #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }     #pragma acc exit data delete(a[0:n], b[0:n]) if(host)      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:data,executable-data,construct-independent,devonly,if,reference-counting,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * a_copy = new real_t[n];     real_t * b = new real_t[n];     real_t * b_copy = new real_t[n];     real_t * c = new real_t[n];     int dev = 1;     int host = 0;     int * devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             a_copy[x] = a[x];             b[x] = rand() / (real_t)(RAND_MAX / 10);             b_copy[x] = b[x];             c[x] = 0.0;         }          #pragma acc enter data copyin(a[0:n], b[0:n]) if(dev)         for (int x = 0; x < n; ++x){             a[x] = 0;             b[x] = 0;         }         #pragma acc data create(a[0:n], b[0:n]) copyout(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] + b[x];                 }             }         }         #pragma acc exit data copyout(a[0:n], b[0:n]) if(dev)          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T4 //T4:data,executable-data,if,construct-independent,devonly,V:2.0-2.7 int test4(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * a_copy = new real_t[n];     real_t * b = new real_t[n];     real_t * b_copy = new real_t[n];     real_t * c = new real_t[n];     int dev = 1;     int host = 0;     int * devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0.0;         }          #pragma acc enter data copyin(a[0:n], b[0:n]) if(host)         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             a_copy[x] = a[x];             b[x] = rand() / (real_t)(RAND_MAX / 10);             b_copy[x] = b[x];         }         #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] + b[x];                 }             }         }         #pragma acc exit data copyout(a[0:n], b[0:n]) if(host)          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T5 //T5:data,executable-data,if,construct-independent,devonly,V:2.0-2.7 int test5(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * a_copy = new real_t[n];     real_t * b = new real_t[n];     real_t * b_copy = new real_t[n];     real_t * c = new real_t[n];     int dev = 1;     int host = 0;     int * devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0.0;         }          #pragma acc enter data create(a[0:n], b[0:n]) if(host)         #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] + b[x];                 }             }         }         #pragma acc exit data copyout(a[0:n], b[0:n]) if(host)          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc copyout", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      acc_create(c, n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      acc_copyout(c, n * sizeof(real_t));      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data create(c[0:n])      #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      acc_copyout(c, n * sizeof(real_t));      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc init device", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:routine,init,runtime,syntactic,V:3.2-3.3 int test1(){     int err = 0;      if (acc_get_device_type() != acc_device_none){         acc_init_device(1, acc_get_device_type());     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature atomic capture expr bitor x", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == (a[x]|prev)){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *passed_a = (int *)malloc(10 * sizeof(int));     int *passed_b = (int *)malloc(10 * sizeof(int));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){ \ta[x] = 0;         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0; \ttotals_comparison[x] = 0;      }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1], b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     b[x] = totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] |= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }     for (int x = 0; x < (n/10 + 1); ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_a[passed_indexer] = a[absolute_indexer];             passed_b[passed_indexer] = b[absolute_indexer];         }         if (!is_possible(passed_a, passed_b, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data with changing subscript", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,data-region,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int length = n;     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:length], b[0:length]) copyout(c[0:length])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < length; ++x){                 c[x] = a[x] + b[x];             }         }         length = 1;     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature declare copyin", "completion": "#define DECLARE_TEST #define DECLARE_COPYIN int mult_copyin = 2; #include \"acc_testsuite_declare.h\" #include \"acc_testsuite.h\"  #pragma acc declare copyin(fixed_size_array) #pragma acc declare copyin(scalar) #pragma acc declare copyin(datapointer) #pragma acc declare copyin(n) #pragma acc routine vector void multiplyData(real_t *a){     #pragma acc loop vector     for (int x = 0; x < n; ++x){         a[x] = a[x] * 2;     } }  #ifndef T1 //T1:declare,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int mult = 2;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x] + fixed_size_array[x%10];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - (a[x] + fixed_size_array[x%10])) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T2 //T2:declare,construct-independent,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int mult = 2;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(scalar)     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x] + scalar;             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - (a[x] + scalar)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T3 //T3:declare,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int mult = 2;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      #pragma acc data copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < 1; ++x){                 extern_multiplyData_copyin(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] * 2)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T4 //T4:declare,construct-independent,V:2.0-2.7 int test4(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int mult = 2;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      #pragma acc data copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < 1; ++x){                 multiplyData(a);             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] * 2)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T5 //T5:declare,construct-independent,attach,V:2.6-2.7 int test5(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int mult = 2;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      datapointer = a;     #pragma acc enter data copyin(a[0:n]) attach(datapointer)     #pragma acc data present(datapointer[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 datapointer[x] = datapointer[x] * 2;             }         }     }     #pragma acc exit data copyout(a[0:n])      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] * 2)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial while loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,reduction,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t avg = 0.0;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(a[0:10*n])     {         #pragma acc serial         {             #pragma acc loop             for (int y = 0; y < 10; ++y){                 avg = 0.0;                 while (avg - 1000 < PRECISION * n){                     avg = 0.0;                     #pragma acc loop reduction(+:avg)                     for (int x = 0; x < n; ++x){                         a[n * y + x] *= 1.5;                         avg += a[n * y + x] / n;                     }                 }             }         }     }      for (int y = 0; y < 10; ++y){         avg = 0.0;         for (int x = 0; x < n; ++x){             avg += a[y * n + x]/n;         }          if (avg < 1000 || avg > 1500){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update bitxor equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .5){                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] ^= a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] ^= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign x bitor expr", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev | a[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         b[x] = totals[x/10];                         totals[x/10] = totals[x/10] | a[x];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] |= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel reduction", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,reduction,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t reduction;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc parallel copyin(a[0:n]) reduction(+:reduction)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             reduction = reduction + a[x];         }     }      for (int x = 0; x < n; ++x){         reduction = reduction - a[x];     }     if (fabs(reduction) > PRECISION){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial if", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,if,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int accel = 1;     int host = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }     #pragma acc serial if(host)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:serial,if,devonly,V:2.6-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int accel = 1;     int host = 0;     int * devtest = (int *)malloc(sizeof(int));     devtest[0] = 1;     #pragma acc data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {       devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0;         }         #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])         #pragma acc serial if(host) present(a[0:n], b[0:n], c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }         #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])          for (int x = 0; x < n; ++x){             if (fabs(c[x]) > PRECISION){                 err = 1;             }         }     }      return err; } #endif  #ifndef T3 //T3:serial,if,V:2.6-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int accel = 1;     int host = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }     #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])     #pragma acc serial if(accel) present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] += a[x] + b[x];         }     }      #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION * 2){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign minus equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev - a[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[10];     real_t *totals_host = new real_t[10];     real_t * passed_ab = new real_t[(n/10 + 1)];     real_t * passed_c = new real_t[(n/10 + 1)];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0; \ttotals_host[x] =0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x%10];                     totals[x%10] -= (a[x] + b[x]);                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign x minus expr", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev - a[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[10];     real_t *totals_host = new real_t[10];     real_t * passed_ab = new real_t[(n/10 + 1)];     real_t * passed_c = new real_t[(n/10 + 1)];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_host[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x%10]; totals[x%10] = totals[x%10] - (a[x] + b[x]);                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature shutdown device type num nvidia", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:shutdown,runtime,syntactic,V:2.5-2.7 int test1(){     int err = 0;     int device_num;      device_num = acc_get_device_num(acc_get_device_type());     #pragma acc shutdown device_type(nvidia) device_num(device_num)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction multiply loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     int m_n = 128;     srand(SEED);     real_t * a = new real_t[10 * m_n];     real_t * b = new real_t[10 * m_n];     real_t * c = new real_t[10 * m_n];     real_t * totals = new real_t[10];     real_t temp;      for (int x = 0; x < 10 * m_n; ++x){         a[x] = .05 + rand() / (real_t)(RAND_MAX);         b[x] = .05 + rand() / (real_t)(RAND_MAX);         c[x] = 0.0;     }       #pragma acc data copyin(a[0:10*m_n], b[0:10*m_n]) copyout(c[0:10*m_n], totals[0:10])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop worker reduction(*:temp)             for (int y = 0; y < m_n; ++y){                 temp *= a[x * m_n + y] + b[x * m_n + y];             }             totals[x] = temp;             #pragma acc loop worker             for (int y = 0; y < m_n; ++y){                 c[x * m_n + y] = (a[x * m_n + y] + b[x * m_n + y]) / totals[x];             }         }     }      for (int x = 0; x < 10; ++x){         temp = 1;         for (int y = 0; y < m_n; ++y){             temp *= a[x * m_n + y] + b[x * m_n + y];         }         if (fabs(temp - totals[x]) > (temp / 2 + totals[x] / 2) * PRECISION){             err += 1;         }         for (int y = 0; y < m_n; ++y){             if (fabs(c[x * m_n + y] - ((a[x * m_n + y] + b[x * m_n + y]) / totals[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     int m_n = 128;     srand(SEED);     real_t * a = new real_t[25 * m_n];     real_t * b = new real_t[25 * m_n];     real_t * c = new real_t[25 * m_n];      real_t * totals = new real_t[25];     real_t reduced[5];      for (int x = 0; x < n; ++x){         a[x] = .05 + rand() / (real_t)(RAND_MAX / 10);         b[x] = .05 + rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc data copyin(a[0:25*m_n], b[0:25*m_n]) copyout(c[0:25*m_n], totals[0:25])     {         #pragma acc parallel loop gang private(reduced)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 reduced[y] = 1.0;             }             #pragma acc loop worker reduction(*:reduced)             for (int y = 0; y < 5 * m_n; ++y) {                 reduced[y%5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];             }             for (int y = 0; y < 5; ++y) {                 totals[x * 5 + y] = reduced[y];             }             for (int y = 0; y < 5 * m_n; ++y) {                 c[x * 5 * m_n + y] = (a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[x * 5 + (y%5)];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             reduced[y] = 1;         }         for (int y = 0; y < 5 * m_n; ++y) {             reduced[y%5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];         }         for (int y = 0; y < 5; ++y) {             if (fabs(totals[x * 5 + y] - reduced[y]) > PRECISION) {                 err += 1;             }         }         for (int y = 0; y < 5 * m_n; ++y) {             if (fabs(c[x * 5 * m_n + y] - ((a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[x * 5 + (y % 5)])) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr times x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = a(x, y) * totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) * a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial wait", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,executable-data,async,wait,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      #pragma acc enter data create(a[0:n])     #pragma acc update device(a[0:n]) async(1)     #pragma acc serial present(a[0:n]) wait(1)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             a[x] += 1;         }     }     #pragma acc exit data copyout(a[0:n])     for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] + 1)) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction min loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10 * n];     real_t * minimum = new real_t[10];     real_t temp = 0;      for (int x = 0; x < 10 * n; ++x){         a[x] = 1 + rand() / (real_t)(RAND_MAX/10);         b[x] = 1 + rand() / (real_t)(RAND_MAX/10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], minimum[0:10])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1000;             #pragma acc loop reduction(min:temp)             for (int y = 0; y < n; ++y){                 temp = fmin(a[x * n + y] * b[x * n + y], temp);             }             minimum[x] = temp;             #pragma acc loop             for (int y = 0; y < n; ++y){                 c[x * n + y] = (a[x * n + y] * b[x * n + y]) / minimum[x];             }         }     }      for (int x = 0; x < 10; ++x){         temp = 1000;         for (int y = 0; y < n; ++y){             temp = fmin(temp, a[x * n + y] * b[x * n + y]);         }         if (fabs(temp - minimum[x]) > PRECISION){             err += 1;         }         for (int y = 0; y < n; ++y){             if (fabs(c[x * n + y] - (a[x * n + y] * b[x * n + y] / minimum[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[25 * n];     real_t * b = new real_t[25 * n];     real_t * c = new real_t[25 * n];     real_t minimums[25];     real_t host_minimums[25];     real_t reduced[5];      for (int x = 0; x < n; ++x){         a[x] = 1 + rand() / (real_t)(RAND_MAX / 10);         b[x] = 1 + rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(minimums[0:25], c[0:25*n])     {         #pragma acc parallel loop gang private(reduced)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 reduced[y] = 1000;             }             #pragma acc loop reduction(min:reduced)             for (int y = 0; y < 5 * n; ++y) {                 reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);             }             for (int y = 0; y < 5; ++y) {                 minimums[x * 5 + y] = reduced[y];             }             #pragma acc loop             for (int y = 0; y < 5 * n; ++y) {                 c[x * 5 * n + y] = (a[x * 5 * n + y] * b[x * 5 * n + y]) / minimums[x * 5 + (y % 5)];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             reduced[y] = 1000;         }         for (int y = 0; y < 5 * n; ++y) {             reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);         }         for (int y = 0; y < 5; ++y) {             host_minimums[x * 5 + y] = reduced[y];             if (fabs(host_minimums[x * 5 + y] - minimums[x * 5 + y]) > PRECISION) {                 err += 1;             }         }         for (int y = 0; y < 5 * n; ++y) {             if (fabs(c[x * 5 * n + y] - ((a[x * 5 * n + y] * b[x * 5 * n + y]) / minimums[x * 5 + (y % 5)])) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture predecrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *c = (int *)malloc(n * sizeof(int));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = --distribution[(int) (a[x]*b[x]/10)];             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]--;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      bool found = false;     for (int x = 0; x < 10; ++x){         for (int y = 0; y > distribution[x]; --y){             for (int z = 0; z < n; ++z){                 if (c[z] == y - 1 && x == (int) (a[z] * b[z] / 10)){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update rshift equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1<<7;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic update                             a[x] >>= 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<7){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature loop collapse", "completion": "#ifndef T1 !T1:construct-independent,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10*LOOPCOUNT):: a, b, c !Data         REAL(8):: total         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          DO x = 0, 9           c(x*LOOPCOUNT + 1) = a(x*LOOPCOUNT + 1) + b(x*LOOPCOUNT + 1)         END DO          !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT))           !$acc parallel             !$acc loop independent             DO x = 0, 9               DO y = 2, LOOPCOUNT                 c(x*LOOPCOUNT + y) = c(x*LOOPCOUNT + y - 1) + a(x*LOOPCOUNT + y) + b(x*LOOPCOUNT + y)               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 0, 9           total = 0           DO y = 1, LOOPCOUNT             total = total + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)             IF (abs(total - c(x * LOOPCOUNT + y)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:construct-independent,loop,V:1.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10*LOOPCOUNT):: a, b, c !Data         REAL(8):: total         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copyout(c(1:10*LOOPCOUNT))           !$acc parallel             !$acc loop independent collapse(2)             DO x = 0, 9               DO y = 1, LOOPCOUNT                 c(x*LOOPCOUNT + y) = a(x*LOOPCOUNT + y) + b(x*LOOPCOUNT + y)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 0, 9           DO y = 1, LOOPCOUNT             IF (abs(c(x*LOOPCOUNT+y) - (a(x*LOOPCOUNT+y)+b(x*LOOPCOUNT+y))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature shutdown device type nvidia", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:shutdown,runtime,syntactic,V:2.5-3.2 int test1(){     int err = 0;      #pragma acc shutdown device_type(nvidia)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction bitor general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int b = 0;     unsigned int host_b = a[0];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX > false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }      #pragma acc data copyin(a[0:n])     {         #pragma acc kernels loop reduction(|:b)         for (int x = 0; x < n; ++x){             b = b | a[x];         }     }       for (int x = 1; x < n; ++x){         host_b = host_b | a[x];     }     if (b != host_b){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc update device with len", "completion": "#ifndef T1 !T1:runtime,data,executable-data,devonly,construct-independent,update,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER,DIMENSION(1):: devtest         REAL(8) :: RAND         INTEGER :: errors = 0          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyout(c(1:LOOPCOUNT)) create(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           CALL acc_update_device(a(1), LOOPCOUNT*8)           CALL acc_update_device(b(1), LOOPCOUNT*8)           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,data,executable-data,devonly,construct-independent,update,V:2.0-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER,DIMENSION(1):: devtest         REAL(8) :: RAND         INTEGER :: errors = 0          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          IF (devtest(1) .eq. 1) THEN           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 0            !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 a(x) = a(x) * a(x)               END DO             !$acc end parallel             CALL acc_update_device(a(1), LOOPCOUNT*8)             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 b(x) = b(x) * b(x)               END DO             !$acc end parallel             CALL acc_update_device(b(1), LOOPCOUNT*8)             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) + b(x)               END DO             !$acc end parallel           !$acc end data            DO x = 1, LOOPCOUNT             IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature declare function scope present", "completion": "FUNCTION present(a, b, c, d, LOOPCOUNT)   REAL(8),DIMENSION(LOOPCOUNT),INTENT(IN) :: a, b   REAL(8),DIMENSION(LOOPCOUNT),INTENT(INOUT) :: c, d   INTEGER,INTENT(IN) :: LOOPCOUNT   INTEGER :: x    !$acc declare present(c(1:LOOPCOUNT))   !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT))     !$acc loop     DO x = 1, LOOPCOUNT       c(x) = c(x) + a(x) + b(x)     END DO     !$acc loop     DO x = 1, LOOPCOUNT       d(x) = c(x) * a(x)     END DO   !$acc end parallel END FUNCTION function_test  #ifndef T1 !T1:devonly,construct-independent,declare,V:2.0-2.7       LOGICAL FUNCTION test1()   USE OPENACC   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d   INTEGER,DIMENSION(1) :: devtest   INTEGER :: x, y    devtest(1) = 1   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = 0   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 1   d = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT)) copyout(d(1:LOOPCOUNT, 1:LOOPCOUNT))     DO x = 1, LOOPCOUNT       !$acc data copy(c(x:x, 1:LOOPCOUNT))         CALL present(a(x), b(x), c(x), d(x), LOOPCOUNT)       !$acc end data     END DO   !$acc end data    DO x = 1, LOOPCOUNT     DO y = 1, LOOPCOUNT       IF (abs(c(x, y) - (1 + a(x, y) + b(x, y))) .gt. PRECISION) THEN         errors = errors + 1       END IF       IF (abs(d(x, y) - (a(x, y) * c(x, y))) .gt. PRECISION * 2) THEN         errors = errors + 1       END IF     END DO   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:devonly,construct-independent,declare,V:2.0-2.7       LOGICAL FUNCTION test2()   USE OPENACC   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d   INTEGER,DIMENSION(1) :: devtest   INTEGER :: x, y    devtest(1) = 1   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = 0   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    IF (devtest(1) .eq. 1) THEN     CALL RANDOM_NUMBER(a)     CALL RANDOM_NUMBER(b)     c = 3      !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))       DO x = 1, LOOPCOUNT         !$acc data copyin(c(x:x, 1:LOOPCOUNT)) copyout(d(x:x, 1:LOOPCOUNT))           CALL present(a(x), b(x), c(x), d(x), LOOPCOUNT)         !$acc end data         DO y = 1, LOOPCOUNT           IF (abs(c(x, y) - 3) .gt. PRECISION) THEN             errors = errors + 1           END IF           IF (abs(d(x, y) - (a(x, y) * (3 + a(x, y) + b(x, y)))) .gt. PRECISION * 2) THEN             errors = errors + 1           END IF         END DO       END DO     !$acc end data   END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update x eqv expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = totals(x) .EQV. a(x, y)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial switch", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     int * a = new int[n];     real_t * b = new real_t[n];     real_t * b_host = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = floor(rand() / (real_t)(RAND_MAX / 10));         b[x] = rand() / (real_t)(RAND_MAX / 10);         b_host[x] = b[x];         c[x] = 0.0;     }     #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])     #pragma acc serial present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             switch(a[x]){                 case 0:                     c[x] = b[x] * b[x];                     break;                 case 1:                     c[x] = b[x] / b[x];                     break;                 case 2:                     b[x] = b[x] / 2;                 default:                     c[x] = a[x] + b[x];               }         }     }     #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])      real_t tempc = 0.0;     for (int x = 0; x < n; ++x){         switch(a[x]){             case 0:                 tempc = b_host[x] * b_host[x];                 break;             case 1:                 tempc = b_host[x] / b_host[x];                 break;             case 2:                 b_host[x] = b_host[x] / 2;             default:                 tempc = a[x] + b_host[x];         }         if (fabs(c[x] - tempc) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature shutdown device num", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,shutdown,nonvalidating,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: device_num         INTEGER :: device_type         INTEGER :: errors = 0          device_num = acc_get_device_num(acc_get_device_type())         !$acc shutdown device_num(device_num)          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction multiply general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     int multiplicitive_n = 128;     srand(SEED);     real_t * a = new real_t[multiplicitive_n];     real_t * b = new real_t[multiplicitive_n];      real_t multiplied_total = 1.0;      for (int x = 0; x < multiplicitive_n; ++x){         a[x] = rand() / (real_t) RAND_MAX;         b[x] = rand() / (real_t) RAND_MAX;     }      #pragma acc data copyin(a[0:multiplicitive_n], b[0:multiplicitive_n]) copy(multiplied_total)     {         #pragma acc serial loop reduction (*:multiplied_total)         for (int x = 0; x < multiplicitive_n; ++x){             multiplied_total *= a[x] + b[x];         }     }      for (int x = 0; x < multiplicitive_n; ++x){         multiplied_total /= (a[x] + b[x]);     }     if (fabs(multiplied_total - 1) > PRECISION * (2 * multiplicitive_n - 1)){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial copy", "completion": "#ifndef T1 !T1:serial,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT):: a, a_host   INTEGER:: x   errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   a_host = a    !$acc serial copy(a(1:LOOPCOUNT))     !$acc loop     DO x = 1, N       a(x) = 2 * a(x)     END DO   !$acc end serial    DO x = 1, N     IF (abs(a(x) - (2 * a_host(x))) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc get property string", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,nonvalidating,V:2.6-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         CHARACTER(len=:),ALLOCATABLE :: output1         CHARACTER(len=:),ALLOCATABLE :: output2         CHARACTER(len=:),ALLOCATABLE :: output3         IF (acc_get_device_type() .ne. acc_device_none) THEN           ! Hopefully, the string is long enough:           allocate(character(len=1024) :: output1, output2, output3)           CALL acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), &                                                           acc_property_name, output1)           CALL acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), &                                                           acc_property_vendor, output2)           CALL acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), &                                                           acc_property_driver, output3)         END IF         test1 = .FALSE.       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature acc update self", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc data create(c[0:n]) copyin(a[0:n], b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         acc_update_self(c, n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = a[x] * a[x];             }         }         acc_update_self(a, n * sizeof(real_t));         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = b[x] * b[x];             }         }         acc_update_self(b, n * sizeof(real_t));         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }       for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update expr bitxor x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .5){                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] ^= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel if", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,if,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int accel = 1;     int host = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }     #pragma acc parallel if(host)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,if,devonly,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int * dev_test = (int *)malloc(sizeof(int));     int accel = 1;     int host = 0;      dev_test[0] = 1;     #pragma acc data copyin(dev_test[0:1])     #pragma acc parallel     {       dev_test[0] = 0;     }      if (devtest[0] != 0){         for (int x = 0; x < n;  ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0;         }          #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])         #pragma acc parallel if(host) present(a[0:n], b[0:n], c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }         #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])          for (int x = 0; x < n; ++x){             if (fabs(c[x]) > PRECISION){                 err = 1;             }         }     }      return err; } #endif  #ifndef T3 //T3:parallel,if,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int accel = 1;     int host = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])      #pragma acc parallel if(accel) present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] += a[x] + b[x];         }     }      #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION * 2){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction min general", "completion": "#ifndef T1 !T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8):: minimum = 1000         REAL(8):: temp = 1000         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc kernels loop reduction(min:minimum)           DO x = 1, LOOPCOUNT             minimum = min(minimum, a(x) * b(x))           END DO         !$acc end data          DO x = 1, LOOPCOUNT           temp = min(temp, a(x) * b(x))         END DO         IF (abs(temp - minimum) .gt. PRECISION) THEN           errors = errors + 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture expr divided x", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x]/prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){     if (length == 0){         if (fabs(current_value - test_value) > PRECISION){             return true;         }         else {             return false;         }     }     real_t * passed = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         for (int y = 0; y < x; ++y){             passed[y] = remaining_combinations[y];         }         for (int y = x + 1; y < length; ++y){             passed[y - 1] = remaining_combinations[y];         }         if (possible_result(passed, length - 1, remaining_combinations[x] / current_value, test_value)){             delete[] passed;             return true;         }     }     delete[] passed;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *passed_ab = new real_t[10];     real_t *passed_c = new real_t[10];     int passed_indexer;     int absolute_indexer;     real_t * passed = new real_t[10];     int indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];             }         }     }       for (int x = 0; x < (n/10 + 1); ++x){         indexer = x;         while (indexer < n){             passed[indexer/(n/10 + 1)] = (a[x] + b[x]);             indexer += (n/10 + 1);         }         if (!(possible_result(passed, 10, 1, totals[x]))){             err += 1;         }     }      for (int x = 0; x < (n/10 + 1); ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction max loop", "completion": "#ifndef T1 !T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c   REAL(8),DIMENSIOn(10):: host_maximums, maximums   REAL(8):: temp   INTEGER:: errors, x, y    errors = 0   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 0   maximums = 0   host_maximums = 0    DO y = 1, 10     DO x = 1, LOOPCOUNT       host_maximums(y) = max(host_maximums(y), a(x, y) * b(x, y))     ENDDO   END DO    !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(c(1:LOOPCOUNT, 1:10), maximums(1:10))     !$acc serial loop gang private(temp)     DO y = 1, 10       temp = 0       !$acc loop worker reduction(max:temp)       DO x = 1, LOOPCOUNT         temp = max(temp, a(x, y) * b(x, y))       END DO       maximums(y) = temp       !$acc loop worker       DO x = 1, LOOPCOUNT         c(x, y) = (a(x, y) * b(x, y)) / maximums(y)       END DO     END DO   !$acc end data    DO y = 1, 10     IF (maximums(y) .ne. host_maximums(y)) THEN       errors = errors + 1     END IF     DO x = 1, LOOPCOUNT       IF (abs(c(x, y) - ((a(x, y) * b(x, y)) / maximums(y))) .gt. PRECISION) THEN         errors = errors + 1       END IF     END DO   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop reduction add vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 0.0;      for(int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10])     {         #pragma acc kernels loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0.0;             #pragma acc loop vector reduction(+:temp)             for (int y = 0; y < n; ++y){                 temp += a[(x * n) + y] + b[(x * n) + y];             }             c[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             c[x] -= a[(x * n) + y] + b[(x * n) + y];         }         if (fabs(c[x]) > PRECISION * (2 * n - 1)){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x eqv expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = totals(x) .EQV. a(x, y)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update expr lshift x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};     int result;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 3; ++y){             a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));         }         b[x] = 0;     }      #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 3; ++y){                     #pragma acc atomic update                         b[x] = a[x * 3 + y] << b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 6; ++y){             result = 0;             for (int z = 0; z < 3; ++z){                 result = a[x * 3 + orders[y * 3 + z]] << result;             }             if (result == b[x]){                 break;             }         }         if (result != b[x]){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t* a = (real_t *) malloc(1024 * sizeof(real_t));     real_t* b = (real_t *) malloc(1024 * sizeof(real_t));     real_t* c = (real_t *) malloc(1024 * sizeof(real_t));      for(int x = 0; x < 1024; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:1024], b[0:1024]) copy(c[0:1024])     {         #pragma acc parallel         {             #pragma acc loop             for (int _0 = 0; _0 < 2; ++_0){                 #pragma acc loop                 for (int _1 = 0; _1 < 2; ++_1){                     #pragma acc loop                     for (int _2 = 0; _2 < 2; ++_2){                         #pragma acc loop                         for (int _3 = 0; _3 < 2; ++_3){                             #pragma acc loop                             for (int _4 = 0; _4 < 2; ++_4){                                 #pragma acc loop                                 for (int _5 = 0; _5 < 2; ++_5){                                     #pragma acc loop                                     for (int _6 = 0; _6 < 2; ++_6){                                         #pragma acc loop                                         for (int _7 = 0; _7 < 2; ++_7){                                             #pragma acc loop                                             for (int _8 = 0; _8 < 2; ++_8){                                                 #pragma acc loop                                                 for (int _9 = 0; _9 < 2; ++_9){                                                     c[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] =                                                     a[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] +                                                     b[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9];                                                 }                                             }                                         }                                     }                                 }                             }                         }                     }                 }             }         }     }      for (int x = 0; x < 1024; ++x){         if(fabs(c[x] - (a[x] +b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic preincrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic                         ++distribution[(int) (a[x]*b[y]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             distribution_comparison[(int) (a[x]*b[y]/10)]++;         }     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign expr bitxor x", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev ^ a[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         for (int y = 0; y < 8; ++y){             totals[x] =  1<<y;             totals_comparison[x] = 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         b[x] = totals[x/10];                         totals[x/10] = a[x] ^ totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] ^= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign expr plus x", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, a[x] + prev)){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t *passed_ab = new real_t[10];     real_t *passed_c = new real_t[10];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x%(n/10 + 1)];                     totals[x%(n/10 + 1)] = (a[x] * b[x]) + totals[x%(n/10 + 1)];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] += a[x] * b[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){             passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature shutdown device type num", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:shutdown,runtime,syntactic,V:2.5-3.2 int test1(){     int err = 0;     int device_num;      device_num = acc_get_device_num(acc_get_device_type());     #pragma acc shutdown device_type(host) device_num(device_num)      return err; } #endif #ifndef T2 //T2:shutdown,runtime,syntactic,V:2.5-3.2 int test2(){     int err = 0;     int device_num;      device_num = acc_get_device_num(acc_get_device_type());     #pragma acc shutdown device_type(multicore) device_num(device_num)      return err; } #endif #ifndef T3 //T3:shutdown,runtime,syntactic,V:2.5-3.2 int test3(){     int err = 0;     int device_num;      device_num = acc_get_device_num(acc_get_device_type());     #pragma acc shutdown device_type(default) device_num(device_num)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels scalar default copy", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data,data-region,default-mapping,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t sum = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      for (int x = 0; x < n; ++x){         sum = sum + a[x];     }      #pragma acc data copyin(b[0:n])     {         #pragma acc kernels num_gangs(1) vector_length(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 sum = sum + b[x];             }         }     }      for (int x = 0; x < n; ++x){         sum = sum - (a[x] + b[x]);     }      if (fabs(sum) > (2 * n - 2) * PRECISION){         err += 1;         sum = 0.0;         for (int x = 0; x < n; ++x){             sum = sum + a[x];         }         sum = 0.0;         for (int x = 0; x < n; ++x){             sum = sum + b[x];         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic iand x expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .gt. .933) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           DO y = 0, 7             totals(x) = totals(x) + ISHFT(1, y)             totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)           END DO         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction multiply vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1() {     int err = 0;     int multiplicitive_n = 128;     srand(SEED);     real_t* a = (real_t*)malloc(10 * multiplicitive_n * sizeof(real_t));     real_t* b = (real_t*)malloc(10 * multiplicitive_n * sizeof(real_t));     real_t* c = (real_t*)malloc(10 * sizeof(real_t));     real_t temp;      for (int x = 0; x < 10 * multiplicitive_n; ++x) {         a[x] = rand() / (real_t)RAND_MAX;         b[x] = rand() / (real_t)RAND_MAX;     }  #pragma acc data copyin(a[0:10*multiplicitive_n], b[0:10*multiplicitive_n]) copyout(c[0:10])     { #pragma acc parallel loop private(temp)         for (int x = 0; x < 10; ++x) {             temp = 1.0; #pragma acc loop vector reduction(*:temp)             for (int y = 0; y < multiplicitive_n; ++y) {                 temp *= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];             }             c[x] = temp;         }     }      for (int x = 0; x < 10; ++x) {         for (int y = 0; y < multiplicitive_n; ++y) {             c[x] /= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];         }     }      for (int x = 0; x < 10; ++x) {         if (fabs(c[x] - 1) > PRECISION* (4 * multiplicitive_n - 1)) {             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2() {     int err = 0;     int m_n = 128;     srand(SEED);     real_t* a = (real_t*)malloc(25 * m_n * sizeof(real_t));     real_t* b = (real_t*)malloc(25 * m_n * sizeof(real_t));     real_t* c = (real_t*)malloc(25 * m_n * sizeof(real_t));     real_t* totals = (real_t*)malloc(25 * sizeof(real_t));     real_t reduced[5];      for (int x = 0; x < n; ++x) {         a[x] = .05 + rand() / (real_t)(RAND_MAX / 10);         b[x] = .05 + rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc data copyin(a[0:25*m_n], b[0:25*m_n]) copyout(c[0:25*m_n], totals[0:25])     {         #pragma acc parallel loop gang private(reduced)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 reduced[y] = 1.0;             }             #pragma acc loop worker reduction(*:reduced)             for (int y = 0; y < 5 * m_n; ++y) {                 reduced[y % 5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];             }             for (int y = 0; y < 5; ++y) {                 totals[x * 5 + y] = reduced[y];             }             #pragma acc loop worker             for (int y = 0; y < 5 * m_n; ++y) {                 c[x * 5 * m_n + y] = (a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[(x * 5) + (y % 5)];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             reduced[y] = 1;         }         for (int y = 0; y < 5 * m_n; ++y) {             reduced[y % 5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];         }         for (int y = 0; y < 5; ++y) {             if (fabs(totals[x * 5 + y] - reduced[y]) > PRECISION) {                 err += 1;             }         }         for (int y = 0; y < 5 * m_n; ++y) {             if (fabs(c[x * 5 * m_n + y] - ((a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[x * 5 + (y % 5)])) > PRECISION){                 err += 1;             }            }     }      return err; } #endif  #ifndef T3 //T3: int test3(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction bitxor loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));     unsigned int temp = 0;      for (int x = 0; x < 10*n; ++x){         b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b_copy[x] = b[x];         a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);     }     for (int x = 0; x < 10; ++x){         c[x] = 0;     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])     {         #pragma acc kernels loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(^:temp)             for (int y = 0; y < n; ++y){                 temp = temp ^ a[x * n + y];             }             c[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 b[x * n + y] = b[x * n + y] + c[x];             }         }     }      for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = temp ^ a[x * n + y];         }         if (temp != c[x]){             err += 1;         }         for (int y = 0; y < n; ++y){             if (b[x * n + y] != b_copy[x * n + y] + c[x]){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel default present", "completion": "#ifndef T1 !T1:parallel,default,V:2.5-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         INTEGER :: errors = 0          a = 0          !$acc data copy(a(1:LOOPCOUNT))           !$acc parallel default(present)             !$acc loop             DO x = 1, LOOPCOUNT               a(x) = 1.0             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(a(x) - 1) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic expr bitand x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] &= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update expr rshift x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};     int result;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 3; ++y){             a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));         }         b[x] = 0;     }      #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop independent                 for (int y = 0; y < 3; ++y){                     #pragma acc atomic update                         b[x] = a[x * 3 + y] >> b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 6; ++y){             result = 0;             for (int z = 0; z < 3; ++z){                 result = a[x * 3 + orders[y * 3 + z]] >> result;             }             if (result == b[x]){                 break;             }         }         if (result != b[x]){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction min vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * min = new real_t[10];     real_t temp = 100;     real_t temp_min;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(min[0:10])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 100;             #pragma acc loop vector reduction(min:temp)             for (int y = 0; y < n; ++y){                 temp = fmin(a[x * n + y] * b[x * n + y], temp);             }             min[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         temp_min = 100;         for (int y = 0; y < n; ++y){             if (temp_min > a[x * n + y] * b[x * n + y]){                 temp_min = a[x * n + y] * b[x * n + y];             }         }         if (fabs(temp_min - min[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[25 * n];     real_t * b = new real_t[25 * n];     real_t * minimums = new real_t[25];     real_t reduced[5];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(minimums[0:25])     {         #pragma acc parallel loop gang private(reduced)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 reduced[y] = 1000;             }             #pragma acc loop vector reduction(min:reduced)             for (int y = 0; y < 5 * n; ++y) {                 reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y % 5]);             }             for (int y = 0; y < 5; ++y) {                 minimums[x * 5 + y] = reduced[y];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             reduced[y] = 1000;         }         for (int y = 0; y < 5 * n; ++y) {             reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y % 5]);         }         for (int y = 0; y < 5; ++y) {             if (fabs(reduced[y] - minimums[x * 5 + y]) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture x plus expr assign", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   REAL(8), INTENT(IN) :: init   REAL(8),DIMENSION(length), INTENT(IN) :: a   REAL(8),DIMENSION(length), INTENT(IN) :: b   REAL(8),DIMENSION(length - 1) :: passed_a   REAL(8),DIMENSION(length - 1) :: passed_b   REAL(8) :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (abs(b(x) - (init + a(x))) .GT. ((10 - length) * PRECISION)) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = b(x)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison   REAL(8),DIMENSION(10):: passed_a, passed_b   REAL(8):: init   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)    totals = 0   totals_comparison = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             totals(x) = totals(x) + a(x, y)             b(x, y) = totals(x)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data   DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = totals_comparison(x) + a(x, y)     END DO   END DO    DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NE. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 0     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop reduction max vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * max = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 0;     real_t temp_max;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(max[0:10])     {         #pragma acc kernels loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(max:temp)             for (int y = 0; y < n; ++y){                 temp = fmax(a[x * n + y] * b[x * n + y], temp);             }             max[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         temp_max = 0;         for (int y = 0; y < n; ++y){             if (temp_max < a[x * n + y] * b[x * n + y]){                 temp_max = a[x * n + y] * b[x * n + y];             }         }         if (fabs(temp_max - max[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured x rshift expr assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if ((b[x] == (prev >> 1) && (a>>x)%2==1) || b[x] == prev && (a>>x)%2==0){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1<<8;      for (int x = 0; x < n; ++x){         a[x] = 1<<8;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                         {                             a[x] = a[x] >> 1;                             c[x * 7 + y] = a[x];                         }                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<8){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic postincrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic                         distribution[(int) (a[x]*b[y]/10)]++;                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             distribution_comparison[(int) (a[x]*b[y]/10)]++;         }     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature exit data", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,devonly,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));     int * devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             a_copy[x] = a[x];         }          #pragma acc enter data copyin(a[0:n])         #pragma acc parallel present(a[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = a[x] + 1;             }         }         #pragma acc exit data delete(a[0:n])          for (int x = 0; x < n; ++x){             if (fabs(a[x] - a_copy[x]) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:data,executable-data,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         a_copy[x] = a[x];     }      #pragma acc enter data copyin(a[0:n])     #pragma acc parallel present(a[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             a[x] = a[x] + 1;         }     }     #pragma acc exit data copyout(a[0:n])      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (a_copy[x] + 1)) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update ior expr x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .lt. .933) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           totals(x) = 0           totals_comparison(x) = 0         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic min x expr list", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial while loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,reduction,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t avg = 0.0;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(a[0:10*n])     {         #pragma acc serial         {             #pragma acc loop             for (int y = 0; y < 10; ++y){                 avg = 0.0;                 while (avg - 1000 < PRECISION * n){                     avg = 0.0;                     #pragma acc loop reduction(+:avg)                     for (int x = 0; x < n; ++x){                         a[n * y + x] *= 1.5;                         avg += a[n * y + x] / n;                     }                 }             }         }     }      for (int y = 0; y < 10; ++y){         avg = 0.0;         for (int x = 0; x < n; ++x){             avg += a[y * n + x]/n;         }          if (avg < 1000 || avg > 1500){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial create zero", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,data-region,V:3.0-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 1;     }      #pragma acc data copyin(a[0:n])      {         #pragma acc serial create(zero: b[0:n]) copyout(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] += a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop seq", "completion": "#ifndef T1 !T1:kernels,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0          !$acc data copyin(a(1:LOOPCOUNT)) copy(b(1:LOOPCOUNT))           !$acc kernels loop seq           DO x = 2, LOOPCOUNT             b(x) = b(x - 1) + a(x)           END DO         !$acc end data          DO x = 2, LOOPCOUNT           IF (abs(b(x) - (b(x - 1) + a(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture max expr x assign", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   REAL(8), INTENT(IN) :: init   REAL(8),DIMENSION(length), INTENT(IN) :: a   REAL(8),DIMENSION(length), INTENT(IN) :: b   REAL(8),DIMENSION(length - 1) :: passed_a   REAL(8),DIMENSION(length - 1) :: passed_b   REAL(8) :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (abs(b(x) - max(init, a(x))) .lt. (10 - length) * PRECISION) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = b(x)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison   REAL(8),DIMENSION(10):: passed_a, passed_b   REAL(8):: init   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)    totals = 0   totals_comparison = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             totals(x) = max(a(x, y), totals(x))             b(x, y) = totals(x)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data   DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = max(totals_comparison(x), a(x, y))     END DO   END DO   DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NE. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 0     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature data copyin no lower bound", "completion": "#ifndef T1 !T1:data,data_region,construct-independent,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(:LOOPCOUNT), b(:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign expr bitor x", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev | a[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         for (int y = 0; y < 8; ++y){             totals[x] =  1<<y;             totals_comparison[x] = 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         b[x] = totals[x/10];                         totals[x/10] = a[x] | totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] |= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel copyin", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,data,data-region,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * a_copy = new real_t[n];     real_t * b = new real_t[n];     int* hasDevice = (int *) malloc(sizeof(int));     hasDevice[0] = 1;     #pragma acc enter data copyin(hasDevice[0:1])     #pragma acc parallel present(hasDevice[0:1])     {       hasDevice[0] = 0;     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         a_copy[x] = a[x];         b[x] = 0.0;     }      #pragma acc parallel copyin(a[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             a[x] = 0.0;         }     }      for (int x = 0; x < n; ++x){         if (((fabs(a[x] - a_copy[x]) > PRECISION) && (hasDevice[0] == 1)) || ((hasDevice[0] == 0) && (fabs(a[x]) > PRECISION))){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,data,data-region,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * a_copy = new real_t[n];     real_t * b = new real_t[n];     for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(b[0:n])     {         #pragma acc parallel copyin(a[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction min loop", "completion": "#ifndef T1 !T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c !Data         REAL(8),DIMENSION(10):: minimum         REAL(8):: temp         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         a = a + 1         b = b + 1          !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT)) copy(minimum(1:10))           !$acc kernels loop gang independent private(temp)           DO x = 0, 9             temp = 1000             !$acc loop worker independent reduction(min:temp)             DO y = 1, LOOPCOUNT               temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))             END DO             minimum(x + 1) = temp             !$acc loop independent             DO y = 1, LOOPCOUNT               c(x * LOOPCOUNT + y) = (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y)) / minimum(x + 1)             END DO           END DO         !$acc end data          DO x = 0, 9           temp = 1000           DO y = 1, LOOPCOUNT             temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))           END DO           IF (abs(temp - minimum(x + 1)) .gt. PRECISION) THEN             errors = errors + 1             WRITE(*, *) minimum(x + 1)           END IF           DO y = 1, LOOPCOUNT             IF (abs(c(x * LOOPCOUNT + y) - (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y) / temp)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction bitor vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int b_host;      for (int x = 0; x < 10 * n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX > false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }     temp = 0;     #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc parallel loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(|:temp)             for (int y = 0; y < n; ++y){                 temp = temp | a[x * n + y];             }             b[x] = temp;         }     }      for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host | a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));      unsigned int reduced[5];     real_t false_margin = pow(exp(1), log(.5)/n);          for (int x = 0; x < 25 * n; ++x) {         a[x] = 0;         for (int y = 0; y < 16; ++y) {             if (rand() / (real_t)RAND_MAX > false_margin) {                 a[x] += 1<<y;             }         }     }      #pragma acc data copyin(a[0:25*n]) copy(b[0:25])     {         #pragma acc parallel loop private(reduced)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 reduced[y] = 0;             }             #pragma acc loop vector reduction(|:reduced)             for (int y = 0; y < 5 * n; ++y) {                 reduced[y%5] = reduced[y%5] | a[x * 5 * n + y];             }             for (int y = 0; y < 5; ++y) {                 b[x * 5 + y] = reduced[y];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             reduced[y] = 0;         }         for (int y = 0; y < 5 * n; ++y) {             reduced[y%5] = reduced[y%5] | a[x * 5 * n + y];         }         for (int y = 0; y < 5; ++y) {             if (b[x * 5 + y] != reduced[y]) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc async test", "completion": "#ifndef T1 !T1:runtime,async,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data         INTEGER :: errors         errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         CALL RANDOM_NUMBER(d)         c = 0         e = 0                  !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT)) async(1)         !$acc enter data copyin(d(1:LOOPCOUNT)) create(e(1:LOOPCOUNT)) async(2)         !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) async(1)           !$acc loop           DO x = 1, LOOPCOUNT             c(x) = a(x) + b(x)           END DO         !$acc end parallel         !$acc parallel present(c(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) async(1) wait(2)           !$acc loop           DO x = 1, LOOPCOUNT             e(x) = c(x) + d(x)           END DO         !$acc end parallel         !$acc exit data copyout(e(1:LOOPCOUNT)) async(1)           DO WHILE (acc_async_test(1) .eqv. .FALSE.)           CONTINUE         END DO          DO x = 1, LOOPCOUNT           IF (abs(e(x) - (a(x) + b(x) + d(x))) .GT. PRECISION) THEN             errors = errors + 1           END IF         END DO         IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif  #ifndef T2 !T2:async,runtime,construct-independent,V:1.0-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e         INTEGER :: errors         errors = 0                  !Initialization         CALL RANDOM_SEED()         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         CALL RANDOM_NUMBER(d)         c = 0         e = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), e(1:LOOPCOUNT))           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           !$acc parallel present(c(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) async(1)             !$acc loop             DO x = 1, LOOPCOUNT               e(x) = c(x) + d(x)             END DO           !$acc end parallel           DO WHILE (acc_async_test(1) .eqv. .FALSE.)             CONTINUE           END DO         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(e(x) - (a(x) + b(x) + d(x))) .GT. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif  #ifndef T3 !T3:runtime,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test3()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e         INTEGER :: errors, async_val         INTEGER :: acc_get_default_async         async_val = acc_get_default_async()         errors = 0          !Initialization         CALL RANDOM_SEED()         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         CALL RANDOM_NUMBER(d)         c = 0         e = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), e(1:LOOPCOUNT))           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) async             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           !$acc parallel present(c(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) async             !$acc loop             DO x = 1, LOOPCOUNT               e(x) = c(x) + d(x)             END DO           !$acc end parallel           DO WHILE (acc_async_test(async_val) .eqv. .FALSE.)             CONTINUE           END DO         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM main       IMPLICIT NONE       INTEGER :: failcode, testrun       LOGICAL :: failed       INCLUDE \"acc_testsuite.Fh\"       !Conditionally define test functions #ifndef T1       LOGICAL :: test1 #endif #ifndef T2       LOGICAL :: test2 #endif #ifndef T3       LOGICAL :: test3 #endif       failcode = 0       failed = .FALSE.  #ifndef T1       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test1()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 0         failed = .FALSE.       END IF #endif  #ifndef T2       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test2()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 1         failed = .FALSE.       END IF #endif  #ifndef T3       DO testrun = 1, NUM_TEST_CALLS         failed = failed .or. test3()       END DO       IF (failed) THEN         failcode = failcode + 2 ** 2         failed = .FALSE.       END IF #endif       CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc delete finalize", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,reference-counting,construct-independent,syntactic,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n])     #pragma acc enter data copyin(a[0:n], b[0:n])      #pragma acc data copyout(c[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      acc_delete_finalize(a, n * sizeof(real_t));     acc_delete_finalize(b, n * sizeof(real_t));      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,reference-counting,syntactic,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      acc_copyin(a, n * sizeof(real_t));     acc_copyin(a, n * sizeof(real_t));     acc_copyin(b, n * sizeof(real_t));     acc_copyin(b, n * sizeof(real_t));      #pragma acc data copyout(c[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      acc_delete_finalize(a, n * sizeof(real_t));     acc_delete_finalize(b, n * sizeof(real_t));      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction or vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = new char[10 * n];     char * b = new char[10];     real_t false_margin = pow(exp(1), log(.5)/n);     char temp = 0;     char found;      for (int x = 0; x < 10 * n; ++x){         if(rand() / (real_t)(RAND_MAX) > false_margin){             a[x] = 1;         }         else{             a[x] = 0;         }     }     #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc kernels loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(||:temp)             for (int y = 0; y < n; ++y){                 temp = temp || a[x * n + y];             }             b[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         found = 0;         for (int y = 0; y < n; ++y){             if (a[x * n + y] &! 0){                 found = 1;             }         }         if (found != b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc set device type", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,internal-control-values,syntactic,V:2.0-2.7 int test1(){     int err = 0;      acc_device_t device_type = acc_get_device_type();      acc_set_device_type(device_type);     if (acc_get_device_type() != device_type){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update min expr list x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update x multiply expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture assign x and expr", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   LOGICAL,DIMENSION(length), INTENT(IN) :: a   LOGICAL,DIMENSION(length), INTENT(IN) :: b   LOGICAL, INTENT(IN) :: init   LOGICAL,DIMENSION(length - 1) :: passed_a   LOGICAL,DIMENSION(length - 1) :: passed_b   LOGICAL :: POSSIBLE, holder   INTEGER :: x, y   IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.   DO x = 1, length     IF (b(x) .eqv. init) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = a(x) .AND. init       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, a(x) .AND. init)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7 LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms   LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data   LOGICAL,DIMENSION(10):: passed_a, passed_b   LOGICAL IS_POSSIBLE   LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison   INTEGER :: errors = 0   LOGICAL :: init    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)   DO x = 1, LOOPCOUNT     DO y = 1, 10       IF (randoms(x, y) < .933) THEN         a(x, y) = .TRUE.       ELSE         a(x, y) = .FALSE.       END IF     END DO   END DO    totals = .FALSE.   totals_comparison = .FALSE.    !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             b(x, y) = totals(x)             totals(x) = totals(x) .AND. a(x, y)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = totals_comparison(x) .AND. a(x, y)     END DO   END DO    DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NEQV. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = .FALSE.     IF (.FALSE. .eqv. IS_POSSIBLE(a(x, 1:10), b(x, 1:10), 10, .FALSE.)) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic x divided expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] / (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature enter data create", "completion": "#ifndef T1 !T1:data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0         c = 0          !$acc enter data create(b(1:LOOPCOUNT))         !$acc data copyin(a(1:LOOPCOUNT))           !$acc parallel present(b(1:LOOPCOUNT))             !$acc loop              DO x = 1, LOOPCOUNT               b(x) = a(x)             END DO           !$acc end parallel         !$acc end data         !$acc data copyout(c(1:LOOPCOUNT))           !$acc parallel present(b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = b(x)             END DO           !$acc end parallel         !$acc end data         !$acc exit data delete(b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(a(x) - c(x)) .gt. PRECISION) THEN             errors = errors + 1             EXIT           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0         c = 0         !$acc enter data present_or_create(b(1:LOOPCOUNT))         !$acc data copyin(a(1:LOOPCOUNT))           !$acc parallel present(b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = a(x)             END DO           !$acc end parallel         !$acc end data         !$acc data copyout(c(1:LOOPCOUNT))           !$acc parallel present(b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = b(x)             END DO           !$acc end parallel         !$acc end data         !$acc exit data delete(b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(a(x) - c(x)) .gt. PRECISION) THEN             errors = errors + 2             EXIT           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test3()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0         c = 0           !$acc enter data pcreate(b(1:LOOPCOUNT))         !$acc data copyin(a(1:LOOPCOUNT))           !$acc parallel present(b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = a(x)             END DO           !$acc end parallel         !$acc end data         !$acc data copyout(c(1:LOOPCOUNT))           !$acc parallel present(b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = b(x)             END DO           !$acc end parallel         !$acc end data         !$acc exit data delete(b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(a(x) - c(x)) .gt. PRECISION) THEN             errors = errors + 4             EXIT           END IF         END DO          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc create async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,async,data,executable-data,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));     real_t *e = (real_t *)malloc(n * sizeof(real_t));     real_t *f = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])     {         acc_create_async(c, n * sizeof(real_t), 1);         acc_create_async(f, n * sizeof(real_t), 2);         #pragma acc data present(c[0:n], f[0:n])         {             #pragma acc parallel async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] + b[x];                 }             }             #pragma acc parallel async(2)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     f[x] = d[x] + e[x];                 }             }             #pragma acc wait         }     }      #pragma acc exit data copyout(c[0:n], f[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }         if (fabs(f[x] - (d[x] + e[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      acc_create_async(c, n * sizeof(real_t), 1);      #pragma acc data copyin(a[0:n], b[0:n])     {         while (!acc_async_test_all());         #pragma acc parallel present(c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      acc_create_async(c, n * sizeof(real_t), 1);      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc wait         #pragma acc parallel present(c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T4 //T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7 int test4(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * d = (real_t *)malloc(n * sizeof(real_t));     real_t * e = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = 0;     }      #pragma acc enter data create(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) copyout(e[0:n])     {         #pragma acc parallel present(c[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         acc_create_async(c, n * sizeof(real_t), 1);         #pragma acc exit data delete(c[0:n]) async(1)         #pragma acc parallel present(c[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 e[x] = c[x] + d[x];             }         }     }     #pragma acc wait     #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x) {         if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T5 //T5:runtime,data,executable-data,devonly,async,construct-independent,reference-counting,V:2.5-2.7 int test5(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int * devtest = (int *)malloc(sizeof(int));          devtest[0] = 0;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 1;     }      if (devtest[0] == 0){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0;         }          #pragma acc enter data create(c[0:n])         #pragma acc data copyin(a[0:n], b[0:n])         {             #pragma acc parallel present(c[0:n]) async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x) {                     c[x] = a[x] + b[x];                 }             }             acc_create_async(c, n * sizeof(real_t), 1);             #pragma acc parallel present(c[0:n]) async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x) {                     c[x] += a[x] + b[x];                 }             }             #pragma acc exit data copyout(c[0:n]) async(1)             #pragma acc wait         }          for (int x = 0; x < n; ++x) {             if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction add general", "completion": "#ifndef T1 !T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8) :: total         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         total = 0         !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(total)           !$acc parallel loop reduction(+:total)           DO x = 1, LOOPCOUNT             total = total + a(x) + b(x)           END DO         !$acc end data         DO x = 1, LOOPCOUNT           total = total - (a(x) + b(x))         END DO         IF (abs(total) .gt. LOOPCOUNT * PRECISION) THEN           WRITE(*, *) total           errors = 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction bitxor loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));     unsigned int temp = 0;      for (int x = 0; x < 10*n; ++x){         b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b_copy[x] = b[x];         a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);     }     for (int x = 0; x < 10; ++x){         c[x] = 0;     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(^:temp)             for (int y = 0; y < n; ++y){                 temp = temp ^ a[x * n + y];             }             c[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 b[x * n + y] = b[x * n + y] + c[x];             }         }     }      for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = temp ^ a[x * n + y];         }         if (temp != c[x]){             err += 1;         }         for (int y = 0; y < n; ++y){             if (b[x * n + y] != b_copy[x * n + y] + c[x]){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture expr minus x", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] - prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }   bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){     if (length == 0){         if (fabs(current_value - test_value) > PRECISION){             return true;         }         else {             return false;         }     }     real_t * passed = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         for (int y = 0; y < x; ++y){             passed[y] = remaining_combinations[y];         }         for (int y = x + 1; y < length; ++y){             passed[y - 1] = remaining_combinations[y];         }         if (possible_result(passed, length - 1, remaining_combinations[x] - current_value, test_value)){             delete[] passed;             return true;         }     }     delete[] passed;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[((n/10) + 1)];     int indexer = 0;     real_t * passed = new real_t[10];     real_t *passed_a = new real_t[10];     real_t *passed_b = new real_t[10];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < (n/10) + 1; ++x){         totals[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     b[x] = totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];             }         }     }     for (int x = 0; x < (n/10) + 1; ++x){         indexer = x;         while (indexer < n){             passed[indexer/((int) (n/10) + 1)] = a[indexer];             indexer += (n/10) + 1;         }         if (!(possible_result(passed, 10, 0, totals[x]))){             err += 1;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_a[passed_indexer] = a[absolute_indexer];             passed_b[passed_indexer] = b[absolute_indexer];         }         if (!is_possible(passed_a, passed_b, passed_indexer, 0)){             err += 1;         }         break;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop auto", "completion": "#include \"acc_testsuite.h\"  #ifndef T1 //T1:parallel,loop,combined-constructs,V:2.0-2.7 //data dependent, treated with as a seq clause. Added the num_gangs clause with 1 int test1(){     int err = 0;     srand(SEED);     real_t * device = new real_t[n];     real_t * host = new real_t[n];      for (int x = 0; x < n; ++x){         device[x] = rand() / (real_t)(RAND_MAX / 10);         host[x] = device[x];     }      #pragma acc data copy(device[0:n])     {       #pragma acc parallel loop num_gangs(1) vector_length(1) num_workers(1) auto       for (int x = 1; x < n; ++x){         device[x] = device[x - 1] + device[x];       }     }      real_t rolling_total = 0.0;     for (int x = 0; x < n; ++x){       rolling_total += host[x];       if (fabs(rolling_total - device[x]) > PRECISION){         err = 1;       }     }      delete[] device;     delete[] host;      return err; }   #endif  int main(){     int failcode = 0;     int failed;  #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }     if (failed){         failcode += (1 << 2);     } #endif     return failcode; }"}
{"prompt": "Create a test for the feature acc wait all", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,async,construct-independent,wait,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];     real_t *a_host = new real_t[n];     real_t *b_host = new real_t[n];     real_t *c_host = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = rand() / (real_t)(RAND_MAX / 10);         d[x] = 0;         a_host[x] = a[x];         b_host[x] = b[x];         c_host[x] = c[x];     }      #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = a[x] * a[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = b[x] * b[x];             }         }         #pragma acc parallel async(3)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = c[x] * c[x];             }         }         acc_wait_all();         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 d[x] = a[x] + b[x] + c[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(d[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x] + c_host[x] * c_host[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature init", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:init,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);      #pragma acc init      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc update device async with len", "completion": "#ifndef T1 !T1:runtime,data,executable-data,async,construct-independent,update,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data         INTEGER :: errors         errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         a_host = a         b_host = b          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))           CALL acc_update_device_async(a(1), LOOPCOUNT*8, 1)           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               a(x) = a(x) * a(x)             END DO           !$acc end parallel           CALL acc_update_device_async(b(1), LOOPCOUNT*8, 2)           !$acc parallel async(2)             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = b(x) * b(x)             END DO           !$acc end parallel           !$acc parallel async(1) wait(2)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           !$acc wait(1)         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - ((a_host(x) * a_host(x)) + (b_host(x) * b_host(x)))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER,DIMENSION(1):: devtest         INTEGER :: errors         errors = 0          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = 0         !$acc end parallel         IF (devtest(1) .eq. 1) THEN           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 0            !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc parallel async(1)               !$acc loop               DO x = 1, LOOPCOUNT                 a(x) = a(x) * a(x)               END DO             !$acc end parallel             CALL acc_update_device_async(a(1), LOOPCOUNT*8, 1)             !$acc parallel async(2)               !$acc loop               DO x = 1, LOOPCOUNT                 b(x) = b(x) * b(x)               END DO             !$acc end parallel             CALL acc_update_device_async(b(1), LOOPCOUNT*8, 2)             !$acc parallel async(1), wait(2)               !$acc loop                DO x = 1, LOOPCOUNT                  c(x) = a(x) + b(x)                END DO             !$acc end parallel             !$acc wait(1)           !$acc end data            DO x = 1, LOOPCOUNT             IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature acc free", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,V:2.6-2.7 int test1(){     int err = 0;     int *a = (int *)acc_malloc(n * sizeof(int));     size_t initial_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);      acc_free(a);     size_t final_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);     if (final_memory < initial_memory + n * sizeof(int)){         err += 1;     }     return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture assign expr divided x", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE_2(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8), INTENT(IN) :: init         REAL(8),DIMENSION(length), INTENT(IN) :: a         REAL(8),DIMENSION(length), INTENT(IN) :: b         REAL(8),DIMENSION(length - 1) :: passed_a         REAL(8),DIMENSION(length - 1) :: passed_b         real(8) :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y         REAL(8):: mindif         IF (length .lt. 10) THEN           WRITE(*, *) length         END IF         IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (abs(b(x) - init) .lt. (100 - length) * PRECISION) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = a(x) / init             IF (IS_POSSIBLE_2(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE_2        RECURSIVE FUNCTION IS_POSSIBLE(subset, destination, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8),DIMENSION(length), INTENT(IN) :: subset         REAL(8), INTENT(IN) :: destination         REAL(8), INTENT(IN) :: init         REAL(8),ALLOCATABLE :: passed(:)         REAL(8) :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y         IF (length .gt. 0) THEN           ALLOCATE(passed(length - 1))         ELSE           IF (abs(init - destination) .lt. (10 - length) * PRECISION) THEN             POSSIBLE = .TRUE.           ELSE             POSSIBLE = .FALSE.           END IF           RETURN         END IF         POSSIBLE = .FALSE.         DO x = 1, length           DO y = 1, x - 1             passed(y) = subset(y)           END DO           DO y = x + 1, length             passed(y - 1) = subset(y)           END DO           holder = subset(x) / init           IF (IS_POSSIBLE(passed, destination, length - 1, holder)) THEN             POSSIBLE = .TRUE.             RETURN           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 10):: b         REAL(8),DIMENSION(LOOPCOUNT):: totals         REAL(8),DIMENSION(10):: passed         REAL(8),DIMENSION(10):: passed_b         REAL(8) :: holder         INTEGER :: errors = 0         LOGICAL IS_POSSIBLE         LOGICAL IS_POSSIBLE_2          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   b(x, y) = totals(x)                   totals(x) = a(x, y) / totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed(y) = a(x, y)           END DO           holder = 1           IF (IS_POSSIBLE(passed, totals(x), 10, holder) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           holder = 1           IF (IS_POSSIBLE_2(passed, passed_b, 10, holder) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update predecrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic update                         --distribution[(int) (a[x]*b[y]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             distribution_comparison[(int) (a[x]*b[y]/10)]--;         }     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction and vector loop", "completion": "#ifndef T1 !T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   LOGICAL,DIMENSION(LOOPCOUNT, 10):: a   LOGICAL,DIMENSION(10):: b, has_false   LOGICAL:: temp   REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms   REAL(8):: false_margin   INTEGER:: errors, x, y    errors = 0   false_margin = exp(log(.5) / LOOPCOUNT)    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)    has_false = .FALSE.   DO y = 1, 10     DO x = 1, LOOPCOUNT       IF (randoms(x, y) .lt. false_margin) THEN         a(x, y) = .TRUE.       ELSE         a(x, y) = .FALSE.         has_false(y) = .TRUE.       END IF     END DO   END DO    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(b(1:10))     !$acc serial loop private(temp)     DO y = 1, 10       temp = .TRUE.       !$acc loop vector reduction(.AND.:temp)       DO x = 1, LOOPCOUNT         temp = temp .AND. a(x, y)       END DO       b(y) = temp     END DO   !$acc end data    DO x = 1, 10     IF (has_false(x) .eqv. b(x)) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels num gangs", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * restrict a = (real_t *)malloc(n * sizeof(real_t));     real_t * restrict b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc kernels loop num_gangs(16)         for (int x = 0; x < n; ++x){             b[x] = a[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc delete finalize", "completion": "#ifndef T1 !T1:runtime,data,executable-data,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))         !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          !$acc data copyout(c(1:LOOPCOUNT))           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_delete_finalize(a(1:LOOPCOUNT))         CALL acc_delete_finalize(b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,data,executable-data,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_copyin(a(1:LOOPCOUNT))         CALL acc_copyin(a(1:LOOPCOUNT))         CALL acc_copyin(b(1:LOOPCOUNT))         CALL acc_copyin(b(1:LOOPCOUNT))          !$acc data copyout(c(1:LOOPCOUNT))           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_delete_finalize(a(1:LOOPCOUNT))         CALL acc_delete_finalize(b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2**1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature enter data create", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc enter data create(b[0:n])     #pragma acc data copyin(a[0:n])     {         #pragma acc parallel present(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }     #pragma acc data copyout(c[0:n])     {         #pragma acc parallel present(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = b[x];             }         }     }     #pragma acc exit data delete(b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - a[x]) > PRECISION) {             err += 1;             break;         }     }      return err; } #endif  #ifndef T2 //T2:data,executable-data,construct-independent,compatibility-features,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc enter data present_or_create(b[0:n])     #pragma acc data copyin(a[0:n])     {         #pragma acc parallel present(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }     #pragma acc data copyout(c[0:n])     {         #pragma acc parallel present(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = b[x];             }         }     }     #pragma acc exit data delete(b[0:n])     for (int x = 0; x < n; ++x){         if (fabs(c[x] - a[x]) > PRECISION) {             err += 2;             break;         }     }      return err; } #endif  #ifndef T3 //T3:data,executable-data,construct-independent,compatibility-features,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc enter data pcreate(b[0:n])     #pragma acc data copyin(a[0:n])     {         #pragma acc parallel present(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }     #pragma acc data copyout(c[0:n])     {         #pragma acc parallel present(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = b[x];             }         }     }     #pragma acc exit data delete(b[0:n])     for (int x = 0; x < n; ++x){         if (fabs(c[x] - a[x]) > PRECISION){             err += 4;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign x bitxor expr", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev ^ a[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         b[x] = totals[x/10];                         totals[x/10] = totals[x/10] ^ a[x];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] ^= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature enter data create no lower bound", "completion": "#ifndef T1 !T1:data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(d)         e = 0          !$acc enter data create(c(:LOOPCOUNT))         !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) copyout(e(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO             !$acc loop             DO x = 1, LOOPCOUNT               e(x) = c(x) + d(x)             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc update device async", "completion": "#ifndef T1 !T1:runtime,data,executable-data,async,construct-independent,update,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         a_host = a         b_host = b          !$acc data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))           CALL acc_update_device_async(a(1:LOOPCOUNT), 1)           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               a(x) = a(x) * a(x)             END DO           !$acc end parallel           CALL acc_update_device_async(b(1:LOOPCOUNT), 2)           !$acc parallel async(2)             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = b(x) * b(x)             END DO           !$acc end parallel           !$acc parallel async(1) wait(2)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           !$acc wait(1)         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - ((a_host(x) * a_host(x)) + (b_host(x) * b_host(x)))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER,DIMENSION(1):: devtest         INTEGER :: errors = 0          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = 0         !$acc end parallel         IF (devtest(1) .eq. 1) THEN           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 0            !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc parallel async(1)               !$acc loop               DO x = 1, LOOPCOUNT                 a(x) = a(x) * a(x)               END DO             !$acc end parallel             CALL acc_update_device_async(a(1:LOOPCOUNT), 1)             !$acc parallel async(2)               !$acc loop               DO x = 1, LOOPCOUNT                 b(x) = b(x) * b(x)               END DO             !$acc end parallel             CALL acc_update_device_async(b(1:LOOPCOUNT), 2)             !$acc parallel async(1) wait(2)               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) + b(x)               END DO             !$acc end parallel             !$acc wait(1)           !$acc end data            DO x = 1, LOOPCOUNT             IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature atomic update expr bitor x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] |= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign x rshift expr", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if ((a >> x) % 2 == 1){                 if (is_possible(passed_a, passed_b, length - 1,prev >> 1)){                     delete[] passed_b;                     return true;                 }             }             else{                 if (is_possible(passed_a, passed_b, length - 1, prev)){                     delete[] passed_b;                     return true;                 }             }         }     }     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1<<8;      for (int x = 0; x < n; ++x){         a[x] = 1<<8;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                         {                             c[x * 7 + y] = a[x];                             a[x] = a[x] >> 1;                         }                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<8){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update expr eqv x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = a(x, y) .EQV. totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update ior expr x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .lt. .933) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           totals(x) = 0           totals_comparison(x) = 0         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update x minus expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = totals(x) - a(x, y)               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) - a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction bitand general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     n = 10;     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int b;     unsigned int host_b;      for (int x = 0; x < n; ++x){         a[x] = 0;         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX < false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }      b = a[0];     host_b = a[0];      #pragma acc data copyin(a[0:n])     {         #pragma acc parallel loop reduction(&:b)         for (int x = 0; x < n; ++x){             b = b & a[x];         }     }      for (int x = 1; x < n; ++x){         host_b = host_b & a[x];     }     if (b != host_b){         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(int));     real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int device[10];     unsigned int host[10];      for (int x = 0; x < 10 * n; ++x) {         a[x] = 0;         for (int y = 0; y < 16; ++y){             if (rand() / (real_t)RAND_MAX < false_margin) {                 a[x] += 1<<y;             }         }     }      for (int x = 0; x < 10; ++x) {         device[x] = 0;         host[x] = 0;         for (int y = 0; y < 16; ++y) {             device[x] += 1<<y;             host[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:10*n])     {         #pragma acc parallel loop reduction(&:device)         for (int x = 0; x < 10 * n; ++x) {             device[x%10] = device[x%10] & a[x];         }     }      for (int x = 0; x < 10 * n; ++x) {         host[x%10] = host[x%10] & a[x];     }      for (int x = 0; x < 10; ++x) {         if (host[x] != device[x]) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels copyin", "completion": "#ifndef T1 !T1:devonly,kernels,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest         devtest(1) = 1          !$acc enter data copyin(devtest(1:1))         !$acc kernels           devtest(1) = 0         !$acc end kernels          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0          !$acc data copy(b(1:LOOPCOUNT))           !$acc kernels copyin(a(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = b(x) + a(x)             END DO           !$acc end kernels         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(a(x) - b(x)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:devonly,kernels,V:2.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest         devtest(1) = 1          !$acc enter data copyin(devtest(1:1))         !$acc kernels           devtest(1) = 0         !$acc end kernels          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          IF (devtest(1) .eq. 1) THEN           CALL RANDOM_NUMBER(a)           b = 0           !$acc data copy(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             DO x = 1, LOOPCOUNT               a(x) = -1             END DO             !$acc kernels copyin(a(1:LOOPCOUNT))               !$acc loop               DO x = 1, LOOPCOUNT                 b(x) = a(x)               END DO             !$acc end kernels             DO x = 1, LOOPCOUNT               IF (abs(a(x) + 1) .gt. PRECISION) THEN                 errors = errors + 1               END IF             END DO           !$acc end data           DO x = 1, LOOPCOUNT             IF (abs(a(x) - b(x)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:devonly,kernels,V:2.0-2.7       LOGICAL FUNCTION test3()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest         devtest(1) = 1          !$acc enter data copyin(devtest(1:1))         !$acc kernels           devtest(1) = 0         !$acc end kernels          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          IF (devtest(1) .eq. 1) THEN           CALL RANDOM_NUMBER(a)           b = 0            !$acc kernels copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = a(x)             END DO           !$acc end kernels            DO x = 1, LOOPCOUNT             IF (abs(b(x)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc shutdown", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,shutdown,nonvalidating,V:1.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         IF (acc_get_device_type() .ne. acc_device_none) THEN           CALL acc_shutdown(acc_get_device_type())         END IF          test1 = .FALSE.       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM"}
{"prompt": "Create a test for the feature atomic max x expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop independent reduction", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,reduction,V:2.7-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t reduction;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc parallel copyin(a[0:n]) reduction(+:reduction)     {         #pragma acc loop independent         for (int x = 0; x < n; ++x){             reduction = reduction + a[x];         }     }      for (int x = 0; x < n; ++x){         reduction = reduction - a[x];     }     if (fabs(reduction) > PRECISION){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature parallel loop reduction add general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t total;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      total = 10;     #pragma acc data copyin(a[0:n], b[0:n]) copy(total)     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x){             total += a[x] + b[x];         }     }     for (int x = 0; x < n; ++x){         total -= a[x] + b[x];     }     if (fabs(total - 10) > PRECISION * (2 * n - 1)){ //199 = # of mathematical operations necessary         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,loop,reduction,combined-constructs,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * 10 * sizeof(real_t));     real_t * b = (real_t *)malloc(n * 10 * sizeof(real_t));     real_t c[10];     real_t c_host[10];      for (int x = 0; x < 10 * n; ++x) {         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      for (int x = 0; x < 10; ++x) {         c[x] = 1.0;         c_host[x] = 1.0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n])     {         #pragma acc parallel loop reduction(+:c[0:10])         for (int x = 0; x < n; ++x) {             for (int y = 0; y < 10; ++y) {                 c[y] += a[x * 10 + y] + b[x * 10 + y];             }         }     }      for (int x = 0; x < n; ++x) {         for (int y = 0; y < 10; ++y) {             c_host[y] += a[x * 10 + y] + b[x * 10 + y];         }     }      for (int x = 0; x < 10; ++x) {         if (fabs(c_host[x] - c[x]) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitor general", "completion": "#ifndef T1 !T1:serial,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors, temp, x, y, b, host_b   INTEGER,DIMENSION(LOOPCOUNT):: a   REAL(8):: false_margin   REAL(8),DIMENSION(LOOPCOUNT, 16):: randoms   errors = 0   false_margin = exp(log(.5) / LOOPCOUNT)    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)    DO x = 1, LOOPCOUNT     DO y = 1, 16       IF (randoms(x, y) .gt. false_margin) THEN         a(x) = a(x) + 2**(y - 1)       END IF     END DO   END DO    DO x = 1, LOOPCOUNT     host_b = ior(host_b, a(x))   END DO    !$acc data copyin(a(1:LOOPCOUNT))     !$acc serial loop reduction(ior:b)     DO x = 1, LOOPCOUNT       b = ior(b, a(x))     END DO   !$acc end data    IF (b .ne. host_b) THEN     errors = errors + 1   END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature declare function scope copyin", "completion": "#include \"acc_testsuite.h\" void function_test(real_t *a, real_t *b, real_t *c){     #pragma acc declare copyin(a[0:n], b[0:n])     #pragma acc parallel present(c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = c[x] + a[x] + b[x];         }     } }  void function_test_dev_only(real_t * a, real_t * b, real_t *c){     #pragma acc declare copyin(a[0:n], b[0:n])     #pragma acc parallel present(c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = c[x] + a[x] + b[x];             a[x] = -1;             b[x] = -1;         }     } }  #ifndef T1 //T1:declare,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];         b[x] = new real_t[n];         c[x] = new real_t[n];         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 1;         }     }      #pragma acc data copy(c[0:n][0:n])     {         for (int x = 0; x < n; ++x){             function_test(a[x], b[x], c[x]);         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:declare,construct-independent,devonly,reference-counting,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     int * devtest = (int *)malloc(sizeof(int));     real_t ** a_host = (real_t **)malloc(n * sizeof(real_t *));     real_t ** b_host = (real_t **)malloc(n * sizeof(real_t *));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a_host[x] = new real_t[n];             b_host[x] = new real_t[n];             for (int y = 0; y < n; ++y){                 a[x][y] = rand() / (real_t)(RAND_MAX / 10);                 a_host[x][y] = a[x][y];                 b[x][y] = rand() / (real_t)(RAND_MAX / 10);                 b_host[x][y] = b[x][y];                 c[x][y] = 0;             }         }          #pragma acc data copy(a[0:n][0:n], b[0:n][0:n], c[0:n][0:n])         {             for (int x = 0; x < n; ++x){                 function_test_dev_only(a[x], b[x], c[x]);             }         }          for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 if (fabs(a[x][y] + 1) > PRECISION){                     err += 1;                 }                 if (fabs(b[x][y] + 1) > PRECISION){                     err += 1;                 }                 if (fabs(c[x][y] - (a_host[x][y] + b_host[x][y])) > PRECISION){                     err += 1;                 }             }         }     }      return err; } #endif  #ifndef T3 //T3:declare,construct-independent,devonly,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     int * devtest = (int *)malloc(sizeof(int));     real_t ** a_host = (real_t **)malloc(n * sizeof(real_t *));     real_t ** b_host = (real_t **)malloc(n * sizeof(real_t *));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 a[x][y] = rand() / (real_t)(RAND_MAX / 10);                 a_host[x][y] = a[x][y];                 b[x][y] = rand() / (real_t)(RAND_MAX / 10);                 b_host[x][y] = b[x][y];                 c[x][y] = 1;             }         }          #pragma acc data copy(c[0:n][0:n])         {             for (int x = 0; x < n; ++x){                 function_test_dev_only(a[x], b[x], c[x]);             }         }          for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 if (fabs(a[x][y] - a_host[x][y]) > PRECISION){                     err += 1;                 }                 if (fabs(b[x][y] - b_host[x][y]) > PRECISION){                     err += 1;                 }                 if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){                     err += 1;                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitor loop", "completion": "#ifndef T1 !T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors, x, y, z, temp   INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b, b_copy   INTEGER,DIMENSION(10):: c   REAL(8):: false_margin   REAL(8),DIMENSION(LOOPCOUNT, 10, 17):: randoms    errors = 0   false_margin = exp(log(.5) / LOOPCOUNT)    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)    DO x = 1, LOOPCOUNT     DO y = 1, 10       b(x, y) = INT(randoms(x, y, 17) * 1000)       DO z = 1, 16         IF (randoms(x, y, z) .gt. false_margin) THEN           a(x, y) = a(x, y) + 2**(z-1)         END IF       END DO     END DO   END DO    b_copy = b    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(b(1:LOOPCOUNT, 1:10), c(1:10))     !$acc serial loop gang private(temp)     DO y = 1, 10       temp = 0       !$acc loop worker reduction(ior:temp)       DO x = 1, LOOPCOUNT         temp = ior(temp, a(x, y))       END DO       c(y) = temp       !$acc loop worker       DO x = 1, LOOPCOUNT         b(x, y) = b(x, y) + c(y)       END DO     END DO   !$acc end data    DO y = 1, 10     temp = a(1, y)     DO x = 2, LOOPCOUNT       temp = ior(temp, a(x, y))     END DO     IF (temp .ne. c(y)) THEN       errors = errors + 1     END IF     DO x = 1, LOOPCOUNT       IF (b(x, y) .ne. (b_copy(x, y) + temp)) THEN         errors = errors + 1       END IF     END DO   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture assign expr or x", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         LOGICAL, INTENT(IN) :: init         LOGICAL,DIMENSION(length), INTENT(IN) :: a         LOGICAL,DIMENSION(length), INTENT(IN) :: b         LOGICAL,DIMENSION(length - 1) :: passed_a         LOGICAL,DIMENSION(length - 1) :: passed_b         LOGICAL :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (b(x) .eqv. init) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = a(x) .or. init             IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         LOGICAL,DIMENSION(10):: passed_a, passed_b         LOGICAL IS_POSSIBLE         LOGICAL:: init         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   b(x, y) = totals(x)                   totals(x) = a(x, y) .OR. totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .OR. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           init = .FALSE.           IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured x rshift expr assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if ((b[x] == (prev >> 1) && (a>>x)%2==1) || b[x] == prev && (a>>x)%2==0){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_b);                 return true;             }         }     }     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1<<8;      for (int x = 0; x < n; ++x){         a[x] = 1<<8;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                         {                             a[x] = a[x] >> 1;                             c[x * 7 + y] = a[x];                         }                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<8){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture expr minus x", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] - prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }   bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){     if (length == 0){         if (fabs(current_value - test_value) > PRECISION){             return true;         }         else {             return false;         }     }     real_t * passed = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         for (int y = 0; y < x; ++y){             passed[y] = remaining_combinations[y];         }         for (int y = x + 1; y < length; ++y){             passed[y - 1] = remaining_combinations[y];         }         if (possible_result(passed, length - 1, remaining_combinations[x] - current_value, test_value)){             free(passed);             return true;         }     }     free(passed);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(((n/10) + 1) * sizeof(real_t));     int indexer = 0;     real_t * passed = (real_t *)malloc(10 * sizeof(real_t));     real_t *passed_a = (real_t *)malloc(10 * sizeof(real_t));     real_t *passed_b = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < (n/10) + 1; ++x){         totals[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     b[x] = totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];             }         }     }     for (int x = 0; x < (n/10) + 1; ++x){         indexer = x;         while (indexer < n){             passed[indexer/((int) (n/10) + 1)] = a[indexer];             indexer += (n/10) + 1;         }         if (!(possible_result(passed, 10, 0, totals[x]))){             err += 1;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_a[passed_indexer] = a[absolute_indexer];             passed_b[passed_indexer] = b[absolute_indexer];         }         if (!is_possible(passed_a, passed_b, passed_indexer, 0)){             err += 1;         }         break;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign bitand equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev & a[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }   #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         for (int y = 0; y < 8; ++y){             totals[x] =  1<<y;             totals_comparison[x] = 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         b[x] = totals[x/10];                         totals[x/10] &= a[x];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] &= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }      for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitand vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int c = 0;     unsigned int b_host;      for (int x = 0; x < 10 * n; ++x){         a[x] = 0;         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX < false_margin){                 a[x] += 1 << y;             }         }     }      #pragma acc data copyin(a[0:10*n]) copyout(b[0:10])     {         #pragma acc parallel loop private(c)         for (int x = 0; x < 10; ++x){             c = a[x * n];             #pragma acc loop vector reduction(&:c)             for (int y = 1; y < n; ++y){                 c = c & a[x * n + y];             }             b[x] = c;         }     }     for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host & a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));     real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int c[5];     unsigned int * b_host = (unsigned int *)malloc(5 * sizeof(unsigned int));           for (int x = 0; x < 25 * n; ++x){         a[x] = 0;         for (int y = 0; y < 16; ++y) {             if (rand() / (real_t)RAND_MAX < false_margin) {                 a[x] += 1 << y;             }         }     }      #pragma acc data copyin(a[0:25*n]) copyout(b[0:25])     {         #pragma acc parallel loop private(c)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 c[y] = a[x * 5 * n + y];             }             #pragma acc loop vector reduction(&:c)             for (int y = 0; y < 5 * n; ++y) {                 c[y%5] = c[y%5] & a[x * 5 * n + y];             }             for (int y = 0; y < 5; ++y) {                 b[x * 5 + y] = c[y];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             b_host[y] = a[x * 5 * n + y];         }         for (int y = 0; y < 5 * n; ++y) {             b_host[y%5] = b_host[y%5] & a[x * 5 * n + y];         }         for (int y = 0; y < 5; ++y) {             if (b_host[y] != b[x * 5 + y]){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured multiply equals assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] * prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x%(n/10 + 1)] *= a[x] + b[x];                     c[x] = totals[x%(n/10 + 1)];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitxor general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     unsigned int host_b;     unsigned int b = 0;      for (int x = 0; x < n; ++x){         a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);     }      #pragma acc data copyin(a[0:n])     {         #pragma acc serial loop reduction(^:b)         for (int x = 0; x < n; ++x){             b = b ^ a[x];         }     }      host_b = a[0];      for (int x = 1; x < n; ++x){         host_b = host_b ^ a[x];     }     if (b != host_b){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel switch", "completion": "#ifndef T1 !T1:parallel,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a         REAL(8),DIMENSION(LOOPCOUNT):: b, c, randoms!Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(randoms)         a = floor(randoms * 3)          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))         !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))           !$acc loop           DO x = 1, LOOPCOUNT             SELECT CASE (a(x))               CASE (0)                 c(x) = b(x) * b(x)               CASE (1)                 c(x) = b(x) / b(x)               CASE (2)                 c(x) = b(x) / 2             END SELECT           END DO         !$acc end parallel         !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           SELECT CASE (a(x))             CASE (0)               IF (abs(c(x) - (b(x) * b(x))) .gt. PRECISION) THEN                 errors = errors + 1               END IF             CASE (1)               IF (abs(c(x) - (b(x) / b(x))) .gt. PRECISION) THEN                 errors = errors + 1               END IF             CASE (2)               IF (abs(c(x) - (b(x) / 2)) .gt. PRECISION) THEN                 errors = errors + 1               END IF           END SELECT         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t* a = new real_t[1024];     real_t* b = new real_t[1024];     real_t* c = new real_t[1024];      for(int x = 0; x < 1024; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:1024], b[0:1024]) copy(c[0:1024])     {         #pragma acc serial         {             #pragma acc loop             for (int _0 = 0; _0 < 2; ++_0){                 #pragma acc loop                 for (int _1 = 0; _1 < 2; ++_1){                     #pragma acc loop                     for (int _2 = 0; _2 < 2; ++_2){                         #pragma acc loop                         for (int _3 = 0; _3 < 2; ++_3){                             #pragma acc loop                             for (int _4 = 0; _4 < 2; ++_4){                                 #pragma acc loop                                 for (int _5 = 0; _5 < 2; ++_5){                                     #pragma acc loop                                     for (int _6 = 0; _6 < 2; ++_6){                                         #pragma acc loop                                         for (int _7 = 0; _7 < 2; ++_7){                                             #pragma acc loop                                             for (int _8 = 0; _8 < 2; ++_8){                                                 #pragma acc loop                                                 for (int _9 = 0; _9 < 2; ++_9){                                                     c[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] =                                                     a[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] +                                                     b[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9];                                                 }                                             }                                         }                                     }                                 }                             }                         }                     }                 }             }         }     }      for (int x = 0; x < 1024; ++x){         if(fabs(c[x] - (a[x] +b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,async,wait,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * restrict a = new real_t[n];     real_t * restrict b = new real_t[n];     real_t * restrict c = new real_t[n];     real_t * restrict d = new real_t[n];     real_t * restrict e = new real_t[n];     real_t * restrict f = new real_t[n];     real_t * restrict g = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);       \tb[x] = rand() / (real_t)(RAND_MAX / 10);       \tc[x] = 0.0;       \td[x] = rand() / (real_t)(RAND_MAX / 10);       \te[x] = rand() / (real_t)(RAND_MAX / 10);       \tf[x] = 0.0;       \tg[x] = 0.0;     }     #pragma acc enter data create(g[0:n], c[0:n], f[0:n])     #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])     {         #pragma acc kernels async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc kernels async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         #pragma acc kernels wait(1, 2) async(3)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 g[x] = c[x] + f[x];             }         }     }     #pragma acc wait(1, 2)     #pragma acc update host(c[0:n], f[0:n])     #pragma acc exit data copyout(g[0:n]) async(3)     for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;       \t}         if (fabs(f[x] - (d[x] + e[x])) > PRECISION){             err += 1;         }     }     #pragma acc wait(3)     for (int x = 0; x < n; ++x){         if (fabs(g[x] - (c[x] + f[x])) > PRECISION){             err += 1;         }     }     #pragma acc exit data delete(c[0:n], f[0:n])      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction max loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * maximum = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 0;     real_t max = 0.0;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);         c[x] = 0.0;     }     for (int x = 0; x < 10; ++x){         maximum[x] = 0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], maximum[0:10])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(max:temp)             for (int y = 0; y < n; ++y){                 temp = fmax(a[x * n + y] * b[x * n + y], temp);             }             maximum[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 c[x * n + y] = (a[x * n + y] * b[x * n + y]) / maximum[x];             }         }     }     for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = fmax(temp, a[x * n + y] * b[x * n + y]);         }         if (fabs(temp - maximum[x]) > PRECISION){             err += 1;         }         for (int y = 0; y < n; ++y){             if (c[x * n + y] > 1){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(25 * n * sizeof(real_t));     real_t * maximum = (real_t *)malloc(25 * sizeof(real_t));     real_t * host_maximum = (real_t *)malloc(25 * sizeof(real_t));     real_t temp[5];      for (int x = 0; x < 25 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      for (int x = 0; x < 25; ++x) {         maximum[x] = 0;         host_maximum[x] = 0;     }      #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(c[0:25*n], maximum[0:25])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 temp[y] = 0;             }             #pragma acc loop worker reduction(max:temp)             for (int y = 0; y < 5 * n; ++y) {                 temp[y%5] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], temp[y%5]);             }             for (int y = 0; y < 5; ++y) {                 maximum[x * 5 + y] = temp[y];             }             #pragma acc loop worker             for (int y = 0; y < 5 * n; ++y) {                 c[x * 5 * n + y] = (a[x * 5 * n + y] * b[x * 5 * n + y]) / maximum[x * 5 + (y % 5)];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5 * n; ++y) {             host_maximum[x * 5 + (y % 5)] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], host_maximum[x * 5 + (y % 5)]);         }         for (int y = 0; y < 5; ++y) {             if (fabs(host_maximum[x * 5 + y] - maximum[x * 5 + y]) > PRECISION) {                 err += 1;             }         }         for (int y = 0; y < 5 * n; ++y) {             if (fabs(c[x * 5 * n + y] - ((a[x * 5 * n + y] * b[x * 5 * n + y]) / maximum[x * 5 + (y % 5)])) > PRECISION) {                 err += 1;             }         }     }       return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc unmap data", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d;     real_t *e = (real_t *)malloc(n * sizeof(real_t));      d = (real_t *)acc_malloc(n * sizeof(real_t));     for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      acc_map_data(c, d, n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      #pragma acc update host(c[0:n])     for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x]))> PRECISION){             err += 1;         }     }      acc_unmap_data(c);     acc_free(d);      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d;     real_t *e = (real_t *)malloc(n * sizeof(real_t));      d = (real_t *)acc_malloc(2 * n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     acc_map_data(c, d, n * sizeof(real_t));     acc_map_data(e, &(d[n]), n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n], e[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 e[x] = a[x] * b[x];             }         }     }      #pragma acc update host(c[0:n])     #pragma acc update host(e[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }         if (fabs(e[x] - (a[x] * b[x])) > PRECISION){             err += 1;         }     }     acc_unmap_data(c);     acc_unmap_data(e);     acc_free(d);      return err; } #endif  #ifndef T3 //T3:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d;     real_t *e = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     d = (real_t *)acc_malloc(n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n]) deviceptr(d)     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 d[x] = a[x] + b[x];             }         }     }      acc_map_data(c, d, n * sizeof(real_t));     #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      #pragma acc update host(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - 2 * (a[x] + b[x])) > 2 * PRECISION){             err += 1;         }     }      acc_unmap_data(c);     acc_free(d);      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign x multiply expr", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, a[x] * prev)){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x%(n/10 + 1)];                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature set device type num", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:set,runtime,syntactic,V:2.5-3.2 int test1(){ \tint err = 0; \tint device_num;  \tdevice_num = acc_get_device_num(acc_get_device_type()); \t#pragma acc set device_type(host) device_num(device_num)  \treturn err; } #endif  #ifndef T2 //T2:set,runtime,syntactic,V:2.5-3.2 int test2(){ int err = 0;         int device_num;          device_num = acc_get_device_num(acc_get_device_type());         #pragma acc set device_type(multicore) device_num(device_num)          return err;\t } #endif  #ifndef T3 //T2:set,runtime,syntactic,V:2.5-3.2 int test3(){ int err = 0;         int device_num;          device_num = acc_get_device_num(acc_get_device_type());         #pragma acc set device_type(default) device_num(device_num)          return err; } #endif  int main(){ \tint failcode = 0;     \tint failed; #ifndef T1     \tfailed = 0;     \tfor (int x = 0; x < NUM_TEST_CALLS; ++x){         \tfailed = failed + test1();     \t}     \tif (failed != 0){         \tfailcode = failcode + (1 << 0);     \t} #endif #ifndef T2     \tfailed = 0;     \tfor (int x = 0; x < NUM_TEST_CALLS; ++x){         \tfailed = failed + test2();     \t}     \tif (failed != 0){         \tfailcode = failcode + (1 << 1);     \t} #endif  #ifndef T3     \tfailed = 0;     \tfor (int x = 0; x < NUM_TEST_CALLS; ++x){         \tfailed = failed + test3();     \t}     \tif (failed != 0){         \tfailcode = failcode + (1 << 2);     \t} #endif      \treturn failcode; } "}
{"prompt": "Create a test for the feature atomic update expr multiply x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction add vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10];     real_t temp = 0.0;      for(int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10])     {         #pragma acc kernels loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0.0;             #pragma acc loop vector reduction(+:temp)             for (int y = 0; y < n; ++y){                 temp += a[(x * n) + y] + b[(x * n) + y];             }             c[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             c[x] -= a[(x * n) + y] + b[(x * n) + y];         }         if (fabs(c[x]) > PRECISION * (2 * n - 1)){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured expr multiply x assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] * prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t * passed_ab = new real_t[10];     real_t * passed_c = new real_t[10];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];                     c[x] = totals[x%(n/10 + 1)];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine bind nonprototype lambda nonstring lambda", "completion": "#include \"acc_testsuite.h\"  //test 1 host lambda #pragma acc routine vector bind(device_array_array) auto host_array_array = [](real_t * a, long long n){     #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; };  //test 1 device lambda auto device_array_array = [](real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; };  //test 2 host lambda #pragma acc routine vector bind(device_object_array) auto host_object_array= [](data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned += a->data[x];     }     return returned; };  //test 2 device lambda auto device_object_array = [](data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; };  //test 3 host lambda #pragma acc routine vector bind(device_array_object) auto host_array_object = [](real_t * a, long long n){    #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; };  //test 3 device lambda auto device_array_object = [](real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; };  //test 4 host lambda #pragma acc routine vector bind(device_object_object) auto host_object_object = [](data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned += a->data[x];     }     return returned; };  //test 4 device lambda auto device_object_object = [](data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; };  #ifndef T1 //T1:routine,V:2.7-3.3 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){        \ta[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_array_array(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_array(a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_array(a, n) - b[x]) > PRECISION)){             err += 1;         }     }     delete[] a;     delete[] b;      return err; } #endif #ifndef T2 //T2:routine,V:2.7-3.3 int test2(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a, a.data[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_object_array(&a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_array(&a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_array(&a, n) - b[x]) > PRECISION)){             err += 1;         }     }      delete[] b;      return err; } #endif #ifndef T3 //T3:routine,V:2.7-3.3 int test3(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b, b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_array_object(a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_object(a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_object(a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      delete[] a;      return err; } #endif #ifndef T4 //T4:routine,V:2.7-3.3 int test4(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a, a.data[0:n], b ,b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_object_object(&a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_object(&a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_object(&a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed = 0; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }      if(failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }      if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }      if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test4();     }      if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitand loop", "completion": "#ifndef T1 !T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b, b_copy   INTEGER,DIMENSION(10):: c, host_c   INTEGER:: errors, x, y, z, temp   REAL(8):: false_margin   REAL(8),DIMENSION(LOOPCOUNT, 10, 17):: randoms    errors = 0   false_margin = exp(log(.5) / LOOPCOUNT)    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)    DO y = 1, 10     DO x = 1, LOOPCOUNT       b(x) = INT(10 * randoms(x, y, 17))       DO z = 1, 16         IF (randoms(x, y, z) .lt. false_margin) THEN           a(x) = a(x) + 2**(z - 1)         END IF       END DO     END DO   END DO    b_copy = b    DO y = 1, 10     temp = a(1, y)     DO x = 1, LOOPCOUNT       temp = iand(temp, a(x, y))     END DO     host_c(y) = temp   END DO    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(b(1:LOOPCOUNT, 1:10), c(1:10))     !$acc serial loop gang private(temp)     DO y = 1, 10       temp = a(1, y)       !$acc loop worker reduction(iand:temp)       DO x = 1, LOOPCOUNT         temp = iand(temp, a(x, y))       END DO       c(y) = temp       !$acc loop worker       DO x = 1, LOOPCOUNT         b(x, y) = b(x, y) + c(y)       END DO     END DO   !$acc end data    DO y = 1, 10     IF (host_c(y) .ne. c(y)) THEN       errors = errors + 1     END IF     DO x = 1, LOOPCOUNT       IF (b(x, y) .ne. b_copy(x, y) + c(y)) THEN         errors = errors + 1       END IF     END DO   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature data create", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,data-region,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc data create(b[0:n])     {         #pragma acc data copyin(a[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = a[x];                 }             }         }         #pragma acc data copyout(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - a[x]) > PRECISION) {             err += 1;             break;         }     }      return err; } #endif  #ifndef T2 //T2:data,data-region,construct-independent,compatibility-features,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc data present_or_create(b[0:n])     {         #pragma acc data copyin(a[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = a[x];                 }             }         }         #pragma acc data copyout(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - a[x]) > PRECISION) {             err += 2;             break;         }     }      return err; } #endif  #ifndef T3 //T3:data,data-region,construct-independent,compatibility-features,V:1.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc data pcreate(b[0:n])     {         #pragma acc data copyin(a[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = a[x];                 }             }         }         #pragma acc data copyout(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - a[x]) > PRECISION){             err += 4;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr plus x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = a(x, y) + totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) + a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial copyout", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,data-region,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);      real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int* hasDevice = (int *) malloc(sizeof(int));     hasDevice[0] = 1;     #pragma acc enter data copyin(hasDevice[0:1])     #pragma acc serial present(hasDevice[0:1])     {       hasDevice[0] = 0;     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n])     {         #pragma acc serial copyout(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T2 //T2:serial,data,data-region,reference-counting,devonly,V:2.6-2.7 int test2(){     int err = 0;     srand(SEED);      real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int* hasDevice = (int *) malloc(sizeof(int));     hasDevice[0] = 1;     #pragma acc enter data copyin(hasDevice[0:1])     #pragma acc serial present(hasDevice[0:1])     {       hasDevice[0] = 0;     }      if (hasDevice[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0;         }         #pragma acc data copyin(a[0:n], b[0:n])         {             #pragma acc serial copyout(b[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = a[x];                 }             }         }         for (int x = 0; x < n; ++x){             if (fabs(b[x]) > PRECISION){                 err += 2;                 break;             }         }     }      return err; } #endif  #ifndef T3 //T3:serial,data,data-region,reference-counting,V:2.6-2.7 int test3(){     int err = 0;     srand(SEED);      real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int* hasDevice = (int *) malloc(sizeof(int));     hasDevice[0] = 1;     #pragma acc enter data copyin(hasDevice[0:1])     #pragma acc serial present(hasDevice[0:1])     {       hasDevice[0] = 0;     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc serial copyout(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }         #pragma acc update host(b[0:n])     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - a[x]) > PRECISION){             err += 4;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction max general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t max = 0.0;     int found = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(max:max)         for (int x = 0; x < n; ++x){             max = fmax(a[x] * b[x], max);         }     }      for (int x = 0; x < n; ++x){         if (fabs(max - (a[x] * b[x] + PRECISION)) < 0){             err = 1;         }         if (fabs(max - (a[x] * b[x] - PRECISION)) > 0){             found = 1;         }     }     if (found = 0){         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t maximums[10];     real_t max_host[10];      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      for (int x = 0; x < 10; ++x) {         maximums[x] = 0;         max_host[x] = 0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n])     {         #pragma acc parallel loop reduction(max:maximums)         for (int x = 0; x < 10 * n; ++x) {             maximums[x%10] = fmax(a[x] * b[x], maximums[x%10]);         }     }      for (int x = 0; x < 10 * n; ++x) {         max_host[x%10] = fmax(a[x] * b[x], maximums[x%10]);     }          for (int x = 0; x < 10; ++x) {         if (fabs(max_host[x] - maximums[x]) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels copyin", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data,data-region,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }       #pragma acc data copy(b[0:n])     {         #pragma acc kernels copyin(a[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] += a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - a[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     int * devtest = (int *)malloc(sizeof(int));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc kernels present(devtest[0:1])     {       devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0.0;         }          #pragma acc data copy(a[0:n], b[0:n])         {             for (int x = 0; x < n; ++x){                 a[x] = -1;             }             #pragma acc kernels copyin(a[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = a[x];                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(b[x] - a[x]) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T3 //T3:kernels,data,data-region,devonly,V:1.0-2.7 int test3(){     int err = 0;     srand(SEED);     int * devtest = (int *)malloc(sizeof(int));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc kernels present(devtest[0:1])     {       devtest[0] = 0;     }          if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0;         }         #pragma acc kernels copyin(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }          for (int x = 0; x < n; ++x){             if (fabs(b[x]) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels create zero", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data,data-region,V:3.0-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc kernels create(zero: b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] += a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data copyout no lower bound", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,data-region,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel if", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,if,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int accel = 1;     int host = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }     #pragma acc parallel if(host)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,if,devonly,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int * dev_test = (int *)malloc(sizeof(int));     int accel = 1;     int host = 0;      dev_test[0] = 1;     #pragma acc data copyin(dev_test[0:1])     #pragma acc parallel     {       dev_test[0] = 0;     }      if (devtest[0] != 0){         for (int x = 0; x < n;  ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0;         }          #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])         #pragma acc parallel if(host) present(a[0:n], b[0:n], c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }         #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])          for (int x = 0; x < n; ++x){             if (fabs(c[x]) > PRECISION){                 err = 1;             }         }     }      return err; } #endif  #ifndef T3 //T3:parallel,if,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int accel = 1;     int host = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])      #pragma acc parallel if(accel) present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] += a[x] + b[x];         }     }      #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION * 2){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels default present", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data,data-region,default,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc enter data copyin(a[0:n]), create(b[0:n])     #pragma acc kernels default(present)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             b[x] = a[x];         }     }     #pragma acc exit data delete(a[0:n]), copyout(b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture min x expr list assign", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, c, length, init) RESULT(POSSIBLE)       INTEGER, INTENT(IN) :: length       REAL(8), INTENT(IN) :: init       REAL(8),DIMENSION(length), INTENT(IN) :: a       REAL(8),DIMENSION(length), INTENT(IN) :: b       REAL(8),DIMENSION(length), INTENT(IN) :: c       REAL(8),DIMENSION(length - 1) :: passed_a       REAL(8),DIMENSION(length - 1) :: passed_b       REAL(8),DIMENSION(length - 1) :: passed_c       REAL(8) :: holder       LOGICAL :: POSSIBLE       INTEGER :: x, y        IF (length .eq. 0) THEN         POSSIBLE = .TRUE.         RETURN       END IF       POSSIBLE = .FALSE.        DO x = 1, length         IF (abs(c(x) - min(init, a(x), b(x))) .lt. (10 - length) * PRECISION) THEN           DO y = 1, x - 1             passed_a(y) = a(y)             passed_b(y) = b(y)           END DO           DO y = x + 1, length             passed_a(y - 1) = a(y)             passed_b(y - 1) = b(y)           END DO           holder = c(x)           IF (IS_POSSIBLE(passed_a, passed_b, passed_c, length - 1, holder)) THEN             POSSIBLE = .TRUE.             RETURN           END IF         END IF       END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()       IMPLICIT NONE       INCLUDE \"acc_testsuite.Fh\"       INTEGER :: x, y !Iterators       REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data       REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison       REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c       REAL(8):: init       LOGICAL IS_POSSIBLE       INTEGER :: errors = 0        !Initilization       SEEDDIM(1) = 1 #     ifdef SEED       SEEDDIM(1) = SEED #     endif       CALL RANDOM_SEED(PUT=SEEDDIM)        CALL RANDOM_NUMBER(a)       CALL RANDOM_NUMBER(b)        totals = 1       totals_comparison = 1        !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))         !$acc parallel           !$acc loop           DO x = 1, LOOPCOUNT             DO y = 1, 10               !$acc atomic capture                 totals(x) = min(totals(x), a(x, y), b(x, y))                 c(x, y) = totals(x)               !$acc end atomic             END DO           END DO         !$acc end parallel       !$acc end data       DO x = 1, LOOPCOUNT         DO y = 1, 10           totals_comparison(x) = min(totals_comparison(x), a(x, y), b(x, y))         END DO       END DO       DO x = 1, LOOPCOUNT         IF (totals_comparison(x) .NE. totals(x)) THEN           errors = errors + 1           WRITE(*, *) totals_comparison(x)         END IF       END DO        DO x = 1, LOOPCOUNT         DO y = 1, 10           passed_a(y) = a(x, y)           passed_b(y) = b(x, y)           passed_c(y) = c(x, y)         END DO         init = 1         IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN           errors = errors + 1         END IF       END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction max vector loop", "completion": "#ifndef T1 !T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(10):: maximum         INTEGER :: errors = 0         REAL(8) :: temp          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         maximum = 0          !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(maximum(1:10))           !$acc parallel loop private(temp)           DO x = 0, 9             temp = 0             !$acc loop vector reduction(max:temp)             DO y = 1, LOOPCOUNT               temp = max(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))             END DO             maximum(x + 1) = temp           END DO         !$acc end data          DO x = 0, 9           temp = 0           DO y = 1, LOOPCOUNT             temp = max(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))           END DO           IF (abs(temp - maximum(x + 1)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign x lshift expr", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if ((a>>x)%2 == 1){                 if (is_possible(passed_a, passed_b, length - 1, prev << 1)){                     return true;                 }             }             else {                 if (is_possible(passed_a, passed_b, length - 1, prev)){                     return true;                 }             }         }     }     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1;      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                         {                             c[x * 7 + y] = a[x];                             a[x] = a[x] << 1;                         }                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature init device type num", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:init,runtime,V:2.5-3.2 int test1(){     int err = 0;     srand(SEED);     int device_num = acc_get_device_num(acc_get_device_type());      #pragma acc init device_type(host) device_num(device_num)      return err; } #endif #ifndef T2 //T1:init,runtime,V:2.5-3.2 int test2(){     int err = 0;     srand(SEED);     int device_num = acc_get_device_num(acc_get_device_type());      #pragma acc init device_type(multicore) device_num(device_num)      return err; } #endif #ifndef T3 //T1:init,runtime,V:2.5-3.2 int test3(){     int err = 0;     srand(SEED);     int device_num = acc_get_device_num(acc_get_device_type());      #pragma acc init device_type(default) device_num(device_num)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }     if (failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }     if (failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }     if (failed){         failcode += (1 << 2);     } #endif      return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction or general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(n * sizeof(char));     real_t false_margin = pow(exp(1), log(.5)/n);     char result = 0;     char found = 0;      for (int x = 0; x < n; ++x){         if(a[x] = rand() / (real_t)(RAND_MAX) > false_margin){             a[x] = 1;         }         else{             a[x] = 0;         }     }       #pragma acc data copyin(a[0:n])     {         #pragma acc kernels loop reduction(||:result)         for (int x = 0; x < n; ++x){             result = result || a[x];         }     }      for (int x = 0; x < n; ++x){         if (a[x] == 1){             found = 1;         }     }     if (found != result){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update x divided expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = totals(x) / a(x, y)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) / a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture bitor equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == (a[x]|prev)){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_indexer = 0;     int absolute_indexer = 0;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     b[x] = totals[x%(n/10 + 1)] |= a[x];             }         }     }     for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] |= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < (n/10 + 1); ++x){         for (absolute_indexer = x, temp_indexer = 0; absolute_indexer < n; absolute_indexer += n/10 + 1, temp_indexer++){             temp_a[temp_indexer] = a[absolute_indexer];             temp_b[temp_indexer] = b[absolute_indexer];         }         if (!(is_possible(temp_a, temp_b, temp_indexer, 0))){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction max general", "completion": "#ifndef T1 !T1:serial,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   REAL(8),DIMENSION(LOOPCOUNT):: a, b   REAL(8):: maxval, host_max   INTEGER:: errors, x    SEEDDIM(1) = 1   #ifdef SEED   SEEDDIM(1) = SEED   #endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)    errors = 0    DO x = 1, LOOPCOUNT     host_max = max(host_max, a(x) * b(x))   END DO    !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))     !$acc serial loop reduction(max:maxval)     DO x = 1, LOOPCOUNT       maxval = max(maxval, a(x) * b(x))     END DO   !$acc end data    IF (abs(host_max - maxval) .gt. PRECISION) THEN     errors = errors + 1   END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM serial_loop_reduction_max_general         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel default present", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,default,data,data-region,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = 0.0;     }     #pragma acc enter data copyin(a[0:n])     #pragma acc parallel default(present)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             a[x] = 1.0;         }     }     #pragma acc exit data copyout(a[0:n])      for (int x = 0; x < n; ++x){         if (fabs(a[x] - 1.0) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop vector", "completion": "#ifndef T1 !T1:parallel,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))           !$acc parallel loop vector           DO x = 1, LOOPCOUNT             c(x) = a(x) + b(x)           END DO         !$acc end data                  DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels wait", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,wait,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n]) async(1)     #pragma acc kernels wait(1)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] += a[x] + b[x];         }     }      #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature init device type num", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-3.2       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: device_num         INTEGER :: device_type         INTEGER :: errors = 0          device_type = acc_get_device_type()         device_num = acc_get_device_num(device_type)         !$acc init device_type(host) device_num(device_num)          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-3.2       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: device_num         INTEGER :: device_type         INTEGER :: errors = 0          device_type = acc_get_device_type()         device_num = acc_get_device_num(device_type)         !$acc init device_type(multicore) device_num(device_num)          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-3.2       LOGICAL FUNCTION test3()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: device_num         INTEGER :: device_type         INTEGER :: errors = 0          device_type = acc_get_device_type()         device_num = acc_get_device_num(device_type)         !$acc init device_type(default) device_num(device_num)          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM init_device_type_num         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM"}
{"prompt": "Create a test for the feature atomic capture expr rshift x", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int* a, unsigned int* b, int length, int prev){     if (length == 0){         return true;     }     unsigned int *passed_a = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if (b[x] == (a[x]>>prev)){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(3 * n * sizeof(int));     int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};     int result;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 3; ++y){             a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));         }         b[x] = 0;     }      #pragma acc data copyin(a[0:3 * n]) copy(b[0:n]) copyout(c[0:3*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop independent                 for (int y = 0; y < 3; ++y){                     #pragma acc atomic capture                         c[x * 3 + y] = b[x] = a[x * 3 + y] >> b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 6; ++y){             result = 0;             for (int z = 0; z < 3; ++z){                 result = a[x * 3 + orders[y * 3 + z]] >> result;             }             if (result == b[x]){                 break;             }         }         if (result != b[x]){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(&(a[3*x]), &(c[3*x]), 3, 0)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc get device num", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,set,V:1.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         INTEGER :: errors         errors = 0          IF (acc_get_device_type() .ne. acc_device_none) THEN           DO x = 1, acc_get_num_devices(acc_get_device_type())             CALL acc_set_device_num(x, acc_get_device_type())             IF (acc_get_device_num(acc_get_device_type()) .ne. x) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature parallel independent atomic capture", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.7-3.2 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(a[0:n], b[0:n])     {         #pragma acc parallel         { \t    #pragma acc loop independent             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     b[x] = (a[x])++;             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] + 1)) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1    failed = 0;    for (int x = 0; x < NUM_TEST_CALLS; ++x){        failed = failed + test1();    }    if (failed != 0){        failcode = failcode + (1 << 0);    } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature acc create", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      acc_create(c, n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      acc_copyout(c, n * sizeof(real_t));      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      acc_create(c, n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel present(c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:runtime,data,executable-data,compatibility-features,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      acc_pcreate(c, n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T4 //T4:runtime,data,executable-data,compatibility-features,construct-independent,V:2.0-2.7 int test4(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      acc_present_or_create(c, n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T5 //T5:runtime,data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7 int test5(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int * dev_test = (int *)malloc(sizeof(int));      dev_test[0] = 1;     #pragma acc enter data copyin(dev_test[0:1])     #pragma acc parallel present(dev_test[0:1])     {         dev_test[0] = 0;     }     if (dev_test[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 1;         }          #pragma acc enter data copyin(c[0:n])         for (int x = 0; x < n; ++x){             c[x] = 0;         }         acc_create(c, n * sizeof(real_t));         #pragma acc data copyin(a[0:n], b[0:n])         {             #pragma acc parallel present(c[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x) {                     c[x] += a[x] + b[x];                 }             }         }          #pragma acc exit data delete(c[0:n])         #pragma acc exit data copyout(c[0:n])              for (int x = 0; x < n; ++x) {             if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial create", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,data-region,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copy(c[0:n])     {         #pragma acc serial create(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - c[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial default present", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,data-region,default,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = 0.0;     }     #pragma acc enter data copyin(a[0:n])     #pragma acc serial default(present)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             a[x] = 1.0;         }     }     #pragma acc exit data copyout(a[0:n])      for (int x = 0; x < n; ++x){         if (fabs(a[x] - 1.0) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature exit data copyout reference counts", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int * devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){           a[x] = rand() / (real_t)(RAND_MAX / 10);           b[x] = rand() / (real_t)(RAND_MAX / 10);           c[x] = 0.0;         }          #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])         #pragma acc data copyin(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] += a[x] + b[x];                 }             }             #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])         }         for (int x = 0; x < n; ++x){             if (fabs(c[x]) > PRECISION){                 err += 1;             }         }      }      return err; } #endif  #ifndef T2 //T2:data,executable-data,reference-counting,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])     #pragma acc data copyin(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }     #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 2;             break;         }     }      return err; } #endif  #ifndef T3 //T3:data,executable-data,reference-counting,construct-independent,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])     #pragma acc enter data create(c[0:n])     #pragma acc parallel     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] += a[x] + b[x];         }     }     #pragma acc exit data delete(c[0:n])     #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 4;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop independent", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,combined-constructs,V:2.7-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel loop independent         for (int x = 0; x < n; ++x){             b[x] = a[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction bitxor loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));     unsigned int temp = 0;      for (int x = 0; x < 10*n; ++x){         b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b_copy[x] = b[x];         a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);     }     for (int x = 0; x < 10; ++x){         c[x] = 0;     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])     {         #pragma acc kernels loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(^:temp)             for (int y = 0; y < n; ++y){                 temp = temp ^ a[x * n + y];             }             c[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 b[x * n + y] = b[x * n + y] + c[x];             }         }     }      for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = temp ^ a[x * n + y];         }         if (temp != c[x]){             err += 1;         }         for (int y = 0; y < n; ++y){             if (b[x * n + y] != b_copy[x * n + y] + c[x]){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature declare copyin", "completion": "!$acc routine vector FUNCTION multiplyData(a)   REAL(8),DIMENSION(LOOPCOUNT), INTENT(INOUT) :: a   INTEGER :: x   !$acc loop vector   DO x = 1, LOOPCOUNT     a(x) = a(x) * 2   END DO END FUNCTION multiplyData  #ifndef T1 !T1:construct-independent,declare,V:2.0-2.7       LOGICAL FUNCTION test1()   USE OPENACC   USE DECLARE_COPYIN_MOD   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   INTEGER :: x   REAL(8),DIMENSION(LOOPCOUNT) :: a, b    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   b = 0    !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT)) present(fixed_size_array)     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         b(x) = a(x) + fixed_size_array(MOD(x, 10))       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(b(x) - (a(x) + fixed_size_array(MOD(x, 10)))) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:construct-independent,declare,V:1.0-2.7       LOGICAL FUNCTION test2()   USE OPENACC   USE DECLARE_COPYIN_MOD   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT) :: a, b    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   b = 0    !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT)) present(scalar)     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         b(x) = a(x) + scalar       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(b(x) - (a(x) + scalar)) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:construct-independent,declare,V:1.0-2.7       LOGICAL FUNCTION test3()   USE OPENACC   USE DECLARE_COPYIN_MOD   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT) :: a, b    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   b = a    !$acc data copy(a(1:LOOPCOUNT))     !$acc parallel       !$acc loop       DO x = 1, 1         CALL externMultiplyData(a, LOOPCOUNT)       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(a(x) - (b(x) * 2)) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif #ifndef T4 !T4:construct-independent,declare,V:1.0-2.7       LOGICAL FUNCTION test4()   USE OPENACC   USE DECLARE_COPYIN_MOD   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT) :: a, b    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   b = a    !$acc data copy(a(1:LOOPCOUNT))     !$acc parallel       !$acc loop       DO x = 1, 1         CALL multiplyData(a)       END DO     !$acc end parallel   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(a(x) - (b(x) * 2)) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test4 = .FALSE.         ELSE           test4 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif #ifndef T4         LOGICAL :: test4 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif #ifndef T4         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test4()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 3           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc wait async", "completion": "#ifndef T1 !T1:runtime,async,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f, g, h, i !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(d)         CALL RANDOM_NUMBER(e)         f = 0         CALL RANDOM_NUMBER(g)         h = 0         i = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT), g(1:LOOPCOUNT)) create(c(1:LOOPCOUNT), f(1:LOOPCOUNT), h(1:LOOPCOUNT)) copyout(i(1:LOOPCOUNT))           !$acc parallel async(1)             !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) + b(x)               END DO           !$acc end parallel           CALL acc_wait_async(1, 2)           !$acc parallel async(2)             !$acc loop             DO x = 1, LOOPCOUNT               h(x) = c(x) + g(x)             END DO           !$acc end parallel           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               f(x) = d(x) + e(x)             END DO           !$acc end parallel           CALL acc_wait_async(1, 2)           !$acc parallel async(2)             !$acc loop             DO x = 1, LOOPCOUNT               i(x) = h(x) + f(x)             END DO           !$acc end parallel           !$acc wait(2)         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(i(x) - (a(x) + b(x) + g(x) + d(x) + e(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update plus equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] += a[x] * b[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] += a[x] * b[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > (n/10 + 1) * PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc delete async with len", "completion": "#ifndef T1 !T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data         INTEGER :: errors = 0           !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(d)         CALL RANDOM_NUMBER(e)         f = 0          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))          !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           !$acc parallel async(2)             !$acc loop             DO x = 1, LOOPCOUNT               f(x) = d(x) + e(x)             END DO           !$acc end parallel           CALL acc_delete_async(a(1), LOOPCOUNT*8, 1)           CALL acc_delete_async(b(1), LOOPCOUNT*8, 1)           CALL acc_delete_async(d(1), LOOPCOUNT*8, 2)           CALL acc_delete_async(e(1), LOOPCOUNT*8, 2)           !$acc wait         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF           IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER,DIMENSION(1):: devtest         INTEGER :: errors = 0          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = 0         !$acc end parallel         IF (devtest(1) == 1) THEN           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 0            !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))           !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))             !$acc parallel async(1)               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) + b(x)               END DO             !$acc end parallel           !$acc end data           CALL acc_delete_async(c(1), LOOPCOUNT*8, 1)           !$acc enter data copyin(c(1:LOOPCOUNT)) async(1)           !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))             !$acc parallel async(1)               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = c(x) + a(x) + b(x)               END DO             !$acc end parallel           !$acc end data           !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))            DO x = 1, LOOPCOUNT             IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2**1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature atomic expr rshift x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};     int result;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 3; ++y){             a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));         }         b[x] = 0;     }      #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop independent                 for (int y = 0; y < 3; ++y){                     #pragma acc atomic                         b[x] = a[x * 3 + y] >> b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 6; ++y){             result = 0;             for (int z = 0; z < 3; ++z){                 result = a[x * 3 + orders[y * 3 + z]] >> result;             }             if (result == b[x]){                 break;             }         }         if (result != b[x]){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial deviceptr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,data-region,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b;      for (int x = 0; x < n; ++x){         a[x] = 0;     }      #pragma acc enter data copyin(a[0:n])     b = (real_t *) acc_deviceptr(a);     if (b == NULL){         err = 1;     }     else{         #pragma acc serial deviceptr(b)         {             #pragma acc loop             for (int x = 0; x < (int) n/2; ++x){                 b[x] = 1;             }         }         #pragma acc exit data copyout(a[0:n])     }     for (int x = 0; x < n; ++x){         if (x < (int) n/2){             if (fabs(a[x] - 1) > PRECISION){                 err = 1;             }         }         else {             if (fabs(a[x]) > PRECISION){                 err = 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured x divided expr assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     real_t *passed_c = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(c[x] - (prev / (a[x] + b[x]))) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];                 passed_c[y] = c[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];                 passed_c[y - 1] = c[y];             }             if (is_possible(passed_a, passed_b, passed_c, length - 1, c[x])){                 delete[] passed_a;                 delete[] passed_b;                 delete[] passed_c;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     delete[] passed_c;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t *temp_a = new real_t[10];     real_t *temp_b = new real_t[10];     real_t *temp_c = new real_t[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x/10] = totals[x/10] / (a[x] + b[x]);                     c[x] = totals[x/10];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];             temp_c[temp_iterator] = c[ab_iterator];             temp_iterator++;         }         if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels scalar default copy", "completion": "#ifndef T1 !T1:kernels,V:2.5-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0         REAL(8) :: total = 0.0         !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          DO x = 1, LOOPCOUNT           total = total + a(x)         END DO         !$acc data copyin(b(1:LOOPCOUNT))           !$acc kernels num_gangs(1) vector_length(1)             !$acc loop             DO x = 1, LOOPCOUNT               total = total + b(x)             END DO           !$acc end kernels         !$acc end data          DO x = 1, LOOPCOUNT           total = total - (a(x) + b(x))         END DO         IF (abs(total) .gt. (2 * LOOPCOUNT - 2) * PRECISION) THEN           errors = errors + 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature declare function scope create", "completion": "#include \"acc_testsuite.h\" void create_test(real_t *a, real_t *b, real_t *c, real_t *d){     #pragma acc declare create(c[0:n])     #pragma acc parallel present(a[0:n], b[0:n], d[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }         #pragma acc loop         for (int x = 0; x < n; ++x){             d[x] = c[x] * a[x];         }     } }  void create_as_present(real_t *a, real_t *b, real_t *c, real_t *d){     #pragma acc declare create(c[0:n])     #pragma acc parallel present(a[0:n], b[0:n], d[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = c[x] + a[x] + b[x];         }         #pragma acc loop         for (int x = 0; x < n; ++x){             d[x] = c[x] * a[x];         }     } }  #ifndef T1 //T1:declare,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     real_t ** d = (real_t **)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));         b[x] = (real_t *)malloc(n * sizeof(real_t));         c[x] = (real_t *)malloc(n * sizeof(real_t));         d[x] = (real_t *)malloc(n * sizeof(real_t));         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 1;             d[x][y] = 0;         }     }     #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copyout(d[0:n][0:n])     {         for (int x = 0; x < n; ++x){             create_test(a[x], b[x], c[x], d[x]);         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             if (fabs(d[x][y] - (a[x][y] * (a[x][y] + b[x][y]))) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:declare,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     real_t ** d = (real_t **)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 2;             d[x][y] = 0;         }     }      #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copy(c[0:n][0:n]) copyout(d[0:n][0:n])     {         for (int x = 0; x < n; ++x){             create_as_present(a[x], b[x], c[x], d[x]);         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             if (fabs(c[x][y] - (2 + a[x][y] + b[x][y])) > PRECISION){                 err += 1;             }             if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){                 err += 1;             }         }     }      return err; } #endif  #ifndef T3 //T3:declare,construct-independent,devonly,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     real_t ** d = (real_t **)malloc(n * sizeof(real_t));     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 a[x][y] = rand() / (real_t)(RAND_MAX / 10);                 b[x][y] = rand() / (real_t)(RAND_MAX / 10);                 c[x][y] = 3;             }         }          #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])         {             for (int x = 0; x < n; ++x){                 #pragma acc data copyin(c[x:1][0:n]) copyout(d[x:1][0:n])                 {                     create_as_present(a[x], b[x], c[x], d[x]);                 }                 for (int y = 0; y < n; ++y){                     if (fabs(c[x][y] - 3) > PRECISION){                         err += 1;                     }                 }                 for (int y = 0; y < n; ++y){                     if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 2){                         err += 1;                     }                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update x neqv expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = totals(x) .NEQV. a(x, y)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial copyout", "completion": "#ifndef T1 !T1:serial,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT):: a, b   INTEGER:: x   INTEGER,DIMENSION(1):: hasDevice   errors = 0    hasDevice(1) = 1   !$acc enter data copyin(hasDevice(1:1))   !$acc parallel present(hasDevice(1:1))   hasDevice(1) = 0   !$acc end parallel      SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   b = 0     !$acc data copyin(a(1:LOOPCOUNT))     !$acc serial copyout(b(1:LOOPCOUNT))       !$acc loop       DO x = 1, LOOPCOUNT         b(x) = a(x)       END DO     !$acc end serial   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(a(x) - b(x)) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:serial,V:2.6-2.7       LOGICAL FUNCTION test2()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT):: a, b   INTEGER:: x   INTEGER,DIMENSION(1):: hasDevice   errors = 0    hasDevice(1) = 1   !$acc enter data copyin(hasDevice(1:1))   !$acc parallel present(hasDevice(1:1))   hasDevice(1) = 0   !$acc end parallel      SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    IF (hasDevice(1) .eq. 1) THEN     !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))       !$acc serial copyout(b(1:LOOPCOUNT))         !$acc loop         DO x = 1, LOOPCOUNT           b(x) = b(x) - a(x)         END DO       !$acc end serial     !$acc end data      DO x = 1, LOOPCOUNT       IF (abs(a(x) - b(x)) .gt. PRECISION) THEN         errors = errors + 1       END IF     END DO   END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:serial,update,V:2.6-2.7       LOGICAL FUNCTION test3()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT):: a, b   INTEGER:: x   INTEGER,DIMENSION(1):: hasDevice   errors = 0    hasDevice(1) = 1   !$acc enter data copyin(hasDevice(1:1))   !$acc parallel present(hasDevice(1:1))   hasDevice(1) = 0   !$acc end parallel      SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))     !$acc serial copyout(b(1:LOOPCOUNT))       !$acc loop       DO x = 1, LOOPCOUNT         b(x) = b(x) - a(x)       END DO     !$acc end serial     !$acc update host(b(1:LOOPCOUNT))   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(b(x)) .gt. 2 * PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop", "completion": "#ifndef T1 !T1:kernels,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9 !Iterators         REAL(8),DIMENSION(1024):: a, b !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0          !$acc data copyin(a(1:1024)) copyout(b(1:1024))           !$acc kernels             !$acc loop             DO _0 = 0, 1               !$acc loop               DO _1 = 0, 1                 !$acc loop                 DO _2 = 0, 1                   !$acc loop                   DO _3 = 0, 1                     !$acc loop                     DO _4 = 0, 1                       !$acc loop                       DO _5 = 0, 1                         !$acc loop                         DO _6 = 0, 1                           !$acc loop                           DO _7 = 0, 1                             !$acc loop                             DO _8 = 0, 1                               !$acc loop                               DO _9 = 1, 2                                 b(_0*512+_1*256+_2*128+_3*64+_4*32+_5*16+_6*8+_7*4+_8*2+_9)=a(_0*512+_1*256+_2*128+_3*64+_4*32+_5*16+_6*8+_7*4+_8*2+_9)                               END DO                             END DO                           END DO                         END DO                       END DO                     END DO                   END DO                 END DO               END DO             END DO           !$acc end kernels         !$acc end data          DO x = 1, 1024           IF (abs(a(x) - b(x)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc copyin async with len", "completion": "#ifndef T1 !T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data         INTEGER :: errors         errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         a_host = a         b_host = b          CALL acc_copyin_async(a(1), LOOPCOUNT*8, 1)         CALL acc_copyin_async(b(1), LOOPCOUNT*8, 2)          !$acc data copyout(c(1:LOOPCOUNT)) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               a(x) = a(x) * a(x)             END DO           !$acc end parallel           !$acc parallel async(2)             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = b(x) * b(x)             END DO           !$acc end parallel           !$acc parallel wait(1, 2)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a_host(x)*a_host(x) + b_host(x)*b_host(x))) .gt. 4*PRECISION) THEN             errors = errors + 1           END IF         END DO         IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif  #ifndef T2 !T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors         errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_copyin_async(a(1), LOOPCOUNT*8, 1)         CALL acc_copyin_async(b(1), LOOPCOUNT*8, 2)          !$acc data copyout(c(1:LOOPCOUNT))           DO WHILE (acc_async_test_all() .eqv. .FALSE.)             CONTINUE           END DO           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif  #ifndef T3 !T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test3()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors         errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_copyin_async(a(1), LOOPCOUNT*8, 1)         CALL acc_copyin_async(b(1), LOOPCOUNT*8, 2)          !$acc data copyout(c(1:LOOPCOUNT))           !$acc wait           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEn             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif  #ifndef T4 !T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7       LOGICAL FUNCTION test4()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initialization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(d)         e = 0          !$acc enter data create(c(1:LOOPCOUNT))         !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) copyout(e(1:LOOPCOUNT))           !$acc parallel present(c(1:LOOPCOUNT)) async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           CALL acc_copyin_async(c(1), LOOPCOUNT*8, 1)           !$acc exit data delete(c(1:LOOPCOUNT))           !$acc parallel present(c(1:LOOPCOUNT)) async(1)             !$acc loop             DO x = 1, LOOPCOUNT               e(x) = c(x) + d(x)             END DO           !$acc end parallel         !$acc end data         !$acc exit data copyout(c(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF           IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test4 = .FALSE.         ELSE           test4 = .TRUE.         END IF       END #endif  #ifndef T5 !T5:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7       LOGICAL FUNCTION test5()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initialization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_copyin_async(a(1), LOOPCOUNT*8, 1)         CALL acc_copyin_async(b(1), LOOPCOUNT*8, 2)          !$acc data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))           !$acc wait           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test5 = .FALSE.         ELSE           test5 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif #ifndef T4         LOGICAL :: test4 #endif #ifndef T5         LOGICAL :: test5 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif #ifndef T4         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test4()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 3           failed = .FALSE.         END IF #endif #ifndef T5         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test5()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 4           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature atomic update max x expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature set default async", "completion": "#ifndef T1 !T1:async,construct-independent,internal-control-values,set,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         a_host = a         b_host = b         c = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))           !$acc set default_async(1)           !$acc parallel async             !$acc loop             DO x = 1, LOOPCOUNT               a(x) = a(x) * a(x)             END DO           !$acc end parallel           !$acc set default_async(2)           !$acc parallel async             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = b(x) * b(x)             END DO           !$acc end parallel           !$acc parallel async(1) wait(2)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           !$acc wait(1)         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a_host(x) * a_host(x) + b_host(x) * b_host(x))) .gt. 4 * PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel copyout", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,data,data-region,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);      real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n])     {         #pragma acc parallel copyout(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,data,data-region,devonly,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);      real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      int* hasDevice = (int *) malloc(sizeof(int));     hasDevice[0] = 1;     #pragma acc enter data copyin(hasDevice[0:1])     #pragma acc parallel present(hasDevice[0:1])     {       hasDevice[0] = 0;     }      if (hasDevice[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = a[x];         }          #pragma acc data copyin(a[0:n], b[0:n])         {             #pragma acc parallel copyout(b[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = b[x] - a[x];                 }             }         }         for (int x = 0; x < n; ++x){           if (fabs(a[x] - b[x]) > PRECISION){             err += 2;             break;           }         }     }      return err; } #endif  #ifndef T3 //T3:parallel,data,data-region,V:1.0-2.7 int test3(){     int err = 0;     srand(SEED);      real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel copyout(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = b[x] - a[x];             }         }         #pragma acc update host(b[0:n])     }      for (int x = 0; x < n; ++x){         if (fabs(b[x]) > 2 * PRECISION){             err += 4;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop seq", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t temp = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copy(b[0:n])     {         #pragma acc parallel loop seq         for (int x = 1; x < n; ++x){             b[x] = b[x-1] + a[x];         }     }      for (int x = 1; x < n; ++x){         temp += a[x];         if (fabs(b[x] - temp) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr bitor x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] |= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data copy no lower bound", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,data-region,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(c[:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction max loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10 * n];     real_t * maximum = new real_t[10];     real_t temp = 0;     real_t max = 0.0;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);         c[x] = 0.0;     }     for (int x = 0; x < 10; ++x){         maximum[x] = 0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], maximum[0:10])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(max:temp)             for (int y = 0; y < n; ++y){                 temp = fmax(a[x * n + y] * b[x * n + y], temp);             }             maximum[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 c[x * n + y] = (a[x * n + y] * b[x * n + y]) / maximum[x];             }         }     }     for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = fmax(temp, a[x * n + y] * b[x * n + y]);         }         if (fabs(temp - maximum[x]) > PRECISION){             err += 1;         }         for (int y = 0; y < n; ++y){             if (c[x * n + y] > 1){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[25 * n];     real_t * b = new real_t[25 * n];     real_t * c = new real_t[25 * n];     real_t * maximum = new real_t[25];     real_t * host_maximum = new real_t[25];     real_t temp[5];      for (int x = 0; x < 25 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      for (int x = 0; x < 25; ++x) {         maximum[x] = 0;         host_maximum[x] = 0;     }      #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(c[0:25*n], maximum[0:25])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 temp[y] = 0;             }             #pragma acc loop worker reduction(max:temp)             for (int y = 0; y < 5 * n; ++y) {                 temp[y%5] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], temp[y%5]);             }             for (int y = 0; y < 5; ++y) {                 maximum[x * 5 + y] = temp[y];             }             #pragma acc loop worker             for (int y = 0; y < 5 * n; ++y) {                 c[x * 5 * n + y] = (a[x * 5 * n + y] * b[x * 5 * n + y]) / maximum[x * 5 + (y % 5)];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5 * n; ++y) {             host_maximum[x * 5 + (y % 5)] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], host_maximum[x * 5 + (y % 5)]);         }         for (int y = 0; y < 5; ++y) {             if (fabs(host_maximum[x * 5 + y] - maximum[x * 5 + y]) > PRECISION) {                 err += 1;             }         }         for (int y = 0; y < 5 * n; ++y) {             if (fabs(c[x * 5 * n + y] - ((a[x * 5 * n + y] * b[x * 5 * n + y]) / maximum[x * 5 + (y % 5)])) > PRECISION) {                 err += 1;             }         }     }       return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic ior expr x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .lt. .933) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           totals(x) = 0           totals_comparison(x) = 0         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture assign expr plus x", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8), INTENT(IN) :: init         REAL(8),DIMENSION(length), INTENT(IN) :: a         REAL(8),DIMENSION(length), INTENT(IN) :: b         REAL(8),DIMENSION(length - 1) :: passed_a         REAL(8),DIMENSION(length - 1) :: passed_b         REAL(8) :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (abs(b(x) - init) .GT. ((10 - length) * PRECISION)) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = a(x) + init             IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         REAL(8),DIMENSION(10):: passed_a, passed_b         REAL(8):: init         LOGICAL IS_POSSIBLE         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   b(x, y) = totals(x)                   totals(x) = a(x, y) + totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) + a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           init = 0           IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction and general", "completion": "#ifndef T1 !T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: randoms         LOGICAL,DIMENSION(LOOPCOUNT):: a !Data         LOGICAL :: results = .TRUE.         LOGICAL :: host_results = .TRUE.         REAL(8) :: false_margin         INTEGER :: errors = 0         false_margin = exp(log(.5) / LOOPCOUNT)         !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           IF (randoms(x) .lt. false_margin) THEN             a(x) = .TRUE.           ELSE             a(x) = .FALSE.           END IF         END DO          !$acc data copyin(a(1:LOOPCOUNT))           !$acc parallel loop reduction(.and.:results)           DO x = 1, LOOPCOUNT             results = results .and. a(x)           END DO         !$acc end data          DO x = 1, LOOPCOUNT           host_results = host_results .and. a(x)         END DO         IF (host_results .neqv. results) THEN           errors = 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update x neqv expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = totals(x) .NEQV. a(x, y)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic expr divided x end", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(subset, destination, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8),DIMENSION(length), INTENT(IN) :: subset         REAL(8), INTENT(IN) :: destination         REAL(8), INTENT(IN) :: init         REAL(8),ALLOCATABLE :: passed(:)         LOGICAL :: POSSIBLE         INTEGER :: x, y         IF (length .gt. 0) THEN           ALLOCATE(passed(length - 1))         ELSE           IF (abs(init - destination) .gt. PRECISION) THEN             POSSIBLE = .TRUE.           ELSE             POSSIBLE = .FALSE.           END IF           RETURN         END IF         POSSIBLE = .FALSE.         DO x = 1, length           DO y = 1, x - 1             passed(y) = subset(y)           END DO           DO y = x + 1, length             passed(y - 1) = subset(y)           END DO           IF (IS_POSSIBLE(passed, destination, length - 1, subset(x) / init)) THEN             POSSIBLE = .TRUE.             RETURN           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals         REAL(8),DIMENSION(10):: passed         INTEGER :: errors = 0         LOGICAL IS_POSSIBLE          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = a(x, y) / totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data           DO x = 1, LOOPCOUNT           DO y = 1, 10             passed(y) = a(x, y)           END DO           IF (IS_POSSIBLE(passed, totals(x), 10, 1) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic predecrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic                         --distribution[(int) (a[x]*b[y]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             distribution_comparison[(int) (a[x]*b[y]/10)]--;         }     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc init", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,init,syntactic,V:2.5-2.7 int test1(){     int err = 0;      if (acc_get_device_type() != acc_device_none){         acc_init(acc_get_device_type());     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign minus equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev - a[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));     real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0; \ttotals_host[x] =0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x%10];                     totals[x%10] -= (a[x] + b[x]);                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update x lshift expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic update                             a[x] = a[x] << 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitxor vector loop", "completion": "#ifndef T1 !T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(10*LOOPCOUNT):: a !Data         REAL(8),DIMENSION(10*LOOPCOUNT):: randoms         INTEGER,DIMENSION(10):: b         INTEGER :: errors = 0         INTEGER :: temp          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = FLOOR(randoms*1000000)          !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10))           !$acc parallel loop gang private(temp)           DO x = 0, 9             temp = 0             !$acc loop vector reduction(ieor:temp)             DO y = 1, LOOPCOUNT               temp = ieor(temp, a(x * LOOPCOUNT + y))             END DO             b(x + 1) = temp           END DO         !$acc end data                  DO x = 0, 9           temp = 0           DO y = 1, LOOPCOUNT             temp = ieor(temp, a(x * LOOPCOUNT + y))           END DO           IF (temp .ne. b(x + 1)) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured x plus expr assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] + prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t *passed_ab = new real_t[10];     real_t *passed_c = new real_t[10];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] + (a[x] * b[x]);                     c[x] = totals[x%(n/10 + 1)];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] += a[x] * b[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){             passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine bind prototype function nonstring lambda", "completion": "#include \"acc_testsuite.h\"  //test 1 host function real_t host_array_array(real_t * a, long long n){     #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  //test 2 host function real_t host_object_array(data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned += a->data[x];     }     return returned; }  //test 3 host function real_t host_array_object(real_t * a, long long n){    #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  //test 4 host function real_t host_object_object(data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned += a->data[x];     }     return returned; }  #pragma acc routine(host_array_array) vector bind(device_array_array) #pragma acc routine(host_object_array) vector bind(device_object_array) #pragma acc routine(host_array_object) vector bind(device_array_object) #pragma acc routine(host_object_object) vector bind(device_object_object)  //test 1 device lambda auto device_array_array = [](real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; };  //test 2 device lambda auto device_object_array = [](data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned -= a->data[x];     }     return returned; };  //test 3 device lambda auto device_array_object = [](real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; };  //test 4 device lambda auto  device_object_object= [](data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; };  #ifndef T1 //T1:routine,V:2.7-3.3 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){        \ta[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_array_array(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_array(a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_array(a, n) - b[x]) > PRECISION)){             err += 1;         }     }     delete[] a;     delete[] b;      return err; } #endif #ifndef T2 //T2:routine,V:2.7-3.3 int test2(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a, a.data[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_object_array(&a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_array(&a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_array(&a, n) - b[x]) > PRECISION)){             err += 1;         }     }      delete[] b;      return err; } #endif #ifndef T3 //T3:routine,V:2.7-3.3 int test3(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b, b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_array_object(a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_object(a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_object(a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      delete[] a;      return err; } #endif #ifndef T4 //T4:routine,V:2.7-3.3 int test4(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a, a.data[0:n], b ,b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_object_object(&a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_object(&a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_object(&a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed = 0; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }      if(failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }      if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }      if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test4();     }      if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update expr divided x", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(subset, destination, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8),DIMENSION(length), INTENT(IN) :: subset         REAL(8), INTENT(IN) :: destination         REAL(8), INTENT(IN) :: init         REAL(8),ALLOCATABLE :: passed(:)         LOGICAL :: POSSIBLE         INTEGER :: x, y         IF (length .gt. 0) THEN           ALLOCATE(passed(length - 1))         ELSE           IF (abs(init - destination) .gt. PRECISION) THEN             POSSIBLE = .TRUE.           ELSE             POSSIBLE = .FALSE.           END IF           RETURN         END IF         POSSIBLE = .FALSE.         DO x = 1, length           DO y = 1, x - 1             passed(y) = subset(y)           END DO           DO y = x + 1, length             passed(y - 1) = subset(y)           END DO           IF (IS_POSSIBLE(passed, destination, length - 1, subset(x) / init)) THEN             POSSIBLE = .TRUE.             RETURN           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals         REAL(8),DIMENSION(10):: passed         INTEGER :: errors = 0         LOGICAL IS_POSSIBLE          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = a(x, y) / totals(x)               END DO             END DO           !$acc end parallel         !$acc end data           DO x = 1, LOOPCOUNT           DO y = 1, 10             passed(y) = a(x, y)           END DO           IF (IS_POSSIBLE(passed, totals(x), 10, 1) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture assign ixor expr x", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   INTEGER, INTENT(IN) :: init   INTEGER,DIMENSION(length), INTENT(IN) :: a   INTEGER,DIMENSION(length), INTENT(IN) :: b   INTEGER,DIMENSION(length - 1) :: passed_a   INTEGER,DIMENSION(length - 1) :: passed_b   INTEGER :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (b(x) .eq. init) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = ieor(a(x), init)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y, z !Iterators   INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms   INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison   INTEGER,DIMENSION(10):: passed_a, passed_b   INTEGER:: init   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)   a = 0   DO x = 1, LOOPCOUNT     DO y = 1, 10       DO z = 1, 8         IF (randoms(x, y, z) .gt. .5) THEN           a(x, y) = a(x, y) + ISHFT(1, z - 1)         END IF       END DO     END DO   END DO   totals = 0   totals_comparison = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             b(x, y) = totals(x)             totals(x) = ieor(a(x, y), totals(x))           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data   DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = ieor(totals_comparison(x), a(x, y))     END DO   END DO   DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NE. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 0     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature declare device resident", "completion": "#include \"acc_testsuite.h\" #define DECLARE_TEST #define DECLARE_DEVICE_RESIDENT #include \"acc_testsuite_declare.h\" #pragma acc declare device_resident(fixed_size_array) #pragma acc declare device_resident(scalar) #pragma acc declare device_resident(datapointer)  int mult_device_resident = 5;  #ifndef T1 //T1:declare,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int mult = 2;      #pragma acc parallel     {       mult_device_resident = 2;       scalar = 10;       for (int x = 0; x < 10; ++x){         fixed_size_array[x] = x*x;       }     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < 10; ++x){                 fixed_size_array[x] = x*x;             }         }         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x] + fixed_size_array[x%10];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - (a[x] + (x%10) * (x%10))) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T2 //T2:declare,construct-independent,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int mult = 2;      #pragma acc parallel     {       mult_device_resident = 2;       scalar = 10;       for (int x = 0; x < 10; ++x){         fixed_size_array[x] = x*x;       }     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x] + scalar;             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - (a[x] + 10)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  #ifndef T3 //T3:declare,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     int mult = 2;      #pragma acc parallel     {       mult_device_resident = 2;       scalar = 10;       for (int x = 0; x < 10; ++x){         fixed_size_array[x] = x*x;       }     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      #pragma acc data copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < 1; ++x){                 extern_multiplyData_device_resident(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] * 2)) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine nohost", "completion": "#include \"acc_testsuite.h\" #pragma acc routine worker nohost real_t function(real_t * a, long long n){     real_t returned = 0;     #pragma acc loop worker reduction(+:returned)     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  #ifndef T1 //T1:routine,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = new real_t[n];     real_t summation;      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang             for (int x = 0; x < n; ++x){                 b[x] = function(a[x], n);             }         }     }      for (int x = 0; x < n; ++x){         summation = 0;         for (int y = 0; y < n; ++y){             summation += a[x][y];         }         if (fabs(summation - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature loop no collapse default", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:loop,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10 * n];     real_t total = 0;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         c[x * n] = a[x * n] + b[x * n];     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n])     {         #pragma acc parallel         {             #pragma acc loop independent             for (int x = 0; x < 10; ++x){                 for (int y = 1; y < n; ++y){                     c[x * n + y] = c[x * n + y - 1] + a[x * n + y] + b[x * n + y];                 }             }         }     }     for (int x = 0; x < 10; ++x){         total = 0;         for (int y = 0; y < n; ++y){             total += a[x * n + y] + b[x * n +y];             if (fabs(total - c[x * n + y]) > PRECISION * y){                 err += 1;             }         }     }      return err; } #endif   int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop vector blocking", "completion": "#ifndef T1 !T1:kernels,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         REAL(8) :: multiplier         INTEGER :: errors = 0          multiplier = 1         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))           !$acc kernels             !$acc loop vector             DO x = 1, LOOPCOUNT               c(x) = (a(x) + b(x)) * multiplier             END DO             multiplier = multiplier + 1             !$acc loop vector             DO x = 1, LOOPCOUNT               c(x) = c(x) + ((a(x) + b(x)) * multiplier)             END DO           !$acc end kernels         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (3 * (a(x) + b(x)))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc create async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,async,data,executable-data,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];     real_t *e = new real_t[n];     real_t *f = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])     {         acc_create_async(c, n * sizeof(real_t), 1);         acc_create_async(f, n * sizeof(real_t), 2);         #pragma acc data present(c[0:n], f[0:n])         {             #pragma acc parallel async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] + b[x];                 }             }             #pragma acc parallel async(2)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     f[x] = d[x] + e[x];                 }             }             #pragma acc wait         }     }      #pragma acc exit data copyout(c[0:n], f[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }         if (fabs(f[x] - (d[x] + e[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      acc_create_async(c, n * sizeof(real_t), 1);      #pragma acc data copyin(a[0:n], b[0:n])     {         while (!acc_async_test_all());         #pragma acc parallel present(c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      acc_create_async(c, n * sizeof(real_t), 1);      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc wait         #pragma acc parallel present(c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T4 //T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7 int test4(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     real_t * d = new real_t[n];     real_t * e = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = 0;     }      #pragma acc enter data create(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) copyout(e[0:n])     {         #pragma acc parallel present(c[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         acc_create_async(c, n * sizeof(real_t), 1);         #pragma acc exit data delete(c[0:n]) async(1)         #pragma acc parallel present(c[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 e[x] = c[x] + d[x];             }         }     }     #pragma acc wait     #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x) {         if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T5 //T5:runtime,data,executable-data,devonly,async,construct-independent,reference-counting,V:2.5-2.7 int test5(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int * devtest = (int *)malloc(sizeof(int));          devtest[0] = 0;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 1;     }      if (devtest[0] == 0){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0;         }          #pragma acc enter data create(c[0:n])         #pragma acc data copyin(a[0:n], b[0:n])         {             #pragma acc parallel present(c[0:n]) async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x) {                     c[x] = a[x] + b[x];                 }             }             acc_create_async(c, n * sizeof(real_t), 1);             #pragma acc parallel present(c[0:n]) async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x) {                     c[x] += a[x] + b[x];                 }             }             #pragma acc exit data copyout(c[0:n]) async(1)             #pragma acc wait         }          for (int x = 0; x < n; ++x) {             if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture assign min x expr", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8), INTENT(IN) :: init         REAL(8),DIMENSION(length), INTENT(IN) :: a         REAL(8),DIMENSION(length), INTENT(IN) :: b         REAL(8),DIMENSION(length - 1) :: passed_a         REAL(8),DIMENSION(length - 1) :: passed_b         REAL(8) :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (abs(b(x) - init) .gt. (10 - length) * PRECISION) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = min(a(x), init)             IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         REAL(8),DIMENSION(10):: passed_a, passed_b         REAL(8):: init         LOGICAL IS_POSSIBLE         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   b(x, y) = totals(x)                   totals(x) = min(totals(x), a(x, y))                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = min(totals_comparison(x), a(x, y))           END DO         END DO         DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           init = 0           IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc async test", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:async,runtime,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));     real_t *e = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = 0;     }      #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n]) async(1)     #pragma acc enter data copyin(d[0:n]) create(e[0:n]) async(2)     #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1) wait(2)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             e[x] = c[x] + d[x];         }     }     #pragma acc exit data copyout(e[0:n]) async(1)      while (!acc_async_test(1));     for (int x = 0; x < n; ++x){         if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:async,runtime,construct-independent,V:1.0-2.7 int test2(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));     real_t *e = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = 0;     }     #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[0:n]) copyout(e[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 e[x] = c[x] + d[x];             }         }         while (!acc_async_test(1));     }      for (int x = 0; x < n; ++x) {         if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {             err += 1;         }     }     return err; } #endif  #ifndef T3 //T3:async,runtime,construct-independent,V:2.5-2.7 int test3() {     int err = 0;     real_t* a = (real_t*)malloc(n * sizeof(real_t));     real_t* b = (real_t*)malloc(n * sizeof(real_t));     real_t* c = (real_t*)malloc(n * sizeof(real_t));     real_t* d = (real_t*)malloc(n * sizeof(real_t));     real_t* e = (real_t*)malloc(n * sizeof(real_t));     int async_val = acc_get_default_async();      for (int x = 0; x < n; ++x) {         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = 0;     }     #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[0:n]) copyout(e[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 e[x] = c[x] + d[x];             }         }         while (!acc_async_test(async_val));     }      for (int x = 0; x < n; ++x) {         if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {             err += 1;         }     }     return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x) {         failed = failed + test3();     }     if (failed != 0) {         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels present", "completion": "#ifndef T1 !T1:kernels,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0          !$acc enter data copyin(a(1:LOOPCOUNT)) create(b(1:LOOPCOUNT))         !$acc kernels present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc loop           DO x = 1, LOOPCOUNT             b(x) = a(x)           END DO         !$acc end kernels         !$acc exit data delete(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(a(x) - b(x)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture expr bitxor x", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == (a[x]^prev)){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *passed_a = (int *)malloc(10 * sizeof(int));     int *passed_b = (int *)malloc(10 * sizeof(int));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .5){                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     b[x] = totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] ^= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_a[passed_indexer] = a[absolute_indexer];             passed_b[passed_indexer] = b[absolute_indexer];         }         if (!(is_possible(passed_a, passed_b, passed_indexer, 0))){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop vector blocking", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,V:2.6-2.7 int test1(){   int err = 0;   srand(SEED);   real_t * a = new real_t[n];   real_t * b = new real_t[n];   real_t * c = new real_t[n];   real_t multiplyer = 1;    for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = 0.0;   }    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])   {     #pragma acc serial     {       #pragma acc loop vector       for (int x = 0; x < n; ++x){         c[x] = (a[x] + b[x]) * multiplyer;       }       multiplyer += 1;       #pragma acc loop vector       for (int x = 0; x < n; ++x){         c[x] += (a[x] + b[x]) * multiplyer;       }     }   }    for (int x = 0; x < n; ++x){     if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){       err += 1;       break;     }   }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc copyout async with len", "completion": "#ifndef T1 !T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(d)         CALL RANDOM_NUMBER(e)         f = 0          !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           !$acc parallel async(2)             !$acc loop             DO x = 1, LOOPCOUNT               f(x) = d(x) + e(x)             END DO           !$acc end parallel           CALL acc_copyout_async(c(1), LOOPCOUNT*8, 1)           CALL acc_copyout_async(f(1), LOOPCOUNT*8, 2)         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF           IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO         IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif          CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature atomic update x rshift expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1<<7;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic update                             a[x] = a[x] >> 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<7){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture assign expr eqv x", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         LOGICAL, INTENT(IN) :: init         LOGICAL,DIMENSION(length), INTENT(IN) :: a         LOGICAL,DIMENSION(length), INTENT(IN) :: b         LOGICAL,DIMENSION(length - 1) :: passed_a         LOGICAL,DIMENSION(length - 1) :: passed_b         LOGICAL :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (b(x) .eqv. init) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = a(x) .eqv. init             IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         LOGICAL,DIMENSION(10):: passed_a, passed_b         LOGICAL:: init         INTEGER :: errors = 0         LOGICAL IS_POSSIBLE          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   b(x, y) = totals(x)                   totals(x) = a(x, y) .EQV. totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           init = .FALSE.           IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN             errors = errors + 1           END IF         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update expr rshift x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};     int result;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 3; ++y){             a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));         }         b[x] = 0;     }      #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop independent                 for (int y = 0; y < 3; ++y){                     #pragma acc atomic update                         b[x] = a[x * 3 + y] >> b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 6; ++y){             result = 0;             for (int z = 0; z < 3; ++z){                 result = a[x * 3 + orders[y * 3 + z]] >> result;             }             if (result == b[x]){                 break;             }         }         if (result != b[x]){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic multiply equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] *= a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data copyout zero", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,data-region,V:3.0-3.2 int test1(){      int err = 0;     srand(SEED);      real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(zero: b[0:n])     {       #pragma acc parallel       {         #pragma acc loop         {           for (int x = 0; x < n; ++x){             b[x] += a[x];           }         }       }     }      for (int x = 0; x < n; ++x){         if(fabs(a[x] - b[x]) > PRECISION){                 err += 1;                 break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction max loop", "completion": "#ifndef T1 !T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c !Data         REAL(8),DIMENSION(10):: maximum         REAL(8) :: temp         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT))           !$acc kernels loop gang private(temp)           DO x = 0, 9             temp = 0             !$acc loop worker reduction(max:temp)             DO y = 1, LOOPCOUNT               temp = max(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))             END DO             maximum(x + 1) = temp             !$acc loop worker             DO y = 1, LOOPCOUNT               c(x * LOOPCOUNT + y) = (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y)) / maximum(x + 1)             END DO           END DO         !$acc end data          DO x = 0, 9           DO y = 1, LOOPCOUNT             IF (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y) - maximum(x + 1) .gt. PRECISION) THEN               errors = errors + 1             ELSE IF ((c(x * LOOPCOUNT + y) - 1) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop gang", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])     {         #pragma acc serial loop gang         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction or general", "completion": "#ifndef T1 !T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         LOGICAL,DIMENSION(LOOPCOUNT):: a !Data         LOGICAL :: results = .FALSE.         LOGICAL :: temp = .FALSE.         REAL(8) :: false_margin = exp(log(.5) / n)         REAL(8),DIMENSION(LOOPCOUNT):: random         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(random)         DO x = 1, LOOPCOUNT           IF (random(x) > false_margin) THEN             a(x) = .TRUE.           ELSE             a(x) = .FALSE.           END IF         END DO          !$acc data copyin(a(1:LOOPCOUNT))           !$acc kernels loop reduction(.OR.:results)           DO x = 1, LOOPCOUNT             results = results .OR. a(x)           END DO         !$acc end data          DO x = 1, LOOPCOUNT           temp = temp .OR. a(x)         END DO         IF (temp .neqv. results) THEN           errors = errors + 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,async,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10 * n];     real_t * d = new real_t[10 * n]; \t\tint * errors = new int[10];  \t\tfor (int x = 0; x < 10; ++x){ \t\t\terrors[x] = 0; \t\t}      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = a[x] + b[x];     }      #pragma acc data copyin(a[0:10*n], b[0:10*n], c[0:10*n], d[0:10*n]) copy(errors[0:10])     {         for (int x = 0; x < 10; ++x){             #pragma acc parallel loop async(x)             for (int y = 0; y < n; ++y){                 c[x * n + y] = a[x * n + y] + b[x * n + y];             }             #pragma acc parallel loop async(x) reduction(+:errors[x])             for (int y = 0; y < n; ++y){                 if(c[x * n + y] - d[x * n + y] > PRECISION || d[x * n + y] - c[x * n + y] > PRECISION){                     errors[x] += 1;                 }             }         } \t\t\t\t#pragma acc wait     }      for (int x = 0; x < 10; ++x){         err += errors[x];     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data with changing subscript", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,data-region,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int length = n;     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:length], b[0:length]) copyout(c[0:length])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < length; ++x){                 c[x] = a[x] + b[x];             }         }         length = 1;     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update x and expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) < .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = totals(x) .AND. a(x, y)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .AND. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc is present with len", "completion": "#ifndef T1 !T1:runtime,devonly,construct-independent,present,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         INTEGER,DIMENSION(1):: devtest         INTEGER :: errors = 0          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = 0         !$acc end parallel          !$acc enter data create(a(1:LOOPCOUNT))         IF (acc_is_present(a(1), LOOPCOUNT*8) .eqv. .FALSE.) THEN           errors = errors + 1         END IF         !$acc exit data delete(a(1:LOOPCOUNT))          IF (devtest(1) .eq. 1) THEN           IF (acc_is_present(a(1), LOOPCOUNT*8) .eqv. .TRUE.) THEN             errors = errors + 1           END IF         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature atomic update expr plus x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic update                         totals[(int) ((a[x] + b[x])/2)] = a[x] * b[x] + totals[(int) ((a[x] + b[x])/2)];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];         }     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > 10 * PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic bitand equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] &= a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] &= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic max expr x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign preincrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *c = (int *)malloc(n * sizeof(int));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));     bool found = false;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = distribution[(int) (a[x]*b[x]/10)];                     ++distribution[(int) (a[x]*b[x]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]++;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < distribution[x]; ++y){             for (int z = 0; z < n; ++z){                 if (c[z] == y && x == (int) (a[z] * b[z] / 10)){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels default present", "completion": "#ifndef T1 !T1:kernels,default,V:2.5-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0          !$acc enter data copyin(a(1:LOOPCOUNT)) create(b(1:LOOPCOUNT))         !$acc kernels default(present)           !$acc loop           DO x = 1, LOOPCOUNT             b(x) = a(x)           END DO         !$acc end kernels         !$acc exit data delete(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(a(x) - b(x)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction or loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(10 * n * sizeof(char));     char * a_copy = (char *)malloc(10 * n * sizeof(char));     char * results = (char *)malloc(10 * sizeof(char));     char temp = 0;     real_t false_margin = pow(exp(1), log(.5)/n);      for (int x = 0; x < 10 * n; ++x){         if (rand() / (real_t)(RAND_MAX) > false_margin){             a[x] = 1;             a_copy[x] = 1;         }         else{             a[x] = 0;             a_copy[x] = 0;         }     }     #pragma acc data copy(a[0:10*n]) copyout(results[0:10])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(||:temp)             for (int y = 0; y < n; ++y){                 temp = temp || a[x * n + y];             }             results[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 if(results[x] == 1){                     if (a[x * n + y] == 1){                         a[x * n + y] = 0;                     }                     else{                         a[x * n + y] = 1;                     }                 }             }         }     }     for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = temp || a_copy[x * n + y];         }         if (temp != results[x]) {             err += 1;         }         for (int y = 0; y < n; ++y){             if (temp == 1){                 if (a[x * n + y] == a_copy[x * n + y]){                     err += 1;                 }             }             else {                 if (a[x * n + y] != a_copy[x * n + y]){                     err += 1;                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured expr bitor x assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == (prev | a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] = a[x] | totals[x/10];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] |= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update max x expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction and vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(10 * n * sizeof(char));     char * b = (char *)malloc(10 * sizeof(char));     char * has_false = (char *)malloc(10 * sizeof(char));     real_t false_margin = pow(exp(1), log(.5)/n);     char temp = 1;      for (int x = 0; x < 10; ++x){         has_false[x] = 0;     }     for (int x = 0; x < 10 * n; ++x){         if(rand() / (real_t)(RAND_MAX) < false_margin){             a[x] = 1;         }         else{             a[x] = 0;             has_false[x/n] = 1;         }     }     #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc parallel loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop vector reduction(&&:temp)             for (int y = 0; y < n; ++y){                 temp = temp && a[x * n + y];             }             b[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         if (has_false[x] == b[x]){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(25 * n * sizeof(char));     char * b = (char *)malloc(25 * sizeof(char));     char * has_false = (char *)malloc(25 * sizeof(char));     real_t false_margin = pow(exp(1), log(.5)/n);     char device[5];     char host[5];      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5 * n; ++y){             if (rand() / (real_t)(RAND_MAX) < false_margin) {                 a[x] = 1;             }             else {                 a[x] = 0;                 has_false[x * 5 + y % 5];             }         }     }      #pragma acc data copyin(a[0:25*n]) copy(b[0:25])     {         #pragma acc parallel loop private(device)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 device[y] = 1;             }             #pragma acc loop vector reduction(&&:device)             for (int y = 0; y < 5 * n; ++y) {                 device[y%5] = device[y%5] && a[x * 5 * n + y];             }             for (int y = 0; y < 5; ++y){                 b[x * 5 + y] = device[y];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             host[y] = 1;         }         for (int y = 0; y < 5 * n; ++y) {             host[y%5] = host[y%5] && a[x * 5 * n + y];         }         for (int y = 0; y < 5; ++y) {             if (b[x * 5 + y] != host[y]) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update ior x expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .lt. .933) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           totals(x) = 0           totals_comparison(x) = 0         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc unmap data", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d;     real_t *e = new real_t[n];      d = (real_t *)acc_malloc(n * sizeof(real_t));     for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      acc_map_data(c, d, n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      #pragma acc update host(c[0:n])     for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x]))> PRECISION){             err += 1;         }     }      acc_unmap_data(c);     acc_free(d);      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d;     real_t *e = new real_t[n];      d = (real_t *)acc_malloc(2 * n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     acc_map_data(c, d, n * sizeof(real_t));     acc_map_data(e, &(d[n]), n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n], e[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 e[x] = a[x] * b[x];             }         }     }      #pragma acc update host(c[0:n])     #pragma acc update host(e[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }         if (fabs(e[x] - (a[x] * b[x])) > PRECISION){             err += 1;         }     }     acc_unmap_data(c);     acc_unmap_data(e);     acc_free(d);      return err; } #endif  #ifndef T3 //T3:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d;     real_t *e = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     d = (real_t *)acc_malloc(n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n]) deviceptr(d)     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 d[x] = a[x] + b[x];             }         }     }      acc_map_data(c, d, n * sizeof(real_t));     #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      #pragma acc update host(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - 2 * (a[x] + b[x])) > 2 * PRECISION){             err += 1;         }     }      acc_unmap_data(c);     acc_free(d);      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic iand x expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .gt. .933) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           DO y = 0, 7             totals(x) = totals(x) + ISHFT(1, y)             totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)           END DO         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature set device type nvidia", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:set,runtime,syntactic,V:2.5-3.2 int test1(){     int err = 0;      int device_type = acc_get_device_type();      #pragma acc set device_type(nvidia)     if (acc_get_device_type() != device_type){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update bitor equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] |= a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] |= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr minus x", "completion": "#include \"acc_testsuite.h\" bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){     if (length == 0){         if (fabs(current_value - test_value) > PRECISION){             return true;         }         else {             return false;         }     }     real_t * passed = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         for (int y = 0; y < x; ++y){             passed[y] = remaining_combinations[y];         }         for (int y = x + 1; y < length; ++y){             passed[y - 1] = remaining_combinations[y];         }         if (possible_result(passed, length - 1, remaining_combinations[x] - current_value, test_value)){             delete[] passed;             return true;         }     }     delete[] passed;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *totals = new real_t[((n/10) + 1)];     int indexer = 0;     real_t * passed = new real_t[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < (n/10) + 1; ++x){         totals[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];             }         }     }     for (int x = 0; x < (n/10) + 1; ++x){         indexer = x;         while (indexer < n){             passed[indexer/((int) (n/10) + 1)] = a[indexer];             indexer += (n/10) + 1;         }         if (!(possible_result(passed, 10, 0, totals[x]))){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine bind", "completion": "#include \"acc_testsuite.h\" real_t host_function_identifier_named(real_t* a, long long n); real_t host_function_string_named(real_t* a, long long n);  #pragma acc routine(host_function_identifier_named) vector bind(device_function_identifier_named) #pragma acc routine(host_function_string_named) vector bind(\"device_function_string_named\")  #pragma acc routine vector bind(device_function_identifier_unnamed) real_t host_function_identifier_unnamed(real_t* a, long long n){     real_t returned = 0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  real_t device_function_identifier_unnamed(real_t *a, long long n){     real_t returned = 0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  #pragma acc routine vector bind(\"device_function_string_unnamed\") real_t host_function_string_unnamed(real_t* a, long long n){     real_t returned = 0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  real_t device_function_string_unnamed(real_t* a, long long n){     real_t returned = 0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  real_t host_function_identifier_named(real_t* a, long long n){     real_t returned = 0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  real_t device_function_identifier_named(real_t* a, long long n){     real_t returned = 0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  real_t host_function_string_named(real_t* a, long long n){     real_t returned = 0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  real_t device_function_string_named(real_t* a, long long n){     real_t returned = 0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  #ifndef T1 //T1:routine,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t **a = (real_t **)malloc(n * sizeof(real_t *));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);     for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_function_identifier_unnamed(a[x], n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_function_identifier_unnamed(a[x], n) + b[x]) > PRECISION)){             err += 1;             return 1;         }         else if ((on_host) && (fabs(host_function_identifier_unnamed(a[x], n) - b[x]) > PRECISION)){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:routine,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t **a = (real_t **)malloc(n * sizeof(real_t *));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);     for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }     }      #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_function_string_unnamed(a[x], n);             }         }     }      for (int x = 0; x < n; ++x){         if (!on_host && fabs(host_function_string_unnamed(a[x], n) + b[x]) > PRECISION){             err += 1;         }         else if (on_host && fabs(host_function_string_unnamed(a[x], n) - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:routine,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t **a = (real_t **)malloc(n * sizeof(real_t *));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);     for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }     }      #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_function_identifier_named(a[x], n);             }         }     }      for (int x = 0; x < n; ++x){         if (!on_host && fabs(host_function_identifier_named(a[x], n) + b[x]) > PRECISION){             err += 1;         }         else if (on_host && fabs(host_function_identifier_named(a[x], n) - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T4 //T4:routine,construct-independent,V:2.0-2.7 int test4(){     int err = 0;     srand(SEED);     real_t **a = (real_t **)malloc(n * sizeof(real_t *));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);     for (int x = 0; x < n; ++x){         a[x] = new real_t[n];     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }     }      #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_function_string_named(a[x], n);             }         }     }      for (int x = 0; x < n; ++x){         if (!on_host && fabs(host_function_string_named(a[x], n) + b[x]) > PRECISION){             err += 1;         }         else if (on_host && fabs(host_function_string_named(a[x], n) - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel wait", "completion": "#ifndef T1 !T1:async,parallel,update,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = a          !$acc enter data create(a(1:LOOPCOUNT))         !$acc update device(a(1:LOOPCOUNT)) async(1)         !$acc parallel present(a(1:LOOPCOUNT)) wait(1)           !$acc loop           DO x = 1, LOOPCOUNT             a(x) = a(x) + 1           END DO         !$acc end parallel         !$acc exit data copyout(a(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(a(x) - (b(x) + 1)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction min general", "completion": "#include \"acc_testsuite.h\"  #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t min = 1000.0;     int found = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:n], b[0:n]) copy(min)     {         #pragma acc parallel loop reduction(min:min)         for (int x = 0; x < n; ++x){             min = fmin(a[x] * b[x], min);         }     }      for (int x = 0; x < n; ++x){         if (fabs((a[x] * b[x]) - (min + PRECISION)) < 0){             err = 1;         }         if (fabs(min - (a[x] * b[x])) < PRECISION){             found = 1;         }     }     if (found == 0){         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t minimums[10];     real_t host_minimums[10];      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      for (int x = 0; x < 10; ++x) {         minimums[x] = 1000;         host_minimums[x] = 1000;     }      printf(\"Here\");      #pragma acc data copyin(a[0:10*n], b[0:10*n])     {         #pragma acc parallel loop reduction(min:minimums)         for (int x = 0; x < 10 * n; ++x) {             minimums[x%10] = fmin(a[x] * b[x], minimums[x%10]);         }     }      for (int x = 0; x < 10 * n; ++x) {         host_minimums[x%10] = fmin(a[x] * b[x], host_minimums[x%10]);     }     for (int x = 0; x < 10; ++x) {         if (fabs(minimums[x] - host_minimums[x]) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update lshift equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic update                             a[x] <<= 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature enter data copyin no lower bound", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,syntactic,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[:n], b[:n]) create(c[0:n])     #pragma acc parallel present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature loop no collapse default", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:loop,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));     real_t total = 0;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         c[x * n] = a[x * n] + b[x * n];     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n])     {         #pragma acc parallel         {             #pragma acc loop independent             for (int x = 0; x < 10; ++x){                 for (int y = 1; y < n; ++y){                     c[x * n + y] = c[x * n + y - 1] + a[x * n + y] + b[x * n + y];                 }             }         }     }     for (int x = 0; x < 10; ++x){         total = 0;         for (int y = 0; y < n; ++y){             total += a[x * n + y] + b[x * n +y];             if (fabs(total - c[x * n + y]) > PRECISION * y){                 err += 1;             }         }     }      return err; } #endif   int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine bind prototype lambda nonstring function", "completion": "#include \"acc_testsuite.h\"  //test 1 host lambda auto host_array_array = [](real_t * a, long long n){     #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; };  //test 2 host lambda auto  host_object_array= [](data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned += a->data[x];     }     return returned; };  //test 3 host lambda auto host_array_object = [](real_t * a, long long n){    #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; };  //test 4 host lambda auto host_object_object = [](data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned += a->data[x];     }     return returned; };  #pragma acc routine(host_array_array) vector bind(device_array_array) #pragma acc routine(host_object_array) vector bind(device_object_array) #pragma acc routine(host_array_object) vector bind(device_array_object) #pragma acc routine(host_object_object) vector bind(device_object_object)  //test 1 device function real_t device_array_array(real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  //test 2 device function real_t device_object_array(data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned -= a->data[x];     }     return returned; }  //test 3 device function real_t device_array_object(real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  //test 4 device function real_t device_object_object(data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; }  #ifndef T1 //T1:routine,V:2.7-3.3 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){        \ta[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_array_array(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_array(a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_array(a, n) - b[x]) > PRECISION)){             err += 1;         }     }     delete[] a;     delete[] b;      return err; } #endif #ifndef T2 //T2:routine,V:2.7-3.3 int test2(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a, a.data[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_object_array(&a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_array(&a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_array(&a, n) - b[x]) > PRECISION)){             err += 1;         }     }      delete[] b;      return err; } #endif #ifndef T3 //T3:routine,V:2.7-3.3 int test3(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b, b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_array_object(a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_object(a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_object(a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      delete[] a;      return err; } #endif #ifndef T4 //T4:routine,V:2.7-3.3 int test4(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a, a.data[0:n], b ,b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_object_object(&a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_object(&a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_object(&a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed = 0; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }      if(failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }      if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }      if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test4();     }      if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction add general", "completion": "#ifndef T1 !T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8) :: total         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         total = 0         !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(total)           !$acc parallel loop reduction(+:total)           DO x = 1, LOOPCOUNT             total = total + a(x) + b(x)           END DO         !$acc end data         DO x = 1, LOOPCOUNT           total = total - (a(x) + b(x))         END DO         IF (abs(total) .gt. LOOPCOUNT * PRECISION) THEN           WRITE(*, *) total           errors = 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc is present", "completion": "#ifndef T1 !T1:runtime,devonly,construct-independent,present,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         INTEGER,DIMENSION(1):: devtest         INTEGER :: errors         errors = 0          devtest(1) = 1         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = 0         !$acc end parallel          !$acc enter data create(a(1:LOOPCOUNT))         IF (acc_is_present(a(1:LOOPCOUNT)) .eqv. .FALSE.) THEN           errors = errors + 1           PRINT*, 1         END IF         !$acc exit data delete(a(1:LOOPCOUNT))          IF (devtest(1) .eq. 1) THEN           IF (acc_is_present(a(1:LOOPCOUNT)) .eqv. .TRUE.) THEN             errors = errors + 1             PRINT*, 2           END IF         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature parallel independent atomic", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.7-3.2 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(a[0:n], b[0:n])     {         #pragma acc parallel         { \t    #pragma acc loop independent             for (int x = 0; x < n; ++x){                 #pragma acc atomic                      a[x] = a[x] * 2; //dependent                     b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,loop,V:2.7-3.2 int test2(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = a[x];     }      #pragma acc data copy(a[0:n])     {         #pragma acc parallel         { \t    #pragma acc loop independent             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     (a[x])++; //independent - without a clause, you're doing atomic update                }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (b[x] + 1)) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1    failed = 0;    for (int x = 0; x < NUM_TEST_CALLS; ++x){        failed = failed + test1();    }    if (failed != 0){        failcode = failcode + (1 << 0);    } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature kernels loop reduction bitand general", "completion": "#ifndef T1 !T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y, z !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         INTEGER :: b         REAL(8),DIMENSION(16 * LOOPCOUNT):: randoms         REAL(8) :: false_margin         INTEGER :: errors = 0         INTEGER :: temp = 1          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         false_margin = exp(log(.5)/n)         DO x = 1, LOOPCOUNT           DO y = 0, 15             IF (randoms(y * LOOPCOUNT + x) .lt. false_margin) THEN               temp = 1               DO z = 0, y                 temp = temp * 2               END DO               a(x) = a(x) + temp             END IF           END DO         END DO          b = a(1)          !$acc data copyin(a(1:LOOPCOUNT))           !$acc kernels loop reduction(iand:b)           DO x = 1, LOOPCOUNT             b = iand(b, a(x))           END DO         !$acc end data          temp = a(1)         DO x = 2, LOOPCOUNT           temp = iand(a(x), temp)         END DO         IF (temp .ne. b) THEN           WRITE(*, *) temp           WRITE(*, *) b           errors = 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop seq", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t temp = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copy(b[0:n])     {         #pragma acc parallel loop seq         for (int x = 1; x < n; ++x){             b[x] = b[x-1] + a[x];         }     }      for (int x = 1; x < n; ++x){         temp += a[x];         if (fabs(b[x] - temp) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel copy", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,data,data-region,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * a_host = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         a_host[x] = a[x];     }      #pragma acc parallel copy(a[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             a[x] = 2 * a[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (2 * a_host[x])) > PRECISION){             err = 1;         }     }      return err; } #endif #ifndef T2 //T2:parallel,data,data-region,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t device = rand() / (real_t)(RAND_MAX / 10);     real_t host = device;     #pragma acc parallel loop copy(device) reduction(+:device)     for(int x = 0; x < n; ++x){         device += 1.0;     }      if(fabs(host - (device - n) ) > PRECISION){             err++;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }     if(failed){         failcode +=  (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }     if(failed){         failcode +=  (1 << 1);     } #endif      return failcode; }"}
{"prompt": "Create a test for the feature shutdown device type num nvidia", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:shutdown,runtime,syntactic,V:2.5-2.7 int test1(){     int err = 0;     int device_num;      device_num = acc_get_device_num(acc_get_device_type());     #pragma acc shutdown device_type(nvidia) device_num(device_num)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature set device type nvidia", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:set,runtime,syntactic,V:2.5-3.2 int test1(){     int err = 0;      int device_type = acc_get_device_type();      #pragma acc set device_type(nvidia)     if (acc_get_device_type() != device_type){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction min loop", "completion": "#ifndef T1 !T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c   REAL(8),DIMENSION(10):: minimums, host_minimums   REAL(8):: temp   INTEGER:: errors, x, y    errors = 0    SEEDDIM(1) = 1   #ifdef SEED   SEEDDIM(1) = SEED   #endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 0   minimums = 0   host_minimums = 0    DO y = 1, 10     DO x = 1, LOOPCOUNT       host_minimums(y) = min(host_minimums(y), a(x, y) * b(x, y))     END DO   END DO    !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(c(1:LOOPCOUNT, 1:10), minimums(1:10))     !$acc serial loop gang private(temp)     DO y = 1, 10       temp = 1       !$acc loop reduction(min: temp)       DO x = 1, LOOPCOUNT         temp = min(temp, a(x, y) * b(x, y))       END DO       minimums(y) = temp       !$acc loop       DO x = 1, LOOPCOUNT         c(x, y) = (a(x, y) * b(x, y)) / minimums(y)       END DO     END DO   !$acc end data    DO y = 1, 10     IF (abs(minimums(y) - host_minimums(y)) .gt. PRECISION) THEN       errors = errors + 1     END IF     DO x = 1, LOOPCOUNT       IF (abs(c(x, y) - ((a(x, y) * b(x, y)) / minimums(y))) .gt. PRECISION) THEN         errors = errors + 1       END IF     END DO   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM serial_loop_reduction_min_loop         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc delete", "completion": "#ifndef T1 !T1:runtime,data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors         errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          !$acc data copyout(c(1:LOOPCOUNT))           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_delete(a(1:LOOPCOUNT))         CALL acc_delete(b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER:: x         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c         INTEGER:: errors         errors = 0          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_copyin(a(1:LOOPCOUNT))         CALL acc_copyin(b(1:LOOPCOUNT))          !$acc data copyout(c(1:LOOPCOUNT))           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_delete(a(1:LOOPCOUNT))         CALL acc_delete(b(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2**1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature data create no lower bound", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,data-region,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     real_t * d = new real_t[n];     real_t * e = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[:n]) copyout(e[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }             #pragma acc loop             for (int x = 0; x < n; ++x){                 e[x] = c[x] + d[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial copyin", "completion": "#ifndef T1 !T1:serial,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b   INTEGER,DIMENSION(1):: hasDevice   INTEGER:: x   errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   a_copy = a   b = 0    hasDevice(1) = 1   !$acc enter data copyin(hasDevice(1:1))   !$acc parallel present(hasDevice(1:1))     hasDevice(1) = 0   !$acc end parallel    !$acc serial copyin(a(1:LOOPCOUNT))     !$acc loop     DO x = 1, LOOPCOUNT       a(x) = 0     END DO   !$acc end serial    DO x = 1, LOOPCOUNT     IF (hasDevice(1) .eq. 1) THEN       IF (abs(a(x) - a_copy(x)) .gt. PRECISION) THEN         errors = errors + 1       END IF     ELSE       IF (abs(a(x)) .gt. PRECISION) THEN         errors = errors + 1       END IF     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:serial,V:2.6-2.7       LOGICAL FUNCTION test2()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER:: errors   REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b   INTEGER,DIMENSION(1):: hasDevice   INTEGER:: x   errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)    !$acc data copy(b(1:LOOPCOUNT))     !$acc serial copyin(a(1:LOOPCOUNT))       !$acc loop       DO x = 1, LOOPCOUNT         b(x) = a(x)       END DO     !$acc end serial   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(a(x) - b(x)) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop worker blocking", "completion": "#ifndef T1 !T1:loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   REAL(8),DIMENSION(LOOPCOUNT):: a, b, c   INTEGER:: multiplier   INTEGER:: x   INTEGER:: errors    errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 0    !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))     !$acc serial       !$acc loop worker       DO x = 1, LOOPCOUNT         c(x) = (a(x) + b(x)) * multiplier       END DO       multiplier = multiplier + 1       !$acc loop worker       DO x = 1, LOOPCOUNT         c(x) = c(x) + ((a(x) + b(x)) * multiplier)       END DO     !$acc end serial   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(c(x) - (3 * (a(x) + b(x)))) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop worker blocking", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,V:1.0-2.7 int test1(){   int err = 0;   srand(SEED);   real_t * a = new real_t[n];   real_t * b = new real_t[n];   real_t * c = new real_t[n];   real_t multiplyer = 1;    for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = 0.0;   }    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])   {     #pragma acc kernels     {       #pragma acc loop worker       for (int x = 0; x < n; ++x){         c[x] = (a[x] + b[x]) * multiplyer;       }       multiplyer += 1;       #pragma acc loop worker       for (int x = 0; x < n; ++x){         c[x] += (a[x] + b[x]) * multiplyer;       }     }   }    for (int x = 0; x < n; ++x){     if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){       err + 1;       break;     }   }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign postincrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *c = (int *)malloc(n * sizeof(int));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));     bool found = false;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = distribution[(int) (a[x]*b[x]/10)];                     distribution[(int) (a[x]*b[x]/10)]++;                 }             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]++;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < distribution_comparison[x]; ++y){             for (int z = 0; z < n; ++z){                 if (c[z] == y && (int) (a[z]*b[z]/10) == x){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction max vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * max = new real_t[10];     real_t temp = 0;     real_t temp_max;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(max[0:10])     {         #pragma acc kernels loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(max:temp)             for (int y = 0; y < n; ++y){                 temp = fmax(a[x * n + y] * b[x * n + y], temp);             }             max[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         temp_max = 0;         for (int y = 0; y < n; ++y){             if (temp_max < a[x * n + y] * b[x * n + y]){                 temp_max = a[x * n + y] * b[x * n + y];             }         }         if (fabs(temp_max - max[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc get default async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,async,construct-independent,internal-control-values,V:2.5-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     int holder = acc_get_default_async();      for(int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])     {         #pragma acc parallel async         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc wait(holder)     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }     if (acc_get_default_async() < 0){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x eqv expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = totals(x) .EQV. a(x, y)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign x divided expr", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_c = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(c[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];                 passed_c[y] = c[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];                 passed_c[y - 1] = c[y];             }             if (is_possible(passed_a, passed_b, passed_c, length - 1, prev / (a[x] + b[x]))){                 free(passed_a);                 free(passed_b);                 free(passed_c);                 return true;             }         }     }     free(passed_a);     free(passed_b);     free(passed_c);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));     real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));     real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x/10];                     totals[x/10] = totals[x/10] / (a[x] + b[x]);                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];             temp_c[temp_iterator] = c[ab_iterator];             temp_iterator++;         }         if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured x bitand expr assign", "completion": "#include \"acc_testsuite.h\"  bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == (prev & a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] = totals[x/10] & a[x];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] &= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial if", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,if,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int accel = 1;     int host = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }     #pragma acc serial if(host)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  #ifndef T2 //T2:serial,if,devonly,V:2.6-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int accel = 1;     int host = 0;     int * devtest = (int *)malloc(sizeof(int));     devtest[0] = 1;     #pragma acc data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {       devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0;         }         #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])         #pragma acc serial if(host) present(a[0:n], b[0:n], c[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }         #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])          for (int x = 0; x < n; ++x){             if (fabs(c[x]) > PRECISION){                 err = 1;             }         }     }      return err; } #endif  #ifndef T3 //T3:serial,if,V:2.6-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     int accel = 1;     int host = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }     #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])     #pragma acc serial if(accel) present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] += a[x] + b[x];         }     }      #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION * 2){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update x lshift expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic update                             a[x] = a[x] << 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop tile", "completion": "#ifndef T1 !T1:parallel,reduction,combined-constructs,loop,tile,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y, z !Iterators         REAL(8),DIMENSION(SMALL_LOOPCOUNT):: a, b, c !Data         REAL(8),DIMENSION(SMALL_LOOPCOUNT,SMALL_LOOPCOUNT)::d         REAL(8) :: temp         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         CALL RANDOM_NUMBER(c)          !$acc data copyin(a(1:SMALL_LOOPCOUNT), b(1:SMALL_LOOPCOUNT), c(1:SMALL_LOOPCOUNT)) copyout(d(1:SMALL_LOOPCOUNT,1:SMALL_LOOPCOUNT))           !$acc parallel loop tile(*, *) reduction(+:temp)           DO x = 1, SMALL_LOOPCOUNT             DO y = 1, SMALL_LOOPCOUNT                temp = 0               DO z = 1, SMALL_LOOPCOUNT                 temp = temp + a(z) + b(z) + c(z)               END DO               d(x,y) = temp             END DO           END DO         !$acc end data                  DO x = 1, SMALL_LOOPCOUNT            DO y = 1, SMALL_LOOPCOUNT              temp = 0             DO z = 1, SMALL_LOOPCOUNT               temp = temp + a(z) + b(z) + c(z)              END DO             IF (abs(d(x,y) - temp) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature exit data copyout no lower bound", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,syntactic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])     #pragma acc parallel present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel deviceptr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,runtime,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b;      for (int x = 0; x < n; ++x){         a[x] = 0;     }      #pragma acc enter data copyin(a[0:n])     b = (real_t *) acc_deviceptr(a);     if (b == NULL){         err = 1;     }     else{         #pragma acc parallel deviceptr(b)         {             #pragma acc loop             for (int x = 0; x < (int) n/2; ++x){                 b[x] = 1;             }         }         #pragma acc exit data copyout(a[0:n])     }     for (int x = 0; x < n; ++x){         if (x < (int) n/2){             if (fabs(a[x] - 1) > PRECISION){                 err = 1;             }         }         else {             if (fabs(a[x]) > PRECISION){                 err = 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic divided equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] /= (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc delete finalize async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,reference-counting,syntactic,construct-independent,async,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));     real_t *e = (real_t *)malloc(n * sizeof(real_t));     real_t *f = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0;     }      #pragma acc enter data copyin(a[0:n], b[0:n], d[0:n], e[0:n])     #pragma acc data present(a[0:n], b[0:n], d[0:n], e[0:n]) copyout(c[0:n], f[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         acc_delete_finalize_async(a, n * sizeof(real_t), 1);         acc_delete_finalize_async(b, n * sizeof(real_t), 1);         acc_delete_finalize_async(d, n * sizeof(real_t), 2);         acc_delete_finalize_async(e, n * sizeof(real_t), 2);         #pragma acc wait     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }         if (fabs(f[x] - (d[x] + e[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,reference-counting,devonly,async,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));     real_t *e = (real_t *)malloc(n * sizeof(real_t));     real_t *f = (real_t *)malloc(n * sizeof(real_t));     int* devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0;         }          #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])         #pragma acc data present(a[0:n], b[0:n], c[0:n])         {             #pragma acc parallel async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] * b[x];                 }             }         }         acc_delete_finalize_async(c, n * sizeof(real_t), 1);         #pragma acc enter data copyin(c[0:n]) async(1)         #pragma acc data present(a[0:n], b[0:n], c[0:n])         {             #pragma acc parallel async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] += a[x] + b[x];                 }             }         } \t#pragma acc wait         #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x multiply expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign x plus expr", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, a[x] + prev)){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x%(n/10 + 1)];                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] + (a[x] * b[x]);                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] += a[x] * b[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){             passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture preincrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *c = new int[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = ++distribution[(int) (a[x]*b[x]/10)];             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]++;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      bool found = false;     for (int x = 0; x < 10; ++x){         for (int y = 0; y < distribution[x]; ++y){             for (int z = 0; z < n; ++z){                 if (c[z] == y + 1 && x == (int) (a[z] * b[z] / 10)){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel copyout", "completion": "#ifndef T1 !T1:parallel,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: hasDevice         hasDevice(1) = 1         !$acc enter data copyin(hasDevice(1:1))         !$acc parallel present(hasDevice(1:1))           hasDevice(1) = 0         !$acc end parallel           !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = 0          !$acc data copyin(a(1:LOOPCOUNT))           !$acc parallel copyout(b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = a(x)             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(a(x) - b(x)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:parallel,V:2.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: hasDevice         hasDevice(1) = 1         !$acc enter data copyin(hasDevice(1:1))         !$acc parallel present(hasDevice(1:1))           hasDevice(1) = 0         !$acc end parallel           !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = a         IF (hasDevice(1) .eq. 1) THEN           !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc parallel copyout(b(1:LOOPCOUNT))               !$acc loop               DO x = 1, LOOPCOUNT                 b(x) = b(x) - a(x)               END DO             !$acc end parallel           !$acc end data            DO x = 1, LOOPCOUNT             IF (abs(a(x) - b(x)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:parallel,update,V:2.0-2.7       LOGICAL FUNCTION test3()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: hasDevice         hasDevice(1) = 1         !$acc enter data copyin(hasDevice(1:1))         !$acc parallel present(hasDevice(1:1))           hasDevice(1) = 0         !$acc end parallel           !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         b = a          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc parallel copyout(b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = b(x) - a(x)             END DO           !$acc end parallel           !$acc update host(b(1:LOOPCOUNT))         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(b(x)) > 2 * PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction max loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * maximum = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);         c[x] = 0.0;     }     for (int x = 0; x < 10; ++x){         maximum[x] = 0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], maximum[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(max:temp)             for (int y = 0; y < n; ++y){                 temp = fmax(a[x * n + y] * b[x * n + y], temp);             }             maximum[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 c[x * n + y] = (a[x * n + y] * b[x * n + y]) / maximum[x];             }         }     }     for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = fmax(temp, a[x * n + y] * b[x * n + y]);         }         if (fabs(temp - maximum[x]) > PRECISION){             err += 1;         }         for (int y = 0; y < n; ++y){             if (c[x * n + y] > 1){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic max expr list x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop reduction bitor vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int b_host;      for (int x = 0; x < 10 * n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX > false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }     temp = 0;     #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc kernels loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(|:temp)             for (int y = 0; y < n; ++y){                 temp = temp | a[x * n + y];             }             b[x] = temp;         }     }      for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host | a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update x multiply expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction or vector loop", "completion": "#ifndef T1 !T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         LOGICAL,DIMENSION(10*LOOPCOUNT):: a !Data         LOGICAL,DIMENSION(10) :: b         LOGICAL :: temp         REAL(8),DIMENSION(10*LOOPCOUNT):: randoms         REAL(8) :: false_margin = exp(log(.5) / 2)         INTEGER :: errors = 0          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)          !Initilization         DO x = 1, 10 * LOOPCOUNT           IF (randoms(x) > false_margin) THEN             a(x) = .TRUE.           ELSE             a(x) = .FALSE.           END IF         END DO          !$acc data copyin(a(1:10*LOOPCOUNT)), copy(b(1:10))           !$acc parallel loop private(temp)           DO x = 0, 9             temp = .FALSE.             !$acc loop vector reduction(.OR.:temp)             DO y = 1, LOOPCOUNT               temp = temp .OR. a(x * LOOPCOUNT + y)             END DO             b(x + 1) = temp           END DO         !$acc end data          DO x = 0, 9           temp = .FALSE.           DO y = 1, LOOPCOUNT             temp = temp .OR. a(x * LOOPCOUNT + y)           END DO           IF (temp .neqv. b(x + 1)) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop reduction or loop", "completion": "#ifndef T1 !T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         LOGICAL,DIMENSION(10*LOOPCOUNT):: a, a_copy !Data         LOGICAL,DIMENSION(10) :: results         LOGICAL :: temp = .FALSE.         REAL(8),DIMENSION(10 * LOOPCOUNT) :: random         REAL(8) :: false_margin = exp(log(.5) / n)         INTEGER :: errors = 0          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(random)          !Initilization         DO x = 1, 10 * LOOPCOUNT           IF (random(x) .gt. false_margin) THEN             a(x) = .TRUE.           ELSE             a(x) = .FALSE.           END IF           a_copy(x) = a(x)         END DO          DO x = 1, 10           results(x) = .FALSE.         END DO          !$acc data copy(a(1:10*LOOPCOUNT), results(1:10))           !$acc kernels loop gang private(temp)           DO x = 0, 9             temp = .FALSE.             !$acc loop worker reduction(.OR.:temp)             DO y = 1, LOOPCOUNT               temp = temp .OR. a(x * LOOPCOUNT + y)             END DO             results(x + 1) = temp             !$acc loop worker             DO y = 1, LOOPCOUNT               IF (results(x + 1) .eqv. .TRUE.) THEN                 IF(a(x * LOOPCOUNT + y) .eqv. .TRUE.) THEN                   a(x * LOOPCOUNT + y) = .FALSE.                 ELSE                   a(x * LOOPCOUNT + y) = .TRUE.                 END IF               END IF             END DO           END DO         !$acc end data          DO x = 0, 9           temp = .FALSE.           DO y = 1, LOOPCOUNT             temp = temp .OR. a_copy(x * LOOPCOUNT + y)           END DO           IF (temp .neqv. results(x + 1)) THEN             errors = errors + 1           END IF           DO y = 1, LOOPCOUNT             IF (temp .eqv. .FALSE.) THEN               IF (a(x * LOOPCOUNT + y) .neqv. a_copy(x * LOOPCOUNT + y)) THEN                 errors = errors + 1               END IF             ELSE               IF (a(x * LOOPCOUNT + y) .eqv. a_copy(x * LOOPCOUNT + y)) THEN                 errors = errors + 1               END IF             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction min general", "completion": "#ifndef T1 !T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8):: minimum = 1000         REAL(8):: temp = 1000         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc parallel loop reduction(min:minimum)           DO x = 1, LOOPCOUNT             minimum = min(minimum, a(x) * b(x))           END DO         !$acc end data          DO x = 1, LOOPCOUNT           temp = min(temp, a(x) * b(x))         END DO         IF (abs(temp - minimum) .gt. PRECISION) THEN           errors = errors + 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature data async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:async,data,V:3.2-3.3 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copy(a[0:n], b[0:n], c[0:n]) async(1)     {         #pragma acc parallel          {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      #pragma acc data copy(a[0:n], b[0:n], c[0:n]) async(1)     {         #pragma acc parallel          {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      #pragma acc wait(1)           for (int x = 0; x < n; ++x){         if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION){             err += 1;         }     }      return err; } #endif #ifndef T2 //T2:async,data,V:3.2-3.3 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copy(a[0:n], b[0:n], c[0:n]) async(0)     {         #pragma acc parallel loop async(1) wait(0)             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }      #pragma acc wait(1) async(0)     }      #pragma acc wait(0)      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature wait if queue false", "completion": "#include \"acc_testsuite.h\"  using namespace std;  #ifndef T1 //T1:parallel,wait,async,V:2.7-3.2 int test1(){     int err = 0;     srand(time(NULL));     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     data_container<real_t> c = *(new data_container<real_t>(n));     data_container<real_t> d = *(new data_container<real_t>(n));     data_container<real_t> e = *(new data_container<real_t>(n));     data_container<real_t> f = *(new data_container<real_t>(n));     data_container<real_t> g = *(new data_container<real_t>(n));      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = rand() / (real_t)(RAND_MAX / 10); \tc.data[x] = 0.0;         d.data[x] = rand() / (real_t)(RAND_MAX / 10);         e.data[x] = rand() / (real_t)(RAND_MAX / 10); \tf.data[x] = 0.0; \tg.data[x] = 0.0;     }      #pragma acc data copyin(a,a.data[0:n], b, b.data[0:n], c, c.data[0:n], d, d.data[0:n], e, e.data[0:n], f, f.data[0:n],g, g.data[0:n])     {         #pragma acc parallel loop async(1)         for (int x = 0; x < n; ++x){             c.data[x] = a.data[x] + b.data[x];         }         #pragma acc parallel loop async(2)         for (int x = 0; x < n; ++x){             f.data[x] = d.data[x] + e.data[x];         }         #pragma acc parallel wait(1, 2) async(3)         for (int x = 0; x < n; ++x){             g.data[x] = c.data[x] + f.data[x];         }      \t#pragma acc update host(c.data[0:n], f.data[0:n]) wait(1,2) if(false) \t#pragma acc update host(g.data[0:n]) wait(1,2,3) if(false)     }      for (int x = 0; x < n; ++x){         if (c.data[x] > PRECISION){             err++;         }         if (f.data[x] > PRECISION){ \t    err++; \t}         if (g.data[x] > PRECISION){             err++;       \t}     }      return err; } #endif #ifndef T2 //T2:parallel,wait,async,V:2.7-3.2 int test2(){     int err = 0;     srand(time(NULL));      real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     real_t * d = new real_t[n];     real_t * e = new real_t[n];     real_t * f = new real_t[n];     real_t * g = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;         g[x] = 0.0;     }     #pragma acc data copyin(a[0:n], b[0:n], c[0:n], d[0:n], e[0:n], f[0:n], g[0:n])     {         #pragma acc parallel loop async(1)         for (int x = 0; x < n; ++x){             c[x] = (a[x] + b[x]);         }         #pragma acc parallel loop async(2)         for (int x = 0; x < n; ++x){             f[x] = (d[x] + e[x]);         }         #pragma acc parallel loop wait(1, 2) async(3)         for (int x = 0; x < n; ++x){             g[x] = (c[x] + f[x]);         }  \t#pragma acc update host(c[0:n], f[0:n]) wait(1,2) if(false)         #pragma acc update host(g[0:n]) wait(1,2,3) if(false)     }      for (int x = 0; x < n; ++x){         if(c[x] > PRECISION){ \t    err++; \t}         if(f[x] > PRECISION){             err++;         }         if(g[x] > PRECISION){             err++;         }     }      delete[] a;     delete[] b;     delete[] c;     delete[] d;     delete[] e;     delete[] f;     delete[] g;      return err; } #endif #ifndef T3 //T3:parallel,wait,async,V:2.7-3.2 int test3(){     int err = 0;     srand(time(NULL));      real_t * a = new real_t[n];     real_t * b = new real_t[n];     data_container<real_t> c = *(new data_container<real_t>(n));     real_t * d = new real_t[n];     real_t * e = new real_t[n];     data_container<real_t> f = *(new data_container<real_t>(n));     data_container<real_t> g = *(new data_container<real_t>(n));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c.data[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f.data[x] = 0.0;         g.data[x] = 0.0;     }     #pragma acc data copyin(a[0:n], b[0:n], c, c.data[0:n], d[0:n], e[0:n], f, f.data[0:n], g, g.data[0:n])     {         #pragma acc parallel loop async(1)         for (int x = 0; x < n; ++x){             c.data[x] = (a[x] + b[x]);         }         #pragma acc parallel loop async(2)         for (int x = 0; x < n; ++x){             f.data[x] = (d[x] + e[x]);         }         #pragma acc parallel loop wait(1, 2) async(3)         for (int x = 0; x < n; ++x){             g.data[x] = (c.data[x] + f.data[x]);         }          #pragma acc update host(c.data[0:n], f.data[0:n]) wait(1,2) if(false)         #pragma acc update host(g.data[0:n]) wait(1,2,3) if(false)     }      for (int x = 0; x < n; ++x){         if(c.data[x] > PRECISION){             err++;         }         if(f.data[x] > PRECISION){             err++;         }         if(g.data[x] > PRECISION){             err++;         }     }      delete[] a;     delete[] b;     delete[] d;     delete[] e;      return err; } #endif #ifndef T4 //T4:parallel,wait,async,V:2.7-3.2 int test4(){     int err = 0;     srand(time(NULL));      data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     real_t * c  = new real_t[n];     data_container<real_t> d = *(new data_container<real_t>(n));     data_container<real_t> e = *(new data_container<real_t>(n));     real_t * f = new real_t[n];     real_t * g = new real_t[n];      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d.data[x] = rand() / (real_t)(RAND_MAX / 10);         e.data[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;         g[x] = 0.0;     }     #pragma acc data copyin(a,a.data[0:n],b,b.data[0:n],c[0:n],d,d.data[0:n],e,e.data[0:n], f[0:n], g[0:n])     {         #pragma acc parallel loop async(1)         for (int x = 0; x < n; ++x){             c[x] = (a.data[x] + b.data[x]);         }         #pragma acc parallel loop async(2)         for (int x = 0; x < n; ++x){             f[x] = (d.data[x] + e.data[x]);         }         #pragma acc parallel loop wait(1, 2) async(3)         for (int x = 0; x < n; ++x){             g[x] = (c[x] + f[x]);         }         #pragma acc update host(c[0:n], f[0:n]) wait(1,2) if(false)         #pragma acc update host(g[0:n]) wait(1,2,3) if(false)     }      for (int x = 0; x < n; ++x){         if (c[x] > PRECISION){             err++;         }         if (f[x] > PRECISION){             err++;         }         if (g[x] > PRECISION){             err++;         }     }      delete[] c;     delete[] f;     delete[] g;      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test1();     }     if(failed){ \tfailcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }     if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }     if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test4();     }     if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature init device type num nvidia", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:init,runtime,V:2.5-3.2 int test1(){     int err = 0;     srand(SEED);     int device_num = acc_get_device_num(acc_get_device_type());      #pragma acc init device_type(nvidia) device_num(device_num)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }     if (failed){         failcode += (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic iand expr x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .gt. .933) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           DO y = 0, 7             totals(x) = totals(x) + ISHFT(1, y)             totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)           END DO         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic min expr x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction add vector loop", "completion": "#ifndef T1 !T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10*LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(10) :: c         REAL(8) :: temp         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copyout(c(1:10))           !$acc parallel loop private(temp)           DO x = 0, 9             temp = 0.0             !$acc loop vector reduction(+:temp)             DO y = 1, LOOPCOUNT               temp = temp + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)             END DO             c(x + 1) = temp           END DO         !$acc end data          DO x = 0, 9           temp = 0           DO y = 1, LOOPCOUNT             temp = temp + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)           END DO           IF (abs(temp - c(x + 1)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign expr multiply x", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, a[x] * prev)){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t * passed_ab = new real_t[10];     real_t * passed_c = new real_t[10];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x%(n/10 + 1)];                     totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction or general", "completion": "#ifndef T1 !T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         LOGICAL,DIMENSION(LOOPCOUNT):: a !Data         LOGICAL :: results = .FALSE.         LOGICAL :: temp = .FALSE.         REAL(8) :: false_margin = exp(log(.5) / n)         REAL(8),DIMENSION(LOOPCOUNT):: random         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(random)         DO x = 1, LOOPCOUNT           IF (random(x) > false_margin) THEN             a(x) = .TRUE.           ELSE             a(x) = .FALSE.           END IF         END DO          !$acc data copyin(a(1:LOOPCOUNT))           !$acc parallel loop reduction(.OR.:results)           DO x = 1, LOOPCOUNT             results = results .OR. a(x)           END DO         !$acc end data          DO x = 1, LOOPCOUNT           temp = temp .OR. a(x)         END DO         IF (temp .neqv. results) THEN           errors = errors + 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction bitxor loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));     unsigned int temp = 0;      for (int x = 0; x < 10*n; ++x){         b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b_copy[x] = b[x];         a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);     }     for (int x = 0; x < 10; ++x){         c[x] = 0;     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(^:temp)             for (int y = 0; y < n; ++y){                 temp = temp ^ a[x * n + y];             }             c[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 b[x * n + y] = b[x * n + y] + c[x];             }         }     }      for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = temp ^ a[x * n + y];         }         if (temp != c[x]){             err += 1;         }         for (int y = 0; y < n; ++y){             if (b[x * n + y] != b_copy[x * n + y] + c[x]){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,nonvalidating,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(25 * sizeof(unsigned int));      unsigned int temp[5];      for (int x = 0; x < n; ++x){         a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b_copy[x] = b[x];     }      for (int x = 0; x < 25; ++x) {         c[x] = 0;     }      for (int x = 0; x < 5; ++x) {         temp[x] = 0;     }      #pragma acc data copyin(a[0:25*n]) copy(b[0:25*n], c[0:25])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 temp[y] = 0;             }             #pragma acc loop worker reduction(^:temp)             for (int y = 0; y < 5 * n; ++y) {                 temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];             }             for (int y = 0; y < 5; ++y) {                 c[x * 5 + y] = temp[y];             }             #pragma acc loop worker             for (int y = 0; y < 5 * n; ++y) {                 b[x * 5 * n + y] = b[x * 5 * n + y] + c[x * 5 + (y % 5)];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             temp[y] = 0;         }         for (int y = 0; y < 5 * n; ++y) {             temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];         }              }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x lshift expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic                             a[x] = a[x] << 1;                     }                 }             }         }     }     for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,async,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10 * n];     real_t * d = new real_t[10 * n]; \t\tint * errors = new int[10];  \t\tfor (int x = 0; x < 10; ++x){ \t\t\terrors[x] = 0; \t\t}      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = a[x] + b[x];     }      #pragma acc data copyin(a[0:10*n], b[0:10*n], c[0:10*n], d[0:10*n]) copy(errors[0:10])     {         for (int x = 0; x < 10; ++x){             #pragma acc serial loop async(x)             for (int y = 0; y < n; ++y){                 c[x * n + y] = a[x * n + y] + b[x * n + y];             }             #pragma acc serial loop async(x)             for (int y = 0; y < n; ++y){                 if(c[x * n + y] - d[x * n + y] > PRECISION || d[x * n + y] - c[x * n + y] > PRECISION){                     errors[x] += 1;                 }             }         } \t\t\t\t#pragma acc wait     }      for (int x = 0; x < 10; ++x){         err += errors[x];     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr minus x", "completion": "#include \"acc_testsuite.h\" bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){     if (length == 0){         if (fabs(current_value - test_value) > PRECISION){             return true;         }         else {             return false;         }     }     real_t * passed = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         for (int y = 0; y < x; ++y){             passed[y] = remaining_combinations[y];         }         for (int y = x + 1; y < length; ++y){             passed[y - 1] = remaining_combinations[y];         }         if (possible_result(passed, length - 1, remaining_combinations[x] - current_value, test_value)){             free(passed);             return true;         }     }     free(passed);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(((n/10) + 1) * sizeof(real_t));     int indexer = 0;     real_t * passed = (real_t *)malloc(10 * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < (n/10) + 1; ++x){         totals[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];             }         }     }     for (int x = 0; x < (n/10) + 1; ++x){         indexer = x;         while (indexer < n){             passed[indexer/((int) (n/10) + 1)] = a[indexer];             indexer += (n/10) + 1;         }         if (!(possible_result(passed, 10, 0, totals[x]))){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign expr bitand x", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev & a[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         for (int y = 0; y < 8; ++y){             totals[x] =  1<<y;             totals_comparison[x] = 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         b[x] = totals[x/10];                         totals[x/10] = a[x] & totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] &= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }      for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc malloc", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,V:1.0-2.7 int test1(){     int err = 0;     size_t initial_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);     int *a = (int *)acc_malloc(n * sizeof(int));      if (initial_memory == 0){         return err;     }     size_t final_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);     if (final_memory + n * sizeof(int) > initial_memory){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x plus expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = totals(x) + a(x, y)               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) + a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc copyin async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:async,data,executable-data,runtime,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *a_host = new real_t[n];     real_t *b_host = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         a_host[x] = a[x];         b_host[x] = b[x];     }      acc_copyin_async(a, n * sizeof(real_t), 1);     acc_copyin_async(b, n * sizeof(real_t), 2);     #pragma acc data copyout(c[0:n]) present(a[0:n], b[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = a[x] * a[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = b[x] * b[x];             }         }         #pragma acc parallel async(2) wait(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > PRECISION * 4){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     real_t * a_copy = new real_t[n];     real_t * b_copy = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 1;     }      acc_copyin_async(a, n*sizeof(real_t), 1);     acc_copyin_async(b, n*sizeof(real_t), 2);      #pragma acc data copyout(c[0:n])     {         while (!acc_async_test_all());         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      acc_copyin_async(a, n * sizeof(real_t), 1);     acc_copyin_async(b, n * sizeof(real_t), 2);      #pragma acc data copyout(c[0:n])     {         #pragma acc wait         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }     }      #pragma acc exit data delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err = err + 1;         }     }      return err; } #endif  #ifndef T4 //T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7 int test4(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     real_t * d = new real_t[n];     real_t * e = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = 0;     }      #pragma acc enter data create(c[0:n])     #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) copyout(e[0:n])     {         #pragma acc parallel present(c[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         acc_copyin_async(c, n * sizeof(real_t), 1);         #pragma acc exit data delete(c[0:n]) async(1)         #pragma acc parallel present(c[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 e[x] = c[x] + d[x];             }         }     }     #pragma acc wait     #pragma acc exit data copyout(c[0:n])      for (int x = 0; x < n; ++x) {         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }         if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  #ifndef T5 //T5:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7 int test5(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     real_t * a_copy = new real_t[n];     real_t * b_copy = new real_t[n];     int * devtest = (int *)malloc(sizeof(int));      devtest[0] = 0;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 1;     }      if (devtest[0] == 0){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0;             a_copy[x] = a[x];             b_copy[x] = b[x];         }          acc_copyin_async(a, n * sizeof(real_t), 1);         acc_copyin_async(b, n * sizeof(real_t), 2);          for (int x = 0; x < n; ++x) {             a[x] = 0;             b[x] = 0;         }          #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])         {             #pragma acc wait             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x) {                     c[x] = a[x] + b[x];                 }             }         }          #pragma acc exit data delete(a[0:n], b[0:n])          for (int x = 0; x < n; ++x) {             if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop vector", "completion": "#ifndef T1 !T1:serial,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   REAL(8),DIMENSION(LOOPCOUNT):: a, b, c   INTEGER:: x   INTEGER:: errors    errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 0    !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))     !$acc serial loop vector     DO x = 1, LOOPCOUNT       c(x) = a(x) + b(x)     END DO   !$acc end data    DO x = 1, LOOPCOUNT     IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture postdecrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *c = (int *)malloc(n * sizeof(int));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = (distribution[(int) (a[x]*b[x]/10)])--;             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]--;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      bool found = false;     for (int x = 0; x < 10; ++x){         for (int y = 0; y > -distribution_comparison[x]; --y){             for (int z = 0; z < n; ++z){                 if (y == c[z] && x == (int) (a[x] * b[x] / 10)){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr plus x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[10];     real_t *totals_comparison = new real_t[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic                         totals[(int) ((a[x] + b[x])/2)] = a[x] * b[x] + totals[(int) ((a[x] + b[x])/2)];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];         }     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] -  totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature loop no collapse", "completion": "#ifndef T1 !T1:construct-independent,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c !Data         REAL(8):: total         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          DO x = 0, 9           c(x * LOOPCOUNT + 1) = a(x * LOOPCOUNT + 1) + b(x * LOOPCOUNT + 1)         END DO          !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT))           !$acc parallel             !$acc loop independent             DO x = 0, 9               DO y = 2, LOOPCOUNT                 c(x * LOOPCOUNT + y) = c(x * LOOPCOUNT + y - 1) + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 0, 9           total = 0           DO y = 1, LOOPCOUNT             total = total + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)             IF (abs(total - c(x * LOOPCOUNT + y)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:construct-independent,loop,V:1.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c !Data         REAL(8):: total         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          DO x = 0, 9           c(x * LOOPCOUNT + 1) = a(x * LOOPCOUNT + 1) + b(x * LOOPCOUNT + 1)         END DO          !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT))           !$acc kernels             !$acc loop independent             DO x = 0, 9               DO y = 2, LOOPCOUNT                 c(x * LOOPCOUNT + y) = c(x * LOOPCOUNT + y - 1) + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)               END DO             END DO           !$acc end kernels         !$acc end data          DO x = 0, 9           total = 0           DO y = 1, LOOPCOUNT             total = total + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)             IF (abs(total - c(x * LOOPCOUNT + y)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels num workers", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * restrict a = (real_t *)malloc(n * sizeof(real_t));     real_t * restrict b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc kernels loop num_workers(16)         for (int x = 0; x < n; ++x){             b[x] = a[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc free", "completion": "#ifndef T1 !T1:runtime,data,executable-data,V:3.3       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         REAL(8),DIMENSION(LOOPCOUNT):: initial_memory, final_memory !Data         INTEGER, POINTER :: a(:)         INTEGER :: errors = 0          initial_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);                  ALLOCATE(a(n))          acc_free(a)          final_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);          ALLOCATE(a(N))          IF (final_memory .lt. (initial_memory + size(a))) THEN             errors = errors + 1         END IF          test1 = .FALSE.       END #endif   PROGRAM main     IMPLICIT NONE     INTEGER :: failcode, testrun     LOGICAL :: failed     INCLUDE \"acc_testsuite.Fh\"     !Conditionally define test functions #ifndef T1     LOGICAL :: test1 #endif     failcode = 0     failed = .FALSE.  #ifndef T1     DO testrun = 1, NUM_TEST_CALLS       failed = failed .or. test1()     END DO     IF (failed) THEN       failcode = failcode + 2 ** 0       failed = .FALSE.     END IF #endif     CALL EXIT (failcode)   END PROGRAM  "}
{"prompt": "Create a test for the feature parallel independent atomic write", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.7-3.2 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copy(a[0:n], b[0:n])     {         #pragma acc parallel         { \t    #pragma acc loop independent             for (int x = 0; x < n; ++x){                 #pragma acc atomic write                     b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif   int main(){     int failcode = 0;     int failed; #ifndef T1    failed = 0;    for (int x = 0; x < NUM_TEST_CALLS; ++x){        failed = failed + test1();    }    if (failed != 0){        failcode = failcode + (1 << 0);    } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature acc deviceptr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *a_ptr;     real_t *b_ptr;     real_t *c_ptr;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])      a_ptr = reinterpret_cast<real_t*>(acc_deviceptr(a));     b_ptr = reinterpret_cast<real_t*>(acc_deviceptr(b));     c_ptr = reinterpret_cast<real_t*>(acc_deviceptr(c));      #pragma acc data deviceptr(a_ptr, b_ptr, c_ptr)     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c_ptr[x] = a_ptr[x] + b_ptr[x];             }         }     }      #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature enter data create no lower bound", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,syntactic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[:n])     #pragma acc parallel present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture assign expr times x", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8), INTENT(IN) :: init         REAL(8),DIMENSION(length), INTENT(IN) :: a         REAL(8),DIMENSION(length), INTENT(IN) :: b         REAL(8),DIMENSION(length - 1) :: passed_a         REAL(8),DIMENSION(length - 1) :: passed_b         REAL(8) :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (abs(b(x) - init) .GT. ((10 - length) * PRECISION)) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = a(x) * init             IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         REAL(8),DIMENSION(10):: passed_a, passed_b         REAL(8):: init         LOGICAL IS_POSSIBLE         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   b(x, y) = totals(x)                   totals(x) = a(x, y) * totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) * a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           init = 1           IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .TRUE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction and vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = new char[10 * n];     char * b = new char[10];     char * has_false = new char[10];     char temp = 1;     real_t false_margin = pow(exp(1), log(.5)/n);      for (int x = 0; x < 10; ++x){         has_false[x] = 0;     }     for (int x = 0; x < 10 * n; ++x){         if(rand() / (real_t)(RAND_MAX) < false_margin){             a[x] = 1;         }         else{             a[x] = 0;             has_false[x/n] = 1;         }     }     #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop vector reduction(&&:temp)             for (int y = 0; y < n; ++y){                 temp = temp && a[x * n + y];             }             b[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         if (has_false[x] == b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc copyout", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      acc_create(c, n * sizeof(real_t));      #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      acc_copyout(c, n * sizeof(real_t));      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data create(c[0:n])      #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      acc_copyout(c, n * sizeof(real_t));      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc delete finalize", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,reference-counting,construct-independent,syntactic,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n])     #pragma acc enter data copyin(a[0:n], b[0:n])      #pragma acc data copyout(c[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      acc_delete_finalize(a, n * sizeof(real_t));     acc_delete_finalize(b, n * sizeof(real_t));      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,reference-counting,syntactic,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      acc_copyin(a, n * sizeof(real_t));     acc_copyin(a, n * sizeof(real_t));     acc_copyin(b, n * sizeof(real_t));     acc_copyin(b, n * sizeof(real_t));      #pragma acc data copyout(c[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      acc_delete_finalize(a, n * sizeof(real_t));     acc_delete_finalize(b, n * sizeof(real_t));      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature enter data create", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc enter data create(b[0:n])     #pragma acc data copyin(a[0:n])     {         #pragma acc parallel present(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }     #pragma acc data copyout(c[0:n])     {         #pragma acc parallel present(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = b[x];             }         }     }     #pragma acc exit data delete(b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - a[x]) > PRECISION) {             err += 1;             break;         }     }      return err; } #endif  #ifndef T2 //T2:data,executable-data,construct-independent,compatibility-features,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc enter data present_or_create(b[0:n])     #pragma acc data copyin(a[0:n])     {         #pragma acc parallel present(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }     #pragma acc data copyout(c[0:n])     {         #pragma acc parallel present(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = b[x];             }         }     }     #pragma acc exit data delete(b[0:n])     for (int x = 0; x < n; ++x){         if (fabs(c[x] - a[x]) > PRECISION) {             err += 2;             break;         }     }      return err; } #endif  #ifndef T3 //T3:data,executable-data,construct-independent,compatibility-features,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc enter data pcreate(b[0:n])     #pragma acc data copyin(a[0:n])     {         #pragma acc parallel present(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }     #pragma acc data copyout(c[0:n])     {         #pragma acc parallel present(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = b[x];             }         }     }     #pragma acc exit data delete(b[0:n])     for (int x = 0; x < n; ++x){         if (fabs(c[x] - a[x]) > PRECISION){             err += 4;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction and loop", "completion": "#include \"acc_testsuite.h\"  #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(10 * n * sizeof(char));     char * a_copy = (char *)malloc(10 * n * sizeof(char));     char * has_false = (char *)malloc(10 * sizeof(char));     real_t false_margin = pow(exp(1), log(.5)/n);     char temp = 1;      for (int x = 0; x < 10; ++x){         has_false[x] = 0;     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (rand() / (real_t)(RAND_MAX) < false_margin){                 a[x * n + y] = 1;                 a_copy[x * n + y] = 1;             }             else {                 a[x * n + y] = 0;                 a_copy[x * n + y] = 0;                 has_false[x] = 1;             }         }     }      #pragma acc data copy(a[0:10*n])     {         #pragma acc parallel loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop worker reduction(&&:temp)             for (int y = 0; y < n; ++y){                 temp = temp && a[x * n + y];             }             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 a[x * n + y] = a[x * n + y] ^ temp;             }         }     }       for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){                 err = 1;             }             else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){                 err = 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(n * 25 * sizeof(char));     char * a_copy = (char *)malloc(n * 25 * sizeof(char));     char * has_false = (char *)malloc(25 * sizeof(char));     real_t false_margin = pow(exp(1), log(.5)/n);     char device[5];     char host[5];      for (int x = 0; x < 5; ++x) {         device[x] = 1;         host[x] = 1;         for (int y = 0; y < 5; ++y) {             has_false[x * 5 + y] = 0;         }     }      for (int x = 0; x < 25 * n; ++x){         if (rand() / (real_t)(RAND_MAX) < false_margin) {             a[x] = 1;             a_copy[x] = 1;         }         else {             a[x] = 0;             a_copy[x] = 0;             has_false[x % 25] = 1;         }     }      #pragma acc data copy(a[0:25*n])     {         #pragma acc parallel loop gang private(device)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 device[y] = 1;             }             #pragma acc loop worker reduction(&&:device)             for (int y = 0; y < 5 * n; ++y) {                 device[y%5] = device[y%5] && a[x * 5 * n + y];             }             #pragma acc loop worker             for (int y = 0; y < 5 * n; ++y) {                 a[x * 5 * n + y] = a[x * 5 * n + y] ^ device[y%5];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             host[y] = 1;         }         for (int y = 0; y < 5 * n; ++y) {             host[y%5] = host[y%5] && a_copy[x * 5 * n + y];         }         for (int y = 0; y < 5 * n; ++y) {             if (a[x * 5 * n + y] != (a_copy[x * 5 * n + y] ^ host[y % 5])) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc set device type", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,set,V:1.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: errors = 0         INTEGER :: device_type          device_type = acc_get_device_type()         CALL acc_set_device_type(device_type)         IF (acc_get_device_type() .ne. device_type) THEN           errors = errors + 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature acc delete finalize async with len", "completion": "#ifndef T1 !T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(d)         CALL RANDOM_NUMBER(e)         f = 0          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))         !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))          !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           !$acc parallel async(2)             !$acc loop             DO x = 1, LOOPCOUNT               f(x) = d(x) + e(x)             END DO           !$acc end parallel           CALL acc_delete_finalize_async(a(1), LOOPCOUNT*8, 1)           CALL acc_delete_finalize_async(b(1), LOOPCOUNT*8, 1)           CALL acc_delete_finalize_async(d(1), LOOPCOUNT*8, 2)           CALL acc_delete_finalize_async(e(1), LOOPCOUNT*8, 2)           !$acc wait         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF           IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))         !$acc enter data copyin(c(1:LOOPCOUNT))         !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_delete_finalize_async(c(1), LOOPCOUNT*8, 1)          !$acc enter data copyin(c(1:LOOPCOUNT)) async(1)         !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = c(x) + a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2**1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature parallel default copy", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,data,data-region,default-mapping,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t c[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:parallel,data,data-region,default-mapping,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t c[n];     int * devtest = (int *)malloc(sizeof(real_t));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 1;         }          #pragma acc enter data copyin(c[0:n])         for (int x = 0; x < n; ++x){             c[x] = 0.0;         }         #pragma acc data copyin(a[0:n], b[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] += a[x] + b[x];                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(c[x]) > PRECISION){                 err += 1;             }         }          #pragma acc exit data copyout(c[0:n])          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop seq", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t temp = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copy(b[0:n])     {         #pragma acc serial loop seq         for (int x = 1; x < n; ++x){             b[x] = b[x-1] + a[x];         }     }      for (int x = 1; x < n; ++x){         temp += a[x];         if (fabs(b[x] - temp) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic x divided expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = totals(x) / a(x, y)               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) / a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop auto", "completion": "#ifndef T1 !T1:parallel,combined-constructs,loop,auto,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b !Data         REAL(8) :: temp         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         a_copy = a         b = 0          !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))           !$acc parallel loop auto           DO x = 1, LOOPCOUNT             b(x) = a(x)           END DO         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(a(x) - b(x)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          !$acc data copy(a(1:LOOPCOUNT))           !$acc parallel loop auto           DO x = 2, LOOPCOUNT             a(x) = a(x - 1) + a(x)           END DO         !$acc end data          temp = 0         DO x = 1, LOOPCOUNT           temp = temp + a_copy(x)           IF (abs(temp - a(x)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc wait all", "completion": "#ifndef T1 !T1:runtime,async,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, a_host, b_host, c_host !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         CALL RANDOM_NUMBER(c)         d = 0         a_host = a         b_host = b         c_host = c          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) copyout(d(1:LOOPCOUNT))           !$acc parallel async(1)             !$acc loop             DO x = 1, LOOPCOUNT               a(x) = a(x) * a(x)             END DO           !$acc end parallel           !$acc parallel async(2)             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = b(x) * b(x)             END DO           !$acc end parallel           !$acc parallel async(3)             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = c(x) * c(x)             END DO           !$acc end parallel           CALL acc_wait_all()           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               d(x) = a(x) + b(x) + c(x)             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(d(x) - ((a_host(x) * a_host(x)) + (b_host(x) * b_host(x)) + (c_host(x) * c_host(x)))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction bitxor vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));     unsigned int temp = 0;     unsigned int b_host;      for (int x = 0; x < 10 * n; ++x){         a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(^:temp)             for (int y = 0; y < n; ++y){                 temp = temp ^ a[x * n + y];             }             b[x] = temp;         }     }      for (int x = 0; x < 10; ++x){         b_host = a[x * n];         for (int y = 1; y < n; ++y){             b_host = b_host ^ a[x * n + y];         }         if (b_host != b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc memcpy device", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *hostdata = new real_t[3 * n];     real_t *devdata;      for (int x = 0; x < n; ++x){         hostdata[x] = rand() / (real_t)(RAND_MAX / 10);         hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);         hostdata[2*n + x] = 1;     }      devdata = reinterpret_cast<real_t*>(acc_copyin(hostdata, 3 * n * sizeof(real_t)));     #pragma acc enter data create(a[0:n], b[0:n], c[0:n])     acc_memcpy_device(acc_deviceptr(a), devdata, n * sizeof(real_t));     acc_memcpy_device(acc_deviceptr(b), devdata+n, n * sizeof(real_t));     acc_memcpy_device(acc_deviceptr(c), devdata+2*n, n * sizeof(real_t));      #pragma acc data present(a[0:n], b[0:n], c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      #pragma acc exit data copyout(a[0:n], b[0:n], c[0:n])      for (int x = 0; x < n; ++x){         if (fabs(a[x] - hostdata[x]) > PRECISION){             err += 1;         }         if (fabs(b[x] - hostdata[n + x]) > PRECISION){             err += 1;         }         if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){             err += 1;         }     }      #pragma acc exit data delete(hostdata[0:3*n])      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction add general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t total;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      total = 10;     #pragma acc data copyin(a[0:n], b[0:n]) copy(total)     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x){             total += a[x] + b[x];         }     }     for (int x = 0; x < n; ++x){         total -= a[x] + b[x];     }     if (fabs(total - 10) > PRECISION * (2 * n - 1)){ //199 = # of mathematical operations necessary         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,loop,reduction,combined-constructs,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n * 10];     real_t * b = new real_t[n * 10];     real_t c[10];     real_t c_host[10];      for (int x = 0; x < 10 * n; ++x) {         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      for (int x = 0; x < 10; ++x) {         c[x] = 1.0;         c_host[x] = 1.0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n])     {         #pragma acc parallel loop reduction(+:c[0:10])         for (int x = 0; x < n; ++x) {             for (int y = 0; y < 10; ++y) {                 c[y] += a[x * 10 + y] + b[x * 10 + y];             }         }     }      for (int x = 0; x < n; ++x) {         for (int y = 0; y < 10; ++y) {             c_host[y] += a[x * 10 + y] + b[x * 10 + y];         }     }      for (int x = 0; x < 10; ++x) {         if (fabs(c_host[x] - c[x]) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction multiply loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * totals = (real_t *)malloc(10 * sizeof(real_t));     real_t temp;      for (int x = 0; x < n; ++x){         a[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;         b[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;         c[x] = 0.0;     }       #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10*n]) copy(totals[0:10])     {         #pragma acc kernels loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop worker reduction(*:temp)             for (int y = 0; y < n; ++y){                 temp *= a[x * n + y] + b[x * n + y];             }             totals[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 c[x * n + y] = (a[x * n + y] + b[x * n + y]) / totals[x];             }         }     }      for (int x = 0; x < 10; ++x){         temp = 1;         for (int y = 0; y < n; ++y){             temp *= a[x * n + y] + b[x * n + y];         }         if (fabs(temp - totals[x]) > (temp / 2 + totals[x] / 2) * PRECISION){             err += 1;         }         for (int y = 0; y < n; ++y){             if (fabs(c[x * n + y] - ((a[x * n + y] + b[x * n + y]) / totals[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature init if", "completion": "#include \"acc_testsuite.h\"  /*  * if clause not implimented on init yet */  #ifndef T1 //T1:,V:2.7-3.0 int test1(){ \tint err = 0; \tsrand(SEED); \t \tint device_num = acc_get_device_num(acc_get_device_type());  \t#pragma acc init if(device_num == device_num) \t//#pragma acc init if(true)  \treturn err; } #endif  #ifndef T2 //T2:,V:2.7-3.0 int test2(){ \tint err = 0; \tsrand(SEED);  \tint device_num = acc_get_device_num(acc_get_device_type());  \t#pragma acc init if(device_num != device_num) \t//#pragma acc init if(false)  \treturn err; } #endif  int main(){ \tint failcode = 0; \tint failed; #ifndef T1 \tfailed = 0; \tfor (int x = 0; x < NUM_TEST_CALLS; ++x){ \t\tfailed = failed + test1(); \t} \tif (failed != 0){ \t\tfailcode = failcode + (1 << 0); \t} #endif #ifndef T2 \tfailed = 0; \tfor (int x = 0; x < NUM_TEST_CALLS; ++x){ \t\tfailed = failed + test2(); \t} \tif (failed != 0){ \t\tfailcode = failcode + (1 << 1); \t} #endif \treturn failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitor loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));     unsigned int host_c;      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             b[x * n + y] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);             b_copy[x * n + y] = b[x * n + y];             for (int z = 0; z < 16; ++z){                 if (rand() / (real_t) RAND_MAX > false_margin){                     temp = 1;                     for (int i = 0; i < z; ++i){                         temp = temp * 2;                     }                     a[x * n + y] += temp;                 }             }         }     }      #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(|:temp)             for (int y = 0; y < n; ++y){                 temp = temp | a[x * n + y];             }             c[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 b[x * n + y] = b[x * n + y] + c[x];             }         }     }     for (int x = 0; x < 10; ++x){         host_c = a[x * n];         for (int y = 1; y < n; ++y){             host_c = host_c | a[x * n + y];         }         if (host_c != c[x]){             err += 1;         }         for (int y = 0; y < n; ++y){             if (b[x * n + y] != b_copy[x * n + y] + host_c){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel create", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,data,data-region,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copy(c[0:n])     {         #pragma acc parallel create(b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - c[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitor general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     unsigned int b = 0;     unsigned int host_b;     real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX > false_margin){                 for (int z = 0; z < y; ++z){                     temp *= 2;                 }                 a[x] += temp;                 temp = 1;             }         }     }      #pragma acc data copyin(a[0:n])     {         #pragma acc serial loop reduction(|:b)         for (int x = 0; x < n; ++x){             b = b | a[x];         }     }      host_b = a[0];     for (int x = 1; x < n; ++x){         host_b = host_b | a[x];     }     if (b != host_b){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature declare function scope copyin", "completion": "FUNCTION function_test(a, b, c, LOOPCOUNT)   REAL(8),DIMENSION(LOOPCOUNT),INTENT(IN) :: a, b   REAL(8),DIMENSION(LOOPCOUNT),INTENT(INOUT) :: c   INTEGER,INTENT(IN) :: LOOPCOUNT   INTEGER :: x    !$acc declare copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))   !$acc parallel present(c(1:LOOPCOUNT))     !$acc loop     DO x = 1, LOOPCOUNT       c(x) = c(x) + a(x) + b(x)     END DO   !$acc end parallel END FUNCTION function_test  FUNCTION function_test_dev_only(a, b, c, LOOPCOUNT)   REAL(8),DIMENSION(LOOPCOUNT),INTENT(INOUT) :: a, b   REAL(8),DIMENSION(LOOPCOUNT),INTENT(INOUT) :: c   INTEGER,INTENT(IN) :: LOOPCOUNT   INTEGER :: x    !$acc declare copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))   !$acc parallel present(c(1:LOOPCOUNT))     !$acc loop     DO x = 1, LOOPCOUNT       c(x) = c(x) + a(x) + b(x)       a(x) = -1       b(x) = -1     END DO   !$acc end parallel END FUNCTION function_test_dev_only  #ifndef T1 !T1:devonly,construct-independent,declare,V:2.0-2.7       LOGICAL FUNCTION test1()   USE OPENACC   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, a_host, b_host   INTEGER,DIMENSION(1) :: devtest   INTEGER :: x, y    devtest(1) = 1   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = 0   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   CALL RANDOM_NUMBER(b)   c = 1    !$acc data copy(c(1:LOOPCOUNT, 1:LOOPCOUNT))     DO x = 1, LOOPCOUNT       CALL function_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)     END DO   !$acc end data    DO x = 1, LOOPCOUNT     DO y = 1, LOOPCOUNT       IF (abs(c(x, y) - (1 + a(x, y) + b(x, y))) .gt. PRECISION) THEN         errors = errors + 1         PRINT*, \"1\"       END IF     END DO   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:devonly,construct-independent,declare,V:2.0-2.7       LOGICAL FUNCTION test2()   USE OPENACC   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, a_host, b_host   INTEGER,DIMENSION(1) :: devtest   INTEGER :: x, y    devtest(1) = 1   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = 0   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    IF (devtest(1) .eq. 1) THEN     CALL RANDOM_NUMBER(a)     CALL RANDOM_NUMBER(b)     c = 0     a_host = a     b_host = b      !$acc data copy(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT), c(1:LOOPCOUNT, 1:LOOPCOUNT))       DO x = 1, LOOPCOUNT         CALL function_test_dev_only(a(:,x), b(:,x), c(:,x), LOOPCOUNT)       END DO     !$acc end data      DO x = 1, LOOPCOUNT       DO y = 1, LOOPCOUNT         IF (abs(a(x, y) + 1) .gt. PRECISION) THEN           errors = errors + 1           PRINT*, \"2\"         END IF         IF (abs(b(x, y) + 1) .gt. PRECISION) THEN           errors = errors + 1           PRINT*, \"3\"         END IF         IF (abs(c(x, y) - (a_host(x, y) + b_host(x, y))) .gt. PRECISION) THEN           errors = errors + 1           PRINT*, \"4\"         END IF       END DO     END DO   END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:devonly,construct-independent,declare,V:2.0-2.7       LOGICAL FUNCTION test3()   USE OPENACC   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: errors = 0   INTEGER :: mult = 2   REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, a_host, b_host   INTEGER,DIMENSION(1) :: devtest   INTEGER :: x, y    devtest(1) = 1   !$acc enter data copyin(devtest(1:1))   !$acc parallel present(devtest(1:1))     devtest(1) = 0   !$acc end parallel    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    IF (devtest(1) .eq. 1) THEN     CALL RANDOM_NUMBER(a)     CALL RANDOM_NUMBER(b)     c = 1     a_host = a     b_host = b      !$acc data copy(c(1:LOOPCOUNT, 1:LOOPCOUNt))       DO x = 1, LOOPCOUNT         CALL function_test_dev_only(a(:,x), b(:,x), c(:,x), LOOPCOUNT)       END DO     !$acc end data      DO x = 1, LOOPCOUNT       DO y = 1, LOOPCOUNT         IF (abs(a(x, y) - a_host(x, y)) .gt. PRECISION) THEN           errors = errors + 1           PRINT*, \"5\"         END IF         IF (abs(b(x, y) - b_host(x, y)) .gt. PRECISION) THEN           errors = errors + 1           PRINT*, \"6\"         END IF         IF (abs(c(x, y) - (1 + a(x, y) + b(x, y))) .gt. PRECISION) THEN           errors = errors + 1           PRINT*, \"7\"         END IF       END DO     END DO   END IF          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update divided equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] /= (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitand vector loop", "completion": "#ifndef T1 !T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y, z, i !Iterators         INTEGER,DIMENSION(10*LOOPCOUNT):: a !Data         INTEGER,DIMENSION(10):: b         INTEGER :: c         REAL(8),DIMENSION(160*LOOPCOUNT):: random         REAL(8) :: false_margin         INTEGER :: errors = 0         INTEGER :: temp          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(random)         false_margin = exp(log(.5) / n)         DO x = 0, 9           DO y = 1, LOOPCOUNT             DO z = 1, 16               IF (random(x * 16 * LOOPCOUNT + (y - 1) * 16 + z - 1) < false_margin) THEN                 temp = 1                 DO i = 1, z                   temp = temp * 2                 END DO                 a(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + temp               END IF             END DO           END DO         END DO                          !$acc data copyin(a(1:10*LOOPCOUNT)), copy(b(1:10))           !$acc parallel loop private(c)           DO x = 0, 9             c = a(x * LOOPCOUNT + 1)             !$acc loop vector reduction(iand:c)             DO y = 1, LOOPCOUNT               c = iand(c, a(x * LOOPCOUNT + y))             END DO             b(x + 1) = c           END DO         !$acc end data          DO x = 0, 9           temp = a(x * LOOPCOUNT + 1)           DO y = 2, LOOPCOUNT             temp = iand(temp, a(x * LOOPCOUNT + y))           END DO           IF (b(x + 1) .ne. temp) THEN             errors = errors + 1           END IF         END DO                 IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update expr divided x end", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(subset, destination, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8),DIMENSION(length), INTENT(IN) :: subset         REAL(8), INTENT(IN) :: destination         REAL(8), INTENT(IN) :: init         REAL(8),ALLOCATABLE :: passed(:)         LOGICAL :: POSSIBLE         INTEGER :: x, y         IF (length .gt. 0) THEN           ALLOCATE(passed(length - 1))         ELSE           IF (abs(init - destination) .gt. PRECISION) THEN             POSSIBLE = .TRUE.           ELSE             POSSIBLE = .FALSE.           END IF           RETURN         END IF         POSSIBLE = .FALSE.         DO x = 1, length           DO y = 1, x - 1             passed(y) = subset(y)           END DO           DO y = x + 1, length             passed(y - 1) = subset(y)           END DO           IF (IS_POSSIBLE(passed, destination, length - 1, subset(x) / init)) THEN             POSSIBLE = .TRUE.             RETURN           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals         REAL(8),DIMENSION(10):: passed         INTEGER :: errors = 0         LOGICAL IS_POSSIBLE          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = a(x, y) / totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data           DO x = 1, LOOPCOUNT           DO y = 1, 10             passed(y) = a(x, y)           END DO           IF (IS_POSSIBLE(passed, totals(x), 10, 1) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial scalar default firstprivate", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,default-mapping,serial,firstprivate,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t scalar = rand() / (real_t)(RAND_MAX / 10);     real_t scalar_copy = scalar;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc serial         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x] + scalar;             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - (a[x] + scalar_copy)) > PRECISION){             err += 1;         }     }     if (fabs(scalar_copy - scalar) > PRECISION){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign expr multiply x", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, a[x] * prev)){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x%(n/10 + 1)];                     totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update x plus expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < n; ++y){                     #pragma acc atomic update                         totals[(int) ((a[x] + b[x])/2)] = totals[(int) ((a[x] + b[x])/2)] + a[x] * b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];         }     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr divided x", "completion": "#include \"acc_testsuite.h\" bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){     if (length == 0){         if (fabs(current_value - test_value) > PRECISION){             return true;         }         else {             return false;         }     }     real_t * passed = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         for (int y = 0; y < x; ++y){             passed[y] = remaining_combinations[y];         }         for (int y = x + 1; y < length; ++y){             passed[y - 1] = remaining_combinations[y];         }         if (possible_result(passed, length - 1, remaining_combinations[x] / current_value, test_value)){             free(passed);             return true;         }     }     free(passed);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed = (real_t *)malloc(10 * sizeof(real_t));     int indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];             }         }     }       for (int x = 0; x < (n/10 + 1); ++x){         indexer = x;         while (indexer < n){             passed[indexer/(n/10 + 1)] = (a[x] + b[x]);             indexer += (n/10 + 1);         }         if (!(possible_result(passed, 10, 1, totals[x]))){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc update device async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *a_host = new real_t[n];     real_t *b_host = new real_t[n];      int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         a_host[x] = a[x];         b_host[x] = b[x];     }        #pragma acc data copyout(c[0:n]) create(a[0:n], b[0:n])     {         acc_update_device_async(a, n * sizeof(real_t), 1);         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = a[x] * a[x];             }         }         acc_update_device_async(b, n * sizeof(real_t), 2);         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = b[x] * b[x];             }         }         #pragma acc parallel async(1) wait(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc wait(1)     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,async,devonly,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *a_host = new real_t[n];     real_t *b_host = new real_t[n];      int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0;         }          #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])         {             #pragma acc parallel async(1)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     a[x] = a[x] * a[x];                 }             }             acc_update_device_async(a, n * sizeof(real_t), 1);             #pragma acc parallel async(2)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = b[x] * b[x];                 }             }             acc_update_device_async(b, n * sizeof(real_t), 2);             #pragma acc parallel async(1) wait(2)             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] + b[x];                 }             }             #pragma acc wait(1)         }           for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update postdecrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     distribution[(int) (a[x] * b[x] / 10)]--;             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]--;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update expr minus x end", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(subset, destination, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8),DIMENSION(length), INTENT(IN) :: subset         REAL(8), INTENT(IN) :: destination         REAL(8), INTENT(IN) :: init         REAL(8),ALLOCATABLE :: passed(:)         LOGICAL :: POSSIBLE         INTEGER :: x, y         IF (length .gt. 0) THEN           ALLOCATE(passed(length - 1))         ELSE           IF (abs(init - destination) .gt. PRECISION) THEN             POSSIBLE = .TRUE.           ELSE             POSSIBLE = .FALSE.           END IF           RETURN         END IF         POSSIBLE = .FALSE.         DO x = 1, length           DO y = 1, x - 1             passed(y) = subset(y)           END DO           DO y = x + 1, length             passed(y - 1) = subset(y)           END DO           IF (IS_POSSIBLE(passed, destination, length - 1, subset(x) - init)) THEN             POSSIBLE = .TRUE.             RETURN           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         LOGICAL IS_POSSIBLE         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals         INTEGER :: errors = 0         REAL(8),DIMENSION(10):: passed          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = a(x, y) - totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed(y) = a(x, y)           END DO           IF (IS_POSSIBLE(passed, totals(x), 10, 0) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc create with len", "completion": "#ifndef T1 !T1:runtime,data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors         errors = 0          !Initilization         SEEDDIM(1) = 1         #ifdef SEED         SEEDDIM(1) = SEED         #endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_create(c(1), LOOPCOUNT*8)          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc parallel present(c(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_copyout(c(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER:: x         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c         INTEGER :: errors         errors = 0          SEEDDIM(1) = 1 #ifdef SEED         SEEDDIM(1) = SEED #endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c= 0          CALL acc_create(c(1), LOOPCOUNT*8)          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc parallel present(c(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data copyout(c(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:runtime,compatibility-features,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test3()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER:: x         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c         INTEGER:: errors         errors = 0          SEEDDIM(1) = 1 #ifdef SEED         SEEDDIM(1) = SEED #endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_pcreate(c(1), LOOPCOUNT*8)          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data copyout(c(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif #ifndef T4 !T4:runtime,compatibility-features,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test4()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER:: x         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c         INTEGER:: errors         errors = 0          SEEDDIM(1) = 1 #ifdef SEED         SEEDDIM(1) = SEED #endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_present_or_create(c(1), LOOPCOUNT*8)          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          !$acc exit data copyout(c(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test4 = .FALSE.         ELSE           test4 = .TRUE.         END IF       END #endif          PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif #ifndef T4         LOGICAL :: test4 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif #ifndef T4         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test4()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 3           failed = .FALSE.         END IF #endif          CALL EXIT (failcode)         END PROGRAM  "}
{"prompt": "Create a test for the feature kernels copyin", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data,data-region,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0.0;     }       #pragma acc data copy(b[0:n])     {         #pragma acc kernels copyin(a[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] += a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - a[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     int * devtest = (int *)malloc(sizeof(int));     real_t * a = new real_t[n];     real_t * b = new real_t[n];     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc kernels present(devtest[0:1])     {       devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0.0;         }          #pragma acc data copy(a[0:n], b[0:n])         {             for (int x = 0; x < n; ++x){                 a[x] = -1;             }             #pragma acc kernels copyin(a[0:n])             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     b[x] = a[x];                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(b[x] - a[x]) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T3 //T3:kernels,data,data-region,devonly,V:1.0-2.7 int test3(){     int err = 0;     srand(SEED);     int * devtest = (int *)malloc(sizeof(int));     real_t * a = new real_t[n];     real_t * b = new real_t[n];     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc kernels present(devtest[0:1])     {       devtest[0] = 0;     }          if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0;         }         #pragma acc kernels copyin(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }          for (int x = 0; x < n; ++x){             if (fabs(b[x]) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc shutdown", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,devonly,shutdown,V:2.0-2.7 int test1(){     int err = 0;      if (acc_get_device_type() != acc_device_none){         acc_shutdown(acc_get_device_type());     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop tile", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,tile,combined-constructs,syntactic,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));     real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));     real_t temp = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = rand() / (real_t)(RAND_MAX / 10);     }     #pragma acc data copy(a[0:n], b[0:n], c[0:n], d2[0:n*n])     {         #pragma acc serial loop tile(*, *) reduction(+:temp)         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 temp = 0;                 for (int z = 0; z < n; ++z){                     temp += a[x] + b[y] + c[z];                 }                 d2[x * n + y] = temp;             }         }     }     for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             temp = 0.0;             for (int z = 0; z < n; ++z){                 temp += a[x] + b[y] + c[z];             }             if (fabs(temp - d2[x * n + y]) > PRECISION * n){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:serial,loop,combined-constructs,tile,V:2.6-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));     real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));     real_t temp = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d3[0:n*n*n])     {         #pragma acc serial loop tile(2, 4, 8)         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 for (int z = 0; z < n; ++z){                     d3[(n * n * x) + (n * y) + z] = a[x] + b[x] + c[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             for (int z = 0; z < n; ++z){                 if (fabs(d3[(n * n * x) + (n * y) + z] - a[x] - b[x] - c[x]) > PRECISION * 2){                     err = 1;                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture expr divided x assign", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE_2(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8), INTENT(IN) :: init         REAL(8),DIMENSION(length), INTENT(IN) :: a         REAL(8),DIMENSION(length), INTENT(IN) :: b         REAL(8),DIMENSION(length - 1) :: passed_a         REAL(8),DIMENSION(length - 1) :: passed_b         real(8) :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y         REAL(8):: mindif         IF (length .lt. 10) THEN           WRITE(*, *) length         END IF         IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (abs(b(x) - (a(x) / init)) .lt. (100 - length) * PRECISION) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = b(x)             IF (IS_POSSIBLE_2(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE_2        RECURSIVE FUNCTION IS_POSSIBLE(subset, destination, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8),DIMENSION(length), INTENT(IN) :: subset         REAL(8), INTENT(IN) :: destination         REAL(8), INTENT(IN) :: init         REAL(8),ALLOCATABLE :: passed(:)         REAL(8) :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y         IF (length .gt. 0) THEN           ALLOCATE(passed(length - 1))         ELSE           IF (abs(init - destination) .lt. (10 - length) * PRECISION) THEN             POSSIBLE = .TRUE.           ELSE             POSSIBLE = .FALSE.           END IF           RETURN         END IF         POSSIBLE = .FALSE.         DO x = 1, length           DO y = 1, x - 1             passed(y) = subset(y)           END DO           DO y = x + 1, length             passed(y - 1) = subset(y)           END DO           holder = subset(x) / init           IF (IS_POSSIBLE(passed, destination, length - 1, holder)) THEN             POSSIBLE = .TRUE.             RETURN           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 10):: b         REAL(8),DIMENSION(LOOPCOUNT):: totals         REAL(8),DIMENSION(10):: passed         REAL(8),DIMENSION(10):: passed_b         REAL(8) :: holder         INTEGER :: errors = 0         LOGICAL IS_POSSIBLE         LOGICAL IS_POSSIBLE_2          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   totals(x) = a(x, y) / totals(x)                   b(x, y) = totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed(y) = a(x, y)           END DO           holder = 1           IF (IS_POSSIBLE(passed, totals(x), 10, holder) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           holder = 1           IF (IS_POSSIBLE_2(passed, passed_b, 10, holder) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign x minus expr", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev - a[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc(10 * sizeof(real_t));     real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));     real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_host[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x%10]; totals[x%10] = totals[x%10] - (a[x] + b[x]);                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update minus equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[10];     real_t *totals_host = new real_t[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_host[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%10] -= (a[x] + b[x]);             }         }     }      for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc on device", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     int device_type = acc_get_device_type();      if (device_type != acc_device_none){         #pragma acc data copy(err)         {             #pragma acc parallel             {                 if (acc_on_device(device_type) == 0){                     err += 1;                 }             }         }     }     else{         #pragma acc parallel         {             if (acc_on_device(acc_device_host) == 0){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured expr multiply x assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] * prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];                     c[x] = totals[x%(n/10 + 1)];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature enter data if", "completion": "#ifndef T1 !T1:data,executable-data,devonly,construct-independent,if,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b, b_copy, c !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest         LOGICAL :: dev = .TRUE.         LOGICAL :: cpu = .FALSE.         devtest(1) = 1          !$acc enter data copyin(devtest(1:1))         !$acc parallel           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(dev)         !$acc data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data         !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(dev)         DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:data,executable-data,devonly,construct-independent,if,V:2.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b, b_copy, c !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest         LOGICAL :: dev = .TRUE.         LOGICAL :: cpu = .FALSE.         devtest(1) = 1          !$acc enter data copyin(devtest(1:1))         !$acc parallel           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(cpu)         !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data         !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(cpu)          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:data,executable-data,devonly,construct-independent,if,V:2.0-2.7       LOGICAL FUNCTION test3()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b, b_copy, c !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest         LOGICAL :: dev = .TRUE.         LOGICAL :: cpu = .FALSE.         devtest(1) = 1          !$acc enter data copyin(devtest(1:1))         !$acc parallel           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          IF (devtest(1) .eq. 1) THEN           CALL RANDOM_NUMBER(a)           a_copy = a           CALL RANDOM_NUMBER(b)           b_copy = b           c = 0            !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(dev)            a = 0           b = 0            !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) + b(x)               END DO             !$acc end parallel           !$acc end data           !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(dev)            DO x = 1, LOOPCOUNT             IF (abs(c(x) - (a_copy(x) + b_copy(x))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif #ifndef T4 !T4:data,executable-data,devonly,construct-independent,if,V:2.0-2.7       LOGICAL FUNCTION test4()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b, b_copy, c !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest         LOGICAL :: dev = .TRUE.         LOGICAL :: cpu = .FALSE.         devtest(1) = 1          !$acc enter data copyin(devtest(1:1))         !$acc parallel           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          IF (devtest(1) .eq. 1) THEN           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 0            !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(cpu)           CALL RANDOM_NUMBER(a)           a_copy = a           CALL RANDOM_NUMBER(b)           b_copy = b            !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) + b(x)               END DO             !$acc end parallel           !$acc end data           !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(cpu)            DO x = 1, LOOPCOUNT             IF (abs(c(x) - (a_copy(x) + b_copy(x))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test4 = .FALSE.         ELSE           test4 = .TRUE.         END IF       END #endif #ifndef T5 !T5:data,executable-data,devonly,construct-independent,if,V:2.0-2.7       LOGICAL FUNCTION test5()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b, b_copy, c !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: devtest         LOGICAL :: dev = .TRUE.         LOGICAL :: cpu = .FALSE.         devtest(1) = 1          !$acc enter data copyin(devtest(1:1))         !$acc parallel           devtest(1) = 0         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          IF (devtest(1) .eq. 1) THEN           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 0            !$acc enter data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(cpu)           !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) + b(x)               END DO             !$acc end parallel           !$acc end data            DO x = 1, LOOPCOUNT             IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test5 = .FALSE.         ELSE           test5 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif #ifndef T4         LOGICAL :: test4 #endif #ifndef T5         LOGICAL :: test5 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif #ifndef T4         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test4()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 3           failed = .FALSE.         END IF #endif #ifndef T5         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test5()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 4           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update x minus expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *totals = new real_t[10];     real_t *totals_host = new real_t[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         totals[x] = 0;         totals_host[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%10] = totals[x%10] - (a[x] + b[x]);             }         }     }       for (int x = 0; x < n; ++x){         totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_host[x] - totals[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitand general", "completion": "#ifndef T1 !T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y, z !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         INTEGER :: b         REAL(8),DIMENSION(16 * LOOPCOUNT):: randoms         REAL(8) :: false_margin         INTEGER :: errors = 0         INTEGER :: temp = 1          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         false_margin = exp(log(.5)/n)         DO x = 1, LOOPCOUNT           DO y = 0, 15             IF (randoms(y * LOOPCOUNT + x) .lt. false_margin) THEN               temp = 1               DO z = 0, y                 temp = temp * 2               END DO               a(x) = a(x) + temp             END IF           END DO         END DO                  b = a(1)          !$acc data copyin(a(1:LOOPCOUNT))           !$acc parallel loop reduction(iand:b)           DO x = 1, LOOPCOUNT             b = iand(b, a(x))           END DO         !$acc end data           temp = a(1)         DO x = 2, LOOPCOUNT           temp = iand(a(x), temp)         END DO         IF (temp .ne. b) THEN           WRITE(*, *) temp           WRITE(*, *) b           errors = 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop reduction bitxor loop", "completion": "#ifndef T1 !T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(10*LOOPCOUNT):: a, b, b_copy !Data         REAL(8),DIMENSION(10*LOOPCOUNT):: randoms, randoms2         INTEGER,DIMENSION(10):: c         REAL*8 :: RAND         INTEGER :: errors = 0         INTEGER :: temp          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = FLOOR(randoms*1000000)         CALL RANDOM_NUMBER(randoms2)         b = FLOOR(randoms2*1000000)         b_copy = b         c = 0          !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10*LOOPCOUNT), c(1:10))           !$acc kernels loop gang private(temp)           DO x = 0, 9             temp = 0             !$acc loop worker reduction(ieor:temp)             DO y = 1, LOOPCOUNT               temp = ieor(temp, a(x * LOOPCOUNT + y))             END DO             c(x + 1) = temp             !$acc loop worker             DO y = 1, LOOPCOUNT               b(x * LOOPCOUNT + y) = b(x * LOOPCOUNT + y) + c(x + 1)             END DO           END DO         !$acc end data          DO x = 0, 9           temp = 0           DO y = 1, LOOPCOUNT             temp = ieor(temp, a(x * LOOPCOUNT + y))           END DO           IF (temp .ne. c(x + 1)) THEN             errors = errors + 1           END IF           DO y = 1, LOOPCOUNT             IF (b(x * LOOPCOUNT + y) .ne. b_copy(x * LOOPCOUNT + y) + c(x + 1)) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel default present", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,default,data,data-region,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = 0.0;     }     #pragma acc enter data copyin(a[0:n])     #pragma acc parallel default(present)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             a[x] = 1.0;         }     }     #pragma acc exit data copyout(a[0:n])      for (int x = 0; x < n; ++x){         if (fabs(a[x] - 1.0) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign rshift equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if ((a >> x) % 2 == 1){                 if (is_possible(passed_a, passed_b, length - 1,prev >> 1)){                     delete[] passed_b;                     return true;                 }             }             else{                 if (is_possible(passed_a, passed_b, length - 1, prev)){                     delete[] passed_b;                     return true;                 }             }         }     }     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1<<8;      for (int x = 0; x < n; ++x){         a[x] = 1<<8;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                         {                             c[x * 7 + y] = a[x];                             a[x] >>= 1;                         }                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<8){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign x plus expr", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, a[x] + prev)){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t *passed_ab = new real_t[10];     real_t *passed_c = new real_t[10];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x%(n/10 + 1)];                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] + (a[x] * b[x]);                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] += a[x] * b[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){             passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc delete finalize with len", "completion": "#ifndef T1 !T1:runtime,data,executable-data,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors         errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))         !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))          !$acc data copyout(c(1:LOOPCOUNT))           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_delete_finalize(a(1), LOOPCOUNT*8)         CALL acc_delete_finalize(b(1), LOOPCOUNT*8)          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,data,executable-data,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors         errors = 0          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_copyin(a(1:LOOPCOUNT))         CALL acc_copyin(a(1:LOOPCOUNT))         CALL acc_copyin(b(1:LOOPCOUNT))         CALL acc_copyin(b(1:LOOPCOUNT))          !$acc data copyout(c(1:LOOPCOUNT))           !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_delete_finalize(a(1), LOOPCOUNT*8)         CALL acc_delete_finalize(b(1), LOOPCOUNT*8)          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2**1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature atomic capture expr times x assign", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         REAL(8), INTENT(IN) :: init         REAL(8),DIMENSION(length), INTENT(IN) :: a         REAL(8),DIMENSION(length), INTENT(IN) :: b         REAL(8),DIMENSION(length - 1) :: passed_a         REAL(8),DIMENSION(length - 1) :: passed_b         REAL(8) :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (abs(b(x) - (init * a(x))) .GT. ((10 - length) * PRECISION)) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = b(x)             IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         REAL(8),DIMENSION(10):: passed_a, passed_b         REAL(8):: init         LOGICAL IS_POSSIBLE         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   totals(x) = a(x, y) * totals(x)                   b(x, y) = totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) * a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           init = 1           IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .TRUE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction max loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10 * n];     real_t * maximum = new real_t[10];     real_t temp = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);         c[x] = 0.0;     }     for (int x = 0; x < 10; ++x){         maximum[x] = 0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], maximum[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop worker reduction(max:temp)             for (int y = 0; y < n; ++y){                 temp = fmax(a[x * n + y] * b[x * n + y], temp);             }             maximum[x] = temp;             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 c[x * n + y] = (a[x * n + y] * b[x * n + y]) / maximum[x];             }         }     }     for (int x = 0; x < 10; ++x){         temp = 0;         for (int y = 0; y < n; ++y){             temp = fmax(temp, a[x * n + y] * b[x * n + y]);         }         if (fabs(temp - maximum[x]) > PRECISION){             err += 1;         }         for (int y = 0; y < n; ++y){             if (c[x * n + y] > 1){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature wait if devnum false", "completion": "#include \"acc_testsuite.h\"  using namespace std;  #ifndef T1 //T1:parallel,wait,async,V:2.7-3.2 int test1(){     int err = 0;     srand(time(NULL));     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     data_container<real_t> c = *(new data_container<real_t>(n));     data_container<real_t> d = *(new data_container<real_t>(n));     data_container<real_t> e = *(new data_container<real_t>(n));     data_container<real_t> f = *(new data_container<real_t>(n));     data_container<real_t> g = *(new data_container<real_t>(n));      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = rand() / (real_t)(RAND_MAX / 10); \tc.data[x] = 0.0;         d.data[x] = rand() / (real_t)(RAND_MAX / 10);         e.data[x] = rand() / (real_t)(RAND_MAX / 10); \tf.data[x] = 0.0; \tg.data[x] = 0.0;     }      #pragma acc data copyin(a,a.data[0:n], b, b.data[0:n], c, c.data[0:n], d, d.data[0:n], e, e.data[0:n], f, f.data[0:n],g, g.data[0:n])     {         #pragma acc parallel loop async(1)         for (int x = 0; x < n; ++x){             c.data[x] = a.data[x] + b.data[x];         }         #pragma acc parallel loop async(2)         for (int x = 0; x < n; ++x){             f.data[x] = d.data[x] + e.data[x];         }         #pragma acc parallel wait(1, 2) async(3)         for (int x = 0; x < n; ++x){             g.data[x] = c.data[x] + f.data[x];         }          \t#pragma acc update host(c.data[0:n]) wait(1) if(false) \t#pragma acc update host(f.data[0:n]) wait(2) if(false) \t#pragma acc update host(g.data[0:n]) wait(3) if(false)     }      for (int x = 0; x < n; ++x){         if (c.data[x] > PRECISION){             err++;         }         if (f.data[x] > PRECISION){ \t    err++; \t}         if (g.data[x] > PRECISION){             err++;       \t}     }      return err; } #endif #ifndef T2 //T2:parallel,wait,async,V:2.7-3.2 int test2(){     int err = 0;     srand(time(NULL));      real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     real_t * d = new real_t[n];     real_t * e = new real_t[n];     real_t * f = new real_t[n];     real_t * g = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;         g[x] = 0.0;     }     #pragma acc data copyin(a[0:n], b[0:n], c[0:n], d[0:n], e[0:n], f[0:n], g[0:n])     {         #pragma acc parallel loop async(1)         for (int x = 0; x < n; ++x){             c[x] = (a[x] + b[x]);         }         #pragma acc parallel loop async(2)         for (int x = 0; x < n; ++x){             f[x] = (d[x] + e[x]);         }         #pragma acc parallel loop wait(1, 2) async(3)         for (int x = 0; x < n; ++x){             g[x] = (c[x] + f[x]);         }         #pragma acc update host(c[0:n]) wait(1) if(false)         #pragma acc update host(f[0:n]) wait(2) if(false)         #pragma acc update host(g[0:n]) wait(3) if(false)     }      for (int x = 0; x < n; ++x){         if(c[x] > PRECISION){ \t    err++; \t}         if(f[x] > PRECISION){             err++;         }         if(g[x] > PRECISION){             err++;         }     }      delete[] a;     delete[] b;     delete[] c;     delete[] d;     delete[] e;     delete[] f;     delete[] g;      return err; } #endif #ifndef T3 //T3:parallel,wait,async,V:2.7-3.2 int test3(){     int err = 0;     srand(time(NULL));      real_t * a = new real_t[n];     real_t * b = new real_t[n];     data_container<real_t> c = *(new data_container<real_t>(n));     real_t * d = new real_t[n];     real_t * e = new real_t[n];     data_container<real_t> f = *(new data_container<real_t>(n));     data_container<real_t> g = *(new data_container<real_t>(n));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c.data[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f.data[x] = 0.0;         g.data[x] = 0.0;     }     #pragma acc data copyin(a[0:n], b[0:n], c, c.data[0:n], d[0:n], e[0:n], f, f.data[0:n], g, g.data[0:n])     {         #pragma acc parallel loop async(1)         for (int x = 0; x < n; ++x){             c.data[x] = (a[x] + b[x]);         }         #pragma acc parallel loop async(2)         for (int x = 0; x < n; ++x){             f.data[x] = (d[x] + e[x]);         }         #pragma acc parallel loop wait(1, 2) async(3)         for (int x = 0; x < n; ++x){             g.data[x] = (c.data[x] + f.data[x]);         }         #pragma acc update host(c.data[0:n]) wait(1) if(false)         #pragma acc update host(f.data[0:n]) wait(2) if(false)         #pragma acc update host(g.data[0:n]) wait(3) if(false)     }      for (int x = 0; x < n; ++x){         if(c.data[x] > PRECISION){             err++;         }         if(f.data[x] > PRECISION){             err++;         }         if(g.data[x] > PRECISION){             err++;         }     }      delete[] a;     delete[] b;     delete[] d;     delete[] e;      return err; } #endif #ifndef T4 //T4:parallel,wait,async,V:2.7-3.2 int test4(){     int err = 0;     srand(time(NULL));      data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     real_t * c  = new real_t[n];     data_container<real_t> d = *(new data_container<real_t>(n));     data_container<real_t> e = *(new data_container<real_t>(n));     real_t * f = new real_t[n];     real_t * g = new real_t[n];      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d.data[x] = rand() / (real_t)(RAND_MAX / 10);         e.data[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;         g[x] = 0.0;     }     #pragma acc data copyin(a,a.data[0:n],b,b.data[0:n],c[0:n],d,d.data[0:n],e,e.data[0:n], f[0:n], g[0:n])     {         #pragma acc parallel loop async(1)         for (int x = 0; x < n; ++x){             c[x] = (a.data[x] + b.data[x]);         }         #pragma acc parallel loop async(2)         for (int x = 0; x < n; ++x){             f[x] = (d.data[x] + e.data[x]);         }         #pragma acc parallel loop wait(1, 2) async(3)         for (int x = 0; x < n; ++x){             g[x] = (c[x] + f[x]);         }         #pragma acc update host(c[0:n]) wait(1) if(false)         #pragma acc update host(f[0:n]) wait(2) if(false)         #pragma acc update host(g[0:n]) wait(3) if(false)     }      for (int x = 0; x < n; ++x){         if (c[x] > PRECISION){             err++;         }         if (f[x] > PRECISION){             err++;         }         if (g[x] > PRECISION){             err++;         }     }      delete[] c;     delete[] f;     delete[] g;      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test1();     }     if(failed){ \tfailcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }     if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }     if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test4();     }     if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel if", "completion": "#ifndef T1 !T1:devonly,parallel,if,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         LOGICAL :: host = .FALSE.         LOGICAL :: device = .TRUE.         INTEGER,DIMENSION(1) :: dev_test         dev_test(1) = 0          !$acc enter data copyin(dev_test(1:1))         !$acc parallel present(dev_test(1:1))           dev_test(1) = 1         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc parallel if(host)           !$acc loop           DO x = 1, LOOPCOUNT             c(x) = a(x) + b(x)           END DO         !$acc end parallel          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:devonly,parallel,if,V:2.0-2.7       LOGICAL FUNCTION test2()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         LOGICAL :: host = .FALSE.         LOGICAL :: device = .TRUE.         INTEGER,DIMENSION(1) :: dev_test         dev_test(1) = 0          !$acc enter data copyin(dev_test(1:1))         !$acc parallel present(dev_test(1:1))           dev_test(1) = 1         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          IF (dev_test(1) .eq. 0) THEN           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = a + b            !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))           !$acc parallel if(host) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = c(x) + a(x) + b(x)             END DO           !$acc end parallel           !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))            DO x = 1, LOOPCOUNT             IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif #ifndef T3 !T3:devonly,parallel,if,V:2.0-2.7       LOGICAL FUNCTION test3()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0         LOGICAL :: host = .FALSE.         LOGICAL :: device = .TRUE.         INTEGER,DIMENSION(1) :: dev_test         dev_test(1) = 0          !$acc enter data copyin(dev_test(1:1))         !$acc parallel present(dev_test(1:1))           dev_test(1) = 1         !$acc end parallel          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = a + b         !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))         !$acc parallel if(device) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))           !$acc loop           DO x = 1, LOOPCOUNT             c(x) = c(x) + a(x) + b(x)           END DO         !$acc end parallel         !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)), copyout(c(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (2 * (a(x) + b(x)))) .gt. 2 * PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop reduction min general", "completion": "#include \"acc_testsuite.h\" #pragma acc routine (fmin) seq  #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t min = 1000.0;     int found = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:n], b[0:n]) copy(min)     {         #pragma acc kernels loop reduction(min:min)         for (int x = 0; x < n; ++x){             min = fmin(a[x] * b[x], min);         }     }      for (int x = 0; x < n; ++x){         if (fabs((a[x] * b[x]) - (min + PRECISION)) < 0){             err = 1;         }         if (fabs(min - (a[x] * b[x])) < PRECISION){             found = 1;         }     }     if (found == 0){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature wait if", "completion": "#include \"acc_testsuite.h\" /*  *if implimented on wait, but not init, set, nor shutdown */  #ifndef T1 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];     real_t *e = new real_t[n];     real_t *f = new real_t[n];      for (int x = 0; x < n; ++x){ \ta[x] = rand() / (real_t)(RAND_MAX / 10); \tb[x] = rand() / (real_t)(RAND_MAX / 10); \tc[x] = 0.0; \td[x] = rand() / (real_t)(RAND_MAX / 10); \te[x] = rand() / (real_t)(RAND_MAX / 10); \tf[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n]) create(c[0:n], f[0:n])     { \t#pragma acc parallel async(1) \t{ \t    #pragma acc loop \t    for (int x = 0; x < n; ++x){ \t\tc[x] = a[x] + b[x]; \t    } \t} \t#pragma acc parallel async(2) \t{ \t    #pragma acc loop \t    for (int x = 0; x < n; ++x){ \t\tf[x] = d[x] + e[x]; \t    } \t} \t#pragma acc update host(c[0:n], f[0:n]) wait(1, 2) if(true)     }          for (int x = 0; x < n; ++x){ \tif (abs(c[x] - (a[x] + b[x])) > PRECISION){ \t    err++; \t} \tif (abs(f[x] - (d[x] + e[x])) > PRECISION){ \t    err++; \t}     }      return err; } #endif #ifndef T2 int test2(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];     real_t *e = new real_t[n];     real_t *f = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n]) create(c[0:n], f[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         #pragma acc update host(c[0:n], f[0:n]) wait(1) if(true) \t#pragma acc update host(c[0:n], f[0:n]) wait(2) if(true)     }      for (int x = 0; x < n; ++x){         if (abs(c[x] - (a[x] + b[x])) > PRECISION){             err++;         }         if (abs(f[x] - (d[x] + e[x])) > PRECISION){             err++;         }     }      return err; } #endif #ifndef T3 int test3(){     int err = 0;     srand(time(NULL));     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];     real_t *e = new real_t[n];     real_t *f = new real_t[n];          for (int x = 0; x < n; ++x){ \ta[x] = rand() / (real_t)(RAND_MAX / 10); \tb[x] = rand() / (real_t)(RAND_MAX / 10); \tc[x] = 0.0; \td[x] = rand() / (real_t)(RAND_MAX / 10); \te[x] = rand() / (real_t)(RAND_MAX / 10); \tf[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n]) create(c[0:n], f[0:n])     { \t#pragma acc parallel async(1) \t{ \t    #pragma acc loop \t    for (int x = 0; x < n; ++x){ \t        c[x] = a[x] + b[x]; \t    }  \t} \t#pragma acc parallel async(2) \t{ \t    #pragma acc loop \t    for (int x = 0; x < n; ++x){ \t\tf[x] = d[x] + e[x]; \t    } \t} \t#pragma acc update host(c[0:n], f[0:n]) wait(1, 2) if(false)     }              for (int x = 0; x < n; ++x){ \tif (c[x] > PRECISION){ \t    err++; \t} \tif (f[x] > PRECISION){ \t    err++; \t}     }     return err; } #endif #ifndef T4 int test4(){     int err = 0;     srand(time(NULL));     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];     real_t *e = new real_t[n];     real_t *f = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n]) create(c[0:n], f[0:n])     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 f[x] = d[x] + e[x];             }         }         #pragma acc update host(c[0:n], f[0:n]) wait(1) if(false) \t#pragma acc update host(c[0:n], f[0:n]) wait(2) if(false)     }      for (int x = 0; x < n; ++x){         if (c[x] > PRECISION){             err++;         }         if (f[x] > PRECISION){             err++;         }     }     return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }     if (failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test2();     }     if (failed){ \tfailcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }     if (failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test4();     }     if (failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture expr or x assign", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         LOGICAL, INTENT(IN) :: init         LOGICAL,DIMENSION(length), INTENT(IN) :: a         LOGICAL,DIMENSION(length), INTENT(IN) :: b         LOGICAL,DIMENSION(length - 1) :: passed_a         LOGICAL,DIMENSION(length - 1) :: passed_b         LOGICAL :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (b(x) .eqv. (init .or. a(x))) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = b(x)             IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         LOGICAL,DIMENSION(10):: passed_a, passed_b         LOGICAL IS_POSSIBLE         LOGICAL:: init         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .933) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   totals(x) = a(x, y) .OR. totals(x)                   b(x, y) = totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .OR. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           init = .FALSE.           IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature init device num", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:init,runtime,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     int device_num = acc_get_device_num(acc_get_device_type());      #pragma acc init device_num(device_num)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data copyin no lower bound", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,data-region,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[:n], b[:n]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic ixor x expr", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .lt. .5) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           totals(x) = 0           totals_comparison(x) = 0         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic x divided expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic                   totals(x) = totals(x) / a(x, y)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) / a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture lshift equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if ((b[x] == prev<<1 && ((a>>x)%2)==1) || ((a>>x)%2==0 && b[x] == prev)){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_b);                 return true;             }         }     }     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1;      for (int x = 0; x < n; ++x){         a[x] = 1;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                             c[x * 7 + y] = a[x] <<= 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] >>= 1;             }         }         if (a[x] != 1){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture multiply equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] * prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t * passed_ab = new real_t[10];     real_t * passed_c = new real_t[10];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = totals[x%(n/10 + 1)] *= a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel copyin", "completion": "#ifndef T1 !T1:parallel,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b !Data         INTEGER :: errors = 0         INTEGER,DIMENSION(1):: hasDevice         hasDevice(1) = 1          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         a_copy = a         b = 0          !$acc enter data copyin(hasDevice(1:1))         !$acc parallel present(hasDevice(1:1))           hasDevice(1) = 0         !$acc end parallel           !$acc parallel copyin(a(1:LOOPCOUNT))           !$acc loop           DO x = 1, LOOPCOUNT             a(x) = 0.0           END DO          !$acc end parallel          DO x = 1, LOOPCOUNT           IF ((abs(a(x) - a_copy(x)) > PRECISION .AND. hasDevice(1) .eq. 1) .OR. (hasDevice(1) .eq. 0 .AND. abs(a(x)) > PRECISION)) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc memcpy from device async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];     real_t *e = new real_t[n];     real_t *f = new real_t[n];     real_t *hostdata = new real_t[6 * n];     real_t *hostdata_copy = new real_t[6 * n];      real_t *devdata;      for (int x = 0; x < n; ++x){         hostdata[x] = rand() / (real_t)(RAND_MAX / 10);         hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);         hostdata[2*n + x] = 1;         hostdata[3*n + x] = rand() / (real_t)(RAND_MAX / 10);         hostdata[4*n + x] = rand() / (real_t)(RAND_MAX / 10);         hostdata[5*n + x] = 2;     }      for (int x = 0; x < 6*n; ++x){         hostdata_copy[x] = hostdata[x];     }      devdata = reinterpret_cast<real_t*>(acc_copyin(hostdata, 6 * n * sizeof(real_t)));      #pragma acc data deviceptr(devdata)     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[x] = devdata[x] * devdata[x];             }         }         acc_memcpy_from_device_async(a, devdata, n * sizeof(real_t), 1);         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[n + x] = devdata[n + x] * devdata[n + x];             }         }         acc_memcpy_from_device_async(b, &(devdata[n]), n * sizeof(real_t), 2);         #pragma acc parallel async(4)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[3*n + x] = devdata[3*n + x] * devdata[3*n + x];             }         }         acc_memcpy_from_device_async(d, &(devdata[3*n]), n * sizeof(real_t), 4);         #pragma acc parallel async(5)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[4*n + x] = devdata[4*n + x] * devdata[4*n + x];             }         }         acc_memcpy_from_device_async(e, &(devdata[4*n]), n * sizeof(real_t), 5);         #pragma acc parallel async(3) wait(1, 2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[2*n + x] += devdata[x] + devdata[n + x];             }         }         acc_memcpy_from_device_async(c, &(devdata[2*n]), n * sizeof(real_t), 3);         #pragma acc parallel async(6) wait(4, 5)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[5*n + x] += devdata[3*n + x] + devdata[4*n + x];             }         }         acc_memcpy_from_device_async(f, &(devdata[5*n]), n * sizeof(real_t), 6);     }      #pragma acc wait(1)     for (int x = 0; x < n; ++x){         if (fabs(a[x] - hostdata_copy[x] * hostdata_copy[x]) > PRECISION){             err += 1;         }     }     #pragma acc wait(2)     for (int x = 0; x < n; ++x){         if (fabs(b[x] - hostdata_copy[n + x] * hostdata_copy[n + x]) > PRECISION){             err += 1;         }     }     #pragma acc wait(4)     for (int x = 0; x < n; ++x){         if (fabs(d[x] - hostdata_copy[3*n + x] * hostdata_copy[3*n + x]) > PRECISION){             err += 1;         }     }     #pragma acc wait(5)     for (int x = 0; x < n; ++x){         if (fabs(e[x] - hostdata_copy[4*n + x] * hostdata_copy[4*n + x]) > PRECISION){             err += 1;         }     }     #pragma acc wait(3)     for (int x = 0; x < n; ++x){         if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){             err += 1;         }     }     #pragma acc wait(6)     for (int x = 0; x < n; ++x){         if (fabs(f[x] - (2 + d[x] + e[x])) > PRECISION){             err += 1;         }     }      #pragma acc exit data delete(hostdata[0:6*n])      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop seq", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,combined-constructs,V:1.0-2.7 int test1(){   int err = 0;   srand(SEED);   real_t * a = new real_t[n];   real_t * b = new real_t[n];   real_t temp = 0.0;    for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = 0.0;   }    #pragma acc data copyin(a[0:n]) copy(b[0:n])   {       #pragma acc kernels loop seq       for (int x = 1; x < n; ++x){           b[x] = b[x-1] + a[x];       }   }    for (int x = 1; x < n; ++x){       temp += a[x];       if (fabs(b[x] - temp) > PRECISION){           err = 1;       }   }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction bitor vector loop", "completion": "#ifndef T1 !T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y, z !Iterators         INTEGER,DIMENSION(10 * LOOPCOUNT):: a !Data         INTEGER,DIMENSION(10) :: b         REAL(8) :: false_margin         REAL(8),DIMENSION(160 * LOOPCOUNT) :: randoms         INTEGER :: errors = 0         INTEGER :: temp          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         false_margin = exp(log(.5) / n)         DO x = 1, 10 * LOOPCOUNT           DO y = 1, 16             IF (randoms(y * 10 * LOOPCOUNT + y - 1) .gt. false_margin) THEN               temp = 1               DO z = 1, y                 temp = temp * 2               END DO               a(x) = a(x) + temp             END IF           END DO         END DO          !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10))           !$acc parallel loop private(temp)           DO x = 0, 9             temp = 0             !$acc loop vector reduction(ior:temp)             DO y = 1, LOOPCOUNT               temp = ior(temp, a(x * LOOPCOUNT + y))             END DO             b(x + 1) = temp           END DO         !$acc end data          DO x = 0, 9           temp = 0           DO y = 1, LOOPCOUNT             temp = ior(temp, a(x * LOOPCOUNT + y))           END DO           IF (temp .ne. b(x + 1)) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop reduction min loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10 * n];     real_t * minimum = new real_t[10];     real_t temp = 0;      for (int x = 0; x < 10 * n; ++x){         a[x] = 1 + rand() / (real_t)(RAND_MAX/10);         b[x] = 1 + rand() / (real_t)(RAND_MAX/10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], minimum[0:10])     {         #pragma acc kernels loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1000;             #pragma acc loop reduction(min:temp)             for (int y = 0; y < n; ++y){                 temp = fmin(a[x * n + y] * b[x * n + y], temp);             }             minimum[x] = temp;             #pragma acc loop             for (int y = 0; y < n; ++y){                 c[x * n + y] = (a[x * n + y] * b[x * n + y]) / minimum[x];             }         }     }      for (int x = 0; x < 10; ++x){         temp = 1000;         for (int y = 0; y < n; ++y){             temp = fmin(temp, a[x * n + y] * b[x * n + y]);         }         if (fabs(temp - minimum[x]) > PRECISION){             err += 1;         }         for (int y = 0; y < n; ++y){             if (fabs(c[x * n + y] - (a[x * n + y] * b[x * n + y] / minimum[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial default copy", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,data-region,default-mapping,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc serial         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:serial,data,data-region,default-mapping,devonly,V:2.6-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int * devtest = (int *)malloc(sizeof(real_t));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 1;         }          #pragma acc enter data copyin(c[0:n])         for (int x = 0; x < n; ++x){             c[x] = 0.0;         }         #pragma acc data copyin(a[0:n], b[0:n])         {             #pragma acc serial             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] += a[x] + b[x];                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(c[x]) > PRECISION){                 err += 1;             }         }          #pragma acc exit data copyout(c[0:n])          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture max x expr assign", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   REAL(8), INTENT(IN) :: init   REAL(8),DIMENSION(length), INTENT(IN) :: a   REAL(8),DIMENSION(length), INTENT(IN) :: b   REAL(8),DIMENSION(length - 1) :: passed_a   REAL(8),DIMENSION(length - 1) :: passed_b   REAL(8) :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (abs(b(x) - max(init, a(x))) .lt. (10 - length) * PRECISION) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = b(x)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y !Iterators   REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison   REAL(8),DIMENSION(10):: passed_a, passed_b   REAL(8):: init   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)    totals = 0   totals_comparison = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             totals(x) = max(totals(x), a(x, y))             b(x, y) = totals(x)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data   DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = max(totals_comparison(x), a(x, y))     END DO   END DO   DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NE. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 0     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc async test", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:async,runtime,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];     real_t *e = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = 0;     }      #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n]) async(1)     #pragma acc enter data copyin(d[0:n]) create(e[0:n]) async(2)     #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1) wait(2)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             e[x] = c[x] + d[x];         }     }     #pragma acc exit data copyout(e[0:n]) async(1)      while (!acc_async_test(1));     for (int x = 0; x < n; ++x){         if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:async,runtime,construct-independent,V:1.0-2.7 int test2(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];     real_t *e = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = 0;     }     #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[0:n]) copyout(e[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 e[x] = c[x] + d[x];             }         }         while (!acc_async_test(1));     }      for (int x = 0; x < n; ++x) {         if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {             err += 1;         }     }     return err; } #endif  #ifndef T3 //T3:async,runtime,construct-independent,V:2.5-2.7 int test3() {     int err = 0;     real_t* a = new real_t[n];     real_t* b = new real_t[n];     real_t* c = new real_t[n];     real_t* d = new real_t[n];     real_t* e = new real_t[n];     int async_val = acc_get_default_async();      for (int x = 0; x < n; ++x) {         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = 0;     }     #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[0:n]) copyout(e[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 c[x] = a[x] + b[x];             }         }         #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async         {             #pragma acc loop             for (int x = 0; x < n; ++x) {                 e[x] = c[x] + d[x];             }         }         while (!acc_async_test(async_val));     }      for (int x = 0; x < n; ++x) {         if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {             err += 1;         }     }     return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x) {         failed = failed + test3();     }     if (failed != 0) {         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture predecrement", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *c = new int[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = --distribution[(int) (a[x]*b[x]/10)];             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]--;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      bool found = false;     for (int x = 0; x < 10; ++x){         for (int y = 0; y > distribution[x]; --y){             for (int z = 0; z < n; ++z){                 if (c[z] == y - 1 && x == (int) (a[z] * b[z] / 10)){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction bitxor general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     unsigned int host_b;     unsigned int b = 0;      for (int x = 0; x < n; ++x){         a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);     }      #pragma acc data copyin(a[0:n])     {         #pragma acc serial loop reduction(^:b)         for (int x = 0; x < n; ++x){             b = b ^ a[x];         }     }      host_b = a[0];      for (int x = 1; x < n; ++x){         host_b = host_b ^ a[x];     }     if (b != host_b){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction or vector loop", "completion": "#ifndef T1 !T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         LOGICAL,DIMENSION(10*LOOPCOUNT):: a !Data         LOGICAL,DIMENSION(10) :: b         LOGICAL :: temp         REAL(8),DIMENSION(10*LOOPCOUNT):: randoms         REAL(8) :: false_margin = exp(log(.5) / 2)         INTEGER :: errors = 0          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)          !Initilization         DO x = 1, 10 * LOOPCOUNT           IF (randoms(x) > false_margin) THEN             a(x) = .TRUE.           ELSE             a(x) = .FALSE.           END IF         END DO          !$acc data copyin(a(1:10*LOOPCOUNT)), copy(b(1:10))           !$acc kernels loop private(temp)           DO x = 0, 9             temp = .FALSE.             !$acc loop vector reduction(.OR.:temp)             DO y = 1, LOOPCOUNT               temp = temp .OR. a(x * LOOPCOUNT + y)             END DO             b(x + 1) = temp           END DO         !$acc end data          DO x = 0, 9           temp = .FALSE.           DO y = 1, LOOPCOUNT             temp = temp .OR. a(x * LOOPCOUNT + y)           END DO           IF (temp .neqv. b(x + 1)) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update expr times x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = a(x, y) * totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) * a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update expr neqv x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = a(x, y) .NEQV. totals(x)               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture expr neqv x assign", "completion": "      RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)         INTEGER, INTENT(IN) :: length         LOGICAL, INTENT(IN) :: init         LOGICAL,DIMENSION(length), INTENT(IN) :: a         LOGICAL,DIMENSION(length), INTENT(IN) :: b         LOGICAL,DIMENSION(length - 1) :: passed_a         LOGICAL,DIMENSION(length - 1) :: passed_b         LOGICAL :: holder         LOGICAL :: POSSIBLE         INTEGER :: x, y          IF (length .eq. 0) THEN           POSSIBLE = .TRUE.           RETURN         END IF         POSSIBLE = .FALSE.          DO x = 1, length           IF (b(x) .eqv. (init .neqv. a(x))) THEN             DO y = 1, x - 1               passed_a(y) = a(y)               passed_b(y) = b(y)             END DO             DO y = x + 1, length               passed_a(y - 1) = a(y)               passed_b(y - 1) = b(y)             END DO             holder = b(x)             IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN               POSSIBLE = .TRUE.               RETURN             END IF           END IF         END DO       END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms         LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data         LOGICAL,DIMENSION(10):: passed_a, passed_b         LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison         LOGICAL IS_POSSIBLE         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         DO x = 1, LOOPCOUNT           DO y = 1, 10             IF (randoms(x, y) > .5) THEN               a(x, y) = .TRUE.             ELSE               a(x, y) = .FALSE.             END IF           END DO         END DO          totals = .FALSE.         totals_comparison = .FALSE.          !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic capture                   totals(x) = a(x, y) .NEQV. totals(x)                   b(x, y) = totals(x)                 !$acc end atomic               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NEQV. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          DO x = 1, LOOPCOUNT           DO y = 1, 10             passed_a(y) = a(x, y)             passed_b(y) = b(x, y)           END DO           IF (IS_POSSIBLE(passed_a, passed_b, 10, .FALSE.) .eqv. .FALSE.) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction min vector loop", "completion": "#ifndef T1 !T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y!Iterators         REAL(8),DIMENSION(10*LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(10):: minimum         REAL(8):: temp = 1000         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(minimum(1:10))           !$acc parallel loop gang private(temp)           DO x = 0, 9             temp = 1000             !$acc loop vector reduction(min:temp)             DO y = 1, LOOPCOUNT               temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))             END DO             minimum(x + 1) = temp           END DO         !$acc end data                  DO x = 0, 9           temp = 1000           DO y = 1, LOOPCOUNT             temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))           END DO           IF (abs(temp - minimum(x + 1)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign expr plus x", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, a[x] + prev)){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x%(n/10 + 1)];                     totals[x%(n/10 + 1)] = (a[x] * b[x]) + totals[x%(n/10 + 1)];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] += a[x] * b[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){             passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data wait", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:async,data,wait,V:3.2-3.3 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copy(a[0:n], b[0:n], c[0:n]) async(0)     {         #pragma acc parallel loop async(1) wait(0)         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }      #pragma acc wait(1) async(0)     }      #pragma acc data copy(a[0:n], b[0:n], c[0:n]) wait(0)     {         #pragma acc parallel loop         for (int x = 0; x < n; ++x){             c[x] += c[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1      failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature serial while loop", "completion": "#ifndef T1 !T1:reduction,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   REAL(8),DIMENSION(LOOPCOUNT, 10):: a   REAL(8):: avg   INTEGER:: errors, x, y    errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)    !$acc data copy(a(1:LOOPCOUNT, 1:10))     !$acc serial       !$acc loop       DO y = 1, 10         avg = 0         DO WHILE (avg .lt. 1000)           avg = 0           !$acc loop reduction(+:avg)           DO x = 1, LOOPCOUNT             a(x, y) = a(x, y) * 1.5             avg = avg + (a(x, y) / LOOPCOUNT)           END DO         END DO       END DO     !$acc end serial   !$acc end data    DO y = 1, 10     avg = 0     DO x = 1, LOOPCOUNT       avg = avg + (a(x, y) / LOOPCOUNT)     END DO     IF ((avg .lt. 1000) .or. (avg .gt. 1500)) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc get num devices", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,devonly,internal-control-values,syntactic,V:1.0-2.7 int test1(){     int err = 0;      if(acc_get_device_type() != acc_device_none && acc_get_num_devices(acc_get_device_type()) == 0){ //Can't have zero of current device type           err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels default copy", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data-region,default-mapping,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t c[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc kernels         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] += a[x] + b[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:kernels,data-region,default-mapping,reference-counting,devonly,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t c[n];     int * devtest = (int *)malloc(sizeof(real_t));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc kernels present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 1;         }          #pragma acc enter data copyin(c[0:n])         for (int x = 0; x < n; ++x){             c[x] = 0.0;         }         #pragma acc data copyin(a[0:n], b[0:n])         {             #pragma acc kernels             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] += a[x] + b[x];                 }             }         }          for (int x = 0; x < n; ++x){             if (fabs(c[x]) > PRECISION){                 err += 1;             }         }          #pragma acc exit data copyout(c[0:n])          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel reduction", "completion": "#ifndef T1 !T1:parallel,reduction,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         REAL(8) :: results = 0         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          !$acc data copyin(a(1:LOOPCOUNT))           !$acc parallel reduction(+:results)             !$acc loop             DO x = 1, LOOPCOUNT               results = results + a(x)             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           results = results - a(x)         END DO         IF (abs(results) .gt. PRECISION) THEN           errors = errors + 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature wait if devnum true", "completion": "#include \"acc_testsuite.h\"  using namespace std;  #ifndef T1 //T1:parallel,wait,async,V:2.7-3.2 int test1(){     int err = 0;     srand(time(NULL));     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     data_container<real_t> c = *(new data_container<real_t>(n));     data_container<real_t> d = *(new data_container<real_t>(n));     data_container<real_t> e = *(new data_container<real_t>(n));     data_container<real_t> f = *(new data_container<real_t>(n));     data_container<real_t> g = *(new data_container<real_t>(n));      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = rand() / (real_t)(RAND_MAX / 10); \tc.data[x] = 0.0;         d.data[x] = rand() / (real_t)(RAND_MAX / 10);         e.data[x] = rand() / (real_t)(RAND_MAX / 10); \tf.data[x] = 0.0; \tg.data[x] = 0.0;     }      #pragma acc data copyin(a,a.data[0:n], b, b.data[0:n], c, c.data[0:n], d, d.data[0:n], e, e.data[0:n], f, f.data[0:n],g, g.data[0:n])     {         #pragma acc parallel loop async(1)         for (int x = 0; x < n; ++x){             c.data[x] = a.data[x] + b.data[x];         }         #pragma acc parallel loop async(2)         for (int x = 0; x < n; ++x){             f.data[x] = d.data[x] + e.data[x];         }         #pragma acc parallel wait(1, 2) async(3)         for (int x = 0; x < n; ++x){             g.data[x] = c.data[x] + f.data[x];         }          \t#pragma acc update host(c.data[0:n]) wait(1) if(true) \t#pragma acc update host(f.data[0:n]) wait(2) if(true) \t#pragma acc update host(g.data[0:n]) wait(3) if(true)     }      for (int x = 0; x < n; ++x){         if (abs(c.data[x] - (a.data[x] + b.data[x])) > PRECISION){             err++;         }         if (abs(f.data[x] - (d.data[x] + e.data[x])) > PRECISION){ \t    err++; \t}         if (abs(g.data[x] - (c.data[x] + f.data[x])) > PRECISION){             err++;       \t}     }      return err; } #endif #ifndef T2 //T2:parallel,wait,async,V:2.7-3.2 int test2(){     int err = 0;     srand(time(NULL));      real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     real_t * d = new real_t[n];     real_t * e = new real_t[n];     real_t * f = new real_t[n];     real_t * g = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;         g[x] = 0.0;     }     #pragma acc data copyin(a[0:n], b[0:n], c[0:n], d[0:n], e[0:n], f[0:n], g[0:n])     {         #pragma acc parallel loop async(1)         for (int x = 0; x < n; ++x){             c[x] = (a[x] + b[x]);         }         #pragma acc parallel loop async(2)         for (int x = 0; x < n; ++x){             f[x] = (d[x] + e[x]);         }         #pragma acc parallel loop wait(1, 2) async(3)         for (int x = 0; x < n; ++x){             g[x] = (c[x] + f[x]);         }         #pragma acc update host(c[0:n]) wait(1) if(true)         #pragma acc update host(f[0:n]) wait(2) if(true)         #pragma acc update host(g[0:n]) wait(3) if(true)     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){ \t    err++; \t}         if (fabs(f[x] - (d[x] + e[x])) > PRECISION){             err++;         }         if (fabs(g[x] - (c[x] + f[x])) > PRECISION){             err++;         }     }      delete[] a;     delete[] b;     delete[] c;     delete[] d;     delete[] e;     delete[] f;     delete[] g;      return err; } #endif #ifndef T3 //T3:parallel,wait,async,V:2.7-3.2 int test3(){     int err = 0;     srand(time(NULL));      real_t * a = new real_t[n];     real_t * b = new real_t[n];     data_container<real_t> c = *(new data_container<real_t>(n));     real_t * d = new real_t[n];     real_t * e = new real_t[n];     data_container<real_t> f = *(new data_container<real_t>(n));     data_container<real_t> g = *(new data_container<real_t>(n));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c.data[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f.data[x] = 0.0;         g.data[x] = 0.0;     }     #pragma acc data copyin(a[0:n], b[0:n], c, c.data[0:n], d[0:n], e[0:n], f, f.data[0:n], g, g.data[0:n])     {         #pragma acc parallel loop async(1)         for (int x = 0; x < n; ++x){             c.data[x] = (a[x] + b[x]);         }         #pragma acc parallel loop async(2)         for (int x = 0; x < n; ++x){             f.data[x] = (d[x] + e[x]);         }         #pragma acc parallel loop wait(1, 2) async(3)         for (int x = 0; x < n; ++x){             g.data[x] = (c.data[x] + f.data[x]);         }         #pragma acc update host(c.data[0:n]) wait(1) if(true)         #pragma acc update host(f.data[0:n]) wait(2) if(true)         #pragma acc update host(g.data[0:n]) wait(3) if(true)     }      for (int x = 0; x < n; ++x){         if (fabs(c.data[x] - (a[x] + b[x])) > PRECISION){             err++;         }         if (fabs(f.data[x] - (d[x] + e[x])) > PRECISION){             err++;         }         if (fabs(g.data[x] - (c.data[x] + f.data[x])) > PRECISION){             err++;         }     }      delete[] a;     delete[] b;     delete[] d;     delete[] e;      return err; } #endif #ifndef T4 //T4:parallel,wait,async,V:2.7-3.2 int test4(){     int err = 0;     srand(time(NULL));      data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     real_t * c  = new real_t[n];     data_container<real_t> d = *(new data_container<real_t>(n));     data_container<real_t> e = *(new data_container<real_t>(n));     real_t * f = new real_t[n];     real_t * g = new real_t[n];      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d.data[x] = rand() / (real_t)(RAND_MAX / 10);         e.data[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;         g[x] = 0.0;     }     #pragma acc data copyin(a,a.data[0:n],b,b.data[0:n],c[0:n],d,d.data[0:n],e,e.data[0:n], f[0:n], g[0:n])     {         #pragma acc parallel loop async(1)         for (int x = 0; x < n; ++x){             c[x] = (a.data[x] + b.data[x]);         }         #pragma acc parallel loop async(2)         for (int x = 0; x < n; ++x){             f[x] = (d.data[x] + e.data[x]);         }         #pragma acc parallel loop wait(1, 2) async(3)         for (int x = 0; x < n; ++x){             g[x] = (c[x] + f[x]);         }         #pragma acc update host(c[0:n]) wait(1) if(true)         #pragma acc update host(f[0:n]) wait(2) if(true)         #pragma acc update host(g[0:n]) wait(3) if(true)     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a.data[x] + b.data[x])) > PRECISION){             err++;         }         if (fabs(f[x] - (d.data[x] + e.data[x])) > PRECISION){             err++;         }         if (fabs(g[x] - (c[x] + f[x])) > PRECISION){             err++;         }     }      delete[] c;     delete[] f;     delete[] g;      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test1();     }     if(failed){ \tfailcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }     if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }     if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test4();     }     if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data with changing subscript", "completion": "#ifndef T1 !T1:data,data_region,construct-independent,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, indexer !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          indexer = LOOPCOUNT         !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(1:indexer), b(1:indexer)) copyout(c(1:indexer))           !$acc parallel             !$acc loop             DO x = 1, indexer               c(x) = a(x) + b(x)             END DO             indexer = 1           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured postdecrement assign", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     int *c = (int *)malloc(n * sizeof(int));     int *distribution = (int *)malloc(10 * sizeof(int));     int *distribution_comparison = (int *)malloc(10 * sizeof(int));     bool found = false;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     (distribution[(int) (a[x]*b[x]/10)])--;                     c[x] = distribution[(int) (a[x]*b[x]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]--;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y > -distribution_comparison[x]; --y){             for (int z = 0; z < n; ++z){                 if (y - 1 == c[z] && x == (int) (a[x] * b[x] / 10)){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature shutdown device type num nvidia", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,shutdown,nonvalidating,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: device_num         INTEGER :: device_type         INTEGER :: errors = 0          device_type = acc_get_device_type()         device_num = acc_get_device_num(device_type)         !$acc shutdown device_type(nvidia) device_num(device_num)          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM shutdown_device_type_num         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign x bitand expr", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = (int *)malloc((length - 1) * sizeof(int));     int *passed_b = (int *)malloc((length - 1) * sizeof(int));     for (int x = 0; x < length; ++x){         if (b[x] == prev){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, prev & a[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = (int *)malloc(n * sizeof(int));     int *b = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));     int *temp_a = (int *)malloc(10 * sizeof(int));     int *temp_b = (int *)malloc(10 * sizeof(int));     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         b[x] = totals[x/10];                         totals[x/10] = totals[x/10] & a[x];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] &= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction min vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * min = new real_t[10];     real_t temp = 100;     real_t temp_min;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(min[0:10])     {         #pragma acc kernels loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 100;             #pragma acc loop vector reduction(min:temp)             for (int y = 0; y < n; ++y){                 temp = fmin(a[x * n + y] * b[x * n + y], temp);             }             min[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         temp_min = 100;         for (int y = 0; y < n; ++y){             if (temp_min > a[x * n + y] * b[x * n + y]){                 temp_min = a[x * n + y] * b[x * n + y];             }         }         if (fabs(temp_min - min[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture expr multiply x", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] * prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     c[x] = totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc deviceptr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *a_ptr;     real_t *b_ptr;     real_t *c_ptr;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])      a_ptr = acc_deviceptr(a);     b_ptr = acc_deviceptr(b);     c_ptr = acc_deviceptr(c);      #pragma acc data deviceptr(a_ptr, b_ptr, c_ptr)     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c_ptr[x] = a_ptr[x] + b_ptr[x];             }         }     }      #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic rshift equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1<<7;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic                             a[x] >>= 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<7){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc set default async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,async,construct-independent,set,V:2.5-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *a_host = (real_t *)malloc(n * sizeof(real_t));     real_t *b_host = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         a_host[x] = a[x];         b_host[x] = b[x];     }      #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])     {         acc_set_default_async(1);         #pragma acc parallel async         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 a[x] = a[x] * a[x];             }         }         acc_set_default_async(2);         #pragma acc parallel async         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = b[x] * b[x];             }         }         #pragma acc parallel async(1) wait(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }         #pragma acc wait(1)     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4*PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop worker blocking", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t multiplyer = 1;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])     {       #pragma acc parallel       {         #pragma acc loop worker         for (int x = 0; x < n; ++x){           c[x] = (a[x] + b[x]) * multiplyer;         }         multiplyer += 1;         #pragma acc loop worker         for (int x = 0; x < n; ++x){           c[x] += (a[x] + b[x]) * multiplyer;         }       }     }      for (int x = 0; x < n; ++x){       if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){         err + 1;         break;       }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc copyout", "completion": "#ifndef T1 !T1:runtime,data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_create(c(1:LOOPCOUNT))          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_copyout(c(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END FUNCTION #endif  #ifndef T2 !T2:runtime,data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c         INTEGER :: errors = 0          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data create(c(1:LOOPCOUNT))          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_copyout(c(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif  #ifndef T3 !T3:runtime,data,executable-data,construct-independent,devonly,reference-counting,V:2.5-2.7       LOGICAL FUNCTION test3()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c         INTEGER :: errors = 0         LOGICAL,DIMENSION(1):: devtest          devtest(1) = .TRUE.         !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = .FALSE.         !$acc end parallel          IF (devtest(1) .eqv. .TRUE.) THEN           SEEDDIM(1) = 1 #         ifdef SEED           SEEDDIM(1) = SEED #         endif           CALL RANDOM_SEED(PUT=SEEDDIM)           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 0            !$acc enter data copyin(c(1:LOOPCOUNT))           !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) + b(x)               END DO             !$acc end parallel             CALL acc_copyout(c(1:LOOPCOUNT))           !$acc end data            DO x = 1, LOOPCOUNT             IF (abs(c(x)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test3 = .FALSE.         ELSE           test3 = .TRUE.         END IF       END #endif  #ifndef T4 !T4:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7       LOGICAL FUNCTION test4()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c         INTEGER :: errors = 0          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data create(c(1:LOOPCOUNT))         !$acc enter data create(c(1:LOOPCOUNT))         !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data         !$acc exit data delete(c(1:LOOPCOUNT))         CALL acc_copyout(c(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test4 = .FALSE.         ELSE           test4 = .TRUE.         END IF       END #endif  #ifndef T5 !T5:runtime,data,executable-data,construct-independent,reference-counting,devonly,V:2.5-2.7       LOGICAL FUNCTION test5()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c         INTEGER :: errors = 0         LOGICAL,DIMENSION(1):: devtest         devtest(1) = .TRUE.          !$acc enter data copyin(devtest(1:1))         !$acc parallel present(devtest(1:1))           devtest(1) = .FALSE.         !$acc end parallel          IF (devtest(1) .eqv. .TRUE.) THEN           SEEDDIM(1) = 1 #         ifdef SEED           SEEDDIM(1) = SEED #         endif           CALL RANDOM_SEED(PUT=SEEDDIM)           CALL RANDOM_NUMBER(a)           CALL RANDOM_NUMBER(b)           c = 0            !$acc enter data create(c(1:LOOPCOUNT))           !$acc enter data create(c(1:LOOPCOUNT))           !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))             !$acc parallel               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) + b(x)               END DO             !$acc end parallel           !$acc end data           CALL acc_copyout(c(1:LOOPCOUNT))           !$acc exit data delete(c(1:LOOPCOUNT))            DO x = 1, LOOPCOUNT             IF (abs(c(x)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END IF          IF (errors .eq. 0) THEN           test5 = .FALSE.         ELSE           test5 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif #ifndef T3         LOGICAL :: test3 #endif #ifndef T4         LOGICAL :: test4 #endif #ifndef T5         LOGICAL :: test5 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif #ifndef T3         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test3()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 2           failed = .FALSE.         END IF #endif #ifndef T4         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test4()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 3           failed = .FALSE.         END IF #endif #ifndef T5         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test5()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 4           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)         END PROGRAM  "}
{"prompt": "Create a test for the feature atomic max expr x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured postdecrement assign", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int *c = new int[n];     int *distribution = new int[10];     int *distribution_comparison = new int[10];     bool found = false;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < 10; ++x){         distribution[x] = 0;         distribution_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     (distribution[(int) (a[x]*b[x]/10)])--;                     c[x] = distribution[(int) (a[x]*b[x]/10)];                 }             }         }     }      for (int x = 0; x < n; ++x){         distribution_comparison[(int) (a[x]*b[x]/10)]--;     }     for (int x = 0; x < 10; ++x){         if (distribution_comparison[x] != distribution[x]){             err += 1;             break;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y > -distribution_comparison[x]; --y){             for (int z = 0; z < n; ++z){                 if (y - 1 == c[z] && x == (int) (a[x] * b[x] / 10)){                     found = true;                     break;                 }             }             if (!found){                 err++;             }             found = false;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature declare function scope present", "completion": "#include \"acc_testsuite.h\" void present(real_t *a, real_t *b, real_t *c, real_t *d){     #pragma acc declare present(c[0:n])     #pragma acc parallel present(a[0:n], b[0:n], d[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = c[x] + a[x] + b[x];         }         #pragma acc loop         for (int x = 0; x < n; ++x){             d[x] = c[x] * a[x];         }     } }  #ifndef T1 //T1:declare,present,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     real_t ** d = (real_t **)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];         b[x] = new real_t[n];         c[x] = new real_t[n];         d[x] = new real_t[n];         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 1;             d[x][y] = 0;         }     }      #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copyout(d[0:n][0:n])     {         for (int x = 0; x < n; ++x){             #pragma acc data copy(c[x:1][0:n])             {                 present(a[x], b[x], c[x], d[x]);             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){                 err += 1;             }             if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:declare,present,devonly,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     real_t ** d = (real_t **)malloc(n * sizeof(real_t));     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 a[x][y] = rand() / (real_t)(RAND_MAX / 10);                 b[x][y] = rand() / (real_t)(RAND_MAX / 10);                 c[x][y] = 3;             }         }          #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])         {             for (int x = 0; x < n; ++x){                 #pragma acc data copyin(c[x:1][0:n]) copyout(d[x:1][0:n])                 {                     present(a[x], b[x], c[x], d[x]);                 }                 for (int y = 0; y < n; ++y){                     if (fabs(c[x][y] - 3) > PRECISION){                         err += 1;                     }                 }                 for (int y = 0; y < n; ++y){                     if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 2){                         err += 1;                     }                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial switch", "completion": "#ifndef T1 !T1:,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER,DIMENSION(LOOPCOUNT):: a   REAL(8),DIMENSION(LOOPCOUNT):: a_randoms, b, b_host, c   INTEGER:: errors, x    errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a_randoms)   CALL RANDOM_NUMBER(b)   c = 0   b_host = b    DO x = 1, LOOPCOUNT     a(x) = INT(a_randoms(x) * 4)   END DO    !$acc data copyin(a(1:LOOPCOUNT)) copy(b(1:LOOPCOUNT), c(1:LOOPCOUNT))     !$acc serial       !$acc loop       DO x = 1, LOOPCOUNT         SELECT CASE(a(x))         CASE (0)           c(x) = b(x) * b(x)         CASE (1)           c(x) = b(x) / b(x)         CASE (2)           b(x) = b(x) / 2         CASE DEFAULT           c(x) = a(x) + b(x)         END SELECT       END DO     !$acc end serial   !$acc end data    DO x = 1, LOOPCOUNT     SELECT CASE(a(x))     CASE(0)       IF (abs(c(x) - (b_host(x) * b_host(x))) .gt. PRECISION) THEN         errors = errors + 1       END IF     CASE(1)       IF (abs(c(x) - 1) .gt. PRECISION) THEN         errors = errors + 1       END IF     CASE(2)       IF (abs(c(x)) .gt. PRECISION) THEN         errors = errors + 1       END IF       IF (abs(b(x) - (b_host(x) / 2)) .gt. PRECISION) THEN         errors = errors + 1       END IF     CASE DEFAULT       IF (abs(c(x) - (b_host(x) + a(x))) .gt. PRECISION) THEN         errors = errors + 1       END IF     END SELECT   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature shutdown device num", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:shutdown,runtime,syntactic,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     int device_num;      device_num = acc_get_device_num(acc_get_device_type());     #pragma acc shutdown device_num(device_num)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature declare function scope present", "completion": "#include \"acc_testsuite.h\" void present(real_t *a, real_t *b, real_t *c, real_t *d){     #pragma acc declare present(c[0:n])     #pragma acc parallel present(a[0:n], b[0:n], d[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = c[x] + a[x] + b[x];         }         #pragma acc loop         for (int x = 0; x < n; ++x){             d[x] = c[x] * a[x];         }     } }  #ifndef T1 //T1:declare,present,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     real_t ** d = (real_t **)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));         b[x] = (real_t *)malloc(n * sizeof(real_t));         c[x] = (real_t *)malloc(n * sizeof(real_t));         d[x] = (real_t *)malloc(n * sizeof(real_t));         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 1;             d[x][y] = 0;         }     }      #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copyout(d[0:n][0:n])     {         for (int x = 0; x < n; ++x){             #pragma acc data copy(c[x:1][0:n])             {                 present(a[x], b[x], c[x], d[x]);             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){                 err += 1;             }             if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:declare,present,devonly,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     real_t ** d = (real_t **)malloc(n * sizeof(real_t));     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 a[x][y] = rand() / (real_t)(RAND_MAX / 10);                 b[x][y] = rand() / (real_t)(RAND_MAX / 10);                 c[x][y] = 3;             }         }          #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])         {             for (int x = 0; x < n; ++x){                 #pragma acc data copyin(c[x:1][0:n]) copyout(d[x:1][0:n])                 {                     present(a[x], b[x], c[x], d[x]);                 }                 for (int y = 0; y < n; ++y){                     if (fabs(c[x][y] - 3) > PRECISION){                         err += 1;                     }                 }                 for (int y = 0; y < n; ++y){                     if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 2){                         err += 1;                     }                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic ixor expr x end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms         INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(randoms)         a = 0         DO x = 1, LOOPCOUNT           DO y = 1, 8             IF (randoms(x, y) .lt. .5) THEN               a(x) = a(x) + ISHFT(1, y - 1)             END IF           END DO         END DO         totals = 0         totals_comparison = 0         DO x = 1, LOOPCOUNT/10 + 1           totals(x) = 0           totals_comparison(x) = 0         END DO          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial copy", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,data,data-region,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * a_host = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         a_host[x] = a[x];     }      #pragma acc serial copy(a[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             a[x] = 2 * a[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - (2 * a_host[x])) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction multiply general", "completion": "#ifndef T1 !T1:serial,reduction,combined-constructs,loop,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   REAL(8),DIMENSION(10):: a, b   REAL(8):: reduced, host_reduced   INTEGER:: errors, x, y    errors = 0   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    DO y = 1, LOOPCOUNT     CALL RANDOM_NUMBER(a)     CALL RANDOM_NUMBER(b)     reduced = 1     host_reduced = 1      DO x = 1, 10       host_reduced = host_reduced * (a(x) + b(x))     END DO      !$acc data copyin(a(1:10), b(1:10))       !$acc serial loop reduction(*:reduced)       DO x = 1, 10         reduced = reduced * (a(x) + b(x))       END DO     !$acc end data      IF (abs(host_reduced - reduced) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic update rshift equals", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));      for (int x = 0; x < n; ++x){         a[x] = 1<<7;         for (int y = 0; y < 7; ++y){             if ((rand()/(unsigned int) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic update                             a[x] >>= 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<7){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop tile", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,tile,reduction,combined-constructs,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));     real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));     real_t temp = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = rand() / (real_t)(RAND_MAX / 10);     }     #pragma acc data copy(a[0:n], b[0:n], c[0:n], d2[0:n*n])     {         #pragma acc parallel loop tile(*, *) reduction(+:temp)         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 temp = 0;                 for (int z = 0; z < n; ++z){                     temp += a[x] + b[y] + c[z];                 }                 d2[x * n + y] = temp;             }         }     }     for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             temp = 0.0;             for (int z = 0; z < n; ++z){                 temp += a[x] + b[y] + c[z];             }             if (fabs(temp - d2[x * n + y]) > PRECISION * n){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,loop,tile,combined-constructs,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));     real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));     real_t temp = 0.0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d3[0:n*n*n])     {         #pragma acc parallel loop tile(2, 4, 8)         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 for (int z = 0; z < n; ++z){                     d3[(n * n * x) + (n * y) + z] = a[x] + b[x] + c[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             for (int z = 0; z < n; ++z){                 if (fabs(d3[(n * n * x) + (n * y) + z] - a[x] - b[x] - c[x]) > PRECISION * 2){                     err = 1;                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc update self", "completion": "#ifndef T1 !T1:runtime,data,executable-data,construct-independent,update,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel           CALL acc_update_self(c(1:LOOPCOUNT))         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif #ifndef T2 !T2:runtime,data,executable-data,construct-independent,update,V:2.0-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               a(x) = a(x) * a(x)             END DO           !$acc end parallel           CALL acc_update_self(a(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               b(x) = b(x) * b(x)             END DO           !$acc end parallel           CALL acc_update_self(b(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction min loop", "completion": "#ifndef T1 !T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c !Data         REAL(8),DIMENSION(10):: minimum         REAL(8):: temp         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         a = a + 1         b = b + 1          !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT)) copy(minimum(1:10))           !$acc parallel loop gang private(temp)           DO x = 0, 9             temp = 1000             !$acc loop worker reduction(min:temp)             DO y = 1, LOOPCOUNT               temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))             END DO             minimum(x + 1) = temp             !$acc loop             DO y = 1, LOOPCOUNT               c(x * LOOPCOUNT + y) = (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y)) / minimum(x + 1)             END DO           END DO         !$acc end data          DO x = 0, 9           temp = 1000           DO y = 1, LOOPCOUNT             temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))           END DO           IF (abs(temp - minimum(x + 1)) .gt. PRECISION) THEN             errors = errors + 1           END IF           DO y = 1, LOOPCOUNT             IF (abs(c(x * LOOPCOUNT + y) - (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y) / temp)) .gt. PRECISION) THEN               errors = errors + 1             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature parallel loop reduction multiply loop", "completion": "#ifndef T1 !T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10*LOOPCOUNT):: a, b, c !Data         REAL(8),DIMENSION(10):: totals         REAL(8) :: temp         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         a = (999.4 + a) / 2000         b = (999.4 + b) / 2000          !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT), totals(1:10))           !$acc parallel loop gang private(temp)           DO x = 0, 9             temp = 1             !$acc loop worker reduction(*:temp)             DO y = 1, LOOPCOUNT               temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))             END DO             totals(x + 1) = temp             !$acc loop worker             DO y = 1, LOOPCOUNT               c(x * LOOPCOUNT + y) = (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)) / totals(x + 1)             END DO           END DO         !$acc end data          DO x = 0, 9           temp = 1           DO y = 1, LOOPCOUNT             temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))           END DO           IF (abs(temp - totals(x + 1)) .gt. ((temp / 2) + (totals(x + 1) / 2)) * PRECISION) THEN             errors = errors + 1             WRITE(*, *) temp             WRITE(*, *) totals(x + 1)             WRITE(*, *) \" \"           END IF           DO y = 1, LOOPCOUNT              IF (abs(c(x * LOOPCOUNT + y) - ((a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)) / totals(x + 1))) .gt. c(x * LOOPCOUNT + y) * PRECISION) THEN               errors = errors + 1               WRITE(*, *) c(x * LOOPCOUNT + y)               WRITE(*, *) a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)               WRITE(*, *) \" \"             END IF           END DO         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured assign plus equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, a[x] + prev)){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x%(n/10 + 1)];                     totals[x%(n/10 + 1)] += a[x] * b[x];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] += a[x] * b[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){             passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine seq", "completion": "#include \"acc_testsuite.h\" void test_routine_seq_loop_named(real_t ** a, real_t * b, long long n); void test_routine_seq_seq_named(real_t ** a, real_t * b, long long n);  #pragma acc routine(test_routine_seq_loop_named) seq #pragma acc routine(test_routine_seq_seq_named) seq  #pragma acc routine seq real_t called_function_seq(real_t **a, int x, long long n){     real_t returned = 0;     #pragma acc loop seq reduction(+:returned)     for (int y = 0; y < n; ++y){         returned += a[x][y];     }     return returned; }  #pragma acc routine seq void test_routine_seq_loop_unnamed(real_t ** a, real_t * b, long long n){     #pragma acc loop seq     for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             b[x] += a[x][y];         }     } }  #pragma acc routine seq void test_routine_seq_seq_unnamed(real_t ** a, real_t *b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_seq(a, x, n);     } }  void test_routine_seq_loop_named(real_t ** a, real_t * b, long long n){     #pragma acc loop seq     for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             b[x] += a[x][y];         }     } }  void test_routine_seq_seq_named(real_t ** a, real_t * b, long long n){     for (int x = 0; x < n; ++x){         b[x] = called_function_seq(a, x, n);     } }  bool validate_data(real_t ** a, real_t * b){     real_t local_total;     for (int x = 0; x < n; ++x){         local_total = 0;         for (int y = 0; y < n; ++y){             local_total += a[x][y];         }         if (fabs(b[x] - local_total) > PRECISION){             return true;         }     }     return false; }  #ifndef T1 //T1:routine,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {               test_routine_seq_loop_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T2 //T2:routine,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_seq_loop_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T3 //T3:routine,construct-independent,V:2.0-2.7 int test3(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_seq_seq_unnamed(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  #ifndef T4 //T4:routine,construct-independent,V:2.0-2.7 int test4(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t *));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = (real_t *)malloc(n * sizeof(real_t));     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);         }         b[x] = 0;     }      #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])     {         #pragma acc parallel         {             test_routine_seq_seq_named(a, b, n);         }     }      if (validate_data(a, b)){         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic min expr list x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial wait", "completion": "#ifndef T1 !T1:async,serial,update,V:2.6-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy   INTEGER:: errors, x    errors = 0    SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(a)   a_copy = a    !$acc enter data create(a(1:LOOPCOUNT))   !$acc update device(a(1:LOOPCOUNT)) async(1)   !$acc serial present(a(1:lOOPCOUNT)) wait(1)     !$acc loop     DO x = 1, LOOPCOUNT       a(x) = a(x) + 1     END DO   !$acc end serial   !$acc exit data copyout(a(1:LOOPCOUNT))    DO x = 1, LOOPCOUNT     IF (abs(a(x) - (a_copy(x) + 1)) .gt. PRECISION) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop reduction bitor general", "completion": "#ifndef T1 !T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y, z !Iterators         INTEGER,DIMENSION(LOOPCOUNT):: a !Data         REAL(8) :: false_margin         REAL(8),DIMENSION(16*LOOPCOUNT):: random         INTEGER :: errors = 0         INTEGER :: temp         INTEGER :: b          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(random)         false_margin = exp(log(.5)/n)         DO x = 1, LOOPCOUNT           DO y = 1, 16             IF (random((y - 1) * LOOPCOUNT + x) < false_margin) THEN               temp = 1               DO z = 1, y                 temp = temp * 2               END DO               a(x) = a(x) + temp             END IF           END DO         END DO         b = a(1)         !$acc data copyin(a(1:LOOPCOUNT))           !$acc kernels loop reduction(ior:b)           DO x = 2, LOOPCOUNT             b = ior(b, a(x))           END DO         !$acc end data         temp = a(1)         DO x = 2, LOOPCOUNT           temp = ior(temp, a(x))         END DO         IF (temp .ne. b) THEN           errors = errors + 1         END IF          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature loop collapse", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:loop,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10 * n];      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }     for (int x = 0; x < 10; ++x){         c[x * n] = a[x * n] + b[x * n];     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n])     {         #pragma acc parallel         {             #pragma acc loop independent collapse(1)             for (int x = 0; x < 10; ++x){                 for (int y = 1; y < n; ++y){                     c[x * n + y] = c[x * n + y - 1] + a[x * n + y] + b[x * n + y];                 }             }         }     }      real_t total;     for (int x = 0; x < 10; ++x){         total = 0;         for (int y = 0; y < n; ++y){             total += a[x * n + y] + b[x * n + y];             if (fabs(c[x * n + y] - total) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:loop,syntactic,construct-independent,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = new real_t[10 * n];     real_t * b = new real_t[10 * n];     real_t * c = new real_t[10 * n];      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10*n])     {         #pragma acc parallel         {             #pragma acc loop independent collapse(2)             for (int x = 0; x < 10; ++x){                 for (int y = 0; y < n; ++y){                     c[x * n + y] = a[x * n + y] + b[x * n + y];                 }             }         }     }      for (int x = 0; x < 10 * n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update expr bitxor x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .5){                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] ^= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature data with derived type", "completion": "#ifndef T1 !T1:data,data_region,construct-independent,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         TYPE multi_item           REAL(8) :: a           REAL(8) :: b           REAL(8) :: c         END TYPE multi_item         INTEGER :: x !Iterators         TYPE (multi_item),DIMENSION(LOOPCOUNT):: a !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          DO x = 1, LOOPCOUNT           CALL RANDOM_NUMBER(a(x)%a)           CALL RANDOM_NUMBER(a(x)%b)           a(x)%c = 0.0         END DO          !$acc data copy(a(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               a(x)%c = a(x)%a + a(x)%b             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           IF (abs(a(x)%c - (a(x)%a + a(x)%b)) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature serial loop reduction add vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * c = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 0.0;      for(int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0.0;             #pragma acc loop vector reduction(+:temp)             for (int y = 0; y < n; ++y){                 temp += a[(x * n) + y] + b[(x * n) + y];             }             c[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             c[x] -= a[(x * n) + y] + b[(x * n) + y];         }         if (fabs(c[x]) > PRECISION * (2 * n - 1)){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update expr multiply x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernel implicit data attributes", "completion": "#include \"acc_testsuite.h\"  #ifndef T1 int test1(){ \tint err = 0; \tsrand(SEED); \tint temp = rand()/ (real_t)(RAND_MAX / 10);  \t#pragma acc kernels \tfor ( int x = 0; x < n; ++x){ \t\ttemp += temp; \t}  \tif(temp > PRECISION){ \t\terr = 1; \t} \treturn err; } #endif #ifndef T2 int test2(){ \tint err = 0; \tsrand(SEED);  \treal_t *test_array = new real_t[n]; \treal_t *host_array = new real_t[n];  \tfor( int x = 0; x < n; ++x){ \t\ttest_array[x] = rand()/(real_t)(RAND_MAX/ 10); \t\thost_array[x] = test_array[x]; \t}  \t#pragma acc kernels \tfor(int x = 0; x < n; ++x){ \t\ttest_array[x] += test_array[x]; \t}  \tfor(int x = 0; x < n; ++x){                 if(fabs(host_array[x]*2 - test_array[x]) > PRECISION){ \t\t\terr = 1;                 }         }  \treturn err; } #endif  int main(){ \tint failcode = 0; \tint failed; #ifndef T1 \tfailed = 0; \tfor(int x = 0; x < NUM_TEST_CALLS; ++x){ \t\tfailed += test1(); \t} \tif(failed){ \t\tfailcode += ( 1 << 0); \t} #endif #ifndef T2         failed = 0;         for(int x = 0; x < NUM_TEST_CALLS; ++x){                 failed += test2();         }         if(failed != 0){                 failcode += ( 1 << 1);         } #endif \treturn failcode; } "}
{"prompt": "Create a test for the feature atomic capture max x expr list assign", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, c, length, init) RESULT(POSSIBLE) INTEGER, INTENT(IN) :: length REAL(8), INTENT(IN) :: init REAL(8),DIMENSION(length), INTENT(IN) :: a REAL(8),DIMENSION(length), INTENT(IN) :: b REAL(8),DIMENSION(length), INTENT(IN) :: c REAL(8),DIMENSION(length - 1) :: passed_a REAL(8),DIMENSION(length - 1) :: passed_b REAL(8),DIMENSION(length - 1) :: passed_c REAL(8) :: holder LOGICAL :: POSSIBLE INTEGER :: x, y  IF (length .eq. 0) THEN   POSSIBLE = .TRUE.   RETURN END IF POSSIBLE = .FALSE.  DO x = 1, length   IF (abs(c(x) - max(init, a(x), b(x))) .lt. ((10 - length) * PRECISION)) THEN     DO y = 1, x - 1       passed_a(y) = a(y)       passed_b(y) = b(y)     END DO     DO y = x + 1, length       passed_a(y - 1) = a(y)       passed_b(y - 1) = b(y)     END DO     holder = c(x)     IF (IS_POSSIBLE(passed_a, passed_b, passed_c, length - 1, holder)) THEN       POSSIBLE = .TRUE.       RETURN     END IF   END IF END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1() IMPLICIT NONE INCLUDE \"acc_testsuite.Fh\" INTEGER :: x, y !Iterators REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c REAL(8):: init LOGICAL IS_POSSIBLE INTEGER :: errors = 0  !Initilization SEEDDIM(1) = 1 #ifdef SEED SEEDDIM(1) = SEED #endif CALL RANDOM_SEED(PUT=SEEDDIM)  CALL RANDOM_NUMBER(a) CALL RANDOM_NUMBER(b)  totals = 0 totals_comparison = 0  !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))   !$acc parallel     !$acc loop     DO x = 1, LOOPCOUNT       DO y = 1, 10         !$acc atomic capture           totals(x) = max(totals(x), a(x, y), b(x, y))           c(x, y) = totals(x)         !$acc end atomic       END DO     END DO   !$acc end parallel !$acc end data DO x = 1, LOOPCOUNT   DO y = 1, 10     totals_comparison(x) = max(totals_comparison(x), a(x, y), b(x, y))   END DO END DO DO x = 1, LOOPCOUNT   IF (totals_comparison(x) .NE. totals(x)) THEN     errors = errors + 1     WRITE(*, *) totals_comparison(x)   END IF END DO  DO x = 1, LOOPCOUNT   DO y = 1, 10     passed_a(y) = a(x, y)     passed_b(y) = b(x, y)     passed_c(y) = c(x, y)   END DO   init = 0   IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN     errors = errors + 1   END IF END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured plus equals assign", "completion": "#include \"acc_testsuite.h\"  bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] + prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t *passed_ab = new real_t[10];     real_t *passed_c = new real_t[10];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x%(n/10 + 1)] += a[x] * b[x];                     c[x] = totals[x%(n/10 + 1)];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] += a[x] * b[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){             passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured assign x divided expr", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     real_t *passed_c = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(c[x] - prev) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];                 passed_c[y] = c[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];                 passed_c[y - 1] = c[y];             }             if (is_possible(passed_a, passed_b, passed_c, length - 1, prev / (a[x] + b[x]))){                 delete[] passed_a;                 delete[] passed_b;                 delete[] passed_c;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     delete[] passed_c;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t *temp_a = new real_t[10];     real_t *temp_b = new real_t[10];     real_t *temp_c = new real_t[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     c[x] = totals[x/10];                     totals[x/10] = totals[x/10] / (a[x] + b[x]);                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];             temp_c[temp_iterator] = c[ab_iterator];             temp_iterator++;         }         if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update x bitxor expr", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = (int *)malloc(n * sizeof(int));     int *totals = (int *)malloc((n/10 + 1) * sizeof(int));     int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .5){                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] =  totals[x%(n/10 + 1)] ^ a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] ^= a[x];     }     for (int x = 0; x < n/10 + 1; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction and general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);      char * a = new char[n];     real_t false_margin = pow(exp(1), log(.5)/n);     char result = 1;      for (int x = 0; x < n; ++x){         if(rand() / (real_t)(RAND_MAX) < false_margin){             a[x] = 1;         }         else{             a[x] = 0;         }     }       #pragma acc data copyin(a[0:n])     {         #pragma acc kernels loop reduction(&&:result)         for (int x = 0; x < n; ++x){             result = result && a[x];         }     }      char found = 0;     for (int x = 0; x < n; ++x){         if (a[x] == 0){             found = 1;             break;         }     }     if (found == result){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels create zero", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,data,data-region,V:3.0-3.2 int test1(){     int err = 0;     srand(SEED);     real_t * a = new real_t[n];     real_t * b = new real_t[n];      for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = 0.0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc kernels create(zero: b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] += a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture ior expr x assign", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   INTEGER, INTENT(IN) :: init   INTEGER,DIMENSION(length), INTENT(IN) :: a   INTEGER,DIMENSION(length), INTENT(IN) :: b   INTEGER,DIMENSION(length - 1) :: passed_a   INTEGER,DIMENSION(length - 1) :: passed_b   INTEGER :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (b(x) .eq. ior(init, a(x))) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = b(x)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y, z !Iterators   INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms   INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison   INTEGER,DIMENSION(10):: passed_a, passed_b   INTEGER:: init   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)   a = 0   DO x = 1, LOOPCOUNT     DO y = 1, 10       DO z = 1, 8         IF (randoms(x, y, z) .gt. .933) THEN           a(x, y) = a(x, y) + ISHFT(1, z - 1)         END IF       END DO     END DO   END DO   totals = 0   totals_comparison = 0    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             totals(x) = ior(a(x, y), totals(x))             b(x, y) = totals(x)           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data   DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = ior(totals_comparison(x), a(x, y))     END DO   END DO   DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NE. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 0     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic capture bitor equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == (a[x]|prev)){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int temp_indexer = 0;     int absolute_indexer = 0;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     b[x] = totals[x%(n/10 + 1)] |= a[x];             }         }     }     for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] |= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < (n/10 + 1); ++x){         for (absolute_indexer = x, temp_indexer = 0; absolute_indexer < n; absolute_indexer += n/10 + 1, temp_indexer++){             temp_a[temp_indexer] = a[absolute_indexer];             temp_b[temp_indexer] = b[absolute_indexer];         }         if (!(is_possible(temp_a, temp_b, temp_indexer, 0))){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc map data", "completion": "#ifndef T1 !T1:runtime,data,executable-data,construct-independent,V:3.3     LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data         INTEGER :: errors = 0         INTEGER :: x,i         !Initilization         SEEDDIM(1) = 1         #ifdef SEED             SEEDDIM(1) = SEED         #endif         CALL RANDOM_SEED(PUT=SEEDDIM)                  CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)          CALL acc_map_data(C_LOC(c), C_LOC(d), LOOPCOUNT)          !$acc data copyin(a, b) present(c)             !$acc parallel                 !$acc loop                 DO i = 1, LOOPCOUNT                     c(i) = a(i) + b(i)                 END DO                 !$acc end loop             !$acc end parallel         !$acc end data           !$acc update host(c(0:LOOPCOUNT))         DO x = 1, LOOPCOUNT             IF (ABS(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1             END IF         END DO          CALL acc_unmap_data(c)         CALL acc_free(d)          IF (errors .eq. 0) THEN             test1 = .FALSE.         ELSE             test1 = .TRUE.         END IF     END #endif   PROGRAM main     IMPLICIT NONE     INTEGER :: failcode, testrun     LOGICAL :: failed     INCLUDE \"acc_testsuite.Fh\" #ifndef T1     LOGICAL :: test1 #endif     failed = .FALSE.     failcode = 0 #ifndef T1     DO testrun = 1, NUM_TEST_CALLS       failed = failed .or. test1()     END DO     IF (failed) THEN       failcode = failcode + 2 ** 0       failed = .FALSE.     END IF #endif     CALL EXIT (failcode)   END PROGRAM"}
{"prompt": "Create a test for the feature atomic update expr bitor x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int  *a = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;     }      #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic update                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] |= a[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop reduction or vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(10 * n * sizeof(char));     char * b = (char *)malloc(10 * sizeof(char));     real_t false_margin = pow(exp(1), log(.5)/n);     char temp = 0;     char found;      for (int x = 0; x < 10 * n; ++x){         if(rand() / (real_t)(RAND_MAX) > false_margin){             a[x] = 1;         }         else{             a[x] = 0;         }     }     #pragma acc data copyin(a[0:10*n]) copy(b[0:10])     {         #pragma acc kernels loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(||:temp)             for (int y = 0; y < n; ++y){                 temp = temp || a[x * n + y];             }             b[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         found = 0;         for (int y = 0; y < n; ++y){             if (a[x * n + y] &! 0){                 found = 1;             }         }         if (found != b[x]){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured divided equals assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     real_t *passed_c = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(c[x] - (prev / (a[x] + b[x]))) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];                 passed_c[y] = c[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];                 passed_c[y - 1] = c[y];             }             if (is_possible(passed_a, passed_b, passed_c, length - 1, c[x])){                 delete[] passed_a;                 delete[] passed_b;                 delete[] passed_c;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     delete[] passed_c;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t *temp_a = new real_t[10];     real_t *temp_b = new real_t[10];     real_t *temp_c = new real_t[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {       #pragma acc parallel       {           #pragma acc loop           for (int x = 0; x < n; ++x){               #pragma acc atomic capture               {                   totals[x/10] /= (a[x] + b[x]);                   c[x] = totals[x/10];               }           }       }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] /= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION){             err += 1;             break;         }     }      for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];             temp_c[temp_iterator] = c[ab_iterator];             temp_iterator++;         }         if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc delete", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n])      #pragma acc data copyout(c[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      acc_delete(a, n * sizeof(real_t));     acc_delete(b, n * sizeof(real_t));      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:runtime,data,executable-data,construct-independent,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      acc_copyin(a, n * sizeof(real_t));     acc_copyin(b, n * sizeof(real_t));      #pragma acc data copyout(c[0:n])     {         #pragma acc parallel present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }      acc_delete(a, n * sizeof(real_t));     acc_delete(b, n * sizeof(real_t));      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update expr times x", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data         REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 1         totals_comparison = 1          !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               DO y = 1, 10                 !$acc atomic update                   totals(x) = a(x, y) * totals(x)               END DO             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           DO y = 1, 10             totals_comparison(x) = totals_comparison(x) * a(x, y)           END DO         END DO          DO x = 1, LOOPCOUNT           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature declare function scope copy", "completion": "#include \"acc_testsuite.h\" void copyin_copyout_test(real_t *a, real_t *b, real_t *c){     #pragma acc declare copy(c[0:n])     #pragma acc parallel present(a[0:n], b[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = c[x] + a[x] + b[x];         }     } }  #ifndef T1 //T1:declare,construct-independent,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = new real_t[n];         b[x] = new real_t[n];         c[x] = new real_t[n];         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 1;         }     }     #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])     {         for (int x = 0; x < n; ++x){             copyin_copyout_test(a[x], b[x], c[x]);         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:declare,construct-independent,reference-counting,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             a[x][y] = rand() / (real_t)(RAND_MAX / 10);             b[x][y] = rand() / (real_t)(RAND_MAX / 10);             c[x][y] = 2;         }     }      #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])     {         for (int x = 0; x < n; ++x){             #pragma acc data copy(c[x:1][0:n])             {                 copyin_copyout_test(a[x], b[x], c[x]);             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < n; ++y){             if (fabs(c[x][y] - (2 + a[x][y] + b[x][y])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T3 //T3:declare,construct-independent,devonly,reference-counting,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 a[x][y] = rand() / (real_t)(RAND_MAX / 10);                 b[x][y] = rand() / (real_t)(RAND_MAX / 10);                 c[x][y] = 3;             }         }          #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])         {             for (int x = 0; x < n; ++x){                 #pragma acc data copyin(c[x:1][0:n])                 {                     copyin_copyout_test(a[x], b[x], c[x]);                     for (int y = 0; y < n; ++y){                         if (fabs(c[x][y] - 3) > PRECISION){                             err += 1;                         }                     }                 }                 for (int y = 0; y < n; ++y){                     if (fabs(c[x][y] - 3) > PRECISION){                         err += 1;                     }                 }             }         }     }      return err; } #endif  #ifndef T4 //T4:declare,construct-independent,devonly,reference-counting,V:2.5-2.7 int test4(){     int err = 0;     srand(SEED);     real_t ** a = (real_t **)malloc(n * sizeof(real_t));     real_t ** b = (real_t **)malloc(n * sizeof(real_t));     real_t ** c = (real_t **)malloc(n * sizeof(real_t));     int *devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {         devtest[0] = 0;     }      if (devtest[1] == 1){         for (int x = 0; x < n; ++x){             for (int y = 0; y < n; ++y){                 a[x][y] = rand() / (real_t)(RAND_MAX / 10);                 b[x][y] = rand() / (real_t)(RAND_MAX / 10);                 c[x][y] = 4;             }         }          #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])         {             for (int x = 0; x < n; ++x){                 #pragma acc data copy(c[x:1][0:n])                 {                     copyin_copyout_test(a[x], b[x], c[x]);                     for (int y = 0; y < n; ++y){                         if (fabs(c[x][y] - 4) > PRECISION){                             err += 1;                         }                     }                 }                 for (int y = 0; y < n; ++y){                     if (fabs(c[x][y] - (4 + a[x][y] + b[x][y])) > PRECISION){                         err += 1;                     }                 }             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc wait", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,async,construct-independent,wait,V:2.0-2.7 int test1(){     int err = 0;     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *d = new real_t[n];     real_t *e = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = 0;     }      #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n]) async(1)     #pragma acc enter data copyin(d[0:n]) create(e[0:n]) async(2)     #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1) wait(2)     {         #pragma acc loop         for (int x = 0; x < n; ++x){             e[x] = c[x] + d[x];         }     }     #pragma acc exit data copyout(e[0:n]) async(1)      acc_wait(1);     for (int x = 0; x < n; ++x){         if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){             err += 1;         }     }      #pragma acc exit data delete(a[0:n], b[0:n], c[0:n], d[0:n])      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels if", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,if,V:1.0-3.2 int test1(){     int err = 0;     srand(SEED);     int data_on_device = 0;     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             b[x] = a[x];         }     }      for (int x = 0; x < n; ++x){         if (fabs(b[x] - a[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:kernels,if,V:2.0-3.2 int test2(){     int err = 0;     srand(SEED);     int data_on_device = 0;     int * devtest = (int *)malloc(sizeof(int));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc enter data copyin(a[0:n]) create(b[0:n])     data_on_device = 1;      #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             b[x] = a[x];         }     }     #pragma acc exit data copyout(b[0:n]) delete(a[0:n])      for (int x = 0; x < n; ++x){         if (fabs(b[x] - a[x]) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:kernels,if,devonly,V:2.0-3.2 int test3(){     int err = 0;     srand(SEED);     int data_on_device = 0;     int * devtest = (int *)malloc(sizeof(int));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     devtest[0] = 1;      #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     { \tdevtest[0] = 0;      }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0;         }          #pragma acc enter data copyin(a[0:n]) create(b[0:n])         for (int x = 0; x < n; ++x){             a[x] = -1;         }          #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }         for (int x = 0; x < n; ++x){             if (fabs(a[x] + 1) > PRECISION){                 err += 1;             }             if (fabs(b[x] + 1) > PRECISION){                 err += 1;             }         }         #pragma acc exit data copyout(a[0:n], b[0:n])         data_on_device = 0;         for (int x = 0; x < n; ++x){             if (fabs(a[x] - b[x]) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T4 //T4:kernels,if,devonly,V:2.0-3.2 int test4(){     int err = 0;     srand(SEED);     int data_on_device = 0;     int * devtest = (int *)malloc(sizeof(int));     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel present(devtest[0:1])     {       devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = 0;         }          #pragma acc enter data copyin(a[0:n], b[0:n])         #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }         for (int x = 0; x < n; ++x){             if (fabs(a[x] - b[x]) > PRECISION) {                 err += 1;             }         }         #pragma acc exit data copyout(a[0:n], b[0:n])         for (int x = 0; x < n; ++x){             if (fabs(b[x]) > PRECISION && b[x] != a[x]){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature shutdown device type", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:shutdown,runtime,syntactic,V:2.5-3.2 int test1(){     int err = 0;      #pragma acc shutdown device_type(host)      return err; } #endif #ifndef T2 //T2:shutdown,runtime,syntactic,V:2.5-3.2 int test2(){     int err = 0;      #pragma acc shutdown device_type(multicore)      return err; } #endif #ifndef T3 //T3:shutdown,runtime,syntactic,V:2.5-3.2 int test3(){     int err = 0;      #pragma acc shutdown device_type(default)      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature enter exit data if", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,construct-independent,if,reference-counting,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int dev = 1;     int host = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n]) if(dev)     #pragma acc data create(a[0:n], b[0:n]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }     #pragma acc exit data delete(a[0:n], b[0:n]) if(dev)      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:data,executable-data,construct-independent,if,V:2.0-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int dev = 1;     int host = 0;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data create(a[0:n], b[0:n]) if(host)     #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 c[x] = a[x] + b[x];             }         }     }     #pragma acc exit data delete(a[0:n], b[0:n]) if(host)      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T3 //T3:data,executable-data,construct-independent,devonly,if,reference-counting,V:2.5-2.7 int test3(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int dev = 1;     int host = 0;     int * devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             a_copy[x] = a[x];             b[x] = rand() / (real_t)(RAND_MAX / 10);             b_copy[x] = b[x];             c[x] = 0.0;         }          #pragma acc enter data copyin(a[0:n], b[0:n]) if(dev)         for (int x = 0; x < n; ++x){             a[x] = 0;             b[x] = 0;         }         #pragma acc data create(a[0:n], b[0:n]) copyout(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] + b[x];                 }             }         }         #pragma acc exit data copyout(a[0:n], b[0:n]) if(dev)          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T4 //T4:data,executable-data,if,construct-independent,devonly,V:2.0-2.7 int test4(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int dev = 1;     int host = 0;     int * devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0.0;         }          #pragma acc enter data copyin(a[0:n], b[0:n]) if(host)         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             a_copy[x] = a[x];             b[x] = rand() / (real_t)(RAND_MAX / 10);             b_copy[x] = b[x];         }         #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] + b[x];                 }             }         }         #pragma acc exit data copyout(a[0:n], b[0:n]) if(host)          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  #ifndef T5 //T5:data,executable-data,if,construct-independent,devonly,V:2.0-2.7 int test5(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int dev = 1;     int host = 0;     int * devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             a[x] = rand() / (real_t)(RAND_MAX / 10);             b[x] = rand() / (real_t)(RAND_MAX / 10);             c[x] = 0.0;         }          #pragma acc enter data create(a[0:n], b[0:n]) if(host)         #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])         {             #pragma acc parallel             {                 #pragma acc loop                 for (int x = 0; x < n; ++x){                     c[x] = a[x] + b[x];                 }             }         }         #pragma acc exit data copyout(a[0:n], b[0:n]) if(host)          for (int x = 0; x < n; ++x){             if (fabs(c[x] - (a[x] + b[x])) > PRECISION){                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature routine bind prototype function nonstring function", "completion": "#include \"acc_testsuite.h\"  //test 1 host function real_t host_array_array(real_t * a, long long n){     #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  //test 2 host function real_t host_object_array(data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned += a->data[x];     }     return returned; }  //test 3 host function real_t host_array_object(real_t * a, long long n){    #pragma acc loop reduction(+:returned)     real_t returned = 0.0;     for (int x = 0; x < n; ++x){         returned += a[x];     }     return returned; }  //test 4 host function real_t host_object_object(data_container<real_t> * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned += a->data[x];     }     return returned; }   #pragma acc routine(host_array_array) vector bind(device_array_array) #pragma acc routine(host_object_array) vector bind(device_object_array) #pragma acc routine(host_array_object) vector bind(device_array_object) #pragma acc routine(host_object_object) vector bind(device_object_object)  //test 1 device function real_t device_array_array(real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  //test 2 device function real_t device_object_array(data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){ \treturned -= a->data[x];     }     return returned; }  //test 3 device function real_t device_array_object(real_t * a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for (int x = 0; x < n; ++x){         returned -= a[x];     }     return returned; }  //test 4 device function real_t device_object_object(data_container<real_t> *a, long long n){     real_t returned = 0.0;     #pragma acc loop reduction(-:returned)     for(int x = 0; x < n; ++x){         returned -= a->data[x];     }     return returned; }  #ifndef T1 //T1:routine,V:2.7-3.3 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){        \ta[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_array_array(a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_array(a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_array(a, n) - b[x]) > PRECISION)){             err += 1;         }     }     delete[] a;     delete[] b;      return err; } #endif #ifndef T2 //T2:routine,V:2.7-3.3 int test2(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     real_t *b = new real_t[n];     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a, a.data[0:n]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b[x] = device_object_array(&a, n);             }         }     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_array(&a, n) + b[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_array(&a, n) - b[x]) > PRECISION)){             err += 1;         }     }      delete[] b;      return err; } #endif #ifndef T3 //T3:routine,V:2.7-3.3 int test3(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a[0:n], b, b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_array_object(a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_array_object(a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_array_object(a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      delete[] a;      return err; } #endif #ifndef T4 //T4:routine,V:2.7-3.3 int test4(){     int err = 0;     srand(SEED);     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     int on_host = (acc_get_device_type() == acc_device_none);      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = 0.0;     }      #pragma acc data copyin(a, a.data[0:n], b ,b.data[0:n])     {         #pragma acc parallel         {             #pragma acc loop gang worker vector             for (int x = 0; x < n; ++x){                 b.data[x] = device_object_object(&a, n);             }         } \t#pragma acc update host(b.data[0:n])     }      for (int x = 0; x < n; ++x){         if ((!on_host) && (fabs(host_object_object(&a, n) + b.data[x]) > PRECISION)){             err += 1;         }         else if ((on_host) && (fabs(host_object_object(&a, n) - b.data[x]) > PRECISION)){             err += 1;         }     }      return err; } #endif int main(){     int failcode = 0;     int failed = 0; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test1();     }      if(failed){         failcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }      if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }      if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test4();     }      if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction add loop type check pt1", "completion": "#include \"acc_testsuite.h\" #ifndef T1:private,reduction,combined-constructs,loop,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     char * a = new char[10 * n];     char * b = new char[10 * n];     char * c = new char[10 * n];     char * d = new char[10 * n];     char total = 10;     char host_total = 10;     char temp;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:10*n],b[0:10*n], c[0:10*n]) copyout(d[0:10*n])     {         #pragma acc parallel loop gang private(total)         for (int x = 0; x < 10; ++x) {             total = 10;             #pragma acc loop worker reduction(+:total)             for (int y = 0; y < n; ++y) {                 total += a[x * n + y] + b[x * n + y];             }             #pragma acc loop worker             for (int y = 0; y < n; ++y) {                 d[x * n + y] = c[x * n + y] + total;             }         }     }     int error_count = 0;     int total_count = 0;     for (int x = 0; x < 10; ++x) {         host_total = 10;         for (int y = 0; y < n; ++y) {             host_total += a[x * n + y] + b[x * n + y];         }         for (int y = 0; y < n; ++y) {             temp = host_total + c[x * n + y];             if (d[x * n + y] != temp) {                 err += 1;                 error_count += 1;                 printf(\"Error location x: %d \\t y: %d\\n\", x, y);                  printf(\"%d != %d\\n\", d[x * n + y], temp);             }             total_count += 1;         }     }      //printf(\"%d out of %d failed\\n\", error_count, total_count);      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; }"}
{"prompt": "Create a test for the feature parallel loop reduction bitand loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));     unsigned int * host_c = (unsigned int *)malloc(10 * sizeof(unsigned int));      real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;      for (int x = 0; x < 10 * n; ++x){         a[x] = 0;         b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b_copy[x] = b[x];         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX < false_margin){                 a[x] += 1 << y;             }         }     }     #pragma acc data copyin(a[0:10 * n]) copy(b[0:10 * n], c[0:10])     {         #pragma acc parallel loop gang private(temp)         for (int y = 0; y < 10; ++y){             temp = a[y * n];             #pragma acc loop worker reduction(&:temp)             for (int x = 1; x < n; ++x){                 temp = temp & a[y * n + x];             }             c[y] = temp;             #pragma acc loop worker             for (int x = 0; x < n; ++x){                 b[y * n + x] = b[y * n + x] + c[y];             }         }     }     for (int x = 0; x < 10; ++x){         host_c[x] = a[x * n];         for (int y = 1; y < n; ++y){             host_c[x] = host_c[x] & a[x * n + y];         }         if (host_c[x] != c[x]){           err += 1;         }     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (b[x * n + y] != b_copy[x * n + y] + c[x]){                 err += 1;             }         }     }      return err; } #endif  #ifndef T2 //T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * b_copy = (unsigned int *)malloc(25 * n * sizeof(unsigned int));     unsigned int * c = (unsigned int *)malloc(25 * sizeof(unsigned int));     unsigned int device[5];     unsigned int host[5];      real_t false_margin = pow(exp(1), log(.5)/n);          for (int x = 0; x < 25 * n; ++x){         a[x] = 0;         b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);         b_copy[x] = b[x];         for (int y = 0; y < 16; ++y) {             if (rand() / (real_t)RAND_MAX < false_margin) {                 a[x] += 1 << y;             }         }     }      #pragma acc data copyin(a[0:25*n]) copy(b[0:25*n], c[0:25])     {         #pragma acc parallel loop gang private(device)         for (int x = 0; x < 5; ++x) {             for (int y = 0; y < 5; ++y) {                 device[y] = a[x * 5 * n + y];             }             #pragma acc loop worker reduction(&:device)             for (int y = 0; y < 5 * n; ++y) {                 device[y%5] = device[y%5] & a[x * 5 * n + y];             }             for (int y = 0; y < 5; ++y) {                 c[x * 5 + y] = device[y];             }             #pragma acc loop worker             for (int y = 0; y < 5 * n; ++y) {                 b[x * 5 * n + y] = b[x * 5 * n + y] + c[x * 5 + (y % 5)];             }         }     }      for (int x = 0; x < 5; ++x) {         for (int y = 0; y < 5; ++y) {             host[y] = a[x * 5 * n + y];         }         for (int y = 0; y < 5 * n; ++y) {             host[y%5] = host[y%5] & a[x * 5 * n + y];         }         for (int y = 0; y < 5; ++y) {             if (host[y] != c[x * 5 + y]) {                 err += 1;             }         }         for (int y = 0; y < 5 * n; ++y) {             if (b[x * 5 * n + y] != (host[y%5] + b_copy[x * 5 * n + y])) {                 err += 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture assign iand x expr", "completion": "RECURSIVE FUNCTION IS_POSSIBLE(a, b, length, init) RESULT(POSSIBLE)   INTEGER, INTENT(IN) :: length   INTEGER, INTENT(IN) :: init   INTEGER,DIMENSION(length), INTENT(IN) :: a   INTEGER,DIMENSION(length), INTENT(IN) :: b   INTEGER,DIMENSION(length - 1) :: passed_a   INTEGER,DIMENSION(length - 1) :: passed_b   INTEGER :: holder   LOGICAL :: POSSIBLE   INTEGER :: x, y    IF (length .eq. 0) THEN     POSSIBLE = .TRUE.     RETURN   END IF   POSSIBLE = .FALSE.    DO x = 1, length     IF (b(x) .eq. init) THEN       DO y = 1, x - 1         passed_a(y) = a(y)         passed_b(y) = b(y)       END DO       DO y = x + 1, length         passed_a(y - 1) = a(y)         passed_b(y - 1) = b(y)       END DO       holder = iand(a(x), init)       IF (IS_POSSIBLE(passed_a, passed_b, length - 1, holder)) THEN         POSSIBLE = .TRUE.         RETURN       END IF     END IF   END DO END FUNCTION IS_POSSIBLE  #ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()   IMPLICIT NONE   INCLUDE \"acc_testsuite.Fh\"   INTEGER :: x, y, z !Iterators   INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data   REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms   INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison   INTEGER,DIMENSION(10):: passed_a, passed_b   INTEGER:: init   LOGICAL IS_POSSIBLE   INTEGER :: errors = 0    !Initilization   SEEDDIM(1) = 1 # ifdef SEED   SEEDDIM(1) = SEED # endif   CALL RANDOM_SEED(PUT=SEEDDIM)    CALL RANDOM_NUMBER(randoms)   a = 0   DO x = 1, LOOPCOUNT     DO y = 1, 10       DO z = 1, 8         IF (randoms(x, y, z) .lt. .933) THEN           a(x, y) = a(x, y) + ISHFT(1, z - 1)         END IF       END DO     END DO   END DO   totals = 0   totals_comparison = 0   DO x = 1, LOOPCOUNT     DO y = 0, 7       totals(x) = totals(x) + ISHFT(1, y)       totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)     END DO   END DO    !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))     !$acc parallel       !$acc loop       DO x = 1, LOOPCOUNT         DO y = 1, 10           !$acc atomic capture             b(x, y) = totals(x)             totals(x) = iand(totals(x), a(x, y))           !$acc end atomic         END DO       END DO     !$acc end parallel   !$acc end data   DO x = 1, LOOPCOUNT     DO y = 1, 10       totals_comparison(x) = iand(totals_comparison(x), a(x, y))     END DO   END DO   DO x = 1, LOOPCOUNT     IF (totals_comparison(x) .NE. totals(x)) THEN       errors = errors + 1       WRITE(*, *) totals_comparison(x)     END IF   END DO    DO x = 1, LOOPCOUNT     DO y = 1, 10       passed_a(y) = a(x, y)       passed_b(y) = b(x, y)     END DO     init = 0     DO y = 0, 7       init = init + ISHFT(1, y)     END DO     IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN       errors = errors + 1     END IF   END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured x multiply expr assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));     real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] * prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 free(passed_a);                 free(passed_b);                 return true;             }         }     }     free(passed_a);     free(passed_b);     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));     real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);                     c[x] = totals[x%(n/10 + 1)];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel loop reduction add general type check pt2", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned short int * a = (unsigned short int*)malloc(n * sizeof(unsigned short int));     unsigned short int * b = (unsigned short int *)malloc(n * sizeof(unsigned short int));     unsigned short int total = 10;     unsigned short int host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (host_total != total) {         err += 1;     }      return err; } #endif   #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     unsigned int * b = (unsigned int *)malloc(n * sizeof(unsigned int));     unsigned int total = 10;     unsigned int host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (host_total != total) {         err += 1;     }      return err; } #endif  #ifndef T3 //T3:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test3(){     int err = 0;     srand(SEED);     unsigned long int * a = (unsigned long int *)malloc(n * sizeof(unsigned long int));     unsigned long int * b = (unsigned long int *)malloc(n * sizeof(unsigned long int));     unsigned long int total = 10;     unsigned long int host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (host_total != total) {         err += 1;     }      return err; } #endif  #ifndef T4 //T4:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test4(){     int err = 0;     srand(SEED);     unsigned long long int * a = (unsigned long long int *)malloc(n * sizeof(unsigned long long int));     unsigned long long int * b = (unsigned long long int *)malloc(n * sizeof(unsigned long long int));     unsigned long long int total = 10;     unsigned long long int host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }          if (total != host_total) {         err += 1;     }      return err; } #endif  #ifndef T5 //T5:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test5(){     int err = 0;     srand(SEED);     float * a = new float[n];     float * b = new float[n];     float total = 10;     float host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (fabsf(total - host_total) > PRECISION) {         err += 1;     }      return err; } #endif  #ifndef T6 //T6:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test6(){     int err = 0;     srand(SEED);     double * a = new double[n];     double * b = new double[n];     double total = 10;     double host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (fabs(host_total - total) > PRECISION) {         err += 1;     }      return err; } #endif  #ifndef T7 //T7:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test7(){     int err = 0;     srand(SEED);     long double * a = (long double *)malloc(n * sizeof(long double));     long double * b = (long double *)malloc(n * sizeof(long double));     long double total = 10;     long double host_total = 10;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }          #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x){             total += a[x] + b[x];         }     }          for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (fabsl(host_total - total) > PRECISION) {         err += 1;     }      return err; } #endif  #ifndef T8 //T8:parallel,reduction,combined-constructs,loop,V:1.0-2.7 int test8(){     int err = 0;     srand(SEED);     float _Complex * a = (float _Complex *)malloc(n * sizeof(float _Complex));     float _Complex * b = (float _Complex *)malloc(n * sizeof(float _Complex));     float _Complex total = 10 + 10 * I;     float _Complex host_total = 10 + 10 * I;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;         b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;     }      #pragma acc data copyin(a[0:n], b[0:n])     {         #pragma acc parallel loop reduction(+:total)         for (int x = 0; x < n; ++x) {             total += a[x] + b[x];         }     }      for (int x = 0; x < n; ++x) {         host_total += a[x] + b[x];     }      if (fabsf(crealf(total) - crealf(host_total)) > PRECISION) {         err += 1;     }     if (fabsf(cimagf(total) - cimagf(host_total)) > PRECISION) {         err += 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif #ifndef T3     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test3();     }     if (failed != 0){         failcode = failcode + (1 << 2);     } #endif #ifndef T4     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test4();     }     if (failed != 0){         failcode = failcode + (1 << 3);     } #endif #ifndef T5     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test5();     }     if (failed != 0){         failcode = failcode + (1 << 4);     } #endif #ifndef T6     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test6();     }     if (failed != 0){         failcode = failcode + (1 << 5);     } #endif #ifndef T7     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test7();     }     if (failed != 0){         failcode = failcode + (1 << 6);     } #endif #ifndef T8     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test8();     }     if (failed != 0){         failcode = failcode + (1 << 7);     } #endif     return failcode; }  "}
{"prompt": "Create a test for the feature parallel loop reduction bitor general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));     real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int temp = 1;     unsigned int b = 0;     unsigned int host_b;      for (int x = 0; x < n; ++x){         a[x] = 0;         for (int y = 0; y < 16; ++y){             if (rand() / (real_t) RAND_MAX > false_margin){                 a[x] += 1 << y;             }         }     }      #pragma acc data copyin(a[0:n])     {         #pragma acc parallel loop reduction(|:b)         for (int x = 0; x < n; ++x){             b = b | a[x];         }     }      host_b = a[0];     for (int x = 1; x < n; ++x){         host_b = host_b | a[x];     }      if (b != host_b){         err = 1;     }      return err; } #endif  #ifndef T2 //T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7 int test2(){     int err = 0;     srand(SEED);     unsigned int * a = (unsigned int *)malloc(5 * n * sizeof(unsigned int));     real_t false_margin = pow(exp(1), log(.5)/n);     unsigned int b[5];     unsigned int host_b[5];      for (int x = 0; x < 5 * n; ++x){         a[x] = 0;         for (int y = 0; y < 16; ++y) {             if (rand() / (real_t) RAND_MAX > false_margin) {                 a[x] += 1 << y;             }         }     }      for (int x = 0; x < 5; ++x) {         b[x] = 0;         host_b[x] = 0;     }      #pragma acc data copyin(a[0:5*n])     {         #pragma acc parallel loop reduction(|:b)         for (int x = 0; x < 5 * n; ++x) {             b[x%5] = b[x%5] | a[x];         }     }      for (int x = 0; x < 5 * n; ++x){         host_b[x%5] = host_b[x%5] | a[x];     }      for (int x = 0; x < 5; ++x) {         if (host_b[x] != b[x]) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature serial loop reduction max vector loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));     real_t * max = (real_t *)malloc(10 * sizeof(real_t));     real_t temp = 0;     real_t temp_max;      for (int x = 0; x < 10 * n; ++x){         a[x] = rand() / (real_t)(RAND_MAX/10);         b[x] = rand() / (real_t)(RAND_MAX/10);     }     #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(max[0:10])     {         #pragma acc serial loop private(temp)         for (int x = 0; x < 10; ++x){             temp = 0;             #pragma acc loop vector reduction(max:temp)             for (int y = 0; y < n; ++y){                 temp = fmax(a[x * n + y] * b[x * n + y], temp);             }             max[x] = temp;         }     }     for (int x = 0; x < 10; ++x){         temp_max = 0;         for (int y = 0; y < n; ++y){             if (temp_max < a[x * n + y] * b[x * n + y]){                 temp_max = a[x * n + y] * b[x * n + y];             }         }         if (fabs(temp_max - max[x]) > PRECISION){             err = 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc memcpy from device async", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *c = (real_t *)malloc(n * sizeof(real_t));     real_t *d = (real_t *)malloc(n * sizeof(real_t));     real_t *e = (real_t *)malloc(n * sizeof(real_t));     real_t *f = (real_t *)malloc(n * sizeof(real_t));     real_t *hostdata = (real_t *)malloc(6 * n * sizeof(real_t));     real_t *hostdata_copy = (real_t *)malloc(6 * n * sizeof(real_t));      real_t *devdata;      for (int x = 0; x < n; ++x){         hostdata[x] = rand() / (real_t)(RAND_MAX / 10);         hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);         hostdata[2*n + x] = 1;         hostdata[3*n + x] = rand() / (real_t)(RAND_MAX / 10);         hostdata[4*n + x] = rand() / (real_t)(RAND_MAX / 10);         hostdata[5*n + x] = 2;     }      for (int x = 0; x < 6*n; ++x){         hostdata_copy[x] = hostdata[x];     }      devdata = acc_copyin(hostdata, 6 * n * sizeof(real_t));      #pragma acc data deviceptr(devdata)     {         #pragma acc parallel async(1)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[x] = devdata[x] * devdata[x];             }         }         acc_memcpy_from_device_async(a, devdata, n * sizeof(real_t), 1);         #pragma acc parallel async(2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[n + x] = devdata[n + x] * devdata[n + x];             }         }         acc_memcpy_from_device_async(b, &(devdata[n]), n * sizeof(real_t), 2);         #pragma acc parallel async(4)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[3*n + x] = devdata[3*n + x] * devdata[3*n + x];             }         }         acc_memcpy_from_device_async(d, &(devdata[3*n]), n * sizeof(real_t), 4);         #pragma acc parallel async(5)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[4*n + x] = devdata[4*n + x] * devdata[4*n + x];             }         }         acc_memcpy_from_device_async(e, &(devdata[4*n]), n * sizeof(real_t), 5);         #pragma acc parallel async(3) wait(1, 2)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[2*n + x] += devdata[x] + devdata[n + x];             }         }         acc_memcpy_from_device_async(c, &(devdata[2*n]), n * sizeof(real_t), 3);         #pragma acc parallel async(6) wait(4, 5)         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 devdata[5*n + x] += devdata[3*n + x] + devdata[4*n + x];             }         }         acc_memcpy_from_device_async(f, &(devdata[5*n]), n * sizeof(real_t), 6);     }      #pragma acc wait(1)     for (int x = 0; x < n; ++x){         if (fabs(a[x] - hostdata_copy[x] * hostdata_copy[x]) > PRECISION){             err += 1;         }     }     #pragma acc wait(2)     for (int x = 0; x < n; ++x){         if (fabs(b[x] - hostdata_copy[n + x] * hostdata_copy[n + x]) > PRECISION){             err += 1;         }     }     #pragma acc wait(4)     for (int x = 0; x < n; ++x){         if (fabs(d[x] - hostdata_copy[3*n + x] * hostdata_copy[3*n + x]) > PRECISION){             err += 1;         }     }     #pragma acc wait(5)     for (int x = 0; x < n; ++x){         if (fabs(e[x] - hostdata_copy[4*n + x] * hostdata_copy[4*n + x]) > PRECISION){             err += 1;         }     }     #pragma acc wait(3)     for (int x = 0; x < n; ++x){         if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){             err += 1;         }     }     #pragma acc wait(6)     for (int x = 0; x < n; ++x){         if (fabs(f[x] - (2 + d[x] + e[x])) > PRECISION){             err += 1;         }     }      #pragma acc exit data delete(hostdata[0:6*n])      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic structured x multiply expr assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(real_t* a, real_t* b, int length, real_t prev){     if (length == 0){         return true;     }     real_t *passed_a = new real_t[(length - 1)];     real_t *passed_b = new real_t[(length - 1)];     for (int x = 0; x < length; ++x){         if (fabs(b[x] - (a[x] * prev)) < PRECISION){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = new real_t[n];     real_t *b = new real_t[n];     real_t *c = new real_t[n];     real_t *totals = new real_t[(n/10 + 1)];     real_t *totals_comparison = new real_t[(n/10 + 1)];     real_t * passed_ab = new real_t[10];     real_t * passed_c = new real_t[10];     int passed_indexer;     int absolute_indexer;      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                 {                     totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);                     c[x] = totals[x%(n/10 + 1)];                 }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      for (int x = 0; x < n/10 + 1; ++x){         for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){             passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];             passed_c[passed_indexer] = c[absolute_indexer];         }         if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic update min x expr end", "completion": "#ifndef T1 !T1:construct-independent,atomic,V:2.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a !Data         REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)          totals = 0         totals_comparison = 0          !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               !$acc atomic update                 totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))               !$acc end atomic             END DO           !$acc end parallel         !$acc end data         DO x = 1, LOOPCOUNT           totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))         END DO         DO x = 1, LOOPCOUNT/10 + 1           IF (totals_comparison(x) .NE. totals(x)) THEN             errors = errors + 1             WRITE(*, *) totals_comparison(x)           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature acc create async with len", "completion": "#ifndef T1 !T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data         REAL(8) :: RAND         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0         CALL RANDOM_NUMBER(d)         CALL RANDOM_NUMBER(e)         f = 0          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))           CALL acc_create_async(c(1), LOOPCOUNT*8, 1)           CALL acc_create_async(f(1), LOOPCOUNT*8, 2)           !$acc data present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))             !$acc parallel async(1)               !$acc loop               DO x = 1, LOOPCOUNT                 c(x) = a(x) + b(x)               END DO             !$acc end parallel             !$acc parallel async(2)               !$acc loop               DO x = 1, LOOPCOUNT                 f(x) = d(x) + e(x)               END DO             !$acc end parallel             !$acc wait           !$acc end data         !$acc end data          !$acc exit data copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF           IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO         IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif          CALL EXIT (failcode)         END PROGRAM  "}
{"prompt": "Create a test for the feature serial loop reduction and loop", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:serial,loop,reduction,combined-constructs,V:2.6-3.2 int test1(){     int err = 0;     srand(SEED);     char * a = (char *)malloc(10 * n * sizeof(char));     char * a_copy = (char *)malloc(10 * n * sizeof(char));     char * has_false = (char *)malloc(10 * sizeof(char));     real_t false_margin = pow(exp(1), log(.5)/n);     char temp = 1;      for (int x = 0; x < 10; ++x){         has_false[x] = 0;     }      for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (rand() / (real_t)(RAND_MAX) < false_margin){                 a[x * n + y] = 1;                 a_copy[x * n + y] = 1;             }             else {                 a[x * n + y] = 0;                 a_copy[x * n + y] = 0;                 has_false[x] = 1;             }         }     }      #pragma acc data copy(a[0:10*n])     {         #pragma acc serial \t{    \t#pragma acc loop gang private(temp)         for (int x = 0; x < 10; ++x){             temp = 1;             #pragma acc loop worker reduction(&&:temp)             for (int y = 0; y < n; ++y){                 temp = temp && a[x * n + y];             }             #pragma acc loop worker             for (int y = 0; y < n; ++y){                 if(temp == 1){                     if  (a[x * n + y] == 1){                         a[x * n + y] = 0;                     }                     else {                         a[x * n + y] = 1;                     }                 }             }         } \t}     }       for (int x = 0; x < 10; ++x){         for (int y = 0; y < n; ++y){             if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){                 err = 1;             }             else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){                 err = 1;             }         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels loop worker blocking", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,V:1.0-2.7 int test1(){   int err = 0;   srand(SEED);   real_t * a = (real_t *)malloc(n * sizeof(real_t));   real_t * b = (real_t *)malloc(n * sizeof(real_t));   real_t * c = (real_t *)malloc(n * sizeof(real_t));   real_t multiplyer = 1;    for (int x = 0; x < n; ++x){       a[x] = rand() / (real_t)(RAND_MAX / 10);       b[x] = rand() / (real_t)(RAND_MAX / 10);       c[x] = 0.0;   }    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])   {     #pragma acc kernels     {       #pragma acc loop worker       for (int x = 0; x < n; ++x){         c[x] = (a[x] + b[x]) * multiplyer;       }       multiplyer += 1;       #pragma acc loop worker       for (int x = 0; x < n; ++x){         c[x] += (a[x] + b[x]) * multiplyer;       }     }   }    for (int x = 0; x < n; ++x){     if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){       err + 1;       break;     }   }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature kernels vector length", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = 0;     }      #pragma acc data copyin(a[0:n]) copyout(b[0:n])     {         #pragma acc kernels vector_length(16)         {             #pragma acc loop vector             for (int x = 0; x < n; ++x){                 b[x] = a[x];             }         }     }      for (int x = 0; x < n; ++x){         if (fabs(a[x] - b[x]) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature acc copyout with len", "completion": "#ifndef T1 !T1:runtime,data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x !Iterators         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          CALL acc_create(c(1:LOOPCOUNT))          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_copyout(c(1), LOOPCOUNT*8)          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif  #ifndef T2 !T2:runtime,data,executable-data,construct-independent,V:2.0-2.7       LOGICAL FUNCTION test2()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x         REAL(8),DIMENSION(LOOPCOUNT):: a, b, c         INTEGER :: errors = 0          SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)         CALL RANDOM_NUMBER(a)         CALL RANDOM_NUMBER(b)         c = 0          !$acc enter data create(c(1:LOOPCOUNT))          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, LOOPCOUNT               c(x) = a(x) + b(x)             END DO           !$acc end parallel         !$acc end data          CALL acc_copyout(c(1), LOOPCOUNT*8)          DO x = 1, LOOPCOUNT           IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test2 = .FALSE.         ELSE           test2 = .TRUE.         END IF       END #endif         PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\"         !Conditionally define test functions #ifndef T1         LOGICAL :: test1 #endif #ifndef T2         LOGICAL :: test2 #endif         failcode = 0         failed = .FALSE.  #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif #ifndef T2         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test2()         END DO         IF (failed) THEN           failcode = failcode + 2**1           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM  "}
{"prompt": "Create a test for the feature wait if queue true", "completion": "#include \"acc_testsuite.h\"  using namespace std;  #ifndef T1 //T1:parallel,wait,async,V:2.7-3.2 int test1(){     int err = 0;     srand(time(NULL));     data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     data_container<real_t> c = *(new data_container<real_t>(n));     data_container<real_t> d = *(new data_container<real_t>(n));     data_container<real_t> e = *(new data_container<real_t>(n));     data_container<real_t> f = *(new data_container<real_t>(n));     data_container<real_t> g = *(new data_container<real_t>(n));      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = rand() / (real_t)(RAND_MAX / 10); \tc.data[x] = 0.0;         d.data[x] = rand() / (real_t)(RAND_MAX / 10);         e.data[x] = rand() / (real_t)(RAND_MAX / 10); \tf.data[x] = 0.0; \tg.data[x] = 0.0;     }      #pragma acc data copyin(a,a.data[0:n], b, b.data[0:n], c, c.data[0:n], d, d.data[0:n], e, e.data[0:n], f, f.data[0:n],g, g.data[0:n])     {         #pragma acc parallel loop async(1)         for (int x = 0; x < n; ++x){             c.data[x] = a.data[x] + b.data[x];         }         #pragma acc parallel loop async(2)         for (int x = 0; x < n; ++x){             f.data[x] = d.data[x] + e.data[x];         }         #pragma acc parallel wait(1, 2) async(3)         for (int x = 0; x < n; ++x){             g.data[x] = c.data[x] + f.data[x];         }  \t#pragma acc update host(c.data[0:n], f.data[0:n]) wait(1,2) if(true)         #pragma acc update host(g.data[0:n]) wait(1,2,3) if(true)     }      for (int x = 0; x < n; ++x){         if (abs(c.data[x] - (a.data[x] + b.data[x])) > PRECISION){             err++;         }         if (abs(f.data[x] - (d.data[x] + e.data[x])) > PRECISION){ \t    err++; \t}         if (abs(g.data[x] - (c.data[x] + f.data[x])) > PRECISION){             err++;       \t}     }      return err; } #endif #ifndef T2 //T2:parallel,wait,async,V:2.7-3.2 int test2(){     int err = 0;     srand(time(NULL));      real_t * a = new real_t[n];     real_t * b = new real_t[n];     real_t * c = new real_t[n];     real_t * d = new real_t[n];     real_t * e = new real_t[n];     real_t * f = new real_t[n];     real_t * g = new real_t[n];      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;         g[x] = 0.0;     }     #pragma acc data copyin(a[0:n], b[0:n], c[0:n], d[0:n], e[0:n], f[0:n], g[0:n])     {         #pragma acc parallel loop async(1)         for (int x = 0; x < n; ++x){             c[x] = (a[x] + b[x]);         }         #pragma acc parallel loop async(2)         for (int x = 0; x < n; ++x){             f[x] = (d[x] + e[x]);         }         #pragma acc parallel loop wait(1, 2) async(3)         for (int x = 0; x < n; ++x){             g[x] = (c[x] + f[x]);         }         #pragma acc update host(c[0:n], f[0:n]) wait(1,2) if(true)         #pragma acc update host(g[0:n]) wait(1,2,3) if(true)     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){ \t    err++; \t}         if (fabs(f[x] - (d[x] + e[x])) > PRECISION){             err++;         }         if (fabs(g[x] - (c[x] + f[x])) > PRECISION){             err++;         }     }      delete[] a;     delete[] b;     delete[] c;     delete[] d;     delete[] e;     delete[] f;     delete[] g;      return err; } #endif #ifndef T3 //T3:parallel,wait,async,V:2.7-3.2 int test3(){     int err = 0;     srand(time(NULL));      real_t * a = new real_t[n];     real_t * b = new real_t[n];     data_container<real_t> c = *(new data_container<real_t>(n));     real_t * d = new real_t[n];     real_t * e = new real_t[n];     data_container<real_t> f = *(new data_container<real_t>(n));     data_container<real_t> g = *(new data_container<real_t>(n));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c.data[x] = 0.0;         d[x] = rand() / (real_t)(RAND_MAX / 10);         e[x] = rand() / (real_t)(RAND_MAX / 10);         f.data[x] = 0.0;         g.data[x] = 0.0;     }     #pragma acc data copyin(a[0:n], b[0:n], c, c.data[0:n], d[0:n], e[0:n], f, f.data[0:n], g, g.data[0:n])     {         #pragma acc parallel loop async(1)         for (int x = 0; x < n; ++x){             c.data[x] = (a[x] + b[x]);         }         #pragma acc parallel loop async(2)         for (int x = 0; x < n; ++x){             f.data[x] = (d[x] + e[x]);         }         #pragma acc parallel loop wait(1, 2) async(3)         for (int x = 0; x < n; ++x){             g.data[x] = (c.data[x] + f.data[x]);         }         #pragma acc update host(c.data[0:n], f.data[0:n]) wait(1,2) if(true)         #pragma acc update host(g.data[0:n]) wait(1,2,3) if(true)     }      for (int x = 0; x < n; ++x){         if (fabs(c.data[x] - (a[x] + b[x])) > PRECISION){             err++;         }         if (fabs(f.data[x] - (d[x] + e[x])) > PRECISION){             err++;         }         if (fabs(g.data[x] - (c.data[x] + f.data[x])) > PRECISION){             err++;         }     }      delete[] a;     delete[] b;     delete[] d;     delete[] e;      return err; } #endif #ifndef T4 //T4:parallel,wait,async,V:2.7-3.2 int test4(){     int err = 0;     srand(time(NULL));      data_container<real_t> a = *(new data_container<real_t>(n));     data_container<real_t> b = *(new data_container<real_t>(n));     real_t * c  = new real_t[n];     data_container<real_t> d = *(new data_container<real_t>(n));     data_container<real_t> e = *(new data_container<real_t>(n));     real_t * f = new real_t[n];     real_t * g = new real_t[n];      for (int x = 0; x < n; ++x){         a.data[x] = rand() / (real_t)(RAND_MAX / 10);         b.data[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;         d.data[x] = rand() / (real_t)(RAND_MAX / 10);         e.data[x] = rand() / (real_t)(RAND_MAX / 10);         f[x] = 0.0;         g[x] = 0.0;     }     #pragma acc data copyin(a,a.data[0:n],b,b.data[0:n],c[0:n],d,d.data[0:n],e,e.data[0:n], f[0:n], g[0:n])     {         #pragma acc parallel loop async(1)         for (int x = 0; x < n; ++x){             c[x] = (a.data[x] + b.data[x]);         }         #pragma acc parallel loop async(2)         for (int x = 0; x < n; ++x){             f[x] = (d.data[x] + e.data[x]);         }         #pragma acc parallel loop wait(1, 2) async(3)         for (int x = 0; x < n; ++x){             g[x] = (c[x] + f[x]);         }         #pragma acc update host(c[0:n], f[0:n]) wait(1,2) if(true)         #pragma acc update host(g[0:n]) wait(1,2,3) if(true)     }      for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a.data[x] + b.data[x])) > PRECISION){             err++;         }         if (fabs(f[x] - (d.data[x] + e.data[x])) > PRECISION){             err++;         }         if (fabs(g[x] - (c[x] + f[x])) > PRECISION){             err++;         }     }      delete[] c;     delete[] f;     delete[] g;      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){ \tfailed += test1();     }     if(failed){ \tfailcode += (1 << 0);     } #endif #ifndef T2     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test2();     }     if(failed){         failcode += (1 << 1);     } #endif #ifndef T3     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test3();     }     if(failed){         failcode += (1 << 2);     } #endif #ifndef T4     failed = 0;     for(int x = 0; x < NUM_TEST_CALLS; ++x){         failed += test4();     }     if(failed){         failcode += (1 << 3);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic capture rshift equals", "completion": "#include \"acc_testsuite.h\" bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){     if (length == 0){         return true;     }     unsigned int passed_a = 0;     unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));     for (int x = 0; x < length; ++x){         if ((b[x] == prev>>1 && ((a>>x)%2)==1) || ((a>>x)%2==0 && b[x] == prev)){             for (int y = 0; y < x; ++y){                 if ((a>>y)%2 == 1){                     passed_a += 1<<y;                 }                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 if ((a>>y) % 2 == 1){                     passed_a += 1<<(y - 1);                 }                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     unsigned int *a = (unsigned int *)malloc(n * sizeof(int));     unsigned int *b = (unsigned int *)malloc(n * sizeof(int));     unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));     unsigned int passed = 1<<8;      for (int x = 0; x < n; ++x){         a[x] = 1<<8;         for (int y = 0; y < 7; ++y){             if ((rand()/(real_t) (RAND_MAX)) > .5){                 b[x] += 1<<y;             }         }     }      #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc loop                 for (int y = 0; y < 7; ++y){                     c[x * 7 + y] = a[x];                     if ((b[x]>>y)%2 == 1){                         #pragma acc atomic capture                             c[x * 7 + y] = a[x] >>= 1;                     }                 }             }         }     }      for (int x = 0; x < n; ++x){         for (int y = 0; y < 7; ++y){             if ((b[x]>>y)%2 == 1){                 a[x] <<= 1;             }         }         if (a[x] != 1<<8){             err += 1;         }     }      for (int x = 0; x < n; ++x){         if (!is_possible(b[x], &(c[x * 7]), 7, passed)){             err++;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature atomic expr multiply x", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     real_t *a = (real_t *)malloc(n * sizeof(real_t));     real_t *b = (real_t *)malloc(n * sizeof(real_t));     real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));     real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 1;         totals_comparison[x] = 1;     }      #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic                     totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];     }     for (int x = 0; x < 10; ++x){         if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){             err += 1;             break;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature parallel while loop", "completion": "#ifndef T1 !T1:parallel,reduction,loop,V:1.0-2.7       LOGICAL FUNCTION test1()         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: x, y !Iterators         REAL(8),DIMENSION(10, LOOPCOUNT):: a !Data         REAL(8) :: avg         INTEGER :: errors = 0          !Initilization         SEEDDIM(1) = 1 #       ifdef SEED         SEEDDIM(1) = SEED #       endif         CALL RANDOM_SEED(PUT=SEEDDIM)          CALL RANDOM_NUMBER(a)           !$acc data copy(a(1:10, 1:LOOPCOUNT))           !$acc parallel             !$acc loop             DO x = 1, 10               avg = 0.0               DO WHILE (avg - 1000 .lt. PRECISION * LOOPCOUNT)                 avg = 0.0                 !$acc loop                 DO y = 1, LOOPCOUNT                   a(x, y) = a(x, y) * 1.5                 END DO                 !$acc loop reduction(+:avg)                 DO y = 1, LOOPCOUNT                   avg = avg + (a(x, y) / LOOPCOUNT)                 END DO               END DO             END DO           !$acc end parallel         !$acc end data          DO x = 1, 10           avg = 0.0           DO y = 1, LOOPCOUNT             avg = avg + (a(x, y) / LOOPCOUNT)           END DO           IF (avg < 1000 .OR. avg > 1600) THEN             errors = errors + 1           END IF         END DO          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM main         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature atomic structured x bitor expr assign", "completion": "#include \"acc_testsuite.h\" bool is_possible(int* a, int* b, int length, int prev){     if (length == 0){         return true;     }     int *passed_a = new int[(length - 1)];     int *passed_b = new int[(length - 1)];     for (int x = 0; x < length; ++x){         if (b[x] == (prev | a[x])){             for (int y = 0; y < x; ++y){                 passed_a[y] = a[y];                 passed_b[y] = b[y];             }             for (int y = x + 1; y < length; ++y){                 passed_a[y - 1] = a[y];                 passed_b[y - 1] = b[y];             }             if (is_possible(passed_a, passed_b, length - 1, b[x])){                 delete[] passed_a;                 delete[] passed_b;                 return true;             }         }     }     delete[] passed_a;     delete[] passed_b;     return false; }  #ifndef T1 //T1:atomic,construct-independent,V:2.0-2.7 int test1(){     int err = 0;     srand(SEED);     int *a = new int[n];     int *b = new int[n];     int *totals = new int[(n/10 + 1)];     int *totals_comparison = new int[(n/10 + 1)];     int *temp_a = new int[10];     int *temp_b = new int[10];     int temp_iterator;     int ab_iterator;      for (int x = 0; x < n; ++x){         for (int y = 0; y < 8; ++y){             if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values                 a[x] += 1<<y;             }         }     }     for (int x = 0; x < n/10 + 1; ++x){         totals[x] = 0;         totals_comparison[x] = 0;         for (int y = 0; y < 8; ++y){             totals[x] +=  1<<y;             totals_comparison[x] += 1<<y;         }     }     for (int x = 0; x < n; ++x){         b[x] = 0;     }     #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])     {         #pragma acc parallel         {             #pragma acc loop             for (int x = 0; x < n; ++x){                 #pragma acc atomic capture                     {                         totals[x/10] = totals[x/10] | a[x];                         b[x] = totals[x/10];                     }             }         }     }      for (int x = 0; x < n; ++x){         totals_comparison[x/10] |= a[x];     }     for (int x = 0; x < (n/10 + 1); ++x){         if (totals_comparison[x] != totals[x]){             err += 1;             break;         }     }     for (int x = 0; x < n; x = x + 10){         temp_iterator = 0;         for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){             temp_a[temp_iterator] = a[ab_iterator];             temp_b[temp_iterator] = b[ab_iterator];         }         if (!is_possible(temp_a, temp_b, temp_iterator, 1)){             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature exit data finalize", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:data,executable-data,reference-counting,construct-independent,V:2.5-2.7 int test1(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));     int * devtest = (int *)malloc(sizeof(int));      devtest[0] = 1;     #pragma acc enter data copyin(devtest[0:1])     #pragma acc parallel     {         devtest[0] = 0;     }      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0;     }      #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])     #pragma acc enter data create(a[0:n], b[0:n], c[0:n])     #pragma acc parallel present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc exit data copyout(a[0:n], b[0:n], c[0:n])     if (devtest[0] == 1){         for (int x = 0; x < n; ++x){             if (fabs(c[x]) > PRECISION) {                 err += 1;             }         }     }     #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])     for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION){             err += 1;         }     }      return err; } #endif  #ifndef T2 //T2:data,executable-data,reference-counting,construct-independent,V:2.5-2.7 int test2(){     int err = 0;     srand(SEED);     real_t * a = (real_t *)malloc(n * sizeof(real_t));     real_t * b = (real_t *)malloc(n * sizeof(real_t));     real_t * c = (real_t *)malloc(n * sizeof(real_t));      for (int x = 0; x < n; ++x){         a[x] = rand() / (real_t)(RAND_MAX / 10);         b[x] = rand() / (real_t)(RAND_MAX / 10);         c[x] = 0.0;     }      #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])     #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])     #pragma acc parallel present(a[0:n], b[0:n], c[0:n])     {         #pragma acc loop         for (int x = 0; x < n; ++x){             c[x] = a[x] + b[x];         }     }     #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n]) finalize     for (int x = 0; x < n; ++x){         if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {             err += 1;         }     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif #ifndef T2     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test2();     }     if (failed != 0){         failcode = failcode + (1 << 1);     } #endif     return failcode; } "}
{"prompt": "Create a test for the feature init device type nvidia", "completion": "#ifndef T1 !T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-3.2       LOGICAL FUNCTION test1()         USE OPENACC         IMPLICIT NONE         INCLUDE \"acc_testsuite.Fh\"         INTEGER :: errors = 0          !$acc init device_type(nvidia)          IF (errors .eq. 0) THEN           test1 = .FALSE.         ELSE           test1 = .TRUE.         END IF       END #endif        PROGRAM init_device_type         IMPLICIT NONE         INTEGER :: failcode, testrun         LOGICAL :: failed         INCLUDE \"acc_testsuite.Fh\" #ifndef T1         LOGICAL :: test1 #endif         failed = .FALSE.         failcode = 0 #ifndef T1         DO testrun = 1, NUM_TEST_CALLS           failed = failed .or. test1()         END DO         IF (failed) THEN           failcode = failcode + 2 ** 0           failed = .FALSE.         END IF #endif         CALL EXIT (failcode)       END PROGRAM "}
{"prompt": "Create a test for the feature kernels loop reduction and general", "completion": "#include \"acc_testsuite.h\" #ifndef T1 //T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7 int test1(){     int err = 0;     srand(SEED);      char * a = (char *)malloc(n * sizeof(char));     real_t false_margin = pow(exp(1), log(.5)/n);     char result = 1;      for (int x = 0; x < n; ++x){         if(rand() / (real_t)(RAND_MAX) < false_margin){             a[x] = 1;         }         else{             a[x] = 0;         }     }       #pragma acc data copyin(a[0:n])     {         #pragma acc kernels loop reduction(&&:result)         for (int x = 0; x < n; ++x){             result = result && a[x];         }     }      char found = 0;     for (int x = 0; x < n; ++x){         if (a[x] == 0){             found = 1;             break;         }     }     if (found == result){         err = 1;     }      return err; } #endif  int main(){     int failcode = 0;     int failed; #ifndef T1     failed = 0;     for (int x = 0; x < NUM_TEST_CALLS; ++x){         failed = failed + test1();     }     if (failed != 0){         failcode = failcode + (1 << 0);     } #endif     return failcode; } "}
